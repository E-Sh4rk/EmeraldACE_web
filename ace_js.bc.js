//# 1 "ace_js.bc.runtime.js"
// Generated by js_of_ocaml 3.9.1
(function(joo_global_object)
   {"use strict";
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    var caml_global_data=[0];
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x)
     {var y=Math.exp(x),z=y - 1;
      return Math.abs(x) > 1?z:z == 0?x:x * z / Math.log(y)}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_bytes_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))
       this.content[name] = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       this.content[name] = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         this.content[name] = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           this.content[name] = new MlFakeFile(bytes)}
         else
          caml_raise_sys_error
           (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var
       a=new (joo_global_object.Uint8Array)(1),
       buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try
       {return this.fs.existsSync(this.nm(name))?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.readdir
    =
    function(name)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.rename
    =
    function(o,n)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_string_of_jsstring(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    var MlObjectTable;
    if(typeof joo_global_object.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function()
      {this.objs = [];this.lookup = new (joo_global_object.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    var caml_ml_channels=new Array();
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function caml_return_exn_constant(tag){return tag}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       content=
        typeof content == "string"?caml_string_of_jsbytes(content):content,
       root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    function caml_set_parser_trace(){return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[args])}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = root.path + root.rest + "/";
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new (joo_global_object.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var g=joo_global_object,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function caml_CamlinternalMod_init_mod(loc,shape)
     {function undef_module(_x)
       {caml_raise_with_arg(caml_global_data.Undefined_recursive_module,loc)}
      function loop(shape,struct,idx)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:struct[idx] = {fun:undef_module};break;
           case 1:struct[idx] = [246,undef_module];break;
           default:struct[idx] = []}
        else
         switch(shape[0])
          {case 0:
            struct[idx] = [0];
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],struct[idx],i);
            break;
           default:struct[idx] = shape[1]}}
      var res=[];
      loop(shape,res,0);
      return res[0]}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_channel_descriptor(chanid)
     {var chan=caml_ml_channels[chanid];return chan.fd}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_raw_backtrace_length(){return 0}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function caml_sys_const_naked_pointers_checked(_unit){return 0}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function caml_ml_debug_info_status(){return 0}
    function caml_sys_const_ostype_cygwin(){return 0}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    var caml_ephe_key_offset=3;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    function caml_gc_compaction(){return 0}
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function win_cleanup(){}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function unix_inet_addr_of_string(){return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_is_js(){return 1}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y)
     {var
       x=Math.abs(x),
       y=Math.abs(y),
       a=Math.max(x,y),
       b=Math.min(x,y) / (a?a:1);
      return a * Math.sqrt(1 + b * b)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_bytes(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_jsbytes(h,v.c);break;
        case 2:h = caml_hash_mix_bytes_arr(h,v.c)
        }
      return h}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            joo_global_object.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)}
      else
       return false}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y){return x.and(y)}
    function caml_sys_const_word_size(){return 32}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_string_of_bytes(s){return s}
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return 1}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_ba_kind_of_typed_array(ta)
     {var g=joo_global_object,kind;
      if(ta instanceof g.Float32Array)
       kind = 0;
      else
       if(ta instanceof g.Float64Array)
        kind = 1;
       else
        if(ta instanceof g.Int8Array)
         kind = 2;
        else
         if(ta instanceof g.Uint8Array)
          kind = 3;
         else
          if(ta instanceof g.Int16Array)
           kind = 4;
          else
           if(ta instanceof g.Uint16Array)
            kind = 5;
           else
            if(ta instanceof g.Int32Array)
             kind = 6;
            else
             if(ta instanceof g.Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_js_typeof(o){return typeof o}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return f.apply(null,args)}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    var caml_ephe_data_offset=2;
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(caml_string_of_bytes(buf),0,len)}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {var g=joo_global_object;
      if(typeof g.XMLHttpRequest !== "undefined")
       try {return new (g.XMLHttpRequest)()}catch(e){}
      if(typeof g.activeXObject !== "undefined")
       {try {return new (g.activeXObject)("Msxml2.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Msxml3.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Microsoft.XMLHTTP")}catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_obj_set_raw_field(o,i,v){return o[i + 1] = v}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_final_register_called_without_value(){return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_obj_raw_field(o,i){return o[i + 1]}
    function caml_js_equals(x,y){return + (x == y)}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_bytes(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_js_pure_expr(f){return f()}
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function caml_gr_sigio_handler(){return 0}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes("Unix"),32,0]}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=path.join("/") + "/";
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_js_to_bool(x){return + x}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === undefined)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name)}
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (joo_global_object.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[this,args])}}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity && f.length == arity)return f.apply(null,arguments);
        var args=new Array(arity),len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function caml_get_current_callstack(){return [0]}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var path=caml_make_path(name),name=path.join("/") + "/",idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (joo_global_object.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    var
     caml_ephe_blit_key=caml_weak_blit,
     caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_sys_time_include_children(b){return caml_sys_time()}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function caml_floatarray_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_open_graph(info)
     {var g=joo_global_object,info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=g.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_memprof_stop(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x)
     {var y=1 + x,z=y - 1;return z == 0?x:x * Math.log(y) / z}
    function caml_int64_or(x,y){return x.or(y)}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_CamlinternalMod_update_mod(shape,real,x)
     {if(typeof shape === "number")
       switch(shape){case 0:case 1:case 2:default:caml_update_dummy(real,x)}
      else
       switch(shape[0])
        {case 0:
          for(var i=1;i < shape[1].length;i++)
           caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);
          break
         }
      return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_backtrace_status(){return 0}
    function caml_install_signal_handler(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return caml_string_of_bytes(buf)}
      caml_raise_no_such_file(name)}
    function caml_js_to_float(x){return x}
    joo_global_object.jsoo_runtime
    =
    {caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     unix_isatty:unix_isatty,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     re_replacement_text:re_replacement_text,
     re_partial_match:re_partial_match,
     re_string_match:re_string_match,
     re_search_backward:re_search_backward,
     re_search_forward:re_search_forward,
     re_match:re_match,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_sys_isatty:caml_sys_isatty,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_time_include_children:caml_sys_time_include_children,
     caml_sys_time:caml_sys_time,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_executable_name:caml_executable_name,
     caml_argv:caml_argv,
     caml_sys_unsafe_getenv:caml_sys_unsafe_getenv,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_sys_exit:caml_sys_exit,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_is_printable:caml_is_printable,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_obj_set_raw_field:caml_obj_set_raw_field,
     caml_obj_raw_field:caml_obj_raw_field,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     caml_get_public_method:caml_get_public_method,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     deserialize_nat:deserialize_nat,
     serialize_nat:serialize_nat,
     lxor_digit_nat:lxor_digit_nat,
     lor_digit_nat:lor_digit_nat,
     land_digit_nat:land_digit_nat,
     compare_nat_real:compare_nat_real,
     compare_nat:compare_nat,
     compare_digits_nat:compare_digits_nat,
     shift_right_nat:shift_right_nat,
     div_nat:div_nat,
     div_digit_nat:div_digit_nat,
     div_helper:div_helper,
     shift_left_nat:shift_left_nat,
     square_nat:square_nat,
     mult_nat:mult_nat,
     mult_digit_nat:mult_digit_nat,
     sub_nat:sub_nat,
     decr_nat:decr_nat,
     complement_nat:complement_nat,
     add_nat:add_nat,
     incr_nat:incr_nat,
     is_digit_odd:is_digit_odd,
     is_digit_zero:is_digit_zero,
     is_digit_int:is_digit_int,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     num_digits_nat:num_digits_nat,
     nth_digit_nat_native:nth_digit_nat_native,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat:set_digit_nat,
     blit_nat:blit_nat,
     set_to_zero_nat:set_to_zero_nat,
     create_nat:create_nat,
     nat_of_array:nat_of_array,
     caml_hash_nat:caml_hash_nat,
     MlNat:MlNat,
     initialize_nat:initialize_nat,
     caml_js_to_string:caml_js_to_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_from_string:caml_js_from_string,
     caml_new_string:caml_new_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_is_ml_string:caml_is_ml_string,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_equal:caml_string_equal,
     caml_string_compare:caml_string_compare,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_string_of_array:caml_string_of_array,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_array_of_string:caml_array_of_string,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_str_repeat:caml_str_repeat,
     caml_md5_bytes:caml_md5_bytes,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_legacy_custom_code:caml_legacy_custom_code,
     MlObjectTable:MlObjectTable,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_custom_ops:caml_custom_ops,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlStringReader:MlStringReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_is_js:caml_is_js,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_channel_descriptor:caml_channel_descriptor,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_format_int:caml_format_int,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_int64_hash:caml_int64_hash,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     MlInt64:MlInt64,
     caml_int64_offset:caml_int64_offset,
     caml_float_of_string:caml_float_of_string,
     caml_format_float:caml_format_float,
     caml_round_float:caml_round_float,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state:caml_gr_state,
     caml_memprof_stop:caml_memprof_stop,
     caml_memprof_start:caml_memprof_start,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_memprof_set:caml_memprof_set,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_failwith:caml_failwith,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     bigstring_of_typed_array:bigstring_of_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_hash:caml_ba_hash,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_blit:caml_ba_blit,
     caml_ba_fill:caml_ba_fill,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_compare:caml_ba_compare,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     Ml_Bigarray:Ml_Bigarray,
     caml_ba_custom_name:caml_ba_custom_name,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init:caml_ba_init,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_ml_debug_info_status:caml_ml_debug_info_status,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_fill:caml_array_fill,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_floatarray_blit:caml_floatarray_blit,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),0],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-1],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-2],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-3],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-5],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));


//# 1 ".js/stdlib/stdlib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_get=runtime.caml_array_get,
     caml_array_set=runtime.caml_array_set,
     caml_array_sub=runtime.caml_array_sub,
     caml_ba_change_layout=runtime.caml_ba_change_layout,
     caml_ba_create=runtime.caml_ba_create,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_dim_2=runtime.caml_ba_dim_2,
     caml_ba_kind=runtime.caml_ba_kind,
     caml_ba_num_dims=runtime.caml_ba_num_dims,
     caml_ba_reshape=runtime.caml_ba_reshape,
     caml_ba_set_1=runtime.caml_ba_set_1,
     caml_ba_set_2=runtime.caml_ba_set_2,
     caml_ba_set_3=runtime.caml_ba_set_3,
     caml_ba_set_generic=runtime.caml_ba_set_generic,
     caml_ba_slice=runtime.caml_ba_slice,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bswap16=runtime.caml_bswap16,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_get16=runtime.caml_bytes_get16,
     caml_bytes_get32=runtime.caml_bytes_get32,
     caml_bytes_get64=runtime.caml_bytes_get64,
     caml_bytes_of_string=runtime.caml_bytes_of_string,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_set16=runtime.caml_bytes_set16,
     caml_bytes_set32=runtime.caml_bytes_set32,
     caml_bytes_set64=runtime.caml_bytes_set64,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_ephe_set_key=runtime.caml_ephe_set_key,
     caml_ephe_unset_key=runtime.caml_ephe_unset_key,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_floatarray_blit=runtime.caml_floatarray_blit,
     caml_floatarray_create=runtime.caml_floatarray_create,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtra=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int32_bswap=runtime.caml_int32_bswap,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_bswap=runtime.caml_int64_bswap,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_nextafter_float=runtime.caml_nextafter_float,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_make_forward=runtime.caml_obj_make_forward,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_restore_raw_backtrace=runtime.caml_restore_raw_backtrace,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_signbit_float=runtime.caml_signbit_float,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_bytes=runtime.caml_string_of_bytes,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_sys_argv=runtime.caml_sys_argv,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_string_of_jsbytes("%,"),
     cst_really_input=caml_string_of_jsbytes("really_input"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_output_substring=caml_string_of_jsbytes("output_substring"),
     cst_output=caml_string_of_jsbytes("output"),
     cst_12g=caml_string_of_jsbytes("%.12g"),
     cst=caml_string_of_jsbytes("."),
     cst_false$1=caml_string_of_jsbytes("false"),
     cst_true$1=caml_string_of_jsbytes("true"),
     cst_false$0=caml_string_of_jsbytes("false"),
     cst_true$0=caml_string_of_jsbytes("true"),
     cst_bool_of_string=caml_string_of_jsbytes("bool_of_string"),
     cst_true=caml_string_of_jsbytes("true"),
     cst_false=caml_string_of_jsbytes("false"),
     cst_char_of_int=caml_string_of_jsbytes("char_of_int"),
     cst_Stdlib_Exit=caml_string_of_jsbytes("Stdlib.Exit"),
     cst_Stdlib_Pervasives_Exit=
      caml_string_of_jsbytes("Stdlib.Pervasives.Exit"),
     cst_option_is_None=caml_string_of_jsbytes("option is None"),
     cst_result_is_Ok=caml_string_of_jsbytes("result is Ok _"),
     cst_result_is_Error=caml_string_of_jsbytes("result is Error _"),
     cst_true$2=caml_string_of_jsbytes("true"),
     cst_false$2=caml_string_of_jsbytes("false"),
     cst$1=caml_string_of_jsbytes("\\\\"),
     cst$2=caml_string_of_jsbytes("\\'"),
     cst_b=caml_string_of_jsbytes("\\b"),
     cst_t=caml_string_of_jsbytes("\\t"),
     cst_n=caml_string_of_jsbytes("\\n"),
     cst_r=caml_string_of_jsbytes("\\r"),
     cst_Char_chr=caml_string_of_jsbytes("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_string_of_jsbytes(" is not a latin1 character"),
     cst_04X=caml_string_of_jsbytes("%04X"),
     cst_U=caml_string_of_jsbytes("U+"),
     cst_is_not_an_Unicode_scalar_v=
      caml_string_of_jsbytes(" is not an Unicode scalar value"),
     cst_X=caml_string_of_jsbytes("%X"),
     err_no_pred=caml_string_of_jsbytes("U+0000 has no predecessor"),
     err_no_succ=caml_string_of_jsbytes("U+10FFFF has no successor"),
     cst_Stdlib_Sys_Break=caml_string_of_jsbytes("Stdlib.Sys.Break"),
     ocaml_version=caml_string_of_jsbytes("4.12.0"),
     cst_List_map2=caml_string_of_jsbytes("List.map2"),
     cst_List_iter2=caml_string_of_jsbytes("List.iter2"),
     cst_List_fold_left2=caml_string_of_jsbytes("List.fold_left2"),
     cst_List_fold_right2=caml_string_of_jsbytes("List.fold_right2"),
     cst_List_for_all2=caml_string_of_jsbytes("List.for_all2"),
     cst_List_exists2=caml_string_of_jsbytes("List.exists2"),
     cst_List_combine=caml_string_of_jsbytes("List.combine"),
     cst_List_rev_map2=caml_string_of_jsbytes("List.rev_map2"),
     cst_List_init=caml_string_of_jsbytes("List.init"),
     cst_List_nth$0=caml_string_of_jsbytes("List.nth"),
     cst_nth=caml_string_of_jsbytes("nth"),
     cst_List_nth=caml_string_of_jsbytes("List.nth"),
     cst_tl=caml_string_of_jsbytes("tl"),
     cst_hd=caml_string_of_jsbytes("hd"),
     cst_Bytes_of_seq_cannot_grow_b=
      caml_string_of_jsbytes("Bytes.of_seq: cannot grow bytes"),
     cst_String_rcontains_from_Byte=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_string_of_jsbytes("Bytes.concat"),
     cst_String_blit_Bytes_blit_str=
      caml_string_of_jsbytes("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_string_of_jsbytes("Bytes.blit"),
     cst_String_fill_Bytes_fill=
      caml_string_of_jsbytes("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_string_of_jsbytes("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_string_of_jsbytes("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Byte$0=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes$0=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt$0=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r$0=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte$0=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in$0=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_String_concat=caml_string_of_jsbytes("String.concat"),
     cst$5=caml_string_of_jsbytes("()"),
     cst_Marshal_from_bytes=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_string_of_jsbytes("Marshal.data_size"),
     cst_Marshal_to_buffer_substrin=
      caml_string_of_jsbytes("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_Ephemeron_blit_key=
      caml_string_of_jsbytes("Obj.Ephemeron.blit_key"),
     cst_Obj_Ephemeron_check_key=
      caml_string_of_jsbytes("Obj.Ephemeron.check_key"),
     cst_Obj_Ephemeron_unset_key=
      caml_string_of_jsbytes("Obj.Ephemeron.unset_key"),
     cst_Obj_Ephemeron_set_key=caml_string_of_jsbytes("Obj.Ephemeron.set_key"),
     cst_Obj_Ephemeron_get_key_copy=
      caml_string_of_jsbytes("Obj.Ephemeron.get_key_copy"),
     cst_Obj_Ephemeron_get_key=caml_string_of_jsbytes("Obj.Ephemeron.get_key"),
     cst_Obj_Ephemeron_create=caml_string_of_jsbytes("Obj.Ephemeron.create"),
     cst_Obj_extension_constructor$0=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Array_exists2=caml_string_of_jsbytes("Array.exists2"),
     cst_Array_for_all2=caml_string_of_jsbytes("Array.for_all2"),
     cst_Array_map2_arrays_must_hav=
      caml_string_of_jsbytes("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_ha=
      caml_string_of_jsbytes("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_string_of_jsbytes("Array.blit"),
     cst_Array_fill=caml_string_of_jsbytes("Array.fill"),
     cst_Array_sub=caml_string_of_jsbytes("Array.sub"),
     cst_Array_init=caml_string_of_jsbytes("Array.init"),
     cst_Stdlib_Array_Bottom=caml_string_of_jsbytes("Stdlib.Array.Bottom"),
     cst_Float_Array_map2_arrays_mu=
      caml_string_of_jsbytes
       ("Float.Array.map2: arrays must have the same length"),
     cst_Float_Array_iter2_arrays_m=
      caml_string_of_jsbytes
       ("Float.Array.iter2: arrays must have the same length"),
     cst_Float_array_blit=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_array_blit$0=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_Array_fill=caml_string_of_jsbytes("Float.Array.fill"),
     cst_Float_Array_sub=caml_string_of_jsbytes("Float.Array.sub"),
     cst_Float_Array_concat=caml_string_of_jsbytes("Float.Array.concat"),
     cst_Float_Array_init=caml_string_of_jsbytes("Float.Array.init"),
     cst_Stdlib_Float_Array_Bottom=
      caml_string_of_jsbytes("Stdlib.Float.Array.Bottom"),
     cst_d=caml_string_of_jsbytes("%d"),
     cst_d$0=caml_string_of_jsbytes("%d"),
     zero$2=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     one$2=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     minus_one$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     min_int$2=runtime.caml_int64_create_lo_mi_hi(0,0,32768),
     max_int$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
     cst_d$1=caml_string_of_jsbytes("%d"),
     cst_Lexing_lex_refill_cannot_g=
      caml_string_of_jsbytes("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_string_of_jsbytes(""),0,0,-1],
     zero_pos=[0,caml_string_of_jsbytes(""),1,0,0],
     cst_syntax_error=caml_string_of_jsbytes("syntax error"),
     cst_Stdlib_Parsing_YYexit=caml_string_of_jsbytes("Stdlib.Parsing.YYexit"),
     cst_Stdlib_Parsing_Parse_error=
      caml_string_of_jsbytes("Stdlib.Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_string_of_jsbytes("Set.remove_min_elt"),
     cst_Set_bal=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$0=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$1=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$2=caml_string_of_jsbytes("Set.bal"),
     cst_Map_remove_min_elt=caml_string_of_jsbytes("Map.remove_min_elt"),
     cst_Map_bal=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$0=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$1=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$2=caml_string_of_jsbytes("Map.bal"),
     cst_Stdlib_Stack_Empty=caml_string_of_jsbytes("Stdlib.Stack.Empty"),
     cst_Stdlib_Queue_Empty=caml_string_of_jsbytes("Stdlib.Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_string_of_jsbytes("CamlinternalLazy.Undefined"),
     cst_count=caml_string_of_jsbytes("{count = "),
     cst_data=caml_string_of_jsbytes("; data = "),
     cst$6=caml_string_of_jsbytes("}"),
     cst_Sempty=caml_string_of_jsbytes("Sempty"),
     cst_Scons=caml_string_of_jsbytes("Scons ("),
     cst$7=caml_string_of_jsbytes(", "),
     cst$8=caml_string_of_jsbytes(")"),
     cst_Sapp=caml_string_of_jsbytes("Sapp ("),
     cst$9=caml_string_of_jsbytes(", "),
     cst$10=caml_string_of_jsbytes(")"),
     cst_Slazy=caml_string_of_jsbytes("Slazy"),
     cst_Sgen=caml_string_of_jsbytes("Sgen"),
     cst_Sbuffio=caml_string_of_jsbytes("Sbuffio"),
     cst_Stdlib_Stream_Failure=caml_string_of_jsbytes("Stdlib.Stream.Failure"),
     cst_Stdlib_Stream_Error=caml_string_of_jsbytes("Stdlib.Stream.Error"),
     cst_Buffer_truncate=caml_string_of_jsbytes("Buffer.truncate"),
     cst_Buffer_add_channel=caml_string_of_jsbytes("Buffer.add_channel"),
     cst_Buffer_add_substring_add_s=
      caml_string_of_jsbytes("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buf=
      caml_string_of_jsbytes("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_string_of_jsbytes("Buffer.nth"),
     cst_Buffer_blit=caml_string_of_jsbytes("Buffer.blit"),
     cst_Buffer_sub=caml_string_of_jsbytes("Buffer.sub"),
     cst_c=caml_string_of_jsbytes("%c"),
     cst_s=caml_string_of_jsbytes("%s"),
     cst_i=caml_string_of_jsbytes("%i"),
     cst_li=caml_string_of_jsbytes("%li"),
     cst_ni=caml_string_of_jsbytes("%ni"),
     cst_Li=caml_string_of_jsbytes("%Li"),
     cst_f=caml_string_of_jsbytes("%f"),
     cst_B=caml_string_of_jsbytes("%B"),
     cst$21=caml_string_of_jsbytes("%{"),
     cst$22=caml_string_of_jsbytes("%}"),
     cst$23=caml_string_of_jsbytes("%("),
     cst$24=caml_string_of_jsbytes("%)"),
     cst_a=caml_string_of_jsbytes("%a"),
     cst_t$0=caml_string_of_jsbytes("%t"),
     cst$25=caml_string_of_jsbytes("%?"),
     cst_r$0=caml_string_of_jsbytes("%r"),
     cst_r$1=caml_string_of_jsbytes("%_r"),
     cst_u$0=caml_string_of_jsbytes("%u"),
     cst_Printf_bad_conversion=
      caml_string_of_jsbytes("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=
      caml_string_of_jsbytes("Printf: bad conversion %_"),
     cst$30=caml_string_of_jsbytes("@{"),
     cst$31=caml_string_of_jsbytes("@["),
     cst$32=caml_string_of_jsbytes("@{"),
     cst$33=caml_string_of_jsbytes("@["),
     cst$34=caml_string_of_jsbytes("@{"),
     cst$35=caml_string_of_jsbytes("@["),
     cst_0=caml_string_of_jsbytes("0"),
     cst_padding=caml_string_of_jsbytes("padding"),
     cst_precision=caml_string_of_jsbytes("precision"),
     cst$40=caml_string_of_jsbytes("'*'"),
     cst$38=caml_string_of_jsbytes("'-'"),
     cst_0$2=caml_string_of_jsbytes("'0'"),
     cst$39=caml_string_of_jsbytes("'*'"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_0$1=caml_string_of_jsbytes("0"),
     cst_precision$0=caml_string_of_jsbytes("precision"),
     cst_precision$1=caml_string_of_jsbytes("precision"),
     cst$41=caml_string_of_jsbytes("'+'"),
     cst$42=caml_string_of_jsbytes("'#'"),
     cst$43=caml_string_of_jsbytes("' '"),
     cst_padding$0=caml_string_of_jsbytes("`padding'"),
     cst_precision$2=caml_string_of_jsbytes("`precision'"),
     cst$44=caml_string_of_jsbytes("'+'"),
     cst$45=caml_string_of_jsbytes("'_'"),
     sub_format=[0,0,caml_string_of_jsbytes("")],
     formatting_lit=[0,caml_string_of_jsbytes("@;"),1,0],
     cst_digit=caml_string_of_jsbytes("digit"),
     cst_character=caml_string_of_jsbytes("character ')'"),
     cst_character$0=caml_string_of_jsbytes("character '}'"),
     cst$49=caml_string_of_jsbytes("'#'"),
     cst$46=caml_string_of_jsbytes("'+'"),
     cst$47=caml_string_of_jsbytes("'+'"),
     cst$48=caml_string_of_jsbytes("' '"),
     cst$50=caml_string_of_jsbytes("'+'"),
     cst_non_zero_widths_are_unsupp=
      caml_string_of_jsbytes
       ("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=
      caml_string_of_jsbytes("unexpected end of format"),
     cst$36=caml_string_of_jsbytes(""),
     cst$37=caml_string_of_jsbytes(""),
     cst_b$0=caml_string_of_jsbytes("b"),
     cst_h=caml_string_of_jsbytes("h"),
     cst_hov=caml_string_of_jsbytes("hov"),
     cst_hv=caml_string_of_jsbytes("hv"),
     cst_v=caml_string_of_jsbytes("v"),
     cst_nan=caml_string_of_jsbytes("nan"),
     cst_neg_infinity=caml_string_of_jsbytes("neg_infinity"),
     cst_infinity=caml_string_of_jsbytes("infinity"),
     cst$29=caml_string_of_jsbytes("."),
     cst_nd$0=caml_string_of_jsbytes("%+nd"),
     cst_nd$1=caml_string_of_jsbytes("% nd"),
     cst_ni$1=caml_string_of_jsbytes("%+ni"),
     cst_ni$2=caml_string_of_jsbytes("% ni"),
     cst_nx=caml_string_of_jsbytes("%nx"),
     cst_nx$0=caml_string_of_jsbytes("%#nx"),
     cst_nX=caml_string_of_jsbytes("%nX"),
     cst_nX$0=caml_string_of_jsbytes("%#nX"),
     cst_no=caml_string_of_jsbytes("%no"),
     cst_no$0=caml_string_of_jsbytes("%#no"),
     cst_nd=caml_string_of_jsbytes("%nd"),
     cst_ni$0=caml_string_of_jsbytes("%ni"),
     cst_nu=caml_string_of_jsbytes("%nu"),
     cst_ld$0=caml_string_of_jsbytes("%+ld"),
     cst_ld$1=caml_string_of_jsbytes("% ld"),
     cst_li$1=caml_string_of_jsbytes("%+li"),
     cst_li$2=caml_string_of_jsbytes("% li"),
     cst_lx=caml_string_of_jsbytes("%lx"),
     cst_lx$0=caml_string_of_jsbytes("%#lx"),
     cst_lX=caml_string_of_jsbytes("%lX"),
     cst_lX$0=caml_string_of_jsbytes("%#lX"),
     cst_lo=caml_string_of_jsbytes("%lo"),
     cst_lo$0=caml_string_of_jsbytes("%#lo"),
     cst_ld=caml_string_of_jsbytes("%ld"),
     cst_li$0=caml_string_of_jsbytes("%li"),
     cst_lu=caml_string_of_jsbytes("%lu"),
     cst_Ld$0=caml_string_of_jsbytes("%+Ld"),
     cst_Ld$1=caml_string_of_jsbytes("% Ld"),
     cst_Li$1=caml_string_of_jsbytes("%+Li"),
     cst_Li$2=caml_string_of_jsbytes("% Li"),
     cst_Lx=caml_string_of_jsbytes("%Lx"),
     cst_Lx$0=caml_string_of_jsbytes("%#Lx"),
     cst_LX=caml_string_of_jsbytes("%LX"),
     cst_LX$0=caml_string_of_jsbytes("%#LX"),
     cst_Lo=caml_string_of_jsbytes("%Lo"),
     cst_Lo$0=caml_string_of_jsbytes("%#Lo"),
     cst_Ld=caml_string_of_jsbytes("%Ld"),
     cst_Li$0=caml_string_of_jsbytes("%Li"),
     cst_Lu=caml_string_of_jsbytes("%Lu"),
     cst_d$3=caml_string_of_jsbytes("%+d"),
     cst_d$4=caml_string_of_jsbytes("% d"),
     cst_i$1=caml_string_of_jsbytes("%+i"),
     cst_i$2=caml_string_of_jsbytes("% i"),
     cst_x=caml_string_of_jsbytes("%x"),
     cst_x$0=caml_string_of_jsbytes("%#x"),
     cst_X$0=caml_string_of_jsbytes("%X"),
     cst_X$1=caml_string_of_jsbytes("%#X"),
     cst_o=caml_string_of_jsbytes("%o"),
     cst_o$0=caml_string_of_jsbytes("%#o"),
     cst_d$2=caml_string_of_jsbytes("%d"),
     cst_i$0=caml_string_of_jsbytes("%i"),
     cst_u=caml_string_of_jsbytes("%u"),
     cst$26=caml_string_of_jsbytes("%!"),
     cst$27=caml_string_of_jsbytes("@{"),
     cst$28=caml_string_of_jsbytes("@["),
     cst_0c=caml_string_of_jsbytes("0c"),
     cst$20=caml_string_of_jsbytes("%%"),
     cst$12=caml_string_of_jsbytes("@]"),
     cst$13=caml_string_of_jsbytes("@}"),
     cst$14=caml_string_of_jsbytes("@?"),
     cst$15=caml_string_of_jsbytes("@\n"),
     cst$16=caml_string_of_jsbytes("@."),
     cst$17=caml_string_of_jsbytes("@@"),
     cst$18=caml_string_of_jsbytes("@%"),
     cst$19=caml_string_of_jsbytes("@"),
     cst$11=caml_string_of_jsbytes(".*"),
     cst_CamlinternalFormat_Type_mi=
      caml_string_of_jsbytes("CamlinternalFormat.Type_mismatch"),
     cst$58=caml_string_of_jsbytes(""),
     cst$59=caml_string_of_jsbytes("\n"),
     cst_a_boolean=caml_string_of_jsbytes("a boolean"),
     cst_an_integer=caml_string_of_jsbytes("an integer"),
     cst_an_integer$0=caml_string_of_jsbytes("an integer"),
     cst_a_float=caml_string_of_jsbytes("a float"),
     cst_a_float$0=caml_string_of_jsbytes("a float"),
     cst$55=caml_string_of_jsbytes(""),
     cst$56=caml_string_of_jsbytes(" "),
     cst$57=caml_string_of_jsbytes(""),
     cst_one_of=caml_string_of_jsbytes("one of: "),
     cst_Arg_Expand_is_is_only_allo=
      caml_string_of_jsbytes
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_string_of_jsbytes("no argument"),
     cst$54=caml_string_of_jsbytes("(?)"),
     cst_help$3=caml_string_of_jsbytes("--help"),
     cst_help$4=caml_string_of_jsbytes("-help"),
     cst_help$2=caml_string_of_jsbytes("-help"),
     cst_Display_this_list_of_optio=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help=caml_string_of_jsbytes("-help"),
     cst_help$1=caml_string_of_jsbytes("--help"),
     cst_Display_this_list_of_optio$0=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help$0=caml_string_of_jsbytes("--help"),
     cst$51=caml_string_of_jsbytes("}"),
     cst$52=caml_string_of_jsbytes("|"),
     cst$53=caml_string_of_jsbytes("{"),
     cst_none=caml_string_of_jsbytes("<none>"),
     cst_Stdlib_Arg_Bad=caml_string_of_jsbytes("Stdlib.Arg.Bad"),
     cst_Stdlib_Arg_Help=caml_string_of_jsbytes("Stdlib.Arg.Help"),
     cst_Stdlib_Arg_Stop=caml_string_of_jsbytes("Stdlib.Arg.Stop"),
     cst$61=caml_string_of_jsbytes(""),
     cst$65=caml_string_of_jsbytes(""),
     cst_Program_not_linked_with_g_=
      caml_string_of_jsbytes
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_string_of_jsbytes("Raised at"),
     cst_Re_raised_at=caml_string_of_jsbytes("Re-raised at"),
     cst_Raised_by_primitive_operat=
      caml_string_of_jsbytes("Raised by primitive operation at"),
     cst_Called_from=caml_string_of_jsbytes("Called from"),
     cst_inlined=caml_string_of_jsbytes(" (inlined)"),
     cst$64=caml_string_of_jsbytes(""),
     partial=[4,0,0,0,[12,45,[4,0,0,0,0]]],
     cst_Out_of_memory=caml_string_of_jsbytes("Out of memory"),
     cst_Stack_overflow=caml_string_of_jsbytes("Stack overflow"),
     cst_Pattern_matching_failed=
      caml_string_of_jsbytes("Pattern matching failed"),
     cst_Assertion_failed=caml_string_of_jsbytes("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_string_of_jsbytes("Undefined recursive module"),
     cst$62=caml_string_of_jsbytes(""),
     cst$63=caml_string_of_jsbytes(""),
     cst$60=caml_string_of_jsbytes("_"),
     locfmt=
      [0,
       [11,
        caml_string_of_jsbytes('File "'),
        [2,
         0,
         [11,
          caml_string_of_jsbytes('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", characters "),
            [4,
             0,
             0,
             0,
             [12,45,[4,0,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]]]]]]]],
       caml_string_of_jsbytes('File "%s", line %d, characters %d-%d: %s')],
     cst_Fun_Finally_raised=caml_string_of_jsbytes("Fun.Finally_raised: "),
     cst_Stdlib_Fun_Finally_raised=
      caml_string_of_jsbytes("Stdlib.Fun.Finally_raised"),
     cst_Digest_from_hex$0=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_from_hex=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_to_hex=caml_string_of_jsbytes("Digest.to_hex"),
     cst_Digest_substring=caml_string_of_jsbytes("Digest.substring"),
     cst_Random_int64=caml_string_of_jsbytes("Random.int64"),
     cst_Random_int32=caml_string_of_jsbytes("Random.int32"),
     cst_Random_int=caml_string_of_jsbytes("Random.int"),
     cst_x$1=caml_string_of_jsbytes("x"),
     cst_Hashtbl_unsupported_hash_t=
      caml_string_of_jsbytes("Hashtbl: unsupported hash table format"),
     cst_OCAMLRUNPARAM=caml_string_of_jsbytes("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_string_of_jsbytes("CAMLRUNPARAM"),
     cst$66=caml_string_of_jsbytes(""),
     cst_Weak_Make_hash_bucket_cann=
      caml_string_of_jsbytes("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_string_of_jsbytes("Weak.fill"),
     cst_Weak_blit=caml_string_of_jsbytes("Weak.blit"),
     cst_Weak_check=caml_string_of_jsbytes("Weak.check"),
     cst_Weak_get_copy=caml_string_of_jsbytes("Weak.get_copy"),
     cst_Weak_get=caml_string_of_jsbytes("Weak.get"),
     cst_Weak_set=caml_string_of_jsbytes("Weak.set"),
     cst_Weak_create=caml_string_of_jsbytes("Weak.create"),
     cst$84=caml_string_of_jsbytes(""),
     cst$85=caml_string_of_jsbytes(""),
     cst$83=caml_string_of_jsbytes("."),
     cst$80=caml_string_of_jsbytes(">"),
     cst$81=caml_string_of_jsbytes("<\/"),
     cst$82=caml_string_of_jsbytes(""),
     cst$77=caml_string_of_jsbytes(">"),
     cst$78=caml_string_of_jsbytes("<"),
     cst$79=caml_string_of_jsbytes(""),
     cst$76=caml_string_of_jsbytes("\n"),
     cst_Format_pp_set_geometry=
      caml_string_of_jsbytes("Format.pp_set_geometry: "),
     cst$72=caml_string_of_jsbytes(""),
     cst$73=caml_string_of_jsbytes(""),
     cst$74=caml_string_of_jsbytes(""),
     cst$75=caml_string_of_jsbytes(""),
     cst$68=caml_string_of_jsbytes(""),
     cst$69=caml_string_of_jsbytes(""),
     cst$70=caml_string_of_jsbytes(""),
     cst$71=caml_string_of_jsbytes(""),
     cst$67=caml_string_of_jsbytes(""),
     cst_Stdlib_Format_String_tag=
      caml_string_of_jsbytes("Stdlib.Format.String_tag"),
     cst_end_of_input_not_found=
      caml_string_of_jsbytes("end of input not found"),
     cst_scanf_bad_conversion_a=
      caml_string_of_jsbytes('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=
      caml_string_of_jsbytes('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_string_of_jsbytes("scanf: missing reader"),
     cst_scanf_bad_conversion_custo=
      caml_string_of_jsbytes('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=
      caml_string_of_jsbytes('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst$91=caml_string_of_jsbytes('"'),
     cst$92=caml_string_of_jsbytes('"'),
     cst$89=caml_string_of_jsbytes('"'),
     cst$90=caml_string_of_jsbytes('"'),
     cst$88=caml_string_of_jsbytes('"'),
     cst_in_format=caml_string_of_jsbytes(' in format "'),
     cst_an=caml_string_of_jsbytes("an"),
     cst_x$2=caml_string_of_jsbytes("x"),
     cst_nfinity=caml_string_of_jsbytes("nfinity"),
     cst_digits=caml_string_of_jsbytes("digits"),
     cst_decimal_digits=caml_string_of_jsbytes("decimal digits"),
     cst_0b=caml_string_of_jsbytes("0b"),
     cst_0o=caml_string_of_jsbytes("0o"),
     cst_0u=caml_string_of_jsbytes("0u"),
     cst_0x=caml_string_of_jsbytes("0x"),
     cst_false$3=caml_string_of_jsbytes("false"),
     cst_true$3=caml_string_of_jsbytes("true"),
     cst_not_a_valid_float_in_hexad=
      caml_string_of_jsbytes("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_fo=
      caml_string_of_jsbytes("no dot or exponent part found in float token"),
     cst$87=caml_string_of_jsbytes("-"),
     cst_unnamed_function=caml_string_of_jsbytes("unnamed function"),
     cst_unnamed_character_string=
      caml_string_of_jsbytes("unnamed character string"),
     cst_unnamed_Stdlib_input_chann=
      caml_string_of_jsbytes("unnamed Stdlib input channel"),
     cst$86=caml_string_of_jsbytes("-"),
     cst_Stdlib_Scanf_Scan_failure=
      caml_string_of_jsbytes("Stdlib.Scanf.Scan_failure"),
     cst_binary=caml_string_of_jsbytes("binary"),
     cst_octal=caml_string_of_jsbytes("octal"),
     cst_hexadecimal=caml_string_of_jsbytes("hexadecimal"),
     cst_a_Char=caml_string_of_jsbytes("a Char"),
     cst_a_String=caml_string_of_jsbytes("a String"),
     cst$93=caml_string_of_jsbytes(""),
     cst$94=caml_string_of_jsbytes(""),
     cst$95=caml_string_of_jsbytes(""),
     cst$96=caml_string_of_jsbytes(""),
     cst$97=caml_string_of_jsbytes(""),
     cst$99=caml_string_of_jsbytes(""),
     cst$98=caml_string_of_jsbytes(""),
     cst_Illegal_character=caml_string_of_jsbytes("Illegal character "),
     cst_Filename_chop_extension=
      caml_string_of_jsbytes("Filename.chop_extension"),
     cst$127=caml_string_of_jsbytes(""),
     cst_Filename_chop_suffix=caml_string_of_jsbytes("Filename.chop_suffix"),
     cst$126=caml_string_of_jsbytes(""),
     cst_2_1$0=caml_string_of_jsbytes(" 2>&1"),
     cst_2$0=caml_string_of_jsbytes(" 2>"),
     cst$125=caml_string_of_jsbytes(""),
     cst$117=caml_string_of_jsbytes(" >"),
     cst$124=caml_string_of_jsbytes(""),
     cst$118=caml_string_of_jsbytes(" <"),
     cst$123=caml_string_of_jsbytes(""),
     cst$119=caml_string_of_jsbytes(" "),
     cst$120=caml_string_of_jsbytes(" "),
     cst$121=caml_string_of_jsbytes('"'),
     cst$122=caml_string_of_jsbytes(""),
     cst_Filename_quote_command_bad=
      caml_string_of_jsbytes("Filename.quote_command: bad file name "),
     cst$115=caml_string_of_jsbytes('"'),
     cst$116=caml_string_of_jsbytes('"'),
     cst$113=caml_string_of_jsbytes("./"),
     cst$112=caml_string_of_jsbytes(".\\"),
     cst$111=caml_string_of_jsbytes("../"),
     cst$110=caml_string_of_jsbytes("..\\"),
     cst_2_1=caml_string_of_jsbytes(" 2>&1"),
     cst_2=caml_string_of_jsbytes(" 2>"),
     cst$109=caml_string_of_jsbytes(""),
     cst$104=caml_string_of_jsbytes(" >"),
     cst$108=caml_string_of_jsbytes(""),
     cst$105=caml_string_of_jsbytes(" <"),
     cst$107=caml_string_of_jsbytes(""),
     cst$106=caml_string_of_jsbytes(" "),
     cst$103=caml_string_of_jsbytes("./"),
     cst$102=caml_string_of_jsbytes("../"),
     cst$101=caml_string_of_jsbytes(""),
     cst$100=caml_string_of_jsbytes(""),
     null$0=caml_string_of_jsbytes("/dev/null"),
     current_dir_name=caml_string_of_jsbytes("."),
     parent_dir_name=caml_string_of_jsbytes(".."),
     dir_sep=caml_string_of_jsbytes("/"),
     cst_TMPDIR=caml_string_of_jsbytes("TMPDIR"),
     cst_tmp=caml_string_of_jsbytes("/tmp"),
     quotequote=caml_string_of_jsbytes("'\\''"),
     null$1=caml_string_of_jsbytes("NUL"),
     current_dir_name$0=caml_string_of_jsbytes("."),
     parent_dir_name$0=caml_string_of_jsbytes(".."),
     dir_sep$0=caml_string_of_jsbytes("\\"),
     cst_TEMP=caml_string_of_jsbytes("TEMP"),
     cst$114=caml_string_of_jsbytes("."),
     null$2=caml_string_of_jsbytes("/dev/null"),
     current_dir_name$1=caml_string_of_jsbytes("."),
     parent_dir_name$1=caml_string_of_jsbytes(".."),
     dir_sep$1=caml_string_of_jsbytes("/"),
     cst_Cygwin=caml_string_of_jsbytes("Cygwin"),
     cst_Win32=caml_string_of_jsbytes("Win32"),
     zero$4=[254,0.,0.],
     one$4=[254,1.,0.],
     i=[254,0.,1.],
     cst_Bigarray_array3_of_genarra=
      caml_string_of_jsbytes("Bigarray.array3_of_genarray"),
     cst_Bigarray_array2_of_genarra=
      caml_string_of_jsbytes("Bigarray.array2_of_genarray"),
     cst_Bigarray_array1_of_genarra=
      caml_string_of_jsbytes("Bigarray.array1_of_genarray"),
     cst_Bigarray_array0_of_genarra=
      caml_string_of_jsbytes("Bigarray.array0_of_genarray"),
     cst_Bigarray_Array3_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array3_of_array_n$0=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array2_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array2.of_array: non-rectangular data"),
     Invalid_argument=global_data.Invalid_argument,
     Failure=global_data.Failure,
     Match_failure=global_data.Match_failure,
     Assert_failure=global_data.Assert_failure,
     Not_found=global_data.Not_found,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Sys_error=global_data.Sys_error,
     End_of_file=global_data.End_of_file,
     Division_by_zero=global_data.Division_by_zero,
     Sys_blocked_io=global_data.Sys_blocked_io,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _l_=[0,0,[0,6,0]],
     _k_=[0,0,[0,7,0]],
     _j_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _i_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _g_=[0,1],
     _h_=[0,0],
     _a_=runtime.caml_int64_create_lo_mi_hi(0,0,32752),
     _b_=runtime.caml_int64_create_lo_mi_hi(0,0,65520),
     _c_=runtime.caml_int64_create_lo_mi_hi(1,0,32752),
     _d_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32751),
     _e_=runtime.caml_int64_create_lo_mi_hi(0,0,16),
     _f_=runtime.caml_int64_create_lo_mi_hi(0,0,15536),
     _p_=[0,0,0],
     _q_=[0,caml_string_of_jsbytes("obj.ml"),100,4],
     _u_=[0,caml_string_of_jsbytes("array.ml"),258,4],
     _w_=[0,caml_string_of_jsbytes("float.ml"),379,6],
     _v_=[0,caml_string_of_jsbytes("float.ml"),206,14],
     _H_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _G_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _F_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _E_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _I_=[0,0,0,0],
     _J_=[0,0,0],
     _K_=[0,caml_string_of_jsbytes("set.ml"),570,18],
     _L_=[0,0,0,0],
     _M_=[0,caml_string_of_jsbytes("map.ml"),400,10],
     _N_=[0,0,0],
     _O_=[0,caml_string_of_jsbytes("stream.ml"),53,12],
     _P_=[0,0],
     _Q_=[0,caml_string_of_jsbytes("stream.ml"),82,12],
     ___=[0,caml_string_of_jsbytes("buffer.ml"),282,9],
     _Z_=[0,caml_string_of_jsbytes("buffer.ml"),263,2],
     _Y_=[0,caml_string_of_jsbytes("buffer.ml"),195,19],
     _X_=[0,caml_string_of_jsbytes("buffer.ml"),213,8],
     _W_=[0,caml_string_of_jsbytes("buffer.ml"),174,19],
     _V_=[0,caml_string_of_jsbytes("buffer.ml"),192,8],
     _U_=[0,caml_string_of_jsbytes("buffer.ml"),138,19],
     _T_=[0,caml_string_of_jsbytes("buffer.ml"),171,8],
     _S_=[0,caml_string_of_jsbytes("buffer.ml"),93,2],
     _R_=[0,caml_string_of_jsbytes("buffer.ml"),94,2],
     _aa_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),850,23],
     _al_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),814,21],
     _ad_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),815,21],
     _am_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),818,21],
     _ae_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),819,21],
     _an_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),822,19],
     _af_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),823,19],
     _ao_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),826,22],
     _ag_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),827,22],
     _ap_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),831,30],
     _ah_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),832,30],
     _aj_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),836,26],
     _ab_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),837,26],
     _ak_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),846,28],
     _ac_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),847,28],
     _ai_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),851,23],
     _ar_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1558,4],
     _as_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1626,39],
     _at_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1649,31],
     _au_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1650,31],
     _av_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1830,8],
     _aZ_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aY_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aB_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", duplicate flag "),[1,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _aC_=[0,1,0],
     _aD_=[0,0],
     _aE_=[1,0],
     _aF_=[1,1],
     _aH_=[1,1],
     _aG_=[1,1],
     _aL_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", flag "),
            [1,
             [11,
              caml_string_of_jsbytes(" is only allowed after the '"),
              [12,
               37,
               [11,
                caml_string_of_jsbytes("', before padding and precision"),
                0]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aI_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aJ_=[0,0],
     _aK_=[0,0],
     _aM_=[0,[12,64,0]],
     _aN_=[0,caml_string_of_jsbytes("@ "),1,0],
     _aO_=[0,caml_string_of_jsbytes("@,"),0,0],
     _aP_=[2,60],
     _aQ_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": '"),
          [12,
           37,
           [11,
            caml_string_of_jsbytes
             ("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_string_of_jsbytes(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aR_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": integer "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(" is greater than the limit "),
            [4,0,0,0,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aS_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2837,11],
     _aT_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,
            [11,caml_string_of_jsbytes('" at character number '),[4,0,0,0,0]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aU_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2899,34],
     _aV_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2935,28],
     _aW_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2957,11],
     _aX_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,
             0,
             [11,
              caml_string_of_jsbytes(" is incompatible with '"),
              [0,[11,caml_string_of_jsbytes("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _aA_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(" expected, read "),[1,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _az_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", '"),
            [0,[11,caml_string_of_jsbytes("' without "),[2,0,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, '%c' without %s")],
     _ay_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]]]],
       caml_string_of_jsbytes("invalid format %S: at character number %d, %s")],
     _ax_=
      [0,
       [11,caml_string_of_jsbytes("invalid box description "),[3,0,0]],
       caml_string_of_jsbytes("invalid box description %S")],
     _aw_=[0,0,4],
     _aq_=[0,103],
     _$_=[0,0,0],
     _bj_=[0,[2,0,[0,0]],caml_string_of_jsbytes("%s%c")],
     _bd_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _be_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bb_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bc_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a$_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _ba_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a5_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": unknown option '"),
         [2,0,[11,caml_string_of_jsbytes("'.\n"),0]]]],
       caml_string_of_jsbytes("%s: unknown option '%s'.\n")],
     _a8_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": wrong argument '"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("'; option '"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("' expects "),
             [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]]]]]],
       caml_string_of_jsbytes
        ("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a9_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": option '"),
         [2,0,[11,caml_string_of_jsbytes("' needs an argument.\n"),0]]]],
       caml_string_of_jsbytes("%s: option '%s' needs an argument.\n")],
     _a__=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": "),
         [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]],
       caml_string_of_jsbytes("%s: %s.\n")],
     _a6_=[0,caml_string_of_jsbytes("-help")],
     _a7_=[0,caml_string_of_jsbytes("--help")],
     _a4_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a3_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _a2_=[0,caml_string_of_jsbytes("-help")],
     _a0_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_string_of_jsbytes("  %s %s\n")],
     _a1_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_string_of_jsbytes("  %s %s%s\n")],
     _bo_=
      [0,
       [11,caml_string_of_jsbytes(", "),[2,0,[2,0,0]]],
       caml_string_of_jsbytes(", %s%s")],
     _bz_=
      [0,
       [11,caml_string_of_jsbytes("Fatal error: exception "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Fatal error: exception %s\n")],
     _bx_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bv_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bw_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_string_of_jsbytes
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _bt_=
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           caml_string_of_jsbytes(' in file "'),
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11,
               caml_string_of_jsbytes(", line "),
               [4,0,0,0,[11,caml_string_of_jsbytes(", characters "),partial]]]]]]]]]],
       caml_string_of_jsbytes
        ('%s %s in file "%s"%s, line %d, characters %d-%d')],
     _bu_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" unknown location"),0]],
       caml_string_of_jsbytes("%s unknown location")],
     _bs_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _br_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _bp_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_string_of_jsbytes("(%s%s)")],
     _bq_=[0,[12,40,[2,0,[12,41,0]]],caml_string_of_jsbytes("(%s)")],
     _bn_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bm_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _by_=
      [0,
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file not found)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file appears to be corrupt)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file has wrong magic number)"),
       caml_string_of_jsbytes
        ("(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)")],
     _bG_=
      [0,
       [11,
        caml_string_of_jsbytes("minor_collections:      "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("minor_collections:      %d\n")],
     _bH_=
      [0,
       [11,
        caml_string_of_jsbytes("major_collections:      "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("major_collections:      %d\n")],
     _bI_=
      [0,
       [11,
        caml_string_of_jsbytes("compactions:            "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("compactions:            %d\n")],
     _bJ_=
      [0,
       [11,
        caml_string_of_jsbytes("forced_major_collections: "),
        [4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("forced_major_collections: %d\n")],
     _bK_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bL_=[0,[8,[0,0,0],0,[0,0],0],caml_string_of_jsbytes("%.0f")],
     _bM_=
      [0,
       [11,
        caml_string_of_jsbytes("minor_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("minor_words:    %*.0f\n")],
     _bN_=
      [0,
       [11,
        caml_string_of_jsbytes("promoted_words: "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("promoted_words: %*.0f\n")],
     _bO_=
      [0,
       [11,
        caml_string_of_jsbytes("major_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("major_words:    %*.0f\n")],
     _bP_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bQ_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bR_=
      [0,
       [11,caml_string_of_jsbytes("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("top_heap_words: %*d\n")],
     _bS_=
      [0,
       [11,caml_string_of_jsbytes("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("heap_words:     %*d\n")],
     _bT_=
      [0,
       [11,caml_string_of_jsbytes("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("live_words:     %*d\n")],
     _bU_=
      [0,
       [11,caml_string_of_jsbytes("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("free_words:     %*d\n")],
     _bV_=
      [0,
       [11,caml_string_of_jsbytes("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("largest_free:   %*d\n")],
     _bW_=
      [0,
       [11,caml_string_of_jsbytes("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("fragments:      %*d\n")],
     _bX_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bY_=
      [0,
       [11,caml_string_of_jsbytes("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("live_blocks: %d\n")],
     _bZ_=
      [0,
       [11,caml_string_of_jsbytes("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("free_blocks: %d\n")],
     _b0_=
      [0,
       [11,caml_string_of_jsbytes("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("heap_chunks: %d\n")],
     _b8_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _b9_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _b__=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _cc_=[0,0],
     _cb_=[0,caml_string_of_jsbytes("hashtbl.ml"),102,23],
     _ci_=[3,0,3],
     _ch_=[1,caml_string_of_jsbytes("max_indent < 2")],
     _cf_=[1,caml_string_of_jsbytes("margin <= max_indent")],
     _cg_=[0,0],
     _ce_=[0,caml_string_of_jsbytes("")],
     _cd_=[0,caml_string_of_jsbytes(""),0,caml_string_of_jsbytes("")],
     _cy_=[0,91],
     _cx_=[0,123],
     _cz_=[0,caml_string_of_jsbytes("scanf.ml"),1453,13],
     _cA_=[0,[3,0,[10,0]],caml_string_of_jsbytes("%S%!")],
     _cw_=[0,37,caml_string_of_jsbytes("")],
     _cv_=
      [0,
       [11,
        caml_string_of_jsbytes("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]],
       caml_string_of_jsbytes("scanf: bad input at char number %i: %s")],
     _cu_=
      [0,
       [11,
        caml_string_of_jsbytes("the character "),
        [1,[11,caml_string_of_jsbytes(" cannot start a boolean"),0]]],
       caml_string_of_jsbytes("the character %C cannot start a boolean")],
     _ct_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character hexadecimal encoding \\"),
        [0,[0,0]]],
       caml_string_of_jsbytes("bad character hexadecimal encoding \\%c%c")],
     _cs_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character decimal encoding \\"),
        [0,[0,[0,0]]]],
       caml_string_of_jsbytes("bad character decimal encoding \\%c%c%c")],
     _cr_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,
         [11,
          caml_string_of_jsbytes(" is not a valid "),
          [2,0,[11,caml_string_of_jsbytes(" digit"),0]]]]],
       caml_string_of_jsbytes("character %C is not a valid %s digit")],
     _cq_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,[11,caml_string_of_jsbytes(" is not a decimal digit"),0]]],
       caml_string_of_jsbytes("character %C is not a decimal digit")],
     _cp_=[0,caml_string_of_jsbytes("scanf.ml"),555,9],
     _co_=
      [0,
       [11,caml_string_of_jsbytes("invalid boolean '"),[2,0,[12,39,0]]],
       caml_string_of_jsbytes("invalid boolean '%s'")],
     _cn_=
      [0,
       [11,
        caml_string_of_jsbytes("looking for "),
        [1,[11,caml_string_of_jsbytes(", found "),[1,0]]]],
       caml_string_of_jsbytes("looking for %C, found %C")],
     _cm_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _cl_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: the specified length was too short for token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: the specified length was too short for token")],
     _ck_=
      [0,
       [11,caml_string_of_jsbytes("illegal escape character "),[1,0]],
       caml_string_of_jsbytes("illegal escape character %C")],
     _cH_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),438,17],
     _cG_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),420,13],
     _cF_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),417,13],
     _cE_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),414,13],
     _cD_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),411,13],
     _cC_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),408,13],
     _cB_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),281,50],
     _cK_=[0,0],
     _cJ_=[0,0],
     _cI_=[0,0],
     _cP_=[0,7,0],
     _cO_=[0,1,[0,3,[0,5,0]]],
     _cN_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_string_of_jsbytes("%s%06x%s")],
     _cM_=[0,caml_string_of_jsbytes('"'),0],
     _cQ_=[254,0.,0.];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (744,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function make(v){return [0,v]}
    function get(r){return r[1]}
    function set(r,v){r[1] = v;return 0}
    function exchange(r,v){var cur=r[1];r[1] = v;return cur}
    function compare_and_set(r,seen,v)
     {var cur=r[1];return cur === seen?(r[1] = v,1):0}
    function fetch_and_add(r,n){var cur=r[1];r[1] = cur + n | 0;return cur}
    function incr(r){fetch_and_add(r,1);return 0}
    function decr(r){fetch_and_add(r,-1);return 0}
    var
     include=
      [0,make,get,set,exchange,compare_and_set,fetch_and_add,incr,decr];
    caml_register_global(745,include,"CamlinternalAtomic");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Stdlib_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function symbol(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function char_of_int(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_g_
              :_h_}
    function string_of_int(n){return caml_string_of_jsbytes("" + n)}
    function int_of_string_opt(s)
     {try
       {var _BP_=[0,caml_int_of_string(s)];return _BP_}
      catch(_BQ_)
       {_BQ_ = caml_wrap_exception(_BQ_);
        if(_BQ_[1] === Failure)return 0;
        throw _BQ_}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return symbol(s,cst);
        var match=caml_string_get(s,i),switch$0=0;
        if(48 <= match)
         {if(! (58 <= match))switch$0 = 1}
        else
         if(45 === match)switch$0 = 1;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function to_string(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function of_string_opt(s)
     {try
       {var _BN_=[0,caml_float_of_string(s)];return _BN_}
      catch(_BO_)
       {_BO_ = caml_wrap_exception(_BO_);
        if(_BO_[1] === Failure)return 0;
        throw _BO_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_i_,438,name)}
    function open_out_bin(name){return open_out_gen(_j_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_BM_)
             {_BM_ = caml_wrap_exception(_BM_);
              if(_BM_[1] !== Sys_error)throw _BM_;
              var _BL_=_BM_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(s) - len | 0) < ofs))
       return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_BK_){}
      try
       {var _BI_=caml_ml_close_channel(oc);return _BI_}
      catch(_BJ_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_k_,0,name)}
    function open_in_bin(name){return open_in_gen(_l_,0,name)}
    function input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);
      really_input(ic,s,0,len);
      return caml_string_of_bytes(s)}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(! accu)throw End_of_file;
          var _BH_=build_result(caml_create_bytes(len),len,accu)}
        else
         {if(! (0 < n))
           {var beg=caml_create_bytes(- n | 0);
            caml_ml_input(chan,beg,0,- n | 0);
            var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
            continue}
          var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           var
            len$0=(len + n | 0) - 1 | 0,
            _BH_=build_result(caml_create_bytes(len$0),len$0,[0,res,accu]);
          else
           var _BH_=res}
        return caml_string_of_bytes(_BH_)}}
    function close_in_noerr(ic)
     {try
       {var _BF_=caml_ml_close_channel(ic);return _BF_}
      catch(_BG_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_string_of_jsbytes("" + i))}
    function print_float(f){return output_string(stdout,to_string(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_string_of_jsbytes("" + i))}
    function prerr_float(f){return output_string(stderr,to_string(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return of_string_opt(read_line(0))}
    function string_of_format(param){var str=param[2];return str}
    function symbol$0(param,_BD_)
     {var
       str2=_BD_[2],
       fmt2=_BD_[1],
       str1=param[2],
       fmt1=param[1],
       _BE_=symbol(str1,symbol(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_BE_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {for(;;)
       {var
         f_yet_to_run=[0,1],
         old_exit=exit_function[1],
         new_exit$0=
          function(f_yet_to_run,old_exit)
           {function new_exit(param)
             {if(compare_and_set(f_yet_to_run,1,0))caml_call1(f,0);
              return caml_call1(old_exit,0)}
            return new_exit},
         new_exit=new_exit$0(f_yet_to_run,old_exit),
         success=compare_and_set(exit_function,old_exit,new_exit),
         _BC_=1 - success;
        if(_BC_)continue;
        return _BC_}}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    if(runtime.caml_sys_const_naked_pointers_checked(0))
     at_exit(function(_BB_){return runtime.caml_gc_major(_BB_)});
    var
     set_binary_mode_in=caml_ml_set_binary_mode,
     close_in=caml_ml_close_channel,
     in_channel_length=caml_ml_channel_size,
     pos_in=runtime.caml_ml_pos_in,
     seek_in=runtime.caml_ml_seek_in,
     input_value=caml_input_value,
     input_binary_int=runtime.caml_ml_input_int,
     input_byte=caml_ml_input_char,
     input_char=caml_ml_input_char,
     set_binary_mode_out=caml_ml_set_binary_mode,
     out_channel_length=caml_ml_channel_size,
     pos_out=runtime.caml_ml_pos_out,
     seek_out=runtime.caml_ml_seek_out,
     output_binary_int=runtime.caml_ml_output_int,
     output_byte=caml_ml_output_char,
     output_char=caml_ml_output_char,
     flush=caml_ml_flush,
     Stdlib=
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
    caml_register_global(758,Stdlib,"Stdlib");
    var
     Exit$0=[248,cst_Stdlib_Pervasives_Exit,caml_fresh_oo_id(0)],
     Stdlib_pervasives=
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       do_at_exit];
    caml_register_global(759,Stdlib_pervasives,"Stdlib__pervasives");
    function empty(param){return 0}
    function return$0(x,param){return [0,x,empty]}
    function cons(x,next,param){return [0,x,next]}
    function append$0(seq1,seq2,param)
     {var match=caml_call1(seq1,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_BA_){return append$0(next,seq2,_BA_)}]}
      return caml_call1(seq2,0)}
    function map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _By_=function(_Bz_){return map(f,next,_Bz_)};
        return [0,caml_call1(f,x),_By_]}
      return 0}
    function filter_map(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1],match$0=caml_call1(f,x);
          if(match$0)
           {var y=match$0[1];
            return [0,y,function(_Bx_){return filter_map(f,next,_Bx_)}]}
          var seq$0=next;
          continue}
        return 0}}
    function filter(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          if(caml_call1(f,x))
           return [0,x,function(_Bw_){return filter(f,next,_Bw_)}];
          var seq$0=next;
          continue}
        return 0}}
    function flat_map$0(counter,f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1],_Bv_=caml_call1(f,x),_Bu_=0;
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return flat_map_app$0(counter$0,f,_Bv_,next,_Bu_)}
        return caml_trampoline_return(flat_map_app$0,[0,f,_Bv_,next,_Bu_])}
      return 0}
    function flat_map_app$0(counter,f,seq,tail,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_Bt_){return flat_map_app(f,next,tail,_Bt_)}]}
      var _Bs_=0;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return flat_map$0(counter$0,f,tail,_Bs_)}
      return caml_trampoline_return(flat_map$0,[0,f,tail,_Bs_])}
    function flat_map(f,seq,param)
     {return caml_trampoline(flat_map$0(0,f,seq,param))}
    function flat_map_app(f,seq,tail,param)
     {return caml_trampoline(flat_map_app$0(0,f,seq,tail,param))}
    function fold_left(f,acc,seq)
     {var acc$0=acc,seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var
           next=match[2],
           x=match[1],
           acc$1=caml_call2(f,acc$0,x),
           acc$0=acc$1,
           seq$0=next;
          continue}
        return acc$0}}
    function iter(f,seq)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          caml_call1(f,x);
          var seq$0=next;
          continue}
        return 0}}
    function unfold(f,u,param)
     {var match=caml_call1(f,u);
      if(match)
       {var match$0=match[1],u$0=match$0[2],x=match$0[1];
        return [0,x,function(_Br_){return unfold(f,u$0,_Br_)}]}
      return 0}
    var
     Stdlib_seq=
      [0,
       empty,
       return$0,
       cons,
       append$0,
       map,
       filter,
       filter_map,
       flat_map,
       fold_left,
       iter,
       unfold];
    caml_register_global(760,Stdlib_seq,"Stdlib__seq");
    var none=0;
    function some(v){return [0,v]}
    function value(o,default$0){if(o){var v=o[1];return v}return default$0}
    function get$0(param)
     {if(param){var v=param[1];return v}
      return invalid_arg(cst_option_is_None)}
    function bind(o,f){if(o){var v=o[1];return caml_call1(f,v)}return 0}
    function join(param){if(param){var o=param[1];return o}return 0}
    function map$0(f,o){if(o){var v=o[1];return [0,caml_call1(f,v)]}return 0}
    function fold(none,some,param)
     {if(param){var v=param[1];return caml_call1(some,v)}return none}
    function iter$0(f,param)
     {if(param){var v=param[1];return caml_call1(f,v)}return 0}
    function is_none(param){return param?0:1}
    function is_some(param){return param?1:0}
    function equal(eq,o0,o1)
     {if(o0)
       {if(o1){var v1=o1[1],v0=o0[1];return caml_call2(eq,v0,v1)}}
      else
       if(! o1)return 1;
      return 0}
    function compare(cmp,o0,o1)
     {if(o0)
       {var _Bq_=o0[1];
        if(o1){var v1=o1[1];return caml_call2(cmp,_Bq_,v1)}
        return 1}
      return o1?-1:0}
    function to_result(none,param)
     {if(param){var v=param[1];return [0,v]}return [1,none]}
    function to_list(param){if(param){var v=param[1];return [0,v,0]}return 0}
    function to_seq(param)
     {if(param){var v=param[1];return function(_Bp_){return return$0(v,_Bp_)}}
      return empty}
    var
     Stdlib_option=
      [0,
       none,
       some,
       value,
       get$0,
       bind,
       join,
       map$0,
       fold,
       iter$0,
       is_none,
       is_some,
       equal,
       compare,
       to_result,
       to_list,
       to_seq];
    caml_register_global(761,Stdlib_option,"Stdlib__option");
    function left(v){return [0,v]}
    function right(v){return [1,v]}
    function is_left(param){return 0 === param[0]?1:0}
    function is_right(param){return 0 === param[0]?0:1}
    function find_left(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function find_right(param)
     {if(0 === param[0])return 0;var v=param[1];return [0,v]}
    function map_left(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_right(f,e)
     {if(0 === e[0])return e;var v=e[1];return [1,caml_call1(f,v)]}
    function map$1(left,right,param)
     {if(0 === param[0]){var v=param[1];return [0,caml_call1(left,v)]}
      var v$0=param[1];
      return [1,caml_call1(right,v$0)]}
    function fold$0(left,right,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(left,v)}
      var v$0=param[1];
      return caml_call1(right,v$0)}
    function equal$0(left,right,e1,match)
     {if(0 === e1[0])
       {var _Bn_=e1[1];
        if(0 === match[0]){var v2=match[1];return caml_call2(left,_Bn_,v2)}}
      else
       {var _Bo_=e1[1];
        if(0 !== match[0])
         {var v2$0=match[1];return caml_call2(right,_Bo_,v2$0)}}
      return 0}
    function compare$0(left,right,e1,match)
     {if(0 === e1[0])
       {var _Bl_=e1[1];
        if(0 === match[0]){var v2=match[1];return caml_call2(left,_Bl_,v2)}
        return -1}
      var _Bm_=e1[1];
      if(0 === match[0])return 1;
      var v2$0=match[1];
      return caml_call2(right,_Bm_,v2$0)}
    var
     Stdlib_either=
      [0,
       left,
       right,
       is_left,
       is_right,
       find_left,
       find_right,
       map_left,
       map_right,
       map$1,
       fold$0,
       fold$0,
       fold$0,
       equal$0,
       compare$0];
    caml_register_global(762,Stdlib_either,"Stdlib__either");
    function ok(v){return [0,v]}
    function error(e){return [1,e]}
    function value$0(r,default$0)
     {if(0 === r[0]){var v=r[1];return v}return default$0}
    function get_ok(param)
     {if(0 === param[0]){var v=param[1];return v}
      return invalid_arg(cst_result_is_Error)}
    function get_error(param)
     {if(0 === param[0])return invalid_arg(cst_result_is_Ok);
      var e=param[1];
      return e}
    function bind$0(r,f)
     {if(0 === r[0]){var v=r[1];return caml_call1(f,v)}return r}
    function join$0(e){if(0 === e[0]){var r=e[1];return r}return e}
    function map$2(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_error(f,v)
     {if(0 === v[0])return v;var e=v[1];return [1,caml_call1(f,e)]}
    function fold$1(ok,error,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(ok,v)}
      var e=param[1];
      return caml_call1(error,e)}
    function iter$1(f,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(f,v)}return 0}
    function iter_error(f,param)
     {if(0 === param[0])return 0;var e=param[1];return caml_call1(f,e)}
    function is_ok(param){return 0 === param[0]?1:0}
    function is_error(param){return 0 === param[0]?0:1}
    function equal$1(ok,error,r0,match)
     {if(0 === r0[0])
       {var _Bj_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_Bj_,v1)}}
      else
       {var _Bk_=r0[1];
        if(0 !== match[0]){var e1=match[1];return caml_call2(error,_Bk_,e1)}}
      return 0}
    function compare$1(ok,error,r0,match)
     {if(0 === r0[0])
       {var _Bh_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_Bh_,v1)}
        return -1}
      var _Bi_=r0[1];
      if(0 === match[0])return 1;
      var e1=match[1];
      return caml_call2(error,_Bi_,e1)}
    function to_option(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function to_list$0(param)
     {if(0 === param[0]){var v=param[1];return [0,v,0]}return 0}
    function to_seq$0(param)
     {if(0 === param[0])
       {var v=param[1];return function(_Bg_){return return$0(v,_Bg_)}}
      return empty}
    var
     Stdlib_result=
      [0,
       ok,
       error,
       value$0,
       get_ok,
       get_error,
       bind$0,
       join$0,
       map$2,
       map_error,
       fold$1,
       iter$1,
       iter_error,
       is_ok,
       is_error,
       equal$1,
       compare$1,
       to_option,
       to_list$0,
       to_seq$0];
    caml_register_global(763,Stdlib_result,"Stdlib__result");
    function equal$2(_Bf_,_Be_){return _Bf_ === _Be_?1:0}
    var compare$2=caml_int_compare;
    function to_float(param){return param?1.:0.}
    function to_string$0(param){return param?cst_true$2:cst_false$2}
    function _m_(_Bd_){return _Bd_}
    var
     Stdlib_bool=
      [0,
       function(_Bc_){return 1 - _Bc_},
       equal$2,
       compare$2,
       _m_,
       to_float,
       to_string$0];
    caml_register_global(764,Stdlib_bool,"Stdlib__bool");
    function chr(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {var switch$0=0;
      if(40 <= c)
       {if(92 === c)return cst$1;if(! (127 <= c))switch$0 = 1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;switch$0 = 1}
       else
        if(! (14 <= c))
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r
           }
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return caml_string_of_bytes(s$0)}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return caml_string_of_bytes(s)}
    function lowercase(c)
     {var _Bb_=c - 192 | 0,switch$0=0;
      if(30 < _Bb_ >>> 0)
       {if(! (25 < (_Bb_ + 127 | 0) >>> 0))switch$0 = 1}
      else
       if(23 !== _Bb_)switch$0 = 1;
      return switch$0?c + 32 | 0:c}
    function uppercase(c)
     {var _Ba_=c - 224 | 0,switch$0=0;
      if(30 < _Ba_ >>> 0)
       {if(! (25 < (_Ba_ + 127 | 0) >>> 0))switch$0 = 1}
      else
       if(23 !== _Ba_)switch$0 = 1;
      return switch$0?c - 32 | 0:c}
    function lowercase_ascii(c)
     {var switcher=c - 65 | 0;return 25 < switcher >>> 0?c:c + 32 | 0}
    function uppercase_ascii(c)
     {var switcher=c - 97 | 0;return 25 < switcher >>> 0?c:c - 32 | 0}
    function compare$3(c1,c2){return c1 - c2 | 0}
    function equal$3(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Stdlib_char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare$3,
       equal$3];
    caml_register_global(765,Stdlib_char,"Stdlib__char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _A8_=0 <= i?1:0,_A9_=_A8_?i <= 55295?1:0:_A8_;
      if(_A9_)
       var _A__=_A9_;
      else
       var _A$_=57344 <= i?1:0,_A__=_A$_?i <= 1114111?1:0:_A$_;
      return _A__}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (symbol
                  (caml_format_int(cst_X,i),cst_is_not_an_Unicode_scalar_v))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (symbol
                  (cst_U,
                   symbol
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_A7_){return _A7_}
    function equal$4(_A6_,_A5_){return _A6_ === _A5_?1:0}
    var compare$4=caml_int_compare;
    function hash(_A4_){return _A4_}
    function _n_(_A3_){return _A3_}
    var
     Stdlib_uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_A2_){return _A2_},
       _n_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$4,
       compare$4,
       hash];
    caml_register_global(766,Stdlib_uchar,"Stdlib__uchar");
    var
     executable_name=runtime.caml_sys_executable_name(0),
     match=runtime.caml_sys_get_config(0),
     os_type=match[1],
     match$0=runtime.caml_sys_const_backend_type(0),
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_floatarray_length=max_array_length / 2 | 0,
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     big_endian=0,
     match$1=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _A0_=[0,caml_sys_getenv(s)];return _A0_}
      catch(_A1_)
       {_A1_ = caml_wrap_exception(_A1_);
        if(_A1_ === Not_found)return 0;
        throw _A1_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Stdlib_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    function Make(_AZ_,_AY_){return [0,1]}
    var
     Immediate64=[0,Make],
     Stdlib_sys=
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       match$0,
       unix,
       win32,
       cygwin,
       match$1,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
    caml_register_global(767,Stdlib_sys,"Stdlib__sys");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons$0(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    var rev_init_threshold=typeof match$0 === "number"?10000:50;
    function init(len,f)
     {if(0 <= len)
       {if(rev_init_threshold < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map$3(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$3(f,l)]}
      return 0}
    function _o_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_o_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _o_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter$2(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left$0(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_AX_=caml_call1(p,a);
          if(_AX_){var param$0=l;continue}
          return _AX_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_AW_=caml_call1(p,a);
          if(_AW_)return _AW_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _AV_=caml_call2(p,a1,a2);
            if(_AV_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _AV_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _AU_=caml_call2(p,a1,a2);
            if(_AU_)return _AU_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_AT_=0 === caml_compare(a,x)?1:0;
          if(_AT_)return _AT_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_AS_=a === x?1:0;
          if(_AS_)return _AS_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _AR_=0 === caml_compare(a,x)?1:0;
          if(_AR_)return _AR_;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_AQ_=a === x?1:0;
          if(_AQ_)return _AQ_;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1],result=caml_call1(f,x);
          if(result)return result;
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function filteri(p,param)
     {var i=0,acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           acc$0=caml_call2(p,i,x)?[0,x,acc]:acc,
           i$0=i + 1 | 0,
           i=i$0,
           acc=acc$0,
           param$0=l;
          continue}
        return rev(acc)}}
    function filter_map$0(f)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1],match=caml_call1(f,x);
            if(match)
             {var v=match[1],accu$1=[0,v,accu$0],accu$0=accu$1,param=l;
              continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function concat_map(f,param)
     {var acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           xs=caml_call1(f,x),
           acc$0=rev_append(xs,acc),
           acc=acc$0,
           param$0=l;
          continue}
        return rev(acc)}}
    function fold_left_map(f,accu,param)
     {var accu$0=accu,l_accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           match=caml_call2(f,accu$0,x),
           x$0=match[2],
           accu$1=match[1],
           l_accu$0=[0,x$0,l_accu],
           accu$0=accu$1,
           l_accu=l_accu$0,
           param$0=l;
          continue}
        return [0,accu$0,rev(l_accu)]}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _AP_=rev(no);
        return [0,rev(yes),_AP_]}}
    function partition_map(p,param)
     {var left=0,right=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1],match=caml_call1(p,x);
          if(0 === match[0])
           {var v=match[1],left$0=[0,v,left],left=left$0,param$0=l;continue}
          var v$0=match[1],right$0=[0,v$0,right],right=right$0,param$0=l;
          continue}
        var _AO_=rev(right);
        return [0,rev(left),_AO_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _p_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,match)
     {if(l1)
       {if(match)
         {var t2=match[2],h2=match[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,match)]}
        return l1}
      return match}
    function fast_sort(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _AK_=l[2];
            if(_AK_)
             {var
               tl=_AK_[2],
               x2=_AK_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _AM_=l[2];
           if(_AM_)
            {var _AN_=_AM_[2];
             if(_AN_)
              {var
                tl$1=_AN_[2],
                x3=_AN_[1],
                x2$0=_AM_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x2$0,x3)
                    ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                      :[0,x3,[0,x1$0,[0,x2$0,0]]]
                  :0 < caml_call2(cmp,x1$0,x3)
                    ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                      :[0,x3,[0,x2$0,[0,x1$0,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            var _AL_=rev_append(l1,accu)}
          else
           var _AL_=rev_append(l2,accu);
          return [0,_AL_,tl$0]}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _AG_=l[2];
            if(_AG_)
             {var
               tl=_AG_[2],
               x2=_AG_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _AI_=l[2];
           if(_AI_)
            {var _AJ_=_AI_[2];
             if(_AJ_)
              {var
                tl$1=_AJ_[2],
                x3=_AJ_[1],
                x2$0=_AI_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x1$0,x3)
                    ?0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                      :[0,x2$0,[0,x3,[0,x1$0,0]]]
                    :[0,x2$0,[0,x1$0,[0,x3,0]]]
                  :0 < caml_call2(cmp,x2$0,x3)
                    ?0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                      :[0,x1$0,[0,x3,[0,x2$0,0]]]
                    :[0,x1$0,[0,x2$0,[0,x3,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            var _AH_=rev_append(l1,accu)}
          else
           var _AH_=rev_append(l2,accu);
          return [0,_AH_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function sort_uniq(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _Ax_=l[2];
            if(_Ax_)
             {var
               tl=_Ax_[2],
               x2=_Ax_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _Az_=l[2];
           if(_Az_)
            {var _AA_=_Az_[2];
             if(_AA_)
              {var
                tl$1=_AA_[2],
                x3=_AA_[1],
                x2$0=_Az_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _AB_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]],
                 s$0=_AB_;
               else
                if(0 < c$1)
                 {var c$3=caml_call2(cmp,x2$0,x3);
                  if(0 === c$3)
                   var _AC_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 < c$3)
                    var _AC_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                   else
                    var
                     c$4=caml_call2(cmp,x1$0,x3),
                     _AD_=
                      0 === c$4
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 < c$4
                         ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                         :[0,x3,[0,x1$0,[0,x2$0,0]]],
                     _AC_=_AD_;
                  var s$0=_AC_}
                else
                 {var c$5=caml_call2(cmp,x1$0,x3);
                  if(0 === c$5)
                   var _AE_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 < c$5)
                    var _AE_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                   else
                    var
                     c$6=caml_call2(cmp,x2$0,x3),
                     _AF_=
                      0 === c$6
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 < c$6
                         ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                         :[0,x3,[0,x2$0,[0,x1$0,0]]],
                     _AE_=_AF_;
                  var s$0=_AE_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            var _Ay_=rev_append(l1,accu)}
          else
           var _Ay_=rev_append(l2,accu);
          return [0,_Ay_,tl$0]}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _Ao_=l[2];
            if(_Ao_)
             {var
               tl=_Ao_[2],
               x2=_Ao_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _Aq_=l[2];
           if(_Aq_)
            {var _Ar_=_Aq_[2];
             if(_Ar_)
              {var
                tl$1=_Ar_[2],
                x3=_Ar_[1],
                x2$0=_Aq_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _As_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]],
                 s$0=_As_;
               else
                if(0 <= c$1)
                 {var c$3=caml_call2(cmp,x1$0,x3);
                  if(0 === c$3)
                   var _At_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 <= c$3)
                    var
                     c$4=caml_call2(cmp,x2$0,x3),
                     _Au_=
                      0 === c$4
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 <= c$4
                         ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                         :[0,x2$0,[0,x3,[0,x1$0,0]]],
                     _At_=_Au_;
                   else
                    var _At_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                  var s$0=_At_}
                else
                 {var c$5=caml_call2(cmp,x2$0,x3);
                  if(0 === c$5)
                   var _Av_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 <= c$5)
                    var
                     c$6=caml_call2(cmp,x1$0,x3),
                     _Aw_=
                      0 === c$6
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 <= c$6
                         ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                         :[0,x1$0,[0,x3,[0,x2$0,0]]],
                     _Av_=_Aw_;
                   else
                    var _Av_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                  var s$0=_Av_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            var _Ap_=rev_append(l1,accu)}
          else
           var _Ap_=rev_append(l2,accu);
          return [0,_Ap_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    function equal$5(eq,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _An_=caml_call2(eq,a1,a2);
            if(_An_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _An_}}
        else
         if(! l2$0)return 1;
        return 0}}
    function compare$5(cmp,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var _Al_=l1$0[2],_Am_=l1$0[1];
          if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],c=caml_call2(cmp,_Am_,a2);
            if(0 === c){var l1$0=_Al_,l2$0=l2$1;continue}
            return c}
          return 1}
        return l2$0?-1:0}}
    function to_seq$1(l)
     {function aux(l,param)
       {if(l)
         {var tail=l[2],x=l[1];
          return [0,x,function(_Ak_){return aux(tail,_Ak_)}]}
        return 0}
      return function(_Aj_){return aux(l,_Aj_)}}
    function of_seq(seq)
     {function direct(depth,seq)
       {if(0 === depth)
         {var _Ai_=0;
          return rev(fold_left(function(acc,x){return [0,x,acc]},_Ai_,seq))}
        var match=caml_call1(seq,0);
        if(match)
         {var next=match[2],x=match[1];
          return [0,x,direct(depth - 1 | 0,next)]}
        return 0}
      return direct(500,seq)}
    var
     include$0=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons$0,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal$5,
       compare$5,
       iter$2,
       iteri,
       map$3,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(768,include$0,"Stdlib__list");
    function make$0(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_Ag_=n - 1 | 0,_Af_=0;
      if(! (_Ag_ < 0))
       {var i=_Af_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _Ah_=i + 1 | 0;
          if(_Ag_ !== i){var i=_Ah_;continue}
          break}}
      return s}
    var empty$0=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string$1(b){return caml_string_of_bytes(copy(b))}
    function of_string(s){return copy(caml_bytes_of_string(s))}
    function sub(s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       {var r=caml_create_bytes(len);caml_blit_bytes(s,ofs,r,0,len);return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function symbol$1(a,b)
     {var c=a + b | 0,_Ae_=b < 0?1:0,match=c < 0?1:0,switch$0=0;
      if(a < 0)
       {if(_Ae_ && ! match)switch$0 = 1}
      else
       if(! _Ae_ && match)switch$0 = 1;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=symbol$1(symbol$1(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var dstoff=left,srcoff=0;
      else
       var dstoff=0,srcoff=- left | 0;
      var cpylen=min(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_bytes_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_string_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_str)}
    function iter$3(f,a)
     {var _Ac_=caml_ml_bytes_length(a) - 1 | 0,_Ab_=0;
      if(! (_Ac_ < 0))
       {var i=_Ab_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _Ad_=i + 1 | 0;
          if(_Ac_ !== i){var i=_Ad_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _z$_=caml_ml_bytes_length(a) - 1 | 0,_z__=0;
      if(! (_z$_ < 0))
       {var i=_z__;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _Aa_=i + 1 | 0;
          if(_z$_ !== i){var i=_Aa_;continue}
          break}}
      return 0}
    function concat(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _z7_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_bytes_length(_z7_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _z9_=caml_ml_bytes_length(_z7_) + acc | 0}
          else
           var _z9_=acc;
          var dst=caml_create_bytes(_z9_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _z8_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_bytes(_z8_,0,dst,pos,caml_ml_bytes_length(_z8_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_z8_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_z8_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_bytes(_z8_,0,dst,pos,caml_ml_bytes_length(_z8_));
              return dst}
            return dst}}}
      return empty$0}
    function cat(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var _z6_=param - 9 | 0,switch$0=0;
      if(4 < _z6_ >>> 0)
       {if(23 === _z6_)switch$0 = 1}
      else
       if(2 !== _z6_)switch$0 = 1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len && is_space(caml_bytes_unsafe_get(s,i[1])))
         {i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s,j[1])))
           {j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty$0}}}
    function escaped$0(s)
     {var n=[0,0],_zZ_=caml_ml_bytes_length(s) - 1 | 0,_zY_=0;
      if(! (_zZ_ < 0))
       {var i$0=_zY_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0),switch$0=0;
          if(32 <= match)
           {var _z3_=match - 34 | 0,switch$1=0;
            if(58 < _z3_ >>> 0)
             {if(93 <= _z3_)switch$1 = 1}
            else
             if(56 < (_z3_ - 1 | 0) >>> 0){switch$0 = 1;switch$1 = 1}
            if(! switch$1){var _z4_=1;switch$0 = 2}}
          else
           if(11 <= match)
            {if(13 === match)switch$0 = 1}
           else
            if(8 <= match)switch$0 = 1;
          switch(switch$0){case 0:var _z4_=4;break;case 1:var _z4_=2;break}
          n[1] = n[1] + _z4_ | 0;
          var _z5_=i$0 + 1 | 0;
          if(_zZ_ !== i$0){var i$0=_z5_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _z1_=caml_ml_bytes_length(s) - 1 | 0,_z0_=0;
      if(! (_z1_ < 0))
       {var i=_z0_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i),switch$2=0;
          if(35 <= c)
           if(92 === c)
            switch$2 = 2;
           else
            if(127 <= c)switch$2 = 1;else switch$2 = 3;
          else
           if(32 <= c)
            if(34 <= c)switch$2 = 2;else switch$2 = 3;
           else
            if(14 <= c)
             switch$2 = 1;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                break;
               default:switch$2 = 1}
          switch(switch$2)
           {case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 2:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 3:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _z2_=i + 1 | 0;
          if(_z1_ !== i){var i=_z2_;continue}
          break}}
      return s$0}
    function map$4(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_zW_=l - 1 | 0,_zV_=0;
      if(! (_zW_ < 0))
       {var i=_zV_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _zX_=i + 1 | 0;
          if(_zW_ !== i){var i=_zX_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_zT_=l - 1 | 0,_zS_=0;
      if(! (_zT_ < 0))
       {var i=_zS_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _zU_=i + 1 | 0;
          if(_zT_ !== i){var i=_zU_;continue}
          break}}
      return r}
    function uppercase_ascii$0(s){return map$4(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$4(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))
       return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec(s,l,i,c);var _zQ_=1;return _zQ_}
       catch(_zR_)
        {_zR_ = caml_wrap_exception(_zR_);
         if(_zR_ === Not_found)return 0;
         throw _zR_}
      return invalid_arg(cst_String_contains_from_Bytes)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i && ! (caml_ml_bytes_length(s) <= i))
       try
        {rindex_rec(s,i,c);var _zO_=1;return _zO_}
       catch(_zP_)
        {_zP_ = caml_wrap_exception(_zP_);
         if(_zP_ === Not_found)return 0;
         throw _zP_}
      return invalid_arg(cst_String_rcontains_from_Byte)}
    function compare$6(x,y){return runtime.caml_bytes_compare(x,y)}
    function uppercase$0(s){return map$4(uppercase,s)}
    function lowercase$0(s){return map$4(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function to_seq$2(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_zM_=i + 1 | 0;
        return [0,x,function(_zN_){return aux(_zM_,_zN_)}]}
      var _zK_=0;
      return function(_zL_){return aux(_zK_,_zL_)}}
    function to_seqi(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_zI_=i + 1 | 0;
        return [0,[0,i,x],function(_zJ_){return aux(_zI_,_zJ_)}]}
      var _zG_=0;
      return function(_zH_){return aux(_zG_,_zH_)}}
    function of_seq$0(i)
     {var n=[0,0],buf=[0,make$0(256,0)];
      iter
       (function(c)
         {if(n[1] === caml_ml_bytes_length(buf[1]))
           {var
             new_len=
              min(2 * caml_ml_bytes_length(buf[1]) | 0,max_string_length);
            if(caml_ml_bytes_length(buf[1]) === new_len)
             failwith(cst_Bytes_of_seq_cannot_grow_b);
            var new_buf=make$0(new_len,0);
            blit(buf[1],0,new_buf,0,n[1]);
            buf[1] = new_buf}
          caml_bytes_set(buf[1],n[1],c);
          n[1]++;
          return 0},
        i);
      return sub(buf[1],0,n[1])}
    function get_int8(b,i){return caml_bytes_get(b,i) << 24 >> 24}
    function get_uint16_le(b,i){return caml_bytes_get16(b,i)}
    function get_uint16_be(b,i){return caml_bswap16(caml_bytes_get16(b,i))}
    function get_int16_ne(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_le(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_be(b,i){return get_uint16_be(b,i) << 16 >> 16}
    function get_int32_le(b,i){return caml_bytes_get32(b,i)}
    function get_int32_be(b,i){return caml_int32_bswap(caml_bytes_get32(b,i))}
    function get_int64_le(b,i){return caml_bytes_get64(b,i)}
    function get_int64_be(b,i){return caml_int64_bswap(caml_bytes_get64(b,i))}
    function set_int16_le(b,i,x){return caml_bytes_set16(b,i,x)}
    function set_int16_be(b,i,x){return caml_bytes_set16(b,i,caml_bswap16(x))}
    function set_int32_le(b,i,x){return caml_bytes_set32(b,i,x)}
    function set_int32_be(b,i,x)
     {return caml_bytes_set32(b,i,caml_int32_bswap(x))}
    function set_int64_le(b,i,x){return caml_bytes_set64(b,i,x)}
    function set_int64_be(b,i,x)
     {return caml_bytes_set64(b,i,caml_int64_bswap(x))}
    var
     set_uint8=caml_bytes_set,
     set_uint16_ne=caml_bytes_set16,
     set_int64_ne=caml_bytes_set64,
     set_int32_ne=caml_bytes_set32,
     set_int16_ne=caml_bytes_set16,
     set_int8=caml_bytes_set,
     get_int64_ne=caml_bytes_get64,
     get_int32_ne=caml_bytes_get32,
     get_uint16_ne=caml_bytes_get16,
     get_uint8=caml_bytes_get,
     unsafe_of_string=caml_bytes_of_string,
     unsafe_to_string=caml_string_of_bytes,
     equal$6=runtime.caml_bytes_equal,
     include$1=
      [0,
       make$0,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$4,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$6,
       equal$6,
       unsafe_to_string,
       unsafe_of_string,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(769,include$1,"Stdlib__bytes");
    function make$1(n,c){return caml_string_of_bytes(make$0(n,c))}
    function init$1(n,f){return caml_string_of_bytes(init$0(n,f))}
    function copy$0(s)
     {return caml_string_of_bytes(copy(caml_bytes_of_string(s)))}
    function sub$0(s,ofs,len)
     {return caml_string_of_bytes(sub(caml_bytes_of_string(s),ofs,len))}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _zD_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_string_length(_zD_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _zF_=caml_ml_string_length(_zD_) + acc | 0}
          else
           var _zF_=acc;
          var dst=caml_create_bytes(_zF_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _zE_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_string(_zE_,0,dst,pos,caml_ml_string_length(_zE_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_zE_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_zE_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_string(_zE_,0,dst,pos,caml_ml_string_length(_zE_))}
            return caml_string_of_bytes(dst)}}}
      return cst$3}
    function iter$4(f,s)
     {var _zB_=caml_ml_string_length(s) - 1 | 0,_zA_=0;
      if(! (_zB_ < 0))
       {var i=_zA_;
        for(;;)
         {caml_call1(f,caml_string_unsafe_get(s,i));
          var _zC_=i + 1 | 0;
          if(_zB_ !== i){var i=_zC_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _zy_=caml_ml_string_length(s) - 1 | 0,_zx_=0;
      if(! (_zy_ < 0))
       {var i=_zx_;
        for(;;)
         {caml_call2(f,i,caml_string_unsafe_get(s,i));
          var _zz_=i + 1 | 0;
          if(_zy_ !== i){var i=_zz_;continue}
          break}}
      return 0}
    function map$5(f,s)
     {return caml_string_of_bytes(map$4(f,caml_bytes_of_string(s)))}
    function mapi$1(f,s)
     {return caml_string_of_bytes(mapi$0(f,caml_bytes_of_string(s)))}
    function is_space$0(param)
     {var _zw_=param - 9 | 0,switch$0=0;
      if(4 < _zw_ >>> 0)
       {if(23 === _zw_)switch$0 = 1}
      else
       if(2 !== _zw_)switch$0 = 1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if
       (!
        is_space$0(caml_string_unsafe_get(s,0))
        &&
        !
        is_space$0(caml_string_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
       return s;
      return caml_string_of_bytes(trim(caml_bytes_of_string(s)))}
    function escaped$1(s)
     {var n=caml_ml_string_length(s),i=0;
      for(;;)
       {if(n <= i)return s;
        var match=caml_string_unsafe_get(s,i),_zv_=match - 32 | 0,switch$0=0;
        if(59 < _zv_ >>> 0)
         {if(33 < (_zv_ - 61 | 0) >>> 0)switch$0 = 1}
        else
         if(2 === _zv_)switch$0 = 1;
        if(switch$0)
         return caml_string_of_bytes(escaped$0(caml_bytes_of_string(s)));
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec$0(s,l,i,c);var _zt_=1;return _zt_}
       catch(_zu_)
        {_zu_ = caml_wrap_exception(_zu_);
         if(_zu_ === Not_found)return 0;
         throw _zu_}
      return invalid_arg(cst_String_contains_from_Bytes$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i && ! (caml_ml_string_length(s) <= i))
       try
        {rindex_rec$0(s,i,c);var _zr_=1;return _zr_}
       catch(_zs_)
        {_zs_ = caml_wrap_exception(_zs_);
         if(_zs_ === Not_found)return 0;
         throw _zs_}
      return invalid_arg(cst_String_rcontains_from_Byte$0)}
    function uppercase_ascii$1(s)
     {return caml_string_of_bytes(uppercase_ascii$0(caml_bytes_of_string(s)))}
    function lowercase_ascii$1(s)
     {return caml_string_of_bytes(lowercase_ascii$0(caml_bytes_of_string(s)))}
    function capitalize_ascii$0(s)
     {return caml_string_of_bytes(capitalize_ascii(caml_bytes_of_string(s)))}
    function uncapitalize_ascii$0(s)
     {return caml_string_of_bytes(uncapitalize_ascii(caml_bytes_of_string(s)))}
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _zn_=caml_ml_string_length(s) - 1 | 0;
      if(! (_zn_ < 0))
       {var i=_zn_;
        for(;;)
         {if(caml_string_unsafe_get(s,i) === sep)
           {var _zp_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_zp_];
            j[1] = i}
          var _zq_=i - 1 | 0;
          if(0 !== i){var i=_zq_;continue}
          break}}
      var _zo_=r[1];
      return [0,sub$0(s,0,j[1]),_zo_]}
    function uppercase$1(s)
     {return caml_string_of_bytes(uppercase$0(caml_bytes_of_string(s)))}
    function lowercase$1(s)
     {return caml_string_of_bytes(lowercase$0(caml_bytes_of_string(s)))}
    function capitalize$0(s)
     {return caml_string_of_bytes(capitalize(caml_bytes_of_string(s)))}
    function uncapitalize$0(s)
     {return caml_string_of_bytes(uncapitalize(caml_bytes_of_string(s)))}
    function compare$7(x,y){return caml_string_compare(x,y)}
    function to_seq$3(s){return to_seq$2(caml_bytes_of_string(s))}
    function to_seqi$0(s){return to_seqi(caml_bytes_of_string(s))}
    function of_seq$1(g){return caml_string_of_bytes(of_seq$0(g))}
    var
     equal$7=caml_string_equal,
     include$2=
      [0,
       make$1,
       init$1,
       concat$0,
       equal$7,
       compare$7,
       contains_from$0,
       rcontains_from$0,
       contains$0,
       sub$0,
       split_on_char,
       map$5,
       mapi$1,
       trim$0,
       escaped$1,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       iter$4,
       iteri$1,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       to_seq$3,
       to_seqi$0,
       of_seq$1,
       blit$0,
       copy$0,
       fill,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0];
    caml_register_global(770,include$2,"Stdlib__string");
    function equal$8(param,_zm_){return 1}
    function compare$8(param,_zl_){return 0}
    function to_string$2(param){return cst$5}
    var Stdlib_unit=[0,equal$8,compare$8,to_string$2];
    caml_register_global(771,Stdlib_unit,"Stdlib__unit");
    function to_buffer(buff,ofs,len,v,flags)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_bytes_length(buff) - len | 0) < ofs))
       return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substrin)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       {var len=caml_marshal_data_size(buff,ofs);
        return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                ?invalid_arg(cst_Marshal_from_bytes$0)
                :runtime.caml_input_value_from_bytes(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs)
     {return from_bytes(caml_bytes_of_string(buff),ofs)}
    var
     Stdlib_marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(772,Stdlib_marshal,"Stdlib__marshal");
    function is_block(a){return 1 - (typeof a === "number"?1:0)}
    function double_field(x,i){return caml_array_get(x,i)}
    function set_double_field(x,i,v){return caml_array_set(x,i,v)}
    function marshal(obj){return runtime.caml_output_value_to_bytes(obj,0)}
    function unmarshal(str,pos)
     {var _zk_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_zk_]}
    var
     first_non_constant_constructor=0,
     last_non_constant_constructor_=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1000,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function info(obj)
     {if(caml_obj_tag(obj) === 247)
       {var
         info=runtime.caml_obj_raw_field(obj,1),
         arity=info >> 24,
         start_env=info << 8 >>> 9 | 0;
        return [0,arity,start_env]}
      throw [0,Assert_failure,_q_]}
    function of_val(x)
     {var switch$0=0;
      if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1)
       {var slot=x[1];switch$0 = 1}
      if(! switch$0)var slot=x;
      var switch$1=0;
      if(is_block(slot) && caml_obj_tag(slot) === 248)
       {var name=slot[1];switch$1 = 1}
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function name(slot){return slot[1]}
    function id(slot){return slot[2]}
    var
     Extension_constructor=[0,of_val,name,id],
     extension_constructor=Extension_constructor[1],
     extension_name=Extension_constructor[2],
     extension_id=Extension_constructor[3],
     max_ephe_length=max_array_length - 2 | 0;
    function create(l)
     {var _zi_=0 <= l?1:0,_zj_=_zi_?l <= max_ephe_length?1:0:_zi_;
      if(1 - _zj_)invalid_arg(cst_Obj_Ephemeron_create);
      return runtime.caml_ephe_create(l)}
    function length$0(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset(e,o,msg)
     {var _zf_=0 <= o?1:0,_zg_=_zf_?o < length$0(e)?1:0:_zf_,_zh_=1 - _zg_;
      return _zh_?invalid_arg(msg):_zh_}
    function get_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key);
      return runtime.caml_ephe_get_key(e,o)}
    function get_key_copy(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key_copy);
      return runtime.caml_ephe_get_key_copy(e,o)}
    function set_key(e,o,x)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_set_key);
      return caml_ephe_set_key(e,o,x)}
    function unset_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_unset_key);
      return caml_ephe_unset_key(e,o)}
    function check_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_check_key);
      return runtime.caml_ephe_check_key(e,o)}
    function blit_key(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$0(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$0(e2) - l | 0) < o2))
       {var
         _zd_=0 !== l?1:0,
         _ze_=_zd_?runtime.caml_ephe_blit_key(e1,o1,e2,o2,l):_zd_;
        return _ze_}
      return invalid_arg(cst_Obj_Ephemeron_blit_key)}
    var
     _r_=runtime.caml_ephe_blit_data,
     _s_=runtime.caml_ephe_check_data,
     _t_=
      [0,
       create,
       length$0,
       get_key,
       get_key_copy,
       set_key,
       unset_key,
       check_key,
       blit_key,
       runtime.caml_ephe_get_data,
       runtime.caml_ephe_get_data_copy,
       runtime.caml_ephe_set_data,
       function(_zc_){return runtime.caml_ephe_unset_data(_zc_)},
       _s_,
       _r_,
       max_ephe_length],
     Stdlib_obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor,
       last_non_constant_constructor_,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       [0,info],
       Extension_constructor,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _t_];
    caml_register_global(773,Stdlib_obj,"Stdlib__obj");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_za_=l - 1 | 0,_y$_=1;
        if(! (_za_ < 1))
         {var i=_y$_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _zb_=i + 1 | 0;
            if(_za_ !== i){var i=_zb_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_y9_=sx - 1 | 0,_y8_=0;
      if(! (_y9_ < 0))
       {var x=_y8_;
        for(;;)
         {res[1 + x] = caml_make_vect(sy,init);
          var _y__=x + 1 | 0;
          if(_y9_ !== x){var x=_y__;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$1(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return runtime.caml_array_fill(a,ofs,len,v);
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((a1.length - 1 - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((a2.length - 1 - len | 0) < ofs2))
       return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$5(f,a)
     {var _y6_=a.length - 1 - 1 | 0,_y5_=0;
      if(! (_y6_ < 0))
       {var i=_y5_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _y7_=i + 1 | 0;
          if(_y6_ !== i){var i=_y7_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_ha);
      var _y3_=a.length - 1 - 1 | 0,_y2_=0;
      if(! (_y3_ < 0))
       {var i=_y2_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _y4_=i + 1 | 0;
          if(_y3_ !== i){var i=_y4_;continue}
          break}}
      return 0}
    function map$6(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_y0_=l - 1 | 0,_yZ_=1;
      if(! (_y0_ < 1))
       {var i=_yZ_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _y1_=i + 1 | 0;
          if(_y0_ !== i){var i=_y1_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Array_map2_arrays_must_hav);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_yX_=la - 1 | 0,_yW_=1;
      if(! (_yX_ < 1))
       {var i=_yW_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _yY_=i + 1 | 0;
          if(_yX_ !== i){var i=_yY_;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _yU_=a.length - 1 - 1 | 0,_yT_=0;
      if(! (_yU_ < 0))
       {var i=_yT_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _yV_=i + 1 | 0;
          if(_yU_ !== i){var i=_yV_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_yR_=l - 1 | 0,_yQ_=1;
      if(! (_yR_ < 1))
       {var i=_yQ_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _yS_=i + 1 | 0;
          if(_yR_ !== i){var i=_yS_;continue}
          break}}
      return r}
    function to_list$1(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[1 + i],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function list_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function of_list(l)
     {if(l)
       {var
         tl=l[2],
         hd=l[1],
         a=caml_make_vect(list_length(0,l),hd),
         i=1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i + 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    function fold_left$1(f,x,a)
     {var r=[0,x],_yO_=a.length - 1 - 1 | 0,_yN_=0;
      if(! (_yO_ < 0))
       {var i=_yN_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _yP_=i + 1 | 0;
          if(_yO_ !== i){var i=_yP_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_yL_=a.length - 1 - 1 | 0;
      if(! (_yL_ < 0))
       {var i=_yL_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _yM_=i - 1 | 0;
          if(0 !== i){var i=_yM_;continue}
          break}}
      return r[1]}
    function exists$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function for_all2$0(p,l1,l2)
     {var n1=l1.length - 1,n2=l2.length - 1;
      if(n1 !== n2)return invalid_arg(cst_Array_for_all2);
      var i=0;
      for(;;)
       {if(i === n1)return 1;
        if(caml_call2(p,l1[1 + i],l2[1 + i]))
         {var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function exists2$0(p,l1,l2)
     {var n1=l1.length - 1,n2=l2.length - 1;
      if(n1 !== n2)return invalid_arg(cst_Array_exists2);
      var i=0;
      for(;;)
       {if(i === n1)return 0;
        if(caml_call2(p,l1[1 + i],l2[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom=[248,cst_Stdlib_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _yE_=i31 + 1 | 0,_yF_=caml_check_bound(a,_yE_)[1 + _yE_];
          if(caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_yF_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _yG_=i31 + 2 | 0,
           _yH_=caml_check_bound(a,_yG_)[1 + _yG_],
           _yI_=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_yI_)[1 + _yI_],_yH_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _yJ_=i31 + 1 | 0,_yK_=caml_check_bound(a,_yJ_)[1 + _yJ_];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_yK_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[1 + j],e))
           {var _yD_=caml_check_bound(a,j)[1 + j];
            caml_check_bound(a,i$0)[1 + i$0] = _yD_;
            var i$0=j;
            continue}
          caml_check_bound(a,i$0)[1 + i$0] = e;
          return 0}}
      function trickle(l,i,e)
       {try
         {var _yC_=trickledown(l,i,e);return _yC_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];caml_check_bound(a,i$0)[1 + i$0] = e;return 0}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_yB_=caml_check_bound(a,i$1)[1 + i$1];
          caml_check_bound(a,i$0)[1 + i$0] = _yB_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _yA_=bubbledown(l,i);return _yA_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_ys_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_ys_ < 0))
       {var i$2=_ys_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[1 + i$2]);
          var _yz_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_yz_;continue}
          break}}
      var _yt_=l - 1 | 0;
      if(! (_yt_ < 2))
       {var i$0=_yt_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[1 + i$0],
           _yx_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[1 + i$0] = _yx_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_u_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[1 + father],e$0))
             caml_check_bound(a,i)[1 + i] = e$0;
            else
             {var _yr_=caml_check_bound(a,father)[1 + father];
              caml_check_bound(a,i)[1 + i] = _yr_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _yy_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_yy_;continue a}
            break}
          break}}
      var _yu_=1 < l?1:0;
      if(_yu_)
       {var e=caml_check_bound(a,1)[2],_yv_=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _yv_;
        caml_check_bound(a,0)[1] = e;
        var _yw_=0}
      else
       var _yw_=_yu_;
      return _yw_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[1 + src2ofs],
         s1$1=caml_check_bound(a,src1ofs)[1 + src1ofs],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[1 + d] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[1 + i2$0],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[1 + d] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[1 + i1$0],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _yj_=len - 1 | 0,_yi_=0;
        if(! (_yj_ < 0))
         {var i=_yi_;
          a:
          for(;;)
           {var
             _yk_=srcofs + i | 0,
             e=caml_check_bound(a,_yk_)[1 + _yk_],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _yl_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_yl_)[1 + _yl_],e))
                 {var
                   _ym_=j[1],
                   _yn_=caml_check_bound(dst,_ym_)[1 + _ym_],
                   _yo_=j[1] + 1 | 0;
                  caml_check_bound(dst,_yo_)[1 + _yo_] = _yn_;
                  j[1] += -1;
                  continue}}
              var _yp_=j[1] + 1 | 0;
              caml_check_bound(dst,_yp_)[1 + _yp_] = e;
              var _yq_=i + 1 | 0;
              if(_yj_ !== i){var i=_yq_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$4(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_yg_=i + 1 | 0;
          return [0,x,function(_yh_){return aux(_yg_,_yh_)}]}
        return 0}
      var _ye_=0;
      return function(_yf_){return aux(_ye_,_yf_)}}
    function to_seqi$1(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_yc_=i + 1 | 0;
          return [0,[0,i,x],function(_yd_){return aux(_yc_,_yd_)}]}
        return 0}
      var _ya_=0;
      return function(_yb_){return aux(_ya_,_yb_)}}
    function of_seq$2(i$2)
     {var _x$_=0,l=fold_left(function(acc,x){return [0,x,acc]},_x$_,i$2);
      if(l)
       {var
         tl=l[2],
         hd=l[1],
         len=list_length(0,l),
         a=caml_make_vect(len,hd),
         i$1=len - 2 | 0,
         i=i$1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i - 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    var
     concat$1=caml_array_concat,
     include$3=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$1,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$6,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       for_all2$0,
       exists2$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(774,include$3,"Stdlib__array");
    var zero=0.,one=1.,minus_one=-1.;
    function is_finite(x){return x - x == 0.?1:0}
    function is_infinite(x){return 1. / x == 0.?1:0}
    function is_nan(x){return x != x?1:0}
    var pi=3.14159265358979312;
    function is_integer(x)
     {var _x__=x == runtime.caml_trunc_float(x)?1:0;
      return _x__?is_finite(x):_x__}
    function succ$0(x){return caml_nextafter_float(x,infinity)}
    function pred$0(x){return caml_nextafter_float(x,neg_infinity)}
    function equal$9(x,y){return 0 === caml_float_compare(x,y)?1:0}
    function min$1(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?x:y}
      return y != y?y:x}
    function max$1(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?y:x}
      return x != x?x:y}
    function min_max(x,y)
     {if(x == x && y == y)
       {if(! (x < y))
         {var switch$0=0;
          if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
          if(switch$0)return [0,y,x]}
        return [0,x,y]}
      return [0,nan,nan]}
    function min_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?x:y}
      return x != x?y:x}
    function max_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?y:x}
      return y != y?x:y}
    function min_max_num(x,y)
     {if(x != x)return [0,y,y];
      if(y != y)return [0,x,x];
      if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return [0,y,x]}
      return [0,x,y]}
    function hash$0(x){return caml_hash(10,100,0,x)}
    function unsafe_fill(a,ofs,len,v)
     {var _x8_=(ofs + len | 0) - 1 | 0;
      if(! (_x8_ < ofs))
       {var i=ofs;
        for(;;)
         {a[1 + i] = v;
          var _x9_=i + 1 | 0;
          if(_x8_ !== i){var i=_x9_;continue}
          break}}
      return 0}
    function check(a,ofs,len,msg)
     {var _x4_=ofs < 0?1:0;
      if(_x4_)
       var _x5_=_x4_;
      else
       {var _x6_=len < 0?1:0;
        if(_x6_)
         var _x5_=_x6_;
        else
         var
          _x7_=(ofs + len | 0) < 0?1:0,
          _x5_=_x7_ || (a.length - 1 < (ofs + len | 0)?1:0)}
      return _x5_?invalid_arg(msg):_x5_}
    function make$2(n,v)
     {var result=caml_floatarray_create(n);
      unsafe_fill(result,0,n,v);
      return result}
    function init$3(l,f)
     {if(0 <= l)
       {var res=caml_floatarray_create(l),_x2_=l - 1 | 0,_x1_=0;
        if(! (_x2_ < 0))
         {var i=_x1_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _x3_=i + 1 | 0;
            if(_x2_ !== i){var i=_x3_;continue}
            break}}
        return res}
      return invalid_arg(cst_Float_Array_init)}
    function append$2(a1,a2)
     {var
       l1=a1.length - 1,
       l2=a2.length - 1,
       result=caml_floatarray_create(l1 + l2 | 0);
      caml_floatarray_blit(a1,0,result,0,l1);
      caml_floatarray_blit(a2,0,result,l1,l2);
      return result}
    function concat$2(l)
     {var acc=0,param=l;
      for(;;)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           x=hd.length - 1 + acc | 0,
           acc$0=acc <= x?x:invalid_arg(cst_Float_Array_concat),
           acc=acc$0,
           param=tl;
          continue}
        var result=caml_floatarray_create(acc),l$0=l,i=0;
        for(;;)
         {if(l$0)
           {var tl$0=l$0[2],hd$0=l$0[1],hlen=hd$0.length - 1;
            caml_floatarray_blit(hd$0,0,result,i,hlen);
            var i$0=i + hlen | 0,l$0=tl$0,i=i$0;
            continue}
          if(i === acc)return result;
          throw [0,Assert_failure,_v_]}}}
    function sub$2(a,ofs,len)
     {check(a,ofs,len,cst_Float_Array_sub);
      var result=caml_floatarray_create(len);
      caml_floatarray_blit(a,ofs,result,0,len);
      return result}
    function copy$2(a)
     {var l=a.length - 1,result=caml_floatarray_create(l);
      caml_floatarray_blit(a,0,result,0,l);
      return result}
    function fill$1(a,ofs,len,v)
     {check(a,ofs,len,cst_Float_Array_fill);return unsafe_fill(a,ofs,len,v)}
    function blit$2(src,sofs,dst,dofs,len)
     {check(src,sofs,len,cst_Float_array_blit);
      check(dst,dofs,len,cst_Float_array_blit$0);
      return caml_floatarray_blit(src,sofs,dst,dofs,len)}
    function to_list$2(a)
     {return init(a.length - 1,function(_x0_){return a[1 + _x0_]})}
    function of_list$0(l)
     {var result=caml_floatarray_create(length(l)),i=0,l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],h=l$0[1];
          result[1 + i] = h;
          var i$0=i + 1 | 0,i=i$0,l$0=t;
          continue}
        return result}}
    function iter$6(f,a)
     {var _xY_=a.length - 1 - 1 | 0,_xX_=0;
      if(! (_xY_ < 0))
       {var i=_xX_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _xZ_=i + 1 | 0;
          if(_xY_ !== i){var i=_xZ_;continue}
          break}}
      return 0}
    function iter2$1(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Float_Array_iter2_arrays_m);
      var _xV_=a.length - 1 - 1 | 0,_xU_=0;
      if(! (_xV_ < 0))
       {var i=_xU_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _xW_=i + 1 | 0;
          if(_xV_ !== i){var i=_xW_;continue}
          break}}
      return 0}
    function map$7(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_xS_=l - 1 | 0,_xR_=0;
      if(! (_xS_ < 0))
       {var i=_xR_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xT_=i + 1 | 0;
          if(_xS_ !== i){var i=_xT_;continue}
          break}}
      return r}
    function map2$1(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Float_Array_map2_arrays_mu);
      var r=caml_floatarray_create(la),_xP_=la - 1 | 0,_xO_=0;
      if(! (_xP_ < 0))
       {var i=_xO_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _xQ_=i + 1 | 0;
          if(_xP_ !== i){var i=_xQ_;continue}
          break}}
      return r}
    function iteri$3(f,a)
     {var _xM_=a.length - 1 - 1 | 0,_xL_=0;
      if(! (_xM_ < 0))
       {var i=_xL_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _xN_=i + 1 | 0;
          if(_xM_ !== i){var i=_xN_;continue}
          break}}
      return 0}
    function mapi$3(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_xJ_=l - 1 | 0,_xI_=0;
      if(! (_xJ_ < 0))
       {var i=_xI_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _xK_=i + 1 | 0;
          if(_xJ_ !== i){var i=_xK_;continue}
          break}}
      return r}
    function fold_left$2(f,x,a)
     {var r=[0,x],_xG_=a.length - 1 - 1 | 0,_xF_=0;
      if(! (_xG_ < 0))
       {var i=_xF_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _xH_=i + 1 | 0;
          if(_xG_ !== i){var i=_xH_;continue}
          break}}
      return r[1]}
    function fold_right$1(f,a,x)
     {var r=[0,x],_xD_=a.length - 1 - 1 | 0;
      if(! (_xD_ < 0))
       {var i=_xD_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _xE_=i - 1 | 0;
          if(0 !== i){var i=_xE_;continue}
          break}}
      return r[1]}
    function exists$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$1(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_float_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem_ieee(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x == a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom$0=[248,cst_Stdlib_Float_Array_Bottom,caml_fresh_oo_id(0)];
    function sort$0(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {if
           (caml_call2
             (cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))
            <
            0)
           x[1] = i31 + 1 | 0;
          if
           (caml_call2
             (cmp,caml_array_get(a,x[1]),caml_array_get(a,i31 + 2 | 0))
            <
            0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if
         ((i31 + 1 | 0)
          <
          l
          &&
          !
          (0
           <=
           caml_call2(cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))))
         return i31 + 1 | 0;
        if(i31 < l)return i31;
        throw [0,Bottom$0,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_array_get(a,j),e))
           {caml_array_set(a,i$0,caml_array_get(a,j));var i$0=j;continue}
          return caml_array_set(a,i$0,e)}}
      function trickle(l,i,e)
       {try
         {var _xC_=trickledown(l,i,e);return _xC_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0)
           {var i$0=exn[2];return caml_array_set(a,i$0,e)}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0);
          caml_array_set(a,i$0,caml_array_get(a,i$1));
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _xB_=bubbledown(l,i);return _xB_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_xv_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_xv_ < 0))
       {var i$2=_xv_;
        for(;;)
         {trickle(l,i$2,caml_array_get(a,i$2));
          var _xA_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_xA_;continue}
          break}}
      var _xw_=l - 1 | 0;
      if(! (_xw_ < 2))
       {var i$0=_xw_;
        a:
        for(;;)
         {var e$0=caml_array_get(a,i$0);
          caml_array_set(a,i$0,caml_array_get(a,0));
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_w_];
            if(0 <= caml_call2(cmp,caml_array_get(a,father),e$0))
             caml_array_set(a,i,e$0);
            else
             {caml_array_set(a,i,caml_array_get(a,father));
              if(0 < father){var i=father;continue}
              caml_array_set(a,0,e$0)}
            var _xz_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_xz_;continue a}
            break}
          break}}
      var _xx_=1 < l?1:0;
      if(_xx_)
       {var e=caml_array_get(a,1);
        caml_array_set(a,1,caml_array_get(a,0));
        var _xy_=caml_array_set(a,0,e)}
      else
       var _xy_=_xx_;
      return _xy_}
    function stable_sort(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_array_get(src2,src2ofs),
         s1$1=caml_array_get(a,src1ofs),
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_array_set(dst,d,s2);
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_array_get(src2,i2$0),
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$2(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_array_set(dst,d,s1);
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_array_get(a,i1$0),
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$2(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _xt_=len - 1 | 0,_xs_=0;
        if(! (_xt_ < 0))
         {var i=_xs_;
          a:
          for(;;)
           {var
             e=caml_array_get(a,srcofs + i | 0),
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if
               (dstofs
                <=
                j[1]
                &&
                0
                <
                caml_call2(cmp,caml_array_get(dst,j[1]),e))
               {caml_array_set(dst,j[1] + 1 | 0,caml_array_get(dst,j[1]));
                j[1] += -1;
                continue}
              caml_array_set(dst,j[1] + 1 | 0,e);
              var _xu_=i + 1 | 0;
              if(_xt_ !== i){var i=_xu_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var l1=l / 2 | 0,l2=l - l1 | 0,t=caml_floatarray_create(l2);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$5(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xq_=i + 1 | 0;
          return [0,x,function(_xr_){return aux(_xq_,_xr_)}]}
        return 0}
      var _xo_=0;
      return function(_xp_){return aux(_xo_,_xp_)}}
    function to_seqi$2(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xm_=i + 1 | 0;
          return [0,[0,i,x],function(_xn_){return aux(_xm_,_xn_)}]}
        return 0}
      var _xk_=0;
      return function(_xl_){return aux(_xk_,_xl_)}}
    function of_seq$3(i$2)
     {var
       _xj_=0,
       param$0=fold_left(function(acc,x){return [0,x,acc]},_xj_,i$2),
       len=length(param$0),
       a=caml_floatarray_create(len),
       i$1=len - 1 | 0,
       i=i$1,
       param=param$0;
      for(;;)
       {if(param)
         {var tl=param[2],hd=param[1];
          a[1 + i] = hd;
          var i$0=i - 1 | 0,i=i$0,param=tl;
          continue}
        return a}}
    function map_to_array(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_xh_=l - 1 | 0,_xg_=1;
      if(! (_xh_ < 1))
       {var i=_xg_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xi_=i + 1 | 0;
          if(_xh_ !== i){var i=_xi_;continue}
          break}}
      return r}
    function map_from_array(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_xe_=l - 1 | 0,_xd_=0;
      if(! (_xe_ < 0))
       {var i=_xd_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _xf_=i + 1 | 0;
          if(_xe_ !== i){var i=_xf_;continue}
          break}}
      return r}
    var
     _x_=caml_floatarray_create,
     _y_=caml_array_set,
     _z_=caml_array_get,
     _A_=
      [0,
       function(_xc_){return _xc_.length - 1},
       _z_,
       _y_,
       make$2,
       _x_,
       init$3,
       append$2,
       concat$2,
       sub$2,
       copy$2,
       fill$1,
       blit$2,
       to_list$2,
       of_list$0,
       iter$6,
       iteri$3,
       map$7,
       mapi$3,
       fold_left$2,
       fold_right$1,
       iter2$1,
       map2$1,
       for_all$1,
       exists$1,
       mem$1,
       mem_ieee,
       sort$0,
       stable_sort,
       stable_sort,
       to_seq$5,
       to_seqi$2,
       of_seq$3,
       map_to_array,
       map_from_array],
     _B_=caml_floatarray_create,
     _C_=caml_array_set,
     _D_=caml_array_get,
     Stdlib_float=
      [0,
       zero,
       one,
       minus_one,
       succ$0,
       pred$0,
       infinity,
       neg_infinity,
       nan,
       pi,
       max_float,
       min_float,
       epsilon,
       is_finite,
       is_infinite,
       is_nan,
       is_integer,
       of_string_opt,
       to_string,
       caml_float_compare,
       equal$9,
       min$1,
       max$1,
       min_max,
       min_num,
       max_num,
       min_max_num,
       hash$0,
       [0,
        function(_xb_){return _xb_.length - 1},
        _D_,
        _C_,
        make$2,
        _B_,
        init$3,
        append$2,
        concat$2,
        sub$2,
        copy$2,
        fill$1,
        blit$2,
        to_list$2,
        of_list$0,
        iter$6,
        iteri$3,
        map$7,
        mapi$3,
        fold_left$2,
        fold_right$1,
        iter2$1,
        map2$1,
        for_all$1,
        exists$1,
        mem$1,
        mem_ieee,
        sort$0,
        stable_sort,
        stable_sort,
        to_seq$5,
        to_seqi$2,
        of_seq$3,
        map_to_array,
        map_from_array],
       _A_];
    caml_register_global(775,Stdlib_float,"Stdlib__float");
    var zero$0=0,one$0=1,minus_one$0=-1;
    function abs$0(x){return 0 <= x?x:- x | 0}
    var max_int$0=2147483647,min_int$0=-2147483648;
    function lognot(x){return x ^ -1}
    function equal$10(_xa_,_w$_){return _xa_ === _w$_?1:0}
    var compare$9=caml_int_compare;
    function to_string$3(x){return caml_string_of_jsbytes("" + x)}
    var
     Stdlib_int=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       equal$10,
       compare$9,
       to_string$3];
    caml_register_global(776,Stdlib_int,"Stdlib__int");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$1(n){return n + 1 | 0}
    function pred$1(n){return n - 1 | 0}
    function abs$1(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$1=-2147483648,max_int$1=2147483647;
    function lognot$0(n){return n ^ -1}
    function unsigned_to_int(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$4(n){return caml_format_int(cst_d,n)}
    function of_string_opt$0(s)
     {try
       {var _w9_=[0,caml_int_of_string(s)];return _w9_}
      catch(_w__)
       {_w__ = caml_wrap_exception(_w__);
        if(_w__[1] === Failure)return 0;
        throw _w__}}
    function compare$10(x,y){return caml_int_compare(x,y)}
    function equal$11(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare(n,d)?one$1:zero$1;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare(r,d)?q + 1 | 0:q}
    function unsigned_rem(n,d){return n - caml_mul(unsigned_div(n,d),d) | 0}
    var
     Stdlib_int32=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       unsigned_div,
       unsigned_rem,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       unsigned_to_int,
       of_string_opt$0,
       to_string$4,
       compare$10,
       unsigned_compare,
       equal$11];
    caml_register_global(777,Stdlib_int32,"Stdlib__int32");
    function succ$2(n){return caml_int64_add(n,_E_)}
    function pred$2(n){return caml_int64_sub(n,_F_)}
    function abs$2(n)
     {return caml_greaterequal(n,_G_)?n:runtime.caml_int64_neg(n)}
    function lognot$1(n){return runtime.caml_int64_xor(n,_H_)}
    var max_int$3=caml_int64_of_int32(2147483647);
    function unsigned_to_int$0(n)
     {if
       (!
        (0 < caml_int64_compare(zero$2,n))
        &&
        !
        (0 < caml_int64_compare(n,max_int$3)))
       return [0,runtime.caml_int64_to_int32(n)];
      return 0}
    function to_string$5(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$1(s)
     {try
       {var _w7_=[0,caml_int64_of_string(s)];return _w7_}
      catch(_w8_)
       {_w8_ = caml_wrap_exception(_w8_);
        if(_w8_[1] === Failure)return 0;
        throw _w8_}}
    function compare$11(x,y){return caml_int64_compare(x,y)}
    function equal$12(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    function unsigned_compare$0(n,m)
     {return caml_int64_compare
              (caml_int64_sub(n,min_int$2),caml_int64_sub(m,min_int$2))}
    function unsigned_div$0(n,d)
     {if(caml_lessthan(d,zero$2))
       return 0 <= unsigned_compare$0(n,d)?one$2:zero$2;
      var
       q=
        caml_int64_shift_left
         (runtime.caml_int64_div
           (runtime.caml_int64_shift_right_unsigned(n,1),d),
          1),
       r=caml_int64_sub(n,caml_int64_mul(q,d));
      return 0 <= unsigned_compare$0(r,d)?succ$2(q):q}
    function unsigned_rem$0(n,d)
     {return caml_int64_sub(n,caml_int64_mul(unsigned_div$0(n,d),d))}
    var
     Stdlib_int64=
      [0,
       zero$2,
       one$2,
       minus_one$2,
       unsigned_div$0,
       unsigned_rem$0,
       succ$2,
       pred$2,
       abs$2,
       max_int$2,
       min_int$2,
       lognot$1,
       unsigned_to_int$0,
       of_string_opt$1,
       to_string$5,
       compare$11,
       unsigned_compare$0,
       equal$12];
    caml_register_global(778,Stdlib_int64,"Stdlib__int64");
    var zero$3=0,one$3=1,minus_one$3=-1;
    function succ$3(n){return n + 1 | 0}
    function pred$3(n){return n - 1 | 0}
    function abs$3(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$3=-2147483648,max_int$4=2147483647;
    function lognot$2(n){return n ^ -1}
    function unsigned_to_int$1(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$6(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$2(s)
     {try
       {var _w5_=[0,caml_int_of_string(s)];return _w5_}
      catch(_w6_)
       {_w6_ = caml_wrap_exception(_w6_);
        if(_w6_[1] === Failure)return 0;
        throw _w6_}}
    function compare$12(x,y){return caml_int_compare(x,y)}
    function equal$13(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare$1(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div$1(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare$1(n,d)?one$3:zero$3;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare$1(r,d)?q + 1 | 0:q}
    function unsigned_rem$1(n,d)
     {return n - caml_mul(unsigned_div$1(n,d),d) | 0}
    var
     Stdlib_nativeint=
      [0,
       zero$3,
       one$3,
       minus_one$3,
       unsigned_div$1,
       unsigned_rem$1,
       succ$3,
       pred$3,
       abs$3,
       match$1,
       max_int$4,
       min_int$3,
       lognot$2,
       unsigned_to_int$1,
       of_string_opt$2,
       to_string$6,
       compare$12,
       unsigned_compare$1,
       equal$13];
    caml_register_global(779,Stdlib_nativeint,"Stdlib__nativeint");
    function engine(tbl,state,buf)
     {var
       result=runtime.caml_lex_engine(tbl,state,buf),
       _w2_=0 <= result?1:0,
       _w3_=_w2_?buf[12] !== dummy_pos?1:0:_w2_;
      if(_w3_)
       {buf[11] = buf[12];
        var _w4_=buf[12];
        buf[12] = [0,_w4_[1],_w4_[2],_w4_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var
       result=runtime.caml_new_lex_engine(tbl,state,buf),
       _wZ_=0 <= result?1:0,
       _w0_=_wZ_?buf[12] !== dummy_pos?1:0:_wZ_;
      if(_w0_)
       {buf[11] = buf[12];
        var _w1_=buf[12];
        buf[12] = [0,_w1_[1],_w1_[2],_w1_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(opt,f)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _wL_=with_positions?zero_pos:dummy_pos,
       _wM_=with_positions?zero_pos:dummy_pos,
       aux_buffer=caml_create_bytes(512),
       _wN_=[0],
       _wO_=0,
       _wP_=0,
       _wQ_=0,
       _wR_=0,
       _wS_=0,
       _wT_=0,
       _wU_=0,
       _wV_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_g);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_wX_=t.length - 1 - 1 | 0,_wW_=0;
                  if(! (_wX_ < 0))
                   {var i=_wW_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[1 + i];
                      if(0 <= v)caml_check_bound(t,i)[1 + i] = v - s | 0;
                      var _wY_=i + 1 | 0;
                      if(_wX_ !== i){var i=_wY_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _wV_,
              _wU_,
              _wT_,
              _wS_,
              _wR_,
              _wQ_,
              _wP_,
              _wO_,
              _wN_,
              _wM_,
              _wL_]}
    function from_channel(with_positions,ic)
     {return from_function
              (with_positions,function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(opt,s)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _wA_=with_positions?zero_pos:dummy_pos,
       _wB_=with_positions?zero_pos:dummy_pos,
       _wC_=[0],
       _wD_=1,
       _wE_=0,
       _wF_=0,
       _wG_=0,
       _wH_=0,
       _wI_=0,
       _wJ_=caml_ml_string_length(s),
       _wK_=of_string(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _wK_,
              _wJ_,
              _wI_,
              _wH_,
              _wG_,
              _wF_,
              _wE_,
              _wD_,
              _wC_,
              _wB_,
              _wA_]}
    function set_position(lexbuf,position)
     {lexbuf[12] = [0,lexbuf[12][1],position[2],position[3],position[4]];
      lexbuf[4] = position[4];
      return 0}
    function set_filename(lexbuf,fname)
     {var _wz_=lexbuf[12];
      lexbuf[12] = [0,fname,_wz_[2],_wz_[3],_wz_[4]];
      return 0}
    function with_positions(lexbuf){return lexbuf[12] !== dummy_pos?1:0}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var
       lcp=lexbuf[12],
       _wx_=lcp !== dummy_pos?1:0,
       _wy_=_wx_?(lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]],0):_wx_;
      return _wy_}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var lcp=lb[12];
      if(lcp !== dummy_pos)
       lb[12] = [0,lcp[1],zero_pos[2],zero_pos[3],zero_pos[4]];
      lb[3] = 0;
      return 0}
    var
     Stdlib_lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       set_position,
       set_filename,
       with_positions,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(780,Stdlib_lexing,"Stdlib__lexing");
    var
     YYexit=[248,cst_Stdlib_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Stdlib_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _wr_=env[13],
                _ws_=
                 caml_call1(caml_check_bound(tables[1],_wr_)[1 + _wr_],env),
                _wt_=4,
                arg$1=_ws_,
                cmd$0=_wt_}
             catch(_ww_)
              {_ww_ = caml_wrap_exception(_ww_);
               if(_ww_ !== Parse_error)throw _ww_;
               var arg$1=0,cmd$0=5,_wu_=_ww_}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _wv_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_wv_)[1 + _wv_] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[1 + tok] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _wq_=env[11] - n | 0;return caml_check_bound(env[2],_wq_)[1 + _wq_]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _wn_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_wn_)[1 + _wn_],
           _wo_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_wo_)[1 + _wo_];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _wp_=env[11];
        return caml_check_bound(env[4],_wp_)[1 + _wp_]}}
    function symbol_end_pos(param)
     {var _wm_=env[11];return caml_check_bound(env[4],_wm_)[1 + _wm_]}
    function rhs_start_pos(n)
     {var _wl_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_wl_)[1 + _wl_]}
    function rhs_end_pos(n)
     {var _wk_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_wk_)[1 + _wk_]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Stdlib_parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_wj_){return runtime.caml_set_parser_trace(_wj_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(781,Stdlib_parsing,"Stdlib__parsing");
    var
     Stdlib_set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _wi_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_wi_]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_wd_=height(lr);
               if(_wd_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_we_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_we_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_wf_=height(rl);
               if(_wf_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_wg_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_wg_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _wh_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_wh_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _wc_=param$0[1];
               if(_wc_){var param$0=_wc_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _wb_=param$0[1];
               if(_wb_){var param$0=_wb_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _wa_=param[1];
             if(_wa_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_wa_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var _v$_=remove_min_elt(match);
               return join(t,min_elt(match),_v$_)}
             return t}
           return match}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _I_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _v__=0 === c?1:0;
               if(_v__)return _v__;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _v9_=remove_min_elt(r);return bal(l,min_elt(r),_v9_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(t1,match)
          {if(t1)
            {if(match)
              {var
                h2=match[4],
                r2=match[3],
                v2=match[2],
                l2=match[1],
                h1=t1[4],
                r1=t1[3],
                v1=t1[2],
                l1=t1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,t1);
                 var
                  match$0=split(v1,match),
                  r2$0=match$0[3],
                  l2$0=match$0[1],
                  _v7_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_v7_)}
               if(1 === h1)return add(v1,match);
               var
                match$1=split(v2,t1),
                r1$0=match$1[3],
                l1$0=match$1[1],
                _v8_=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_v8_)}
             return t1}
           return match}
         function inter(s1,match)
          {if(s1)
            {if(match)
              {var
                r1=s1[3],
                v1=s1[2],
                l1=s1[1],
                _v3_=split(v1,match),
                _v4_=_v3_[1];
               if(_v3_[2])
                {var r2=_v3_[3],_v5_=inter(r1,r2);
                 return join(inter(l1,_v4_),v1,_v5_)}
               var r2$0=_v3_[3],_v6_=inter(r1,r2$0);
               return concat(inter(l1,_v4_),_v6_)}
             return 0}
           return 0}
         function split_bis(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return 0;
             if(0 <= c)
              {var match=split_bis(x,r);
               if(match)
                {var rr=match[2],lr=match[1];return [0,join(l,v,lr),rr]}
               return 0}
             var match$0=split_bis(x,l);
             if(match$0)
              {var rl=match$0[2],ll=match$0[1];
               return [0,
                       ll,
                       function(param){return join(caml_call1(rl,0),v,r)}]}
             return 0}
           return [0,0,function(param){return 0}]}
         function disjoint(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0 && s2$0)
              {var r1=s1$0[3],v1=s1$0[2],l1=s1$0[1];
               if(s1$0 === s2$0)return 0;
               var match=split_bis(v1,s2$0);
               if(match)
                {var r2=match[2],l2=match[1],_v2_=disjoint(l1,l2);
                 if(_v2_)
                  {var s2$1=caml_call1(r2,0),s1$0=r1,s2$0=s2$1;continue}
                 return _v2_}
               return 0}
             return 1}}
         function diff(t1,match)
          {if(t1)
            {if(match)
              {var
                r1=t1[3],
                v1=t1[2],
                l1=t1[1],
                _vY_=split(v1,match),
                _vZ_=_vY_[1];
               if(_vY_[2])
                {var r2=_vY_[3],_v0_=diff(r1,r2);
                 return concat(diff(l1,_vZ_),_v0_)}
               var r2$0=_vY_[3],_v1_=diff(r1,r2$0);
               return join(diff(l1,_vZ_),v1,_v1_)}
             return t1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _vV_=subset(l1,l2);
                   if(_vV_){var s1$0=r1,s2$0=r2;continue}
                   return _vV_}
                 if(0 <= c)
                  {var _vW_=subset([0,0,v1,r1,0],r2);
                   if(_vW_){var s1$0=l1;continue}
                   return _vW_}
                 var _vX_=subset([0,l1,v1,0,0],l2);
                 if(_vX_){var s1$0=r1;continue}
                 return _vX_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _vS_=caml_call1(p,v);
               if(_vS_)
                {var _vT_=for_all(p,l);
                 if(_vT_){var param$0=r;continue}
                 var _vU_=_vT_}
               else
                var _vU_=_vS_;
               return _vU_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _vP_=caml_call1(p,v);
               if(_vP_)
                var _vQ_=_vP_;
               else
                {var _vR_=exists(p,l);
                 if(! _vR_){var param$0=r;continue}
                 var _vQ_=_vR_}
               return _vQ_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0 && r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _vN_=concat(lf,rf);return [0,join(lt,v,rt),_vN_]}
             var _vO_=join(lf,v,rf);
             return [0,concat(lt,rt),_vO_]}
           return _J_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_vM_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _vM_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function try_join(l,v,r)
          {var switch$0=0;
           if(0 !== l)
            {var _vL_=max_elt(l);
             if(0 <= caml_call2(Ord[1],_vL_,v))switch$0 = 1}
           if(! switch$0)
            {var switch$1=0;
             if(0 !== r)
              {var _vK_=min_elt(r);
               if(0 <= caml_call2(Ord[1],v,_vK_))switch$1 = 1}
             if(! switch$1)return join(l,v,r)}
           return union(l,add(v,r))}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0 && v === v$0 && r === r$0)return t;
             return try_join(l$0,v$0,r$0)}
           return 0}
         function filter_map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              t$0=filter_map(f,l),
              v$0=caml_call1(f,v),
              match=filter_map(f,r);
             if(v$0)
              {var v$1=v$0[1];
               if(l === t$0 && v === v$1 && r === match)return t;
               return try_join(t$0,v$1,match)}
             if(t$0)
              {if(match)
                {var _vJ_=remove_min_elt(match);
                 return try_join(t$0,min_elt(match),_vJ_)}
               return t$0}
             return match}
           return 0}
         function of_list(l)
          {if(l)
            {var _vy_=l[2],_vz_=l[1];
             if(_vy_)
              {var _vA_=_vy_[2],_vB_=_vy_[1];
               if(_vA_)
                {var _vC_=_vA_[2],_vD_=_vA_[1];
                 if(_vC_)
                  {var _vE_=_vC_[2],_vF_=_vC_[1];
                   if(_vE_)
                    {if(_vE_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _vG_=l[2];
                                 if(_vG_)
                                  {var l$4=_vG_[2],x1=_vG_[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _vH_=l[2];
                                 if(_vH_)
                                  {var _vI_=_vH_[2];
                                   if(_vI_)
                                    {var l$5=_vI_[2],x2=_vI_[1],x1$0=_vH_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_K_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_vE_[1];
                     return add(x4,add(_vF_,add(_vD_,add(_vB_,singleton(_vz_)))))}
                   return add(_vF_,add(_vD_,add(_vB_,singleton(_vz_))))}
                 return add(_vD_,add(_vB_,singleton(_vz_)))}
               return add(_vB_,singleton(_vz_))}
             return singleton(_vz_)}
           return empty}
         function add_seq(i,m)
          {return fold_left(function(s,x){return add(x,s)},m,i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_vw_=cons_enum(t,rest);
             return [0,x,function(_vx_){return seq_of_enum(_vw_,_vx_)}]}
           return 0}
         function to_seq(c)
          {var _vu_=cons_enum(c,0);
           return function(_vv_){return seq_of_enum(_vu_,_vv_)}}
         function snoc_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                s$1=s$0[3],
                v=s$0[2],
                l=s$0[1],
                e$1=[0,v,l,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function rev_seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_vs_=snoc_enum(t,rest);
             return [0,x,function(_vt_){return rev_seq_of_enum(_vs_,_vt_)}]}
           return 0}
         function to_rev_seq(c)
          {var _vq_=snoc_enum(c,0);
           return function(_vr_){return rev_seq_of_enum(_vq_,_vr_)}}
         function to_seq_from(low,s)
          {var s$0=s,c=0;
           for(;;)
            {if(s$0)
              {var r=s$0[3],v=s$0[2],l=s$0[1],n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,r,c],s$0=l,c=c$0;continue}
                 var s$0=r;
                 continue}
               var _vo_=[0,v,r,c]}
             else
              var _vo_=c;
             return function(_vp_){return seq_of_enum(_vo_,_vp_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 disjoint,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 filter_map,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list,
                 to_seq_from,
                 to_seq,
                 to_rev_seq,
                 add_seq,
                 of_seq]}];
    caml_register_global(782,Stdlib_set,"Stdlib__set");
    var
     Stdlib_map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_vn_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_vn_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_vi_=height(lr);
               if(_vi_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _vj_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_vj_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_vk_=height(rl);
               if(_vk_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _vl_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_vl_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _vm_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_vm_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _vh_=0 === c?1:0;
               if(_vh_)return _vh_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vg_=param$0[1];
               if(_vg_){var param$0=_vg_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vf_=param$0[1];
               if(_vf_){var param$0=_vf_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _ve_=param[1];
             if(_ve_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_ve_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _uP_(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return bal(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _uP_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _uP_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _vb_=caml_call2(p,v,d);
               if(_vb_)
                {var _vc_=for_all(p,l);
                 if(_vc_){var param$0=r;continue}
                 var _vd_=_vc_}
               else
                var _vd_=_vb_;
               return _vd_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _u__=caml_call2(p,v,d);
               if(_u__)
                var _u$_=_u__;
               else
                {var _va_=exists(p,l);
                 if(! _va_){var param$0=r;continue}
                 var _u$_=_va_}
               return _u$_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return join(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _L_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _u6_=merge(f,r1,r2),
                _u7_=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_u7_,_u6_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _u8_=merge(f,r1$0,r2$0),
              _u9_=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_u9_,_u8_)}
           throw [0,Assert_failure,_M_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0 && r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function filter_map(f,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=filter_map(f,l),
              fvd=caml_call2(f,v,d),
              r$0=filter_map(f,r);
             if(fvd){var d$0=fvd[1];return join(l$0,v,d$0,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _u4_=concat(lf,rf);return [0,join(lt,v,d,rt),_u4_]}
             var _u5_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_u5_]}
           return _N_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _u1_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_u1_)
                  {var _u2_=caml_call2(cmp,d1,d2);
                   if(_u2_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _u3_=_u2_}
                 else
                  var _u3_=_u1_;
                 return _u3_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_u0_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _u0_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         function add_seq(i,m)
          {return fold_left
                   (function(m,param)
                     {var v=param[2],k=param[1];return add(k,v,m)},
                    m,
                    i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_uY_=cons_enum(t,rest);
             return [0,[0,k,v],function(_uZ_){return seq_of_enum(_uY_,_uZ_)}]}
           return 0}
         function to_seq(m)
          {var _uW_=cons_enum(m,0);
           return function(_uX_){return seq_of_enum(_uW_,_uX_)}}
         function snoc_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                s$1=s$0[4],
                d=s$0[3],
                v=s$0[2],
                l=s$0[1],
                e$1=[0,v,d,l,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function rev_seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_uU_=snoc_enum(t,rest);
             return [0,
                     [0,k,v],
                     function(_uV_){return rev_seq_of_enum(_uU_,_uV_)}]}
           return 0}
         function to_rev_seq(c)
          {var _uS_=snoc_enum(c,0);
           return function(_uT_){return rev_seq_of_enum(_uS_,_uT_)}}
         function to_seq_from(low,m)
          {var m$0=m,c=0;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,d,r,c],m$0=l,c=c$0;continue}
                 var m$0=r;
                 continue}
               var _uQ_=[0,v,d,r,c]}
             else
              var _uQ_=c;
             return function(_uR_){return seq_of_enum(_uQ_,_uR_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 filter_map,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi,
                 to_seq,
                 to_rev_seq,
                 to_seq_from,
                 add_seq,
                 of_seq]}];
    caml_register_global(783,Stdlib_map,"Stdlib__map");
    var Empty=[248,cst_Stdlib_Stack_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$3(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _uO_=s[1];
      if(_uO_)
       {var tl=_uO_[2],hd=_uO_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function pop_opt(s)
     {var _uN_=s[1];
      if(_uN_)
       {var tl=_uN_[2],hd=_uN_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return [0,hd]}
      return 0}
    function top(s)
     {var _uM_=s[1];if(_uM_){var hd=_uM_[1];return hd}throw Empty}
    function top_opt(s)
     {var _uL_=s[1];if(_uL_){var hd=_uL_[1];return [0,hd]}return 0}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$7(f,s){return iter$2(f,s[1])}
    function fold$2(f,acc,s){return fold_left$0(f,acc,s[1])}
    function to_seq$6(s){return to_seq$1(s[1])}
    function add_seq(q,i){return iter(function(x){return push(x,q)},i)}
    function of_seq$4(g){var s=create$0(0);add_seq(s,g);return s}
    var
     Stdlib_stack=
      [0,
       Empty,
       create$0,
       push,
       pop,
       pop_opt,
       top,
       top_opt,
       clear,
       copy$3,
       is_empty,
       length$1,
       iter$7,
       fold$2,
       to_seq$6,
       add_seq,
       of_seq$4];
    caml_register_global(784,Stdlib_stack,"Stdlib__stack");
    var Empty$0=[248,cst_Stdlib_Queue_Empty,caml_fresh_oo_id(0)];
    function create$1(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_uK_=q[3];
      return _uK_
              ?(q[1] = q[1] + 1 | 0,_uK_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _uJ_=q[2];if(_uJ_){var content=_uJ_[1];return content}throw Empty$0}
    function peek_opt(q)
     {var _uI_=q[2];if(_uI_){var content=_uI_[1];return [0,content]}return 0}
    function take(q)
     {var _uG_=q[2];
      if(_uG_)
       {var _uH_=_uG_[1];
        if(_uG_[2])
         {var next=_uG_[2];q[1] = q[1] - 1 | 0;q[2] = next;return _uH_}
        clear$0(q);
        return _uH_}
      throw Empty$0}
    function take_opt(q)
     {var _uE_=q[2];
      if(_uE_)
       {var _uF_=_uE_[1];
        if(_uE_[2])
         {var next=_uE_[2];q[1] = q[1] - 1 | 0;q[2] = next;return [0,_uF_]}
        clear$0(q);
        return [0,_uF_]}
      return 0}
    function copy$4(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$8(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$3(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _uC_=0 < q1[1]?1:0;
      if(_uC_)
       {var _uD_=q2[3];
        return _uD_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _uD_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _uC_}
    function to_seq$7(q)
     {function aux(c,param)
       {if(c)
         {var x=c[1],next=c[2];
          return [0,x,function(_uB_){return aux(next,_uB_)}]}
        return 0}
      var _uz_=q[2];
      return function(_uA_){return aux(_uz_,_uA_)}}
    function add_seq$0(q,i){return iter(function(x){return add(x,q)},i)}
    function of_seq$5(g){var q=create$1(0);add_seq$0(q,g);return q}
    var
     Stdlib_queue=
      [0,
       Empty$0,
       create$1,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear$0,
       copy$4,
       is_empty$0,
       length$2,
       iter$8,
       fold$3,
       transfer,
       to_seq$7,
       add_seq$0,
       of_seq$5];
    caml_register_global(785,Stdlib_queue,"Stdlib__queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        caml_obj_make_forward(blk,result);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      caml_obj_make_forward(blk,result);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(786,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250 && t !== 246 && t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    var
     Stdlib_lazy=
      [0,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(787,Stdlib_lazy,"Stdlib__lazy");
    var
     Failure$0=[248,cst_Stdlib_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stdlib_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_O_]}
           case 2:
            var
             f=d$0[1],
             _uv_=caml_obj_tag(f),
             d$1=250 === _uv_?f[1]:246 === _uv_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _uw_=d$0[1],_ux_=_uw_[1];
            if(_ux_)
             {var _uy_=_ux_[1];
              if(_uy_){var a$0=_uy_[1];_uw_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_uw_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _uw_[1] = _P_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _uq_=s[2];
        if(typeof _uq_ === "number")
         return 0;
        else
         switch(_uq_[0])
          {case 0:var a=_uq_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_Q_]}
           case 2:
            var
             f=_uq_[1],
             _ur_=caml_obj_tag(f),
             _us_=250 === _ur_?f[1]:246 === _ur_?force_lazy_block(f):f;
            s[2] = _us_;
            continue;
           case 3:
            var _ut_=_uq_[1],_uu_=_ut_[1];
            if(_uu_){var a$1=_uu_[1];return a$1}
            var x=caml_call1(_ut_[2],s[1]);
            _ut_[1] = [0,x];
            return x;
           default:
            var b=_uq_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _uo_=s[2];
        if(typeof _uo_ !== "number")
         switch(_uo_[0])
          {case 0:var d=_uo_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _up_=_uo_[1];
            if(_up_[1]){s[1] = s[1] + 1 | 0;_up_[1] = 0;return 0}
            break;
           case 4:
            var b=_uo_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :(s[1] = s[1] + 1 | 0,b[4] = b[4] + 1 | 0,0)
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$1(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$9(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$1(l)
     {var _un_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_un_)]]}
    function of_string$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _um_=data(s);return [0,[0,0,[1,data(i),_um_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_uk_)
                  {var _ul_=data(s);return [1,data(caml_call1(f,0)),_ul_]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_ui_)
                  {var _uj_=data(s);return [0,caml_call1(f,0),_uj_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_uh_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_ug_){return data(caml_call1(f,0))}]]]]}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$7);
          dump_data(f,d);
          return print_string(cst$8);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$9);
          dump_data(f,d2);
          return print_string(cst$10);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$6);
      return print_newline(0)}
    var
     Stdlib_stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$1,
       of_string$0,
       of_bytes,
       of_channel,
       iter$9,
       next,
       empty$1,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(788,Stdlib_stream,"Stdlib__stream");
    function create$2(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes(b){return sub(b[1],0,b[2])}
    function sub$3(b,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((b[2] - len | 0) < ofs))
       return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$3(src,srcoff,dst,dstoff,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        srcoff
        &&
        !
        ((src[2] - len | 0) < srcoff)
        &&
        0
        <=
        dstoff
        &&
        !
        ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
       return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs && ! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var old_pos=b[2],old_len=b[3],new_len=[0,old_len];
      for(;;)
       {if(new_len[1] < (old_pos + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((old_pos + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buf);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        if((b[2] + more | 0) <= b[3])
         {if((old_pos + more | 0) <= b[3])return 0;
          throw [0,Assert_failure,_R_]}
        throw [0,Assert_failure,_S_]}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_T_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_U_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_V_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_W_]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_X_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_Y_]}
    function add_substring(b,s,offset,len)
     {var _ud_=offset < 0?1:0;
      if(_ud_)
       var _ue_=_ud_;
      else
       var
        _uf_=len < 0?1:0,
        _ue_=_uf_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_ue_)invalid_arg(cst_Buffer_add_substring_add_s);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,caml_string_of_bytes(s),offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,caml_string_of_bytes(s))}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len)
     {var _ub_=len < 0?1:0,_uc_=_ub_ || (max_string_length < len?1:0);
      if(_uc_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len | 0))resize(b,len);
      var already_read=0,ofs=b[2],to_read=len,_ua_=b[1];
      for(;;)
       {if(0 !== to_read)
         {var r=input(ic,_ua_,ofs,to_read);
          if(0 !== r)
           {var
             already_read$0=already_read + r | 0,
             ofs$0=ofs + r | 0,
             to_read$0=to_read - r | 0,
             already_read=already_read$0,
             ofs=ofs$0,
             to_read=to_read$0;
            continue}}
        if((b[2] + already_read | 0) <= b[3])
         {b[2] = b[2] + already_read | 0;
          if(already_read < len)throw End_of_file;
          return 0}
        throw [0,Assert_failure,_Z_]}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start),switch$0=0;
            if(40 !== opening && 123 !== opening)
             {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
              for(;;)
               {if(lim$0 <= i$3)
                 var stop=lim$0;
                else
                 {var match=caml_string_get(s,i$3),switch$1=0;
                  if(91 <= match)
                   {if(97 <= match)
                     {if(! (123 <= match))switch$1 = 1}
                    else
                     if(95 === match)switch$1 = 1}
                  else
                   if(58 <= match)
                    {if(65 <= match)switch$1 = 1}
                   else
                    if(48 <= match)switch$1 = 1;
                  if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                  var stop=i$3}
                var match$0=[0,sub$0(s,start,stop - start | 0),stop];
                switch$0 = 1;
                break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _t__=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,___];var _t__=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _t__)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _t$_=92 === previous?1:0;
        return _t$_?add_char(b,previous):_t$_}}
    function truncate(b,len)
     {if(0 <= len && ! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    function to_seq$8(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_t8_=i + 1 | 0;
        return [0,x,function(_t9_){return aux(_t8_,_t9_)}]}
      var _t6_=0;
      return function(_t7_){return aux(_t6_,_t7_)}}
    function to_seqi$3(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_t4_=i + 1 | 0;
        return [0,[0,i,x],function(_t5_){return aux(_t4_,_t5_)}]}
      var _t2_=0;
      return function(_t3_){return aux(_t2_,_t3_)}}
    function add_seq$1(b,seq)
     {return iter(function(_t1_){return add_char(b,_t1_)},seq)}
    function of_seq$6(i){var b=create$2(32);add_seq$1(b,i);return b}
    function add_int8(b,x)
     {var new_position=b[2] + 1 | 0;
      if(b[3] < new_position)resize(b,1);
      caml_bytes_unsafe_set(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_ne(b,x)
     {var new_position=b[2] + 2 | 0;
      if(b[3] < new_position)resize(b,2);
      caml_bytes_set16(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int32_ne(b,x)
     {var new_position=b[2] + 4 | 0;
      if(b[3] < new_position)resize(b,4);
      caml_bytes_set32(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int64_ne(b,x)
     {var new_position=b[2] + 8 | 0;
      if(b[3] < new_position)resize(b,8);
      caml_bytes_set64(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_le(b,x){return add_int16_ne(b,x)}
    function add_int16_be(b,x)
     {var x$0=caml_bswap16(x);return add_int16_ne(b,x$0)}
    function add_int32_le(b,x){return add_int32_ne(b,x)}
    function add_int32_be(b,x)
     {var x$0=caml_int32_bswap(x);return add_int32_ne(b,x$0)}
    function add_int64_le(b,x){return add_int64_ne(b,x)}
    function add_int64_be(b,x)
     {var x$0=caml_int64_bswap(x);return add_int64_ne(b,x$0)}
    var
     Stdlib_buffer=
      [0,
       create$2,
       contents,
       to_bytes,
       sub$3,
       blit$3,
       nth$0,
       length$3,
       clear$1,
       reset,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       output_buffer,
       truncate,
       to_seq$8,
       to_seqi$3,
       add_seq$1,
       of_seq$6,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
    caml_register_global(789,Stdlib_buffer,"Stdlib__buffer");
    function create_char_set(param){return make$0(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return to_string$1(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _t0_=i + 1 | 0;
        if(31 !== i){var i=_t0_;continue}
        return caml_string_of_bytes(char_set$0)}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_tZ_=[0,ndec];else var _tZ_=0;
          return [0,[8,_$_,pad_of_pad_opt(pad_opt$5),_tZ_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    function default_float_precision(fconv){return 5 === fconv[2]?12:-6}
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _tX_=len < min_len?1:0;
      if(_tX_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _tY_=0}
      else
       var _tY_=_tX_;
      return _tY_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 12:
        case 15:return 117;
        case 0:
        case 1:
        case 2:
        case 13:return 100;
        default:return 105}}
    function char_of_fconv(opt,fconv)
     {if(opt)var sth=opt[1],cF=sth;else var cF=70;
      switch(fconv[2])
       {case 0:return 102;
        case 1:return 101;
        case 2:return 69;
        case 3:return 103;
        case 4:return 71;
        case 5:return cF;
        case 6:return 104;
        case 7:return 72;
        default:return 70}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_string_of_jsbytes("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")return prec?buffer_add_string(buf,cst$11):0;
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:
        case 13:
        case 14:
        case 15:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv[1])
       {case 0:break;
        case 1:buffer_add_char(buf,43);break;
        default:buffer_add_char(buf,32)}
      return 8 <= fconv[2]?buffer_add_char(buf,35):0}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$12;
         case 1:return cst$13;
         case 2:return cst$14;
         case 3:return cst$15;
         case 4:return cst$16;
         case 5:return cst$17;
         default:return cst$18}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return symbol(cst$19,make$1(1,c))}}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$20):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _tV_=caml_ml_string_length(str) - 1 | 0,_tU_=0;
      if(! (_tV_ < 0))
       {var i=_tU_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _tW_=i + 1 | 0;
          if(_tV_ !== i){var i=_tW_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$21);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$22);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$23);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$25);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt$1)
     {var buf=buffer_create(16),fmt=fmt$1,ign_flag=0;
      a:
      for(;;)
       if(typeof fmt === "number")
        return buffer_contents(buf);
       else
        switch(fmt[0])
         {case 0:
           var rest=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,99);
           var fmt=rest,ign_flag=0;
           continue;
          case 1:
           var rest$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,67);
           var fmt=rest$0,ign_flag=0;
           continue;
          case 2:
           var rest$1=fmt[2],pad=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad);
           buffer_add_char(buf,115);
           var fmt=rest$1,ign_flag=0;
           continue;
          case 3:
           var rest$2=fmt[2],pad$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$0);
           buffer_add_char(buf,83);
           var fmt=rest$2,ign_flag=0;
           continue;
          case 4:
           var rest$3=fmt[4],prec=fmt[3],pad$1=fmt[2],iconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_iconv_flag(buf,iconv);
           bprint_padding(buf,pad$1);
           bprint_precision(buf,prec);
           buffer_add_char(buf,char_of_iconv(iconv));
           var fmt=rest$3,ign_flag=0;
           continue;
          case 5:
           var rest$4=fmt[4],prec$0=fmt[3],pad$2=fmt[2],iconv$0=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$0,pad$2,prec$0,108);
           var fmt=rest$4,ign_flag=0;
           continue;
          case 6:
           var rest$5=fmt[4],prec$1=fmt[3],pad$3=fmt[2],iconv$1=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$1,pad$3,prec$1,110);
           var fmt=rest$5,ign_flag=0;
           continue;
          case 7:
           var rest$6=fmt[4],prec$2=fmt[3],pad$4=fmt[2],iconv$2=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$2,pad$4,prec$2,76);
           var fmt=rest$6,ign_flag=0;
           continue;
          case 8:
           var rest$7=fmt[4],prec$3=fmt[3],pad$5=fmt[2],fconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_fconv_flag(buf,fconv);
           bprint_padding(buf,pad$5);
           bprint_precision(buf,prec$3);
           buffer_add_char(buf,char_of_fconv(0,fconv));
           var fmt=rest$7,ign_flag=0;
           continue;
          case 9:
           var rest$8=fmt[2],pad$6=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$6);
           buffer_add_char(buf,66);
           var fmt=rest$8,ign_flag=0;
           continue;
          case 10:
           var rest$9=fmt[1];
           buffer_add_string(buf,cst$26);
           var fmt=rest$9;
           continue;
          case 11:
           var rest$10=fmt[2],str=fmt[1];
           bprint_string_literal(buf,str);
           var fmt=rest$10;
           continue;
          case 12:
           var rest$11=fmt[2],chr$0=fmt[1];
           bprint_char_literal(buf,chr$0);
           var fmt=rest$11;
           continue;
          case 13:
           var rest$12=fmt[3],fmtty=fmt[2],pad_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt);
           buffer_add_char(buf,123);
           bprint_fmtty(buf,fmtty);
           buffer_add_char(buf,37);
           buffer_add_char(buf,125);
           var fmt=rest$12,ign_flag=0;
           continue;
          case 14:
           var rest$13=fmt[3],fmtty$0=fmt[2],pad_opt$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt$0);
           buffer_add_char(buf,40);
           bprint_fmtty(buf,fmtty$0);
           buffer_add_char(buf,37);
           buffer_add_char(buf,41);
           var fmt=rest$13,ign_flag=0;
           continue;
          case 15:
           var rest$14=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,97);
           var fmt=rest$14,ign_flag=0;
           continue;
          case 16:
           var rest$15=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,116);
           var fmt=rest$15,ign_flag=0;
           continue;
          case 17:
           var rest$16=fmt[2],fmting_lit=fmt[1];
           bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
           var fmt=rest$16;
           continue;
          case 18:
           var rest$17=fmt[2],fmting_gen=fmt[1];
           if(0 === fmting_gen[0])
            {var match$1=fmting_gen[1],str$0=match$1[2];
             buffer_add_string(buf,cst$27);
             buffer_add_string(buf,str$0)}
           else
            {var match$2=fmting_gen[1],str$1=match$2[2];
             buffer_add_string(buf,cst$28);
             buffer_add_string(buf,str$1)}
           var fmt=rest$17;
           continue;
          case 19:
           var rest$18=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,114);
           var fmt=rest$18,ign_flag=0;
           continue;
          case 20:
           var rest$19=fmt[3],char_set=fmt[2],width_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,width_opt);
           var
            print_char=
             function(buf,i)
              {var c=char_of_int(i);
               return 37 === c
                       ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                       :64 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                         :buffer_add_char(buf,c)};
           buffer_add_char(buf,91);
           var
            _tK_=
             is_in_char_set(char_set,0)
              ?(buffer_add_char(buf,94),rev_char_set(char_set))
              :char_set,
            is_alone$0=
             function(_tP_)
              {function is_alone(c)
                {var
                  after=chr(c + 1 | 0),
                  before=chr(c - 1 | 0),
                  _tQ_=is_in_char_set(_tP_,c);
                 if(_tQ_)
                  var
                   _tR_=is_in_char_set(_tP_,before),
                   _tS_=_tR_?is_in_char_set(_tP_,after):_tR_,
                   _tT_=1 - _tS_;
                 else
                  var _tT_=_tQ_;
                 return _tT_}
               return is_alone},
            is_alone=is_alone$0(_tK_);
           if(is_alone(93))buffer_add_char(buf,93);
           var i=1;
           b:
           for(;;)
            {if(i < 256)
              {if(! is_in_char_set(_tK_,char_of_int(i)))
                {var i$0=i + 1 | 0,i=i$0;continue}
               var match=char_of_int(i),switcher=match - 45 | 0,switch$0=0;
               if(48 < switcher >>> 0)
                if(210 <= switcher)print_char(buf,255);else switch$0 = 1;
               else
                {var switcher$0=switcher - 1 | 0;
                 if(46 < switcher$0 >>> 0){var i$2=i + 1 | 0,i=i$2;continue}
                 switch$0 = 1}
               if(switch$0)
                {var i$1=i + 1 | 0;
                 if(! is_in_char_set(_tK_,char_of_int(i$1)))
                  {print_char(buf,i$1 - 1 | 0);
                   var i$6=i$1 + 1 | 0,i=i$6;
                   continue}
                 var
                  match$0=char_of_int(i$1),
                  switcher$1=match$0 - 45 | 0,
                  switch$1=0;
                 if(48 < switcher$1 >>> 0)
                  if(210 <= switcher$1)
                   {print_char(buf,254);print_char(buf,255)}
                  else
                   switch$1 = 1;
                 else
                  {var switcher$2=switcher$1 - 1 | 0;
                   if(46 < switcher$2 >>> 0)
                    {if(! is_in_char_set(_tK_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       var i$5=i$1 + 1 | 0,i=i$5;
                       continue}
                     switch$1 = 1}
                   else
                    switch$1 = 1}
                 if(switch$1)
                  {if(! is_in_char_set(_tK_,char_of_int(i$1 + 1 | 0)))
                    {print_char(buf,i$1 - 1 | 0);
                     print_char(buf,i$1);
                     var i$4=i$1 + 2 | 0,i=i$4;
                     continue}
                   var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                   for(;;)
                    {if(256 !== j$0 && is_in_char_set(_tK_,char_of_int(j$0)))
                      {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                     print_char(buf,i$3);
                     print_char(buf,45);
                     print_char(buf,j$0 - 1 | 0);
                     if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                     break}}}}
             if(is_alone(45))buffer_add_char(buf,45);
             buffer_add_char(buf,93);
             var fmt=rest$19,ign_flag=0;
             continue a}
          case 21:
           var rest$20=fmt[2],counter=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           switch(counter)
            {case 0:var _tL_=108;break;
             case 1:var _tL_=110;break;
             default:var _tL_=78}
           buffer_add_char(buf,_tL_);
           var fmt=rest$20,ign_flag=0;
           continue;
          case 22:
           var rest$21=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_string_literal(buf,cst_0c);
           var fmt=rest$21,ign_flag=0;
           continue;
          case 23:
           var
            rest$22=fmt[2],
            ign=fmt[1],
            match$3=param_format_of_ignored_format(ign,rest$22),
            fmt$0=match$3[1],
            fmt=fmt$0,
            ign_flag=1;
           continue;
          default:
           var
            rest$23=fmt[3],
            arity=fmt[1],
            _tN_=int_of_custom_arity(arity),
            _tM_=1;
           if(! (_tN_ < 1))
            {var i$8=_tM_;
             for(;;)
              {buffer_add_char(buf,37);
               bprint_ignored_flag(buf,ign_flag);
               buffer_add_char(buf,63);
               var _tO_=i$8 + 1 | 0;
               if(_tN_ !== i$8){var i$8=_tO_;continue}
               break}}
           var fmt=rest$23,ign_flag=0;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function trans(ty1,match)
     {var switch$0=0;
      if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:break;
          case 11:switch$0 = 1;break;
          case 12:switch$0 = 2;break;
          case 13:switch$0 = 3;break;
          case 14:switch$0 = 4;break;
          case 8:switch$0 = 5;break;
          case 9:switch$0 = 6;break;
          default:throw [0,Assert_failure,_aa_]}
      else
       switch(ty1[0])
        {case 0:
          var switch$1=0,_tr_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_tr_,rest2)];
             case 8:switch$0 = 5;switch$1 = 1;break;
             case 9:switch$0 = 6;switch$1 = 1;break;
             case 10:switch$1 = 1;break;
             case 11:switch$0 = 1;switch$1 = 1;break;
             case 12:switch$0 = 2;switch$1 = 1;break;
             case 13:switch$0 = 3;switch$1 = 1;break;
             case 14:switch$0 = 4;switch$1 = 1;break
             }
          if(! switch$1)switch$0 = 7;
          break;
         case 1:
          var switch$2=0,_ts_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_ts_,rest2$0)];
             case 8:switch$0 = 5;switch$2 = 1;break;
             case 9:switch$0 = 6;switch$2 = 1;break;
             case 10:switch$2 = 1;break;
             case 11:switch$0 = 1;switch$2 = 1;break;
             case 12:switch$0 = 2;switch$2 = 1;break;
             case 13:switch$0 = 3;switch$2 = 1;break;
             case 14:switch$0 = 4;switch$2 = 1;break
             }
          if(! switch$2)switch$0 = 7;
          break;
         case 2:
          var switch$3=0,_tt_=ty1[1];
          if(typeof match === "number")
           switch$3 = 1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_tt_,rest2$1)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$3 = 1}
          if(switch$3)switch$0 = 7;
          break;
         case 3:
          var switch$4=0,_tu_=ty1[1];
          if(typeof match === "number")
           switch$4 = 1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_tu_,rest2$2)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$4 = 1}
          if(switch$4)switch$0 = 7;
          break;
         case 4:
          var switch$5=0,_tv_=ty1[1];
          if(typeof match === "number")
           switch$5 = 1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_tv_,rest2$3)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$5 = 1}
          if(switch$5)switch$0 = 7;
          break;
         case 5:
          var switch$6=0,_tw_=ty1[1];
          if(typeof match === "number")
           switch$6 = 1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_tw_,rest2$4)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$6 = 1}
          if(switch$6)switch$0 = 7;
          break;
         case 6:
          var switch$7=0,_tx_=ty1[1];
          if(typeof match === "number")
           switch$7 = 1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_tx_,rest2$5)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$7 = 1}
          if(switch$7)switch$0 = 7;
          break;
         case 7:
          var switch$8=0,_ty_=ty1[1];
          if(typeof match === "number")
           switch$8 = 1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_ty_,rest2$6)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$8 = 1}
          if(switch$8)switch$0 = 7;
          break;
         case 8:
          var switch$9=0,_tz_=ty1[2],_tA_=ty1[1];
          if(typeof match === "number")
           switch$9 = 1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_tB_=trans(_tz_,rest2$7);
              return [8,trans(_tA_,ty2),_tB_];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$9 = 1}
          if(switch$9)throw [0,Assert_failure,_aj_];
          break;
         case 9:
          var switch$10=0,_tC_=ty1[3],_tD_=ty1[2],_tE_=ty1[1];
          if(typeof match === "number")
           switch$10 = 1;
          else
           switch(match[0])
            {case 8:switch$0 = 5;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_tD_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_tE_,ty22,trans(_tC_,rest2$8)];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$10 = 1}
          if(switch$10)throw [0,Assert_failure,_ak_];
          break;
         case 10:
          var _tF_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_tF_,rest2$9)]}
          throw [0,Assert_failure,_al_];
         case 11:
          var switch$11=0,_tG_=ty1[1];
          if(typeof match === "number")
           switch$11 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:var rest2$10=match[1];return [11,trans(_tG_,rest2$10)];
             default:switch$11 = 1}
          if(switch$11)throw [0,Assert_failure,_am_];
          break;
         case 12:
          var switch$12=0,_tH_=ty1[1];
          if(typeof match === "number")
           switch$12 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:var rest2$11=match[1];return [12,trans(_tH_,rest2$11)];
             default:switch$12 = 1}
          if(switch$12)throw [0,Assert_failure,_an_];
          break;
         case 13:
          var switch$13=0,_tI_=ty1[1];
          if(typeof match === "number")
           switch$13 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:var rest2$12=match[1];return [13,trans(_tI_,rest2$12)];
             default:switch$13 = 1}
          if(switch$13)throw [0,Assert_failure,_ao_];
          break;
         default:
          var switch$14=0,_tJ_=ty1[1];
          if(typeof match === "number")
           switch$14 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:var rest2$13=match[1];return [14,trans(_tJ_,rest2$13)];
             default:switch$14 = 1}
          if(switch$14)throw [0,Assert_failure,_ap_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_ad_];
        case 1:throw [0,Assert_failure,_ae_];
        case 2:throw [0,Assert_failure,_af_];
        case 3:throw [0,Assert_failure,_ag_];
        case 4:throw [0,Assert_failure,_ah_];
        case 5:throw [0,Assert_failure,_ab_];
        case 6:throw [0,Assert_failure,_ac_];
        default:throw [0,Assert_failure,_ai_]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _s5_=function(param){return 0},
         _s6_=function(param){return 0},
         _s7_=function(param){return 0};
        return [0,function(param){return 0},_s7_,_s6_,_s5_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _s8_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_s8_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _s9_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _s9_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _s__=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _s__,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _s$_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _s$_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _ta_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _ta_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _tb_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _tb_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _tc_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _tc_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _td_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _td_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _te_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _te_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _tf_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _tg_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _th_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _th_,
                  _tg_,
                  _tf_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _ti_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _ti_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _tj_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _tj_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _tk_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _tk_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _tl_=function(param){caml_call1(de$12,0);return 0},
           _tm_=function(param){caml_call1(ed$12,0);return 0},
           _tn_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _tn_,
                  _tm_,
                  _tl_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _to_=function(param){caml_call1(de$13,0);return 0},
           _tp_=function(param){caml_call1(ed$13,0);return 0},
           _tq_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _tq_,
                  _tp_,
                  _to_]}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?prec?[2,fmtty]:fmtty:fmtty}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _s3_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_s4_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _s4_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_s4_,_s3_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mi,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(prec)
         {var _s2_=match[2];
          if(typeof _s2_ !== "number" && 2 === _s2_[0])
           {var rest=_s2_[1],pad$0=match[1];return [0,pad$0,1,rest]}
          throw Type_mismatch}
        var rest$0=match[2],pad$1=match[1];
        return [0,pad$1,0,rest$0]}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_ignored_format_substituti(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substituti(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substituti
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substituti
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substituti
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substituti
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substituti
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substituti
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substituti
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substituti
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _s0_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_s0_))
             throw Type_mismatch;
            var _s1_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_s1_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substituti
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substituti
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substituti
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substituti
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substituti
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           match$1=type_padding(pad,fmtty),
           _sJ_=match$1[2],
           _sI_=match$1[1];
          if(typeof _sJ_ !== "number" && 1 === _sJ_[0])
           {var
             fmtty_rest$1=_sJ_[1],
             match$2=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$2[2],
             fmt$2=match$2[1];
            return [0,[2,_sI_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           match$3=type_padding(pad$0,fmtty),
           _sL_=match$3[2],
           _sK_=match$3[1];
          if(typeof _sL_ !== "number" && 1 === _sL_[0])
           {var
             fmtty_rest$2=_sL_[1],
             match$4=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$4[2],
             fmt$3=match$4[1];
            return [0,[3,_sK_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           match$5=type_padprec(pad$1,prec,fmtty),
           _sN_=match$5[3],
           _sM_=match$5[1];
          if(typeof _sN_ !== "number" && 2 === _sN_[0])
           {var
             fmtty_rest$3=_sN_[1],
             prec$0=match$5[2],
             match$6=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$6[2],
             fmt$4=match$6[1];
            return [0,[4,iconv,_sM_,prec$0,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$1=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           match$7=type_padprec(pad$2,prec$1,fmtty),
           _sP_=match$7[3],
           _sO_=match$7[1];
          if(typeof _sP_ !== "number" && 3 === _sP_[0])
           {var
             fmtty_rest$4=_sP_[1],
             prec$2=match$7[2],
             match$8=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$8[2],
             fmt$5=match$8[1];
            return [0,[5,iconv$0,_sO_,prec$2,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$3=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           match$9=type_padprec(pad$3,prec$3,fmtty),
           _sR_=match$9[3],
           _sQ_=match$9[1];
          if(typeof _sR_ !== "number" && 4 === _sR_[0])
           {var
             fmtty_rest$5=_sR_[1],
             prec$4=match$9[2],
             match$10=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$10[2],
             fmt$6=match$10[1];
            return [0,[6,iconv$1,_sQ_,prec$4,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$5=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           match$11=type_padprec(pad$4,prec$5,fmtty),
           _sT_=match$11[3],
           _sS_=match$11[1];
          if(typeof _sT_ !== "number" && 5 === _sT_[0])
           {var
             fmtty_rest$6=_sT_[1],
             prec$6=match$11[2],
             match$12=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$12[2],
             fmt$7=match$12[1];
            return [0,[7,iconv$2,_sS_,prec$6,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$7=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           match$13=type_padprec(pad$5,prec$7,fmtty),
           _sV_=match$13[3],
           _sU_=match$13[1];
          if(typeof _sV_ !== "number" && 6 === _sV_[0])
           {var
             fmtty_rest$7=_sV_[1],
             prec$8=match$13[2],
             match$14=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$14[2],
             fmt$8=match$14[1];
            return [0,[8,fconv,_sU_,prec$8,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           match$15=type_padding(pad$6,fmtty),
           _sX_=match$15[2],
           _sW_=match$15[1];
          if(typeof _sX_ !== "number" && 7 === _sX_[0])
           {var
             fmtty_rest$8=_sX_[1],
             match$16=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$16[2],
             fmt$9=match$16[1];
            return [0,[9,_sW_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$17=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$17[2],
           fmt$10=match$17[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$18=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$18[2],
           fmt$11=match$18[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$19=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$19[2],
           fmt$12=match$19[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$20=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$20[2],
             fmt$13=match$20[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _sY_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_sY_))
             throw Type_mismatch;
            var
             match$21=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$21[2],
             fmt$14=match$21[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$22=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$22[2],
             fmt$15=match$22[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$23=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$23[2],
             fmt$16=match$23[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$24=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$24[2],
           fmt$17=match$24[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$28=formatting_gen[1],
             str$0=match$28[2],
             fmt1=match$28[1],
             match$29=type_format_gen(fmt1,fmtty),
             fmtty2=match$29[2],
             fmt2=match$29[1],
             match$30=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$30[2],
             fmt3=match$30[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$31=formatting_gen[1],
           str$1=match$31[2],
           fmt1$0=match$31[1],
           match$32=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$32[2],
           fmt2$0=match$32[1],
           match$33=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$33[2],
           fmt3$0=match$33[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$25=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$25[2],
             fmt$18=match$25[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$26=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$26[2],
             fmt$19=match$26[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$27=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$27[2],
             fmt$20=match$27[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$34=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$34[2],
                 fmt$21=match$34[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _sZ_=type_ignored_format_substituti(sub_fmtty$3,rest,fmtty),
               match$35=_sZ_[2],
               fmtty$22=match$35[2],
               fmt$22=match$35[1],
               sub_fmtty$4=_sZ_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format(fmt,fmtty)
     {var _sH_=type_format_gen(fmt,fmtty);
      if(typeof _sH_[2] === "number"){var fmt$0=_sH_[1];return fmt$0}
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _sG_=2 === padty$0?48:32,res=make$0(width$0,_sG_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         var switch$0=0;
         if(0 < len)
          {var switch$1=0;
           if
            (43
             !==
             caml_string_get(str,0)
             &&
             45
             !==
             caml_string_get(str,0)
             &&
             32
             !==
             caml_string_get(str,0))
            {switch$0 = 1;switch$1 = 1}
           if(! switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0)}}
         else
          switch$0 = 1;
         if(switch$0)
          {var switch$2=0;
           if(1 < len && 48 === caml_string_get(str,0))
            {var switch$3=0;
             if
              (120
               !==
               caml_string_get(str,1)
               &&
               88
               !==
               caml_string_get(str,1))
              {switch$2 = 1;switch$3 = 1}
             if(! switch$3)
              {caml_bytes_set(res,1,caml_string_get(str,1));
               blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0)}}
           else
            switch$2 = 1;
           if(switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return caml_string_of_bytes(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0),
       switch$0=0;
      if(58 <= c)
       {if(71 <= c)
         {if(! (5 < (c - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= c)switch$0 = 1}
      else
       {var switch$1=0;
        if(32 !== c)
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0) && 1 < len)
               {var switch$2=0;
                if
                 (120
                  ===
                  caml_string_get(str,1)
                  ||
                  88
                  ===
                  caml_string_get(str,1))
                 switch$2 = 1;
                if(switch$2)
                 {var res$1=make$0(prec$0 + 2 | 0,48);
                  caml_bytes_set(res$1,1,caml_string_get(str,1));
                  blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                  return caml_string_of_bytes(res$1)}}
              switch$0 = 1;
              switch$1 = 1;
              break;
             case 0:
             case 2:break;
             case 1:
             case 3:
             case 4:switch$1 = 1;break;
             default:switch$0 = 1;switch$1 = 1}}
         else
          switch$1 = 1;
        if(! switch$1 && len < (prec$0 + 1 | 0))
         {var res$0=make$0(prec$0 + 1 | 0,48);
          caml_bytes_set(res$0,0,c);
          blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
          return caml_string_of_bytes(res$0)}}
      if(switch$0 && len < prec$0)
       {var res=make$0(prec$0,48);
        blit$0(str,0,res,prec$0 - len | 0,len);
        return caml_string_of_bytes(res)}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make$0(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return caml_string_of_bytes(res)}
    function format_of_fconv(fconv,prec)
     {var
       prec$0=abs(prec),
       symb=char_of_fconv(_aq_,fconv),
       buf=buffer_create(16);
      buffer_add_char(buf,37);
      bprint_fconv_flag(buf,fconv);
      buffer_add_char(buf,46);
      buffer_add_string(buf,caml_string_of_jsbytes("" + prec$0));
      buffer_add_char(buf,symb);
      return buffer_contents(buf)}
    function transform_int_alt(iconv,s)
     {if(13 <= iconv)
       {var n=[0,0],_sB_=caml_ml_string_length(s) - 1 | 0,_sA_=0;
        if(! (_sB_ < 0))
         {var i$0=_sA_;
          for(;;)
           {var match=caml_string_unsafe_get(s,i$0),switcher$0=match - 48 | 0;
            if(! (9 < switcher$0 >>> 0))n[1]++;
            var _sF_=i$0 + 1 | 0;
            if(_sB_ !== i$0){var i$0=_sF_;continue}
            break}}
        var
         digits=n[1],
         buf=
          caml_create_bytes
           (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
         pos=[0,0],
         put=function(c){caml_bytes_set(buf,pos[1],c);pos[1]++;return 0},
         left=[0,((digits - 1 | 0) % 3 | 0) + 1 | 0],
         _sD_=caml_ml_string_length(s) - 1 | 0,
         _sC_=0;
        if(! (_sD_ < 0))
         {var i=_sC_;
          for(;;)
           {var c=caml_string_unsafe_get(s,i),switcher=c - 48 | 0;
            if(9 < switcher >>> 0)
             put(c);
            else
             {if(0 === left[1]){put(95);left[1] = 3}left[1] += -1;put(c)}
            var _sE_=i + 1 | 0;
            if(_sD_ !== i){var i=_sE_;continue}
            break}}
        return caml_string_of_bytes(buf)}
      return s}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 1:var _sz_=cst_d$3;break;
        case 2:var _sz_=cst_d$4;break;
        case 4:var _sz_=cst_i$1;break;
        case 5:var _sz_=cst_i$2;break;
        case 6:var _sz_=cst_x;break;
        case 7:var _sz_=cst_x$0;break;
        case 8:var _sz_=cst_X$0;break;
        case 9:var _sz_=cst_X$1;break;
        case 10:var _sz_=cst_o;break;
        case 11:var _sz_=cst_o$0;break;
        case 0:
        case 13:var _sz_=cst_d$2;break;
        case 3:
        case 14:var _sz_=cst_i$0;break;
        default:var _sz_=cst_u}
      return transform_int_alt(iconv,caml_format_int(_sz_,n))}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 1:var _sy_=cst_ld$0;break;
        case 2:var _sy_=cst_ld$1;break;
        case 4:var _sy_=cst_li$1;break;
        case 5:var _sy_=cst_li$2;break;
        case 6:var _sy_=cst_lx;break;
        case 7:var _sy_=cst_lx$0;break;
        case 8:var _sy_=cst_lX;break;
        case 9:var _sy_=cst_lX$0;break;
        case 10:var _sy_=cst_lo;break;
        case 11:var _sy_=cst_lo$0;break;
        case 0:
        case 13:var _sy_=cst_ld;break;
        case 3:
        case 14:var _sy_=cst_li$0;break;
        default:var _sy_=cst_lu}
      return transform_int_alt(iconv,caml_format_int(_sy_,n))}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 1:var _sx_=cst_nd$0;break;
        case 2:var _sx_=cst_nd$1;break;
        case 4:var _sx_=cst_ni$1;break;
        case 5:var _sx_=cst_ni$2;break;
        case 6:var _sx_=cst_nx;break;
        case 7:var _sx_=cst_nx$0;break;
        case 8:var _sx_=cst_nX;break;
        case 9:var _sx_=cst_nX$0;break;
        case 10:var _sx_=cst_no;break;
        case 11:var _sx_=cst_no$0;break;
        case 0:
        case 13:var _sx_=cst_nd;break;
        case 3:
        case 14:var _sx_=cst_ni$0;break;
        default:var _sx_=cst_nu}
      return transform_int_alt(iconv,caml_format_int(_sx_,n))}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 1:var _sw_=cst_Ld$0;break;
        case 2:var _sw_=cst_Ld$1;break;
        case 4:var _sw_=cst_Li$1;break;
        case 5:var _sw_=cst_Li$2;break;
        case 6:var _sw_=cst_Lx;break;
        case 7:var _sw_=cst_Lx$0;break;
        case 8:var _sw_=cst_LX;break;
        case 9:var _sw_=cst_LX$0;break;
        case 10:var _sw_=cst_Lo;break;
        case 11:var _sw_=cst_Lo$0;break;
        case 0:
        case 13:var _sw_=cst_Ld;break;
        case 3:
        case 14:var _sw_=cst_Li$0;break;
        default:var _sw_=cst_Lu}
      return transform_int_alt(iconv,caml_int64_format(_sw_,n))}
    function convert_float(fconv,prec,x)
     {function hex(param)
       {switch(fconv[1])
         {case 0:var sign=45;break;
          case 1:var sign=43;break;
          default:var sign=32}
        return runtime.caml_hexstring_of_float(x,prec,sign)}
      function caml_special_val(str)
       {var match=runtime.caml_classify_float(x);
        return 3 === match
                ?x < 0.?cst_neg_infinity:cst_infinity
                :4 <= match?cst_nan:str}
      switch(fconv[2])
       {case 5:
         var
          str=caml_format_float(format_of_fconv(fconv,prec),x),
          len=caml_ml_string_length(str),
          i=0;
         for(;;)
          {if(i === len)
            var _su_=0;
           else
            {var match=caml_string_get(str,i),_st_=match - 46 | 0,switch$0=0;
             if(23 < _st_ >>> 0)
              {if(55 === _st_)switch$0 = 1}
             else
              if(21 < (_st_ - 1 | 0) >>> 0)switch$0 = 1;
             if(! switch$0){var i$0=i + 1 | 0,i=i$0;continue}
             var _su_=1}
           var _sv_=_su_?str:symbol(str,cst$29);
           return caml_special_val(_sv_)}
        case 6:return hex(0);
        case 7:return uppercase_ascii$1(hex(0));
        case 8:return caml_special_val(hex(0));
        default:return caml_format_float(format_of_fconv(fconv,prec),x)}}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_printf$0(counter,k,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make$0(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,caml_string_of_bytes(res)];
             return make_printf(k$0,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding(k$0,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return prec$3
                      ?function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(x)
                        {var
                          str=
                           convert_float(fconv,default_float_precision(fconv),x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _sq_=pad$5[2],_sr_=pad$5[1];
               if(typeof prec$3 === "number")
                return prec$3
                        ?function(p,x)
                          {var str=fix_padding(_sr_,_sq_,convert_float(fconv,p,x));
                           return make_printf(k$0,[4,acc$0,str],rest$7)}
                        :function(x)
                          {var
                            str=convert_float(fconv,default_float_precision(fconv),x),
                            str$0=fix_padding(_sr_,_sq_,str);
                           return make_printf(k$0,[4,acc$0,str$0],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_sr_,_sq_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,[4,acc$0,str],rest$7)}}
             var _ss_=pad$5[1];
             if(typeof prec$3 === "number")
              return prec$3
                      ?function(w,p,x)
                        {var str=fix_padding(_ss_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision(fconv),x),
                          str$0=fix_padding(_ss_,w,str);
                         return make_printf(k$0,[4,acc$0,str$0],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_ss_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str){return make_printf(k$0,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _so_=fmt$0[1];
           if(0 === _so_[0])
            {var
              rest$13=fmt$0[2],
              match=_so_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(kacc)
                  {return make_printf(k,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_so_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(kacc){return make_printf(k,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_ar_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _sp_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,acc$0,rest$19,arity,_sp_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,acc$0,rest$19,arity,_sp_])}}
    function make_ignored_param$0(counter,k,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:throw [0,Assert_failure,_as_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,acc,fmtty,fmt)}
          return caml_trampoline_return(make_from_fmtty$0,[0,k,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}}
    function make_from_fmtty$0(counter,k,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_sn_)
           {return make_from_fmtty(k,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_at_];
         default:throw [0,Assert_failure,_au_]}}
    function make_invalid_arg(counter,k,acc,fmt)
     {var _sm_=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_sm_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,_sm_,fmt])}
    function make_custom$0(counter,k,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,acc,rest,arity$0,caml_call1(f,x))}}
      var _sl_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_sl_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,_sl_,rest])}
    function make_printf(k,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,acc,fmt))}
    function make_ignored_param(k,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,acc,ign,fmt))}
    function make_from_fmtty(k,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,acc,fmtty,fmt))}
    function make_custom(k,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,acc,rest,arity,f))}
    function make_padding(k,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,new_acc,fmt)}}}
    function make_int_padding_precision(k,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return match
                 ?function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _si_=pad[2],_sj_=pad[1];
          if(typeof match === "number")
           return match
                   ?function(p,x)
                     {var
                       str=
                        fix_padding
                         (_sj_,_si_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,[4,acc,str],fmt)}
                   :function(x)
                     {var str=fix_padding(_sj_,_si_,caml_call2(trans,iconv,x));
                      return make_printf(k,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_sj_,_si_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,[4,acc,str],fmt)}}
        var _sk_=pad[1];
        if(typeof match === "number")
         return match
                 ?function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_sk_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(w,x)
                   {var str=fix_padding(_sk_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_sk_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,[4,acc,str],fmt)}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_rz_=make_iprintf(k$0,o,rest);
           return function(_sh_){return _rz_};
          case 1:
           var rest$0=fmt$0[1],_rA_=make_iprintf(k$0,o,rest$0);
           return function(_sg_){return _rA_};
          case 2:
           var _rB_=fmt$0[1];
           if(typeof _rB_ === "number")
            {var rest$1=fmt$0[2],_rC_=make_iprintf(k$0,o,rest$1);
             return function(_sc_){return _rC_}}
           else
            {if(0 === _rB_[0])
              {var rest$2=fmt$0[2],_rD_=make_iprintf(k$0,o,rest$2);
               return function(_sf_){return _rD_}}
             var
              rest$3=fmt$0[2],
              _rE_=make_iprintf(k$0,o,rest$3),
              _rF_=function(_se_){return _rE_};
             return function(_sd_){return _rF_}}
          case 3:
           var _rG_=fmt$0[1];
           if(typeof _rG_ === "number")
            {var rest$4=fmt$0[2],_rH_=make_iprintf(k$0,o,rest$4);
             return function(_r__){return _rH_}}
           else
            {if(0 === _rG_[0])
              {var rest$5=fmt$0[2],_rI_=make_iprintf(k$0,o,rest$5);
               return function(_sb_){return _rI_}}
             var
              rest$6=fmt$0[2],
              _rJ_=make_iprintf(k$0,o,rest$6),
              _rK_=function(_sa_){return _rJ_};
             return function(_r$_){return _rK_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _rL_=fmt$0[1];
           if(typeof _rL_ === "number")
            {var rest$12=fmt$0[2],_rM_=make_iprintf(k$0,o,rest$12);
             return function(_r6_){return _rM_}}
           else
            {if(0 === _rL_[0])
              {var rest$13=fmt$0[2],_rN_=make_iprintf(k$0,o,rest$13);
               return function(_r9_){return _rN_}}
             var
              rest$14=fmt$0[2],
              _rO_=make_iprintf(k$0,o,rest$14),
              _rP_=function(_r8_){return _rO_};
             return function(_r7_){return _rP_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_rQ_=make_iprintf(k$0,o,rest$15);
           return function(_r5_){return _rQ_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _rR_=make_iprintf(k$0,o,rest$17),
            _rS_=function(_r4_){return _rR_};
           return function(_r3_){return _rS_};
          case 16:
           var rest$18=fmt$0[1],_rT_=make_iprintf(k$0,o,rest$18);
           return function(_r2_){return _rT_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _rU_=fmt$0[1];
           if(0 === _rU_[0])
            {var
              rest$19=fmt$0[2],
              match=_rU_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_rU_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_av_];
          case 20:
           var rest$21=fmt$0[3],_rV_=make_iprintf(k$0,o,rest$21);
           return function(_r1_){return _rV_};
          case 21:
           var rest$22=fmt$0[2],_rW_=make_iprintf(k$0,o,rest$22);
           return function(_r0_){return _rW_};
          case 22:
           var rest$23=fmt$0[1],_rX_=make_iprintf(k$0,o,rest$23);
           return function(_rZ_){return _rX_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_rY_=0;
           return make_ignored_param
                   (function(param){return caml_call1(k$0,o)},_rY_,ign,rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_rx_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_ry_){return _rx_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)
           {var _q5_=make_iprintf(k,o,fmt),_q6_=function(_rl_){return _q5_};
            return function(_rk_){return _q6_}}
          var _q7_=make_iprintf(k,o,fmt);
          return function(_rj_){return _q7_}}
        var _q8_=make_iprintf(k,o,fmt);
        return function(_ri_){return _q8_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(prec)
             {var _q9_=make_iprintf(k,o,fmt),_q__=function(_rw_){return _q9_};
              return function(_rv_){return _q__}}
            var _q$_=make_iprintf(k,o,fmt);
            return function(_ru_){return _q$_}}
          var _ra_=make_iprintf(k,o,fmt);
          return function(_rt_){return _ra_}}
        if(typeof prec === "number")
         {if(prec)
           {var
             _rb_=make_iprintf(k,o,fmt),
             _rc_=function(_rs_){return _rb_},
             _rd_=function(_rr_){return _rc_};
            return function(_rq_){return _rd_}}
          var _re_=make_iprintf(k,o,fmt),_rf_=function(_rp_){return _re_};
          return function(_ro_){return _rf_}}
        var _rg_=make_iprintf(k,o,fmt),_rh_=function(_rn_){return _rg_};
        return function(_rm_){return _rh_}}}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _q3_=acc$0[2],_q4_=acc$0[1];
           if(0 === _q3_[0])
            {var acc$1=_q3_[1];
             output_acc(o,_q4_);
             output_string(o,cst$30);
             var acc$0=acc$1;
             continue}
           var acc$2=_q3_[1];
           output_acc(o,_q4_);
           output_string(o,cst$31);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _q1_=acc$0[2],_q2_=acc$0[1];
           if(0 === _q1_[0])
            {var acc$1=_q1_[1];
             bufput_acc(b,_q2_);
             add_string(b,cst$32);
             var acc$0=acc$1;
             continue}
           var acc$2=_q1_[1];
           bufput_acc(b,_q2_);
           add_string(b,cst$33);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _qZ_=acc$0[2],_q0_=acc$0[1];
           if(0 === _qZ_[0])
            {var acc$1=_qZ_[1];
             strput_acc(b,_q0_);
             add_string(b,cst$34);
             var acc$0=acc$1;
             continue}
           var acc$2=_qZ_[1];
           strput_acc(b,_q0_);
           add_string(b,cst$35);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$2(256);
      function k(acc){strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$36))return _aw_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_ax_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match && 32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switch$0=0;
          if(48 <= match)
           {if(! (58 <= match))switch$0 = 1}
          else
           if(45 === match)switch$0 = 1;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _qX_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_qX_}
       catch(_qY_)
        {_qY_ = caml_wrap_exception(_qY_);
         if(_qY_[1] !== Failure)throw _qY_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      var switch$0=0;
      if
       (caml_string_notequal(box_name,cst$37)
        &&
        caml_string_notequal(box_name,cst_b$0))
       var
        box_type=
         caml_string_notequal(box_name,cst_h)
          ?caml_string_notequal(box_name,cst_hov)
            ?caml_string_notequal(box_name,cst_hv)
              ?caml_string_notequal(box_name,cst_v)?invalid_box(0):1
              :2
            :3
          :0;
      else
       switch$0 = 1;
      if(switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=prec?[0,1,fmt]:[0,0,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_ay_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_az_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_aA_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0),switcher=c - 48 | 0;
          if(9 < switcher >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aR_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0),switcher=c - 48 | 0;
           if(9 < switcher >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aS_]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aX_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {var switch$0=0;
          if(plus$0)
           {if(hash$0)
             switch$0 = 1;
            else
             if(! space$0){if(100 === symb)return 1;if(105 === symb)return 4}}
          else
           if(hash$0)
            if(space$0)
             switch$0 = 1;
            else
             {var switcher$0=symb - 88 | 0;
              if(32 < switcher$0 >>> 0)
               switch$0 = 1;
              else
               switch(switcher$0)
                {case 0:return 9;
                 case 12:return 13;
                 case 17:return 14;
                 case 23:return 11;
                 case 29:return 15;
                 case 32:return 7;
                 default:switch$0 = 1}}
           else
            if(space$0)
             {if(100 === symb)return 2;if(105 === symb)return 5}
            else
             {var switcher$1=symb - 88 | 0;
              if(! (32 < switcher$1 >>> 0))
               switch(switcher$1)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6
                 }}
          if(switch$0)
           {var switcher=symb - 88 | 0;
            if(! (32 < switcher >>> 0))
             switch(switcher)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$49)
               }}
          if(plus$0)
           {if(space$0)
             {if(legacy_behavior$0){var space$0=0;continue}
              return incompatible_flag(pct_ind,str_ind,32,cst$46)}
            if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$47)}
          if(space$0)
           {if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$48)}
          throw [0,Assert_failure,_aV_]}}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aT_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 {var switcher=match$0 - 123 | 0;
                  switch(switcher)
                   {case 0:
                     var
                      sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                      str_ind$2=sub_end + 2 | 0,
                      str_ind$0=str_ind$2;
                     continue;
                    case 1:break;
                    default:
                     return expected_character
                             (str_ind$0 + 1 | 0,cst_character,125)}}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$2)
           {if(! (58 <= match$2))switch$0 = 1}
          else
           if(45 === match$2)switch$0 = 1;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _qV_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _qV_=0;
          var _qU_=_qV_}
        catch(_qW_)
         {_qW_ = caml_wrap_exception(_qW_);
          if(_qW_ !== Not_found && _qW_[1] !== Failure)throw _qW_;
          var _qU_=0}
        if(_qU_)
         {var
           match=_qU_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aP_,fmt_rest$0]]}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _qN_=str_ind === end_ind?1:0,
           _qO_=_qN_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_qO_)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$0)
           {if(! (58 <= match$0))switch$0 = 1}
          else
           if(45 === match$0)switch$0 = 1;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0,
           switch$1=0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _qP_=[0,s,width,0],
             _qQ_=str_ind_3 + 1 | 0,
             formatting_lit$0=_qP_,
             next_ind=_qQ_;
           else
            switch$1 = 1;
          else
           {var switcher$0=switcher - 1 | 0;
            if(1 < switcher$0 >>> 0)
             {var
               match$3=parse_integer(str_ind_3,end_ind),
               offset=match$3[2],
               str_ind_4=match$3[1],
               str_ind_5=parse_spaces(str_ind_4,end_ind);
              if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
              var
               s$0=
                sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
               _qR_=[0,s$0,width,offset],
               _qS_=str_ind_5 + 1 | 0,
               formatting_lit$0=_qR_,
               next_ind=_qS_}
            else
             switch$1 = 1}
          if(switch$1)throw Not_found}
        catch(_qT_)
         {_qT_ = caml_wrap_exception(_qT_);
          if(_qT_ !== Not_found && _qT_[1] !== Failure)throw _qT_;
          var formatting_lit$0=formatting_lit,next_ind=str_ind}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str],
             formatting$0=is_open_tag?[0,sub_format$0]:[1,sub_format$0],
             _qL_=[0,[18,formatting$0,fmt_rest$0]];
            return _qL_}
          throw Not_found}
        catch(_qM_)
         {_qM_ = caml_wrap_exception(_qM_);
          if(_qM_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _qM_}}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _qI_=flag[1],_qJ_=_qI_?1 - legacy_behavior$0:_qI_;
          if(_qJ_)
           {var _qK_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_aB_),str,str_ind,_qK_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _qD_=space[1],
           _qE_=hash[1],
           _qF_=plus[1],
           _qG_=minus[1],
           _qH_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            _qH_
             ?_qG_
               ?legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0)
               :2
             :_qG_?0:1,
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _qG_,
                       _qF_,
                       _qE_,
                       _qD_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _qG_,
                     _qF_,
                     _qE_,
                     _qD_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_qG_,_qF_,_qE_,_qD_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_qG_,_qF_,_qE_,_qD_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_qG_,_qF_,_qE_,_qD_,ign,_aC_)}}}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            {var switcher=symb$0 - 42 | 0;
             switch(switcher)
              {case 0:
                return parse_after_precision
                        (pct_ind,
                         str_ind$0 + 1 | 0,
                         end_ind,
                         minus,
                         plus,
                         hash,
                         space,
                         ign,
                         pad,
                         1);
               case 1:
               case 3:
                if(legacy_behavior$0)
                 {var
                   _qC_=str_ind$0 + 1 | 0,
                   minus$0=minus || (45 === symb$0?1:0);
                  return parse_literal(minus$0,_qC_)}
                break
               }}
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aD_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,match)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   match,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof match === "number" && ! match)return parse_conv(0);
          if(minus)
           {if(typeof match === "number")return parse_conv(_aE_);
            var n=match[1];
            return parse_conv([0,0,n])}
          if(typeof match === "number")return parse_conv(_aF_);
          var n$0=match[1];
          return parse_conv([0,1,n$0])}
        return parse_conv(pad)}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number" && ! match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aG_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aH_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$38);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$39)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        var switch$0=0;
        if(124 <= symb)
         switch$0 = 1;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]];
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _p$_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _p$_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_p$_;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind);break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _qb_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_qb_;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_qh_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _qh_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_qh_;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _qi_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _qi_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_qi_;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _qB_=i + 1 | 0;
                    if(c !== i){var i=_qB_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aQ_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _qA_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_qA_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_qA_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0),switch$0=0;
                  if(46 <= c$1)
                   {if(64 === c$1)
                     switch$0 = 1;
                    else
                     if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}}
                  else
                   if(37 === c$1)
                    switch$0 = 1;
                   else
                    if(45 <= c$1)
                     {var str_ind$2=str_ind$0 + 1 | 0;
                      if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                      var c$2=caml_string_get(str,str_ind$2);
                      if(37 === c$2)
                       {if((str_ind$2 + 1 | 0) === end_ind)
                         unexpected_end_of_format(end_ind);
                        var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                        if(37 !== c$3 && 64 !== c$3)
                         return fail_single_percent(str_ind$2);
                        add_range(c$0,c$3);
                        var _qy_=str_ind$2 + 2 | 0;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return parse_char_set_content(counter$2,_qy_,end_ind)}
                        return caml_trampoline_return
                                (parse_char_set_content,[0,_qy_,end_ind])}
                      if(93 === c$2)
                       {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                      add_range(c$0,c$2);
                      var _qz_=str_ind$2 + 1 | 0;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return parse_char_set_content(counter$1,_qz_,end_ind)}
                      return caml_trampoline_return
                              (parse_char_set_content,[0,_qz_,end_ind])}
                  if(switch$0 && 37 === c$0)
                   {add_char(c$1);
                    var _qx_=str_ind$0 + 1 | 0;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return parse_char_set_content(counter$0,_qx_,end_ind)}
                    return caml_trampoline_return
                            (parse_char_set_content,[0,_qx_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,reverse=1,str_ind$1=str_ind$0;
            else
             var reverse=0,str_ind$1=str_ind;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _qn_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _qn_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_qn_;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]];
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _qo_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _qp_=_qo_;
              else
               var
                _qp_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,cst_non_zero_widths_are_unsupp);
              var _qq_=_qp_}
            else
             var _qq_=char_format(fmt_rest$21);
            var fmt_result=_qq_;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _qr_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_qr_;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _qs_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _qs_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_qs_;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]];
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _qt_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _qt_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_qt_;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _qa_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _qa_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_qa_;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]];
            break;
           case 76:
           case 108:
           case 110:
            var switch$1=0;
            if(str_ind !== end_ind)
             {var
               symb$0=caml_string_get(str,str_ind),
               _qu_=symb$0 - 88 | 0,
               switch$2=0;
              if(! (32 < _qu_ >>> 0))
               switch(_qu_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _qg_=1;switch$2 = 1;break
                 }
              if(! switch$2)var _qg_=0;
              if(_qg_){switch$0 = 1;switch$1 = 1}}
            if(! switch$1)
             {var
               match$15=parse(str_ind,end_ind),
               fmt_rest$13=match$15[1],
               switch$3=0;
              if(108 <= symb)
               {if(! (111 <= symb))
                 {var switcher$0=symb - 108 | 0;
                  switch(switcher$0)
                   {case 0:var counter=0;switch$3 = 1;break;
                    case 1:break;
                    default:var counter=1;switch$3 = 1}}}
              else
               if(76 === symb){var counter=2;switch$3 = 1}
              if(! switch$3)throw [0,Assert_failure,_aU_];
              if(get_ign(0))
               var ignored$5=[11,counter],_qf_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _qf_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_qf_}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=
              caml_call3(failwith_message(_aL_),str,pct_ind,symb);
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _qj_=get_space(0),
             _qk_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_qk_,_qj_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _ql_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _qm_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_qm_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _ql_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_ql_;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             hash$1=get_hash(0),
             plus$2=get_plus(0),
             flag=
              plus$2
               ?space$1
                 ?legacy_behavior$0
                   ?1
                   :incompatible_flag(pct_ind,str_ind,32,cst$50)
                 :1
               :space$1?2:0,
             switch$4=0;
            if(73 <= symb)
             {var switcher$1=symb - 101 | 0;
              if(3 < switcher$1 >>> 0)
               switch$4 = 1;
              else
               {switch(switcher$1)
                 {case 0:var _qv_=1;break;
                  case 1:var _qv_=0;break;
                  case 2:var _qv_=3;break;
                  default:var _qv_=6}
                var kind=_qv_}}
            else
             if(69 <= symb)
              {var switcher$2=symb - 69 | 0,switch$5=0;
               switch(switcher$2)
                {case 0:var _qw_=2;break;
                 case 1:switch$4 = 1;switch$5 = 1;break;
                 case 2:var _qw_=4;break;
                 default:var _qw_=7}
               if(! switch$5)var kind=_qw_}
             else
              switch$4 = 1;
            if(switch$4)
             {var switch$6=0;
              if(hash$1)
               if(70 === symb)var kind=8;else switch$6 = 1;
              else
               if(70 === symb)var kind=5;else switch$6 = 1;
              if(switch$6)throw [0,Assert_failure,_aW_]}
            var
             fconv=[0,flag,kind],
             match$13=parse(str_ind,end_ind),
             fmt_rest$11=match$13[1];
            if(get_ign(0))
             {var match=get_prec(0);
              if(typeof match === "number")
               var _qc_=match?incompatible_flag(pct_ind,str_ind,95,cst$40):0;
              else
               var ndec=match[1],_qc_=[0,ndec];
              var
               ignored$4=[6,get_pad_opt(95),_qc_],
               _qd_=[0,[23,ignored$4,fmt_rest$11]]}
            else
             var
              _qe_=get_prec(0),
              match$14=make_padprec_fmt_ebb(get_pad(0),_qe_,fmt_rest$11),
              fmt_rest$12=match$14[3],
              prec$3=match$14[2],
              pad$5=match$14[1],
              _qd_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
            var fmt_result=_qd_;
            break;
           default:switch$0 = 1}
        if(switch$0)
         {var switch$7=0;
          if(108 <= symb)
           if(111 <= symb)
            switch$7 = 1;
           else
            {var switcher=symb - 108 | 0,switch$8=0;
             switch(switcher)
              {case 0:
                var
                 _pV_=caml_string_get(str,str_ind),
                 _pW_=get_space(0),
                 _pX_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_pX_,_pW_,_pV_),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _pY_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _p0_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_p0_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _pY_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _pZ_=_pY_;
                break;
               case 1:switch$7 = 1;switch$8 = 1;break;
               default:
                var
                 _p1_=caml_string_get(str,str_ind),
                 _p2_=get_space(0),
                 _p3_=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_p3_,_p2_,_p1_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _p4_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _p5_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_p5_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _p4_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _pZ_=_p4_}
             if(! switch$8)var fmt_result=_pZ_}
          else
           if(76 === symb)
            {var
              _p6_=caml_string_get(str,str_ind),
              _p7_=get_space(0),
              _p8_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_p8_,_p7_,_p6_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _p9_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _p__=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_p__,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _p9_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_p9_}
           else
            switch$7 = 1;
          if(switch$7)
           var
            fmt_result=
             caml_call3(failwith_message(_aI_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _pM_=1 - plus_used[1],plus$0=_pM_?plus:_pM_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _pN_=1 - hash_used[1],hash$0=_pN_?hash:_pN_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$42);
          var _pO_=1 - space_used[1],space$0=_pO_?space:_pO_;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$43);
          var _pP_=1 - pad_used[1],_pQ_=_pP_?caml_notequal([0,pad],_aJ_):_pP_;
          if(_pQ_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _pR_=1 - prec_used[1],
           _pS_=_pR_?caml_notequal([0,prec],_aK_):_pR_;
          if(_pS_)
           {var _pT_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_pT_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$44)}
        var _pU_=1 - ign_used[1],ign$0=_pU_?ign:_pU_;
        if(ign$0)
         {var switch$9=0;
          if(38 <= symb)
           {if(44 !== symb && 64 !== symb)switch$9 = 1}
          else
           if(33 !== symb && ! (37 <= symb))switch$9 = 1;
          var switch$10=0;
          if(switch$9 || ! legacy_behavior$0)switch$10 = 1;
          if(switch$10)incompatible_flag(pct_ind,str_ind,symb,cst$45)}
        return fmt_result}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _pL_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_pL_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aM_;
            else
             {var c=caml_string_get(str,str_ind$0),switch$0=0;
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  switch$0 = 1;
                 else
                  switch(switcher)
                   {case 0:
                     var match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]]}}
               else
                if(91 <= c)
                 {var switcher$0=c - 91 | 0;
                  switch(switcher$0)
                   {case 0:
                     var match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$4=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$3=match$4[1],
                      match$0=[0,[17,0,fmt_rest$3]]}}
                else
                 switch$0 = 1;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]];
               else
                if(32 <= c)
                 {var switcher$1=c - 32 | 0;
                  switch(switcher$1)
                   {case 0:
                     var
                      match$6=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$5=match$6[1],
                      match$0=[0,[17,_aN_,fmt_rest$5]];
                     break;
                    case 5:
                     var switch$1=0;
                     if
                      ((str_ind$0 + 1 | 0)
                       <
                       end_ind
                       &&
                       37
                       ===
                       caml_string_get(str,str_ind$0 + 1 | 0))
                      {var
                        match$7=parse(str_ind$0 + 2 | 0,end_ind),
                        fmt_rest$6=match$7[1],
                        match$0=[0,[17,6,fmt_rest$6]];
                       switch$1 = 1}
                     if(! switch$1)
                      var
                       match$8=parse(str_ind$0,end_ind),
                       fmt_rest$7=match$8[1],
                       match$0=[0,[12,64,fmt_rest$7]];
                     break;
                    case 12:
                     var
                      match$9=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$8=match$9[1],
                      match$0=[0,[17,_aO_,fmt_rest$8]];
                     break;
                    case 14:
                     var
                      match$10=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$9=match$10[1],
                      match$0=[0,[17,4,fmt_rest$9]];
                     break;
                    case 27:
                     var match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 28:
                     var match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 31:
                     var
                      match$11=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$10=match$11[1],
                      match$0=[0,[17,2,fmt_rest$10]];
                     break;
                    case 32:
                     var
                      match$12=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$11=match$12[1],
                      match$0=[0,[17,5,fmt_rest$11]];
                     break;
                    default:switch$0 = 1}}
                else
                 switch$0 = 1;
              if(switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _pJ_=[0,type_format(fmt,fmtty),str];return _pJ_}
      catch(_pK_)
       {_pK_ = caml_wrap_exception(_pK_);
        if(_pK_ === Type_mismatch)
         {var _pI_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aY_),str,_pI_)}
        throw _pK_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _pG_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _pG_}
      catch(_pH_)
       {_pH_ = caml_wrap_exception(_pH_);
        if(_pH_ === Type_mismatch)
         return caml_call2(failwith_message(_aZ_),str,str$0);
        throw _pH_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(790,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_pF_=0;
      return make_printf
              (function(acc){output_acc(o,acc);return caml_call1(k,o)},
               _pF_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_pE_=0;
      return make_printf
              (function(acc){bufput_acc(b,acc);return caml_call1(k,b)},
               _pE_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_pD_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_pC_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_pB_){return 0},oc,fmt)}
    function ibprintf(b,fmt){return ikfprintf(function(_pA_){return 0},b,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(acc)
       {var buf=create$2(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Stdlib_printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
    caml_register_global(791,Stdlib_printf,"Stdlib__printf");
    var
     Bad=[248,cst_Stdlib_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Stdlib_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Stdlib_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$1=l$0[2],l$0=l$1;
          continue}
        throw Not_found}}
    function split$0(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _pz_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_pz_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_py_=symbol(prefix,h);
        return symbol
                (fold_left$0
                  (function(x,y){return symbol(x,symbol(sep,y))},_py_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_a2_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _pv_=0,_pt_=_pv_}
      catch(_px_)
       {_px_ = caml_wrap_exception(_px_);
        if(_px_ !== Not_found)throw _px_;
        var
         _pt_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_optio],0]}
      try
       {assoc3(cst_help$1,speclist);var _pu_=0,add2=_pu_}
      catch(_pw_)
       {_pw_ = caml_wrap_exception(_pw_);
        if(_pw_ !== Not_found)throw _pw_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_optio$0],
           0]}
      return append(speclist,append(_pt_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a3_),errmsg);
      var _pq_=add_help(speclist);
      return iter$2
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _pr_=0 < caml_ml_string_length(doc)?1:0;
                 if(_pr_)
                  {if(11 === spec[0])
                    {var l=spec[1],_ps_=make_symlist(cst$53,cst$52,cst$51,l);
                     return caml_call3(bprintf(buf,_a1_),key,_ps_,doc)}
                   return caml_call2(bprintf(buf,_a0_),key,doc)}
                 return _pr_},
               _pq_)}
    function usage_string(speclist,errmsg)
     {var b=create$2(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _pp_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a4_),_pp_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _pn_=[0,bool_of_string(x)];return _pn_}
      catch(_po_)
       {_po_ = caml_wrap_exception(_po_);
        if(_po_[1] === Invalid_argument)return 0;
        throw _po_}}
    function int_of_string_opt$0(x)
     {try
       {var _pl_=[0,caml_int_of_string(x)];return _pl_}
      catch(_pm_)
       {_pm_ = caml_wrap_exception(_pm_);
        if(_pm_[1] === Failure)return 0;
        throw _pm_}}
    function float_of_string_opt(x)
     {try
       {var _pj_=[0,caml_float_of_string(x)];return _pj_}
      catch(_pk_)
       {_pk_ = caml_wrap_exception(_pk_);
        if(_pk_[1] === Failure)return 0;
        throw _pk_}}
    function parse_and_expand_argv_dynamic_
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$2(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[1 + initpos]
           :cst$54;
        switch(error[0])
         {case 0:
           var _pi_=error[1];
           if
            (caml_string_notequal(_pi_,cst_help$3)
             &&
             caml_string_notequal(_pi_,cst_help$4))
            caml_call2(bprintf(b,_a5_),progname,_pi_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a8_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a9_),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a__),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a6_) && ! caml_equal(error,_a7_))
         return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var
             _o9_=current[1],
             s=caml_check_bound(argv[1],_o9_)[1 + _o9_],
             switch$0=0;
            if(1 <= caml_ml_string_length(s) && 45 === caml_string_get(s,0))
             {try
               {var
                 follow$1=0,
                 _o$_=assoc3(s,speclist[1]),
                 follow$0=follow$1,
                 action=_o$_}
              catch(_pg_)
               {_pg_ = caml_wrap_exception(_pg_);
                if(_pg_ !== Not_found)throw _pg_;
                try
                 {var
                   match=split$0(s),
                   arg=match[2],
                   keyword=match[1],
                   follow=[0,arg],
                   _o__=assoc3(keyword,speclist[1])}
                catch(_ph_)
                 {_ph_ = caml_wrap_exception(_ph_);
                  if(_ph_ === Not_found)throw [0,Stop,[0,s]];
                  throw _ph_;
                  var _pa_=_ph_}
                var follow$0=follow,action=_o__,_pb_=_pg_}
              var
               no_arg$0=
                function(s,follow)
                 {function no_arg(param)
                   {if(follow)
                     {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                    return 0}
                  return no_arg},
               no_arg=no_arg$0(s,follow$0),
               get_arg$0=
                function(s,follow)
                 {function get_arg(param)
                   {if(follow){var arg=follow[1];return arg}
                    if((current[1] + 1 | 0) < argv[1].length - 1)
                     {var _pf_=current[1] + 1 | 0;
                      return caml_check_bound(argv[1],_pf_)[1 + _pf_]}
                    throw [0,Stop,[2,s]]}
                  return get_arg},
               get_arg=get_arg$0(s,follow$0),
               consume_arg$0=
                function(follow)
                 {function consume_arg(param)
                   {return follow?0:(current[1]++,0)}
                  return consume_arg},
               consume_arg=consume_arg$0(follow$0),
               treat_action$0=
                function(s,no_arg,get_arg,consume_arg)
                 {function treat_action(param)
                   {switch(param[0])
                     {case 0:var f=param[1];no_arg(0);return caml_call1(f,0);
                      case 1:
                       var
                        f$0=param[1],
                        arg=get_arg(0),
                        match=bool_of_string_opt$0(arg);
                       if(match)
                        {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg,cst_a_boolean]];
                      case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                      case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                      case 4:
                       var f$1=param[1],arg$0=get_arg(0);
                       caml_call1(f$1,arg$0);
                       return consume_arg(0);
                      case 5:
                       var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                      case 6:
                       var
                        f$2=param[1],
                        arg$1=get_arg(0),
                        match$0=int_of_string_opt$0(arg$1);
                       if(match$0)
                        {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                      case 7:
                       var
                        r$2=param[1],
                        arg$2=get_arg(0),
                        match$1=int_of_string_opt$0(arg$2);
                       if(match$1)
                        {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                      case 8:
                       var
                        f$3=param[1],
                        arg$3=get_arg(0),
                        match$2=float_of_string_opt(arg$3);
                       if(match$2)
                        {var x$1=match$2[1];
                         caml_call1(f$3,x$1);
                         return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$3,cst_a_float]];
                      case 9:
                       var
                        r$3=param[1],
                        arg$4=get_arg(0),
                        match$3=float_of_string_opt(arg$4);
                       if(match$3)
                        {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                      case 10:
                       var specs=param[1];
                       no_arg(0);
                       return iter$2(treat_action,specs);
                      case 11:
                       var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                       if(mem(arg$5,symb))
                        {caml_call1(f$4,arg$5);return consume_arg(0)}
                       throw [0,
                              Stop,
                              [1,
                               s,
                               arg$5,
                               symbol(cst_one_of,make_symlist(cst$57,cst$56,cst$55,symb))]];
                      case 12:
                       var f$5=param[1];
                       no_arg(0);
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _pc_=current[1] + 1 | 0;
                           caml_call1(f$5,caml_check_bound(argv[1],_pc_)[1 + _pc_]);
                           consume_arg(0);
                           continue}
                         return 0}
                      case 13:
                       var f$6=param[1];
                       no_arg(0);
                       var acc=[0,0];
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _pe_=current[1] + 1 | 0,_pd_=acc[1];
                           acc[1] = [0,caml_check_bound(argv[1],_pe_)[1 + _pe_],_pd_];
                           consume_arg(0);
                           continue}
                         return caml_call1(f$6,rev(acc[1]))}
                      default:
                       var f$7=param[1];
                       if(1 - allow_expand)
                        throw [0,Invalid_argument,cst_Arg_Expand_is_is_only_allo];
                       var arg$6=get_arg(0),newarg=caml_call1(f$7,arg$6);
                       consume_arg(0);
                       var
                        before=sub$1(argv[1],0,current[1] + 1 | 0),
                        after=
                         sub$1
                          (argv[1],
                           current[1] + 1 | 0,
                           (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                       argv[1]
                       =
                       caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                       return 0}}
                  return treat_action},
               treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
              treat_action(action);
              switch$0 = 1}
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn$0)
           {exn$0 = caml_wrap_exception(exn$0);
            if(exn$0[1] === Bad){var m=exn$0[2];throw convert_error([3,m])}
            if(exn$0[1] === Stop){var e=exn$0[2];throw convert_error(e)}
            throw exn$0;
            var exn=exn$0}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _o8_=parse_argv(0,caml_sys_argv(0),l,f,msg);return _o8_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a$_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_ba_),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _o7_=parse_argv_dynamic(0,caml_sys_argv(0),l,f,msg);return _o7_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bb_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bc_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,caml_sys_argv(0)],
         spec=[0,l],
         current$0=[0,current[1]],
         _o6_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _o6_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bd_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_be_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_o4_)
       {_o4_ = caml_wrap_exception(_o4_);
        if(_o4_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_o5_)
           {_o5_ = caml_wrap_exception(_o5_);
            if(_o5_ === Not_found)return len;
            throw _o5_}
          return loop(n + 1 | 0)}
        throw _o4_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max(cur,caml_ml_string_length(kwd))
              :max(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$5
              (function(c)
                {if(9 === c && ! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left$0(max_arg_len,0,completed),
       len$0=min(len,limit);
      return map$3
              (function(ksd)
                {var _o2_=ksd[1],_o3_=ksd[2];
                 if(caml_string_notequal(ksd[3],cst$58))
                  {if(11 === _o3_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$1(max(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _o2_,
                             _o3_,
                             symbol(cst$59,symbol(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    spec=ksd[2],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_o2_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$1(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_o2_,spec,symbol(prefix,symbol(spaces,suffix))]}
                   return [0,_o2_,spec,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$2(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s),switch$0=0;
          if(0 < len && 13 === caml_string_get(s,len - 1 | 0))
           {var _o1_=sub$0(s,0,len - 1 | 0);switch$0 = 1}
          if(! switch$0)var _o1_=s;
          var word=_o1_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      try
       {for(;;)
         {var c=caml_ml_input_char(ic);
          if(c === sep)stash(0);else add_char(buf,c);
          continue}}
      catch(_o0_)
       {_o0_ = caml_wrap_exception(_o0_);
        if(_o0_ === End_of_file)
         {if(0 < buf[2])stash(0);
          caml_ml_close_channel(ic);
          return of_list(rev(words[1]))}
        throw _o0_}}
    var _bf_=10,_bg_=1;
    function read_arg(_oZ_){return read_aux(_bg_,_bf_,_oZ_)}
    var _bh_=0,_bi_=0;
    function read_arg0(_oY_){return read_aux(_bi_,_bh_,_oY_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$5(function(s){return caml_call2(fprintf(oc,_bj_),s,sep)},args);
      return close_out(oc)}
    var _bk_=10;
    function write_arg(_oW_,_oX_){return write_aux(_bk_,_oW_,_oX_)}
    var _bl_=0;
    function write_arg0(_oU_,_oV_){return write_aux(_bl_,_oU_,_oV_)}
    var
     Stdlib_arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(792,Stdlib_arg,"Stdlib__arg");
    var
     Stdlib_atomic=
      [0,make,get,set,exchange,compare_and_set,fetch_and_add,incr,decr];
    caml_register_global(793,Stdlib_atomic,"Stdlib__atomic");
    var printers=[0,0];
    function field(x,i)
     {var f=x[1 + i];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bm_),f)
                :caml_obj_tag(f) === 253?to_string(f):cst$60
              :caml_call1(sprintf(_bn_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$61;
      var _oS_=other_fields(x,i + 1 | 0),_oT_=field(x,i);
      return caml_call2(sprintf(_bo_),_oT_,_oS_)}
    function use_printers(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try
             {var switch$0=0,val=caml_call1(hd,x);switch$0 = 1}
            catch(_oR_){}
            if(switch$0 && val){var s=val[1];return [0,s]}
            var param$0=tl;
            continue}
          return 0}}
      return conv(printers[1])}
    function to_string_default(x)
     {if(x === Out_of_memory)return cst_Out_of_memory;
      if(x === Stack_overflow)return cst_Stack_overflow;
      if(x[1] === Match_failure)
       {var match$0=x[2],char$0=match$0[3],line=match$0[2],file=match$0[1];
        return caml_call5
                (sprintf(locfmt),
                 file,
                 line,
                 char$0,
                 char$0 + 5 | 0,
                 cst_Pattern_matching_failed)}
      if(x[1] === Assert_failure)
       {var
         match$1=x[2],
         char$1=match$1[3],
         line$0=match$1[2],
         file$0=match$1[1];
        return caml_call5
                (sprintf(locfmt),
                 file$0,
                 line$0,
                 char$1,
                 char$1 + 6 | 0,
                 cst_Assertion_failed)}
      if(x[1] === Undefined_recursive_module)
       {var
         match$2=x[2],
         char$2=match$2[3],
         line$1=match$2[2],
         file$1=match$2[1];
        return caml_call5
                (sprintf(locfmt),
                 file$1,
                 line$1,
                 char$2,
                 char$2 + 6 | 0,
                 cst_Undefined_recursive_module)}
      if(0 === caml_obj_tag(x))
       {var constructor=x[1][1],match=x.length - 1;
        if(2 < match >>> 0)
         var
          _oN_=other_fields(x,2),
          _oO_=field(x,1),
          _oQ_=caml_call2(sprintf(_bp_),_oO_,_oN_);
        else
         switch(match)
          {case 0:var _oQ_=cst$62;break;
           case 1:var _oQ_=cst$63;break;
           default:var _oP_=field(x,1),_oQ_=caml_call1(sprintf(_bq_),_oP_)}
        return symbol(constructor,_oQ_)}
      return x[1]}
    function to_string$7(e)
     {var match=use_printers(e);
      if(match){var s=match[1];return s}
      return to_string_default(e)}
    function print(fct,arg)
     {try
       {var _oM_=caml_call1(fct,arg);return _oM_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _oL_=to_string$7(x);
        caml_call1(eprintf(_br_),_oL_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _oK_=caml_call1(fct,arg);return _oK_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _oJ_=to_string$7(x);
        caml_call1(eprintf(_bs_),_oJ_);
        return exit(2)}}
    function raw_backtrace_entries(bt){return bt}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos?cst_Raised_by_primitive_operat:cst_Called_from}
      if(0 === slot[0])
       {var
         _oB_=slot[5],
         _oC_=slot[4],
         _oD_=slot[3],
         _oE_=slot[6]?cst_inlined:cst$64,
         _oF_=slot[2],
         _oG_=slot[7],
         _oH_=info(slot[1]);
        return [0,
                caml_call7(sprintf(_bt_),_oH_,_oG_,_oF_,_oE_,_oD_,_oC_,_oB_)]}
      if(slot[1])return 0;
      var _oI_=info(0);
      return [0,caml_call1(sprintf(_bu_),_oI_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_oz_=a.length - 1 - 1 | 0,_oy_=0;
        if(! (_oz_ < 0))
         {var i=_oy_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bv_),str)}
            var _oA_=i + 1 | 0;
            if(_oz_ !== i){var i=_oA_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bw_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtra(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$2(1024),_ow_=a.length - 1 - 1 | 0,_ov_=0;
        if(! (_ow_ < 0))
         {var i=_ov_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(bprintf(b,_bx_),str)}
            var _ox_=i + 1 | 0;
            if(_ow_ !== i){var i=_ox_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slot_defname(param)
     {if(0 === param[0] && caml_string_notequal(param[7],cst$65))
       return [0,param[7]];
      return 0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _ou_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[1 + i],
             _ot_=0 === param[0]?1:0;
            if(! _ot_){var i$0=i - 1 | 0,i=i$0;continue}
            var _ou_=_ot_}
          return _ou_?[0,backtrace]:0}}
      return 0}
    function backtrace_slots_of_raw_entry(entry)
     {return backtrace_slots([0,entry])}
    function raw_backtrace_length(bt){return bt.length - 1}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtra(0))}
    function register_printer(fn)
     {for(;;)
       {var
         old_printers=printers[1],
         new_printers=[0,fn,old_printers],
         success=compare_and_set(printers,old_printers,new_printers),
         _os_=1 - success;
        if(_os_)continue;
        return _os_}}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    var errors=_by_.slice();
    function default_uncaught_exception_han(exn,raw_backtrace)
     {var _oq_=to_string$7(exn);
      caml_call1(eprintf(_bz_),_oq_);
      print_raw_backtrace(stderr,raw_backtrace);
      var status=runtime.caml_ml_debug_info_status(0);
      if(status < 0)
       {var _or_=abs(status);
        prerr_endline(caml_check_bound(errors,_or_)[1 + _or_])}
      return caml_ml_flush(stderr)}
    var uncaught_exception_handler=[0,default_uncaught_exception_han];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = fn;return 0}
    function _bA_(_op_){return runtime.caml_raw_backtrace_next_slot(_op_)}
    function _bB_(_oo_){return runtime.caml_convert_raw_backtrace_slot(_oo_)}
    function _bC_(_on_,_om_)
     {return runtime.caml_raw_backtrace_slot(_on_,_om_)}
    var
     _bD_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       backtrace_slot_defname,
       format_backtrace_slot];
    function _bE_(_ol_){return caml_get_exception_raw_backtra(_ol_)}
    function _bF_(_ok_){return runtime.caml_backtrace_status(_ok_)}
    var
     Stdlib_printexc=
      [0,
       to_string$7,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_oj_){return runtime.caml_record_backtrace(_oj_)},
       _bF_,
       register_printer,
       use_printers,
       raw_backtrace_entries,
       _bE_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       backtrace_slots_of_raw_entry,
       _bD_,
       raw_backtrace_length,
       _bC_,
       _bB_,
       _bA_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(794,Stdlib_printexc,"Stdlib__printexc");
    function const$0(c,param){return c}
    function flip(f,x,y){return caml_call2(f,y,x)}
    function negate(p,v){return 1 - caml_call1(p,v)}
    var
     Finally_raised=
      [248,cst_Stdlib_Fun_Finally_raised,caml_fresh_oo_id(0)];
    register_printer
     (function(param)
       {if(param[1] === Finally_raised)
         {var exn=param[2];
          return [0,symbol(cst_Fun_Finally_raised,to_string$7(exn))]}
        return 0});
    function protect(finally$0,work)
     {function finally_no_exn(param)
       {try
         {var _oi_=caml_call1(finally$0,0);return _oi_}
        catch(e)
         {e = caml_wrap_exception(e);
          var bt=caml_get_exception_raw_backtra(0),exn=[0,Finally_raised,e];
          caml_restore_raw_backtrace(exn,bt);
          throw exn}}
      try
       {var result=caml_call1(work,0)}
      catch(work_exn)
       {work_exn = caml_wrap_exception(work_exn);
        var work_bt=caml_get_exception_raw_backtra(0);
        finally_no_exn(0);
        caml_restore_raw_backtrace(work_exn,work_bt);
        throw work_exn}
      finally_no_exn(0);
      return result}
    var Stdlib_fun=[0,const$0,flip,negate,protect,Finally_raised];
    caml_register_global(795,Stdlib_fun,"Stdlib__fun");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_n2_=st[4];
      caml_call1(fprintf(c,_bG_),_n2_);
      var _n3_=st[5];
      caml_call1(fprintf(c,_bH_),_n3_);
      var _n4_=st[14];
      caml_call1(fprintf(c,_bI_),_n4_);
      var _n5_=st[17];
      caml_call1(fprintf(c,_bJ_),_n5_);
      fprintf(c,_bK_);
      var
       _n6_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bL_),_n6_)),
       _n7_=st[1];
      caml_call2(fprintf(c,_bM_),l1,_n7_);
      var _n8_=st[2];
      caml_call2(fprintf(c,_bN_),l1,_n8_);
      var _n9_=st[3];
      caml_call2(fprintf(c,_bO_),l1,_n9_);
      fprintf(c,_bP_);
      var
       _n__=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bQ_),_n__)),
       _n$_=st[15];
      caml_call2(fprintf(c,_bR_),l2,_n$_);
      var _oa_=st[6];
      caml_call2(fprintf(c,_bS_),l2,_oa_);
      var _ob_=st[8];
      caml_call2(fprintf(c,_bT_),l2,_ob_);
      var _oc_=st[10];
      caml_call2(fprintf(c,_bU_),l2,_oc_);
      var _od_=st[12];
      caml_call2(fprintf(c,_bV_),l2,_od_);
      var _oe_=st[13];
      caml_call2(fprintf(c,_bW_),l2,_oe_);
      fprintf(c,_bX_);
      var _of_=st[9];
      caml_call1(fprintf(c,_bY_),_of_);
      var _og_=st[11];
      caml_call1(fprintf(c,_bZ_),_og_);
      var _oh_=st[7];
      return caml_call1(fprintf(c,_b0_),_oh_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _b1_(param){return 0}
    function _b2_(param){return 0}
    function _b3_(param){return 0}
    function _b4_(param){return 0}
    var null_tracker=[0,function(param){return 0},_b4_,_b3_,_b2_,_b1_];
    function start(sampling_rate,opt,tracker)
     {if(opt)
       var sth=opt[1],callstack_size=sth;
      else
       var callstack_size=max_int;
      return runtime.caml_memprof_start(sampling_rate,callstack_size,tracker)}
    var _b5_=[0,null_tracker,start,runtime.caml_memprof_stop];
    function _b6_(_n1_){return runtime.caml_final_release(_n1_)}
    function _b7_(_n0_,_nZ_)
     {return runtime.caml_final_register_called_without_value(_n0_,_nZ_)}
    var
     Stdlib_gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_nY_,_nX_){return runtime.caml_final_register(_nY_,_nX_)},
       _b7_,
       _b6_,
       create_alarm,
       delete_alarm,
       _b5_];
    caml_register_global(796,Stdlib_gc,"Stdlib__gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(caml_string_of_bytes(b))}
    function substring(str,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(str) - len | 0) < ofs))
       return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len)
     {return substring(caml_string_of_bytes(b),ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _nW_=10 <= n?87:48;return n + _nW_ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _nV_=i + 1 | 0;
        if(15 !== i){var i=_nV_;continue}
        return caml_string_of_bytes(result)}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         {var switcher=c - 48 | 0;if(! (9 < switcher >>> 0))return c - 48 | 0}
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_nT_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _nT_ | 0));
        var _nU_=i + 1 | 0;
        if(15 !== i){var i=_nU_;continue}
        return caml_string_of_bytes(result)}}
    var
     Stdlib_digest=
      [0,
       compare$7,
       equal$7,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(797,Stdlib_digest,"Stdlib__digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[1 + i$0] = i$0;
        var _nS_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_nS_;continue}
        var accu=[0,cst_x$1],_nO_=54 + max(55,l) | 0,_nN_=0;
        if(! (_nO_ < 0))
         {var i=_nN_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[1 + k];
            accu[1] = string(symbol(accu[1],caml_string_of_jsbytes("" + x)));
            var
             _nP_=accu[1],
             _nJ_=caml_string_get(_nP_,3) << 24,
             _nK_=caml_string_get(_nP_,2) << 16,
             _nL_=caml_string_get(_nP_,1) << 8,
             _nM_=((caml_string_get(_nP_,0) + _nL_ | 0) + _nK_ | 0) + _nJ_ | 0,
             _nQ_=(caml_check_bound(s[1],j)[1 + j] ^ _nM_) & 1073741823;
            caml_check_bound(s[1],j)[1 + j] = _nQ_;
            var _nR_=i + 1 | 0;
            if(_nO_ !== i){var i=_nR_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$3(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$3(caml_sys_random_seed(0))}
    function copy$5(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _nG_=s[2],
       curval=caml_check_bound(s[1],_nG_)[1 + _nG_],
       _nH_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_nH_)[1 + _nH_]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _nI_=s[2];
      caml_check_bound(s[1],_nI_)[1 + _nI_] = newval30;
      return newval30}
    function int$0(s,bound)
     {if(! (1073741823 < bound) && 0 < bound)
       for(;;)
        {var r=bits(s),v=caml_mod(r,bound);
         if(((1073741823 - bound | 0) + 1 | 0) < (r - v | 0))continue;
         return v}
      return invalid_arg(cst_Random_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b9_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$2,bound),_b8_)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824. + r2) / 1073741824. * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_b__.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$4(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$5(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _b$_=
      [0,
       make$3,
       make_self_init,
       copy$5,
       bits,
       int$0,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Stdlib_random=
      [0,
       init$4,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _b$_,
       get_state,
       set_state];
    caml_register_global(798,Stdlib_random,"Stdlib__random");
    function ongoing_traversal(h)
     {var _nE_=h.length - 1 < 4?1:0,_nF_=_nE_ || (h[4] < 0?1:0);return _nF_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cU_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cU_}
    catch(_nC_)
     {_nC_ = caml_wrap_exception(_nC_);
      if(_nC_ !== Not_found)throw _nC_;
      try
       {var _cT_=caml_sys_getenv(cst_CAMLRUNPARAM),_ca_=_cT_}
      catch(_nD_)
       {_nD_ = caml_wrap_exception(_nD_);
        if(_nD_ !== Not_found)throw _nD_;
        var _ca_=cst$66}
      var params=_ca_}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_nB_){return caml_call1(_b$_[2],0)}];
    function power_2_above(x,n)
     {var x$0=x;
      for(;;)
       {if(n <= x$0)return x$0;
        if(max_array_length < (x$0 * 2 | 0))return x$0;
        var x$1=x$0 * 2 | 0,x$0=x$1;
        continue}}
    function create$3(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var s=power_2_above(16,initial_size);
      if(random)
       var
        _nz_=caml_obj_tag(prng),
        _nA_=250 === _nz_?prng[1]:246 === _nz_?force_lazy_block(prng):prng,
        seed=caml_call1(_b$_[4],_nA_);
      else
       var seed=0;
      return [0,0,caml_make_vect(s,0),seed,s]}
    function clear$2(h)
     {var _ny_=0 < h[1]?1:0;
      return _ny_?(h[1] = 0,fill$0(h[2],0,h[2].length - 1,0)):_ny_}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1 && len !== abs(h[4]))
       {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_cb_]}
          return prec$0}}
      return 0}
    function copy$6(init)
     {var _nv_=init[4],_nw_=init[3],_nx_=map$6(copy_bucketlist,init[2]);
      return [0,init[1],_nx_,_nw_,_nv_]}
    function length$4(h){return h[1]}
    function insert_all_buckets(indexfun,inplace,odata,ndata)
     {var
       nsize=ndata.length - 1,
       ndata_tail=caml_make_vect(nsize,0),
       _np_=odata.length - 1 - 1 | 0,
       _no_=0;
      if(! (_np_ < 0))
       {var i$0=_no_;
        a:
        for(;;)
         {var cell$1=caml_check_bound(odata,i$0)[1 + i$0],cell=cell$1;
          for(;;)
           {if(cell)
             {var
               key=cell[1],
               data=cell[2],
               next=cell[3],
               cell$0=inplace?cell:[0,key,data,0],
               nidx=caml_call1(indexfun,key),
               match=caml_check_bound(ndata_tail,nidx)[1 + nidx];
              if(match)
               match[3] = cell$0;
              else
               caml_check_bound(ndata,nidx)[1 + nidx] = cell$0;
              caml_check_bound(ndata_tail,nidx)[1 + nidx] = cell$0;
              var cell=next;
              continue}
            var _nu_=i$0 + 1 | 0;
            if(_np_ !== i$0){var i$0=_nu_;continue a}
            break}
          break}}
      if(inplace)
       {var _nr_=nsize - 1 | 0,_nq_=0;
        if(! (_nr_ < 0))
         {var i=_nq_;
          for(;;)
           {var match$0=caml_check_bound(ndata_tail,i)[1 + i];
            if(match$0)match$0[3] = 0;
            var _nt_=i + 1 | 0;
            if(_nr_ !== i){var i=_nt_;continue}
            break}}
        var _ns_=0}
      else
       var _ns_=inplace;
      return _ns_}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _nn_=nsize < max_array_length?1:0;
      if(_nn_)
       {var ndata=caml_make_vect(nsize,0),inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        return insert_all_buckets(caml_call1(indexfun,h),inplace,odata,ndata)}
      return _nn_}
    function iter$10(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_nj_=d.length - 1 - 1 | 0,_ni_=0;
        if(! (_nj_ < 0))
         {var i=_ni_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[1 + i]);
            var _nm_=i + 1 | 0;
            if(_nj_ !== i){var i=_nm_;continue}
            break}}
        var _nk_=1 - old_trav,_nl_=_nk_?flip_ongoing_traversal(h):_nk_;
        return _nl_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[1 + i] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0
                ?(prec$0[3] = 0,0)
                :(caml_check_bound(h[2],i)[1 + i] = 0,0)}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _ne_=d.length - 1 - 1 | 0,_nd_=0;
        if(! (_ne_ < 0))
         {var i=_nd_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[1 + i]);
            var _nh_=i + 1 | 0;
            if(_ne_ !== i){var i=_nh_;continue}
            break}}
        var _nf_=1 - old_trav,_ng_=_nf_?flip_ongoing_traversal(h):_nf_;
        return _ng_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$4(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_m$_=d.length - 1 - 1 | 0,_m__=0;
        if(! (_m$_ < 0))
         {var i=_m__;
          for(;;)
           {var _nb_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[1 + i],_nb_);
            var _nc_=i + 1 | 0;
            if(_m$_ !== i){var i=_nc_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _na_=accu[1];
        return _na_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _m6_=h[2],
       _m7_=0,
       mbl=
        fold_left$1(function(m,b){return max(m,bucket_length(0,b))},_m7_,_m6_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _m8_=h[2];
      iter$5
       (function(b)
         {var
           l=bucket_length(0,b),
           _m9_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
          caml_check_bound(histo,l)[1 + l] = _m9_;
          return 0},
        _m8_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function to_seq$9(tbl)
     {var tbl_data=tbl[2];
      function aux(i,buck,param)
       {var i$0=i,buck$0=buck;
        for(;;)
         {if(buck$0)
           {var key=buck$0[1],data=buck$0[2],next=buck$0[3];
            return [0,[0,key,data],function(_m5_){return aux(i$0,next,_m5_)}]}
          if(i$0 === tbl_data.length - 1)return 0;
          var
           buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           buck$0=buck$1;
          continue}}
      var _m2_=0,_m3_=0;
      return function(_m4_){return aux(_m3_,_m2_,_m4_)}}
    function to_seq_keys(m)
     {var _mY_=to_seq$9(m);
      function _mZ_(_m1_){return _m1_[1]}
      return function(_m0_){return map(_mZ_,_mY_,_m0_)}}
    function to_seq_values(m)
     {var _mU_=to_seq$9(m);
      function _mV_(_mX_){return _mX_[2]}
      return function(_mW_){return map(_mV_,_mU_,_mW_)}}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _mT_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _mT_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _mS_=h[2].length - 1 << 1 < h[1]?1:0;
        return _mS_?resize$0(key_index,h):_mS_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[1 + i],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :(caml_check_bound(h[2],i)[1 + i] = next,0)}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _mR_=key_index(h,key),match=caml_check_bound(h[2],_mR_)[1 + _mR_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _mQ_=key_index(h,key),match=caml_check_bound(h[2],_mQ_)[1 + _mQ_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _mP_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_mP_)[1 + _mP_])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[1 + i],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _mM_=0}
          else
           var _mM_=1;
          if(_mM_)
           {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _mN_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_mN_)return resize$0(key_index,h);
            var _mO_=_mN_}
          else
           var _mO_=_mM_;
          return _mO_}}
      function mem(h,key)
       {var
         _mL_=key_index(h,key),
         param$0=caml_check_bound(h[2],_mL_)[1 + _mL_],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_mK_=caml_call2(H[1],k,key);
            if(_mK_)return _mK_;
            var param=next;
            continue}
          return 0}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create$3,
              clear$2,
              reset$0,
              copy$6,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$10,
              filter_map_inplace,
              fold$4,
              length$4,
              stats,
              to_seq$9,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function Make$0(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       _mJ_=include[1];
      function create(sz){return caml_call2(_mJ_,_cc_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function hash$1(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function key_index(h,key)
     {return 4 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :invalid_arg(cst_Hashtbl_unsupported_hash_t)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
      caml_check_bound(h[2],i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _mI_=h[2].length - 1 << 1 < h[1]?1:0;
      return _mI_?resize$0(key_index,h):_mI_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[1 + i],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :(caml_check_bound(h[2],i)[1 + i] = next,0)}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _mH_=key_index(h,key),match=caml_check_bound(h[2],_mH_)[1 + _mH_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$0(h,key)
     {var _mG_=key_index(h,key),match=caml_check_bound(h[2],_mG_)[1 + _mG_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _mF_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_mF_)[1 + _mF_])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[1 + i],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _mC_=0}
        else
         var _mC_=1;
        if(_mC_)
         {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _mD_=h[2].length - 1 << 1 < h[1]?1:0;
          if(_mD_)return resize$0(key_index,h);
          var _mE_=_mD_}
        else
         var _mE_=_mC_;
        return _mE_}}
    function mem$2(h,key)
     {var
       _mB_=key_index(h,key),
       param$0=caml_check_bound(h[2],_mB_)[1 + _mB_],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_mA_=0 === caml_compare(k,key)?1:0;
          if(_mA_)return _mA_;
          var param=next;
          continue}
        return 0}}
    function add_seq$2(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return add$0(tbl,k,v)},
               i)}
    function replace_seq(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return replace(tbl,k,v)},
               i)}
    function of_seq$7(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
    function rebuild(opt,h)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var s=power_2_above(16,h[2].length - 1);
      if(random)
       var
        _mt_=caml_obj_tag(prng),
        _mu_=250 === _mt_?prng[1]:246 === _mt_?force_lazy_block(prng):prng,
        seed=caml_call1(_b$_[4],_mu_);
      else
       var seed=4 <= h.length - 1?h[3]:0;
      var
       _mv_=4 <= h.length - 1?h[4]:s,
       h$0=[0,h[1],caml_make_vect(s,0),seed,_mv_],
       _mw_=h$0[2],
       _mx_=h[2],
       _my_=0;
      insert_all_buckets
       (function(_mz_){return key_index(h$0,_mz_)},_my_,_mx_,_mw_);
      return h$0}
    var
     Stdlib_hashtbl=
      [0,
       create$3,
       clear$2,
       reset$0,
       copy$6,
       add$0,
       find$0,
       find_opt$0,
       find_all$0,
       mem$2,
       remove,
       replace,
       iter$10,
       filter_map_inplace,
       fold$4,
       length$4,
       randomize,
       is_randomized,
       rebuild,
       stats,
       to_seq$9,
       to_seq_keys,
       to_seq_values,
       add_seq$2,
       replace_seq,
       of_seq$7,
       Make$0,
       MakeSeeded,
       hash$1,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(799,Stdlib_hashtbl,"Stdlib__hashtbl");
    function weak_create(l)
     {var _mr_=0 <= l?1:0,_ms_=_mr_?l <= _t_[15]?1:0:_mr_;
      if(1 - _ms_)invalid_arg(cst_Weak_create);
      return runtime.caml_weak_create(l)}
    function length$5(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset$0(e,o,msg)
     {var _mo_=0 <= o?1:0,_mp_=_mo_?o < length$5(e)?1:0:_mo_,_mq_=1 - _mp_;
      return _mq_?invalid_arg(msg):_mq_}
    function set$0(e,o,x)
     {raise_if_invalid_offset$0(e,o,cst_Weak_set);
      if(x){var x$0=x[1];return caml_ephe_set_key(e,o,x$0)}
      return caml_ephe_unset_key(e,o)}
    function get$1(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get);
      return runtime.caml_weak_get(e,o)}
    function get_copy(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get_copy);
      return runtime.caml_weak_get_copy(e,o)}
    function check$0(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_check);
      return runtime.caml_weak_check(e,o)}
    function blit$4(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$5(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$5(e2) - l | 0) < o2))
       {var
         _mm_=0 !== l?1:0,
         _mn_=_mm_?runtime.caml_weak_blit(e1,o1,e2,o2,l):_mm_;
        return _mn_}
      return invalid_arg(cst_Weak_blit)}
    function fill$2(ar,ofs,len,x)
     {if(0 <= ofs && 0 <= len && ! ((length$5(ar) - len | 0) < ofs))
       {var _mk_=(ofs + len | 0) - 1 | 0;
        if(! (_mk_ < ofs))
         {var i=ofs;
          for(;;)
           {set$0(ar,i,x);
            var _ml_=i + 1 | 0;
            if(_mk_ !== i){var i=_ml_;continue}
            break}}
        return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$1(H)
     {var emptybucket=weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _mi_=t[1].length - 1 - 1 | 0,_mh_=0;
        if(! (_mi_ < 0))
         {var i=_mh_;
          for(;;)
           {caml_check_bound(t[1],i)[1 + i] = emptybucket;
            caml_check_bound(t[2],i)[1 + i] = [0];
            var _mj_=i + 1 | 0;
            if(_mi_ !== i){var i=_mj_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _mg_=t[1],i=0;
        return fold_right$0
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=get$1(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _mg_,
                 init)}
      function iter(f,t)
       {var _mf_=t[1],i=0;
        return iter$5
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=get$1(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _mf_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _me_=check$0(b,i$0)?1:0,
           accu$1=accu$0 + _me_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _l$_=0,_ma_=t[1],_mb_=0;
        return fold_right$0
                (function(_mc_,_md_){return count_bucket(_mb_,_mc_,_md_)},
                 _ma_,
                 _l$_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)failwith(cst_Weak_Make_hash_bucket_cann);
            var
             newbucket$0=weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            blit$4(bucket$0,0,newbucket$0,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket$0,sz,d);
            caml_check_bound(newhashes,sz)[1 + sz] = h;
            caml_check_bound(t[1],index)[1 + index] = newbucket$0;
            caml_check_bound(t[2],index)[1 + index] = newhashes;
            var _l7_=sz <= t[3]?1:0,_l8_=_l7_?t[3] < newsz?1:0:_l7_;
            if(_l8_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _lX_=t[5],
                 bucket=caml_check_bound(t[1],_lX_)[1 + _lX_],
                 _lY_=t[5],
                 hbucket=caml_check_bound(t[2],_lY_)[1 + _lY_],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(check$0(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(check$0(bucket,j))
                       {blit$4(bucket,j,bucket,i$0,1);
                        var _lZ_=caml_check_bound(hbucket,j)[1 + j];
                        caml_check_bound(hbucket,i$0)[1 + i$0] = _lZ_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _l0_=t[5];
                      caml_check_bound(t[1],_l0_)[1 + _l0_] = emptybucket;
                      var _l1_=t[5];
                      caml_check_bound(t[2],_l1_)[1 + _l1_] = [0]}
                    else
                     {var newbucket=weak_create(prev_len);
                      blit$4(bucket,0,newbucket,0,prev_len);
                      var _l4_=t[5];
                      caml_check_bound(t[1],_l4_)[1 + _l4_] = newbucket;
                      var _l5_=sub$1(hbucket,0,prev_len),_l6_=t[5];
                      caml_check_bound(t[2],_l6_)[1 + _l6_] = _l5_}
                    var _l2_=t[3] < n?1:0,_l3_=_l2_?prev_len <= t[3]?1:0:_l2_;
                    if(_l3_)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _l__=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_l__;continue}
                break}}
            var _l9_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_l9_)
             {var
               n$0=t[1].length - 1,
               newlen=min(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_lW_=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=check$0(ob,i$0);
                      if(match)
                       {var
                         oh=caml_check_bound(t[2],j)[1 + j],
                         setter$0=
                          function(i)
                           {function setter(nb,ni,param){return blit$4(ob,i,nb,ni,1)}
                            return setter},
                         setter=setter$0(i$0),
                         h=caml_check_bound(oh,i$0)[1 + i$0];
                        add_aux(newt,setter,0,h,get_index(newt,h));
                        var i$1=i$0 + 1 | 0,i$0=i$1;
                        continue}
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _lW_);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _l9_}
          if(check$0(bucket$0,i$3)){var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          caml_check_bound(hashes,i$3)[1 + i$3] = h;
          return 0}}
      function add(t,d)
       {var h=caml_call1(H[2],d);
        return add_aux(t,set$0,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$1(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,
                 d,
                 function(h,index){add_aux(t,set$0,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=get$1(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _lV_=0;
        return find_shadow(t,d,function(w,i){return set$0(w,i,0)},_lV_)}
      function mem(t,d)
       {var _lU_=0;return find_shadow(t,d,function(w,i){return 1},_lU_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$1(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$6(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _lM_=0,
         totlen=
          fold_left$1(function(_lT_,_lS_){return _lT_ + _lS_ | 0},_lM_,lens),
         _lN_=len - 1 | 0,
         _lP_=len / 2 | 0,
         _lO_=caml_check_bound(lens,_lN_)[1 + _lN_],
         _lQ_=caml_check_bound(lens,_lP_)[1 + _lP_],
         _lR_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_lR_,_lQ_,_lO_]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Stdlib_weak=
      [0,
       weak_create,
       length$5,
       set$0,
       get$1,
       get_copy,
       check$0,
       fill$2,
       blit$4,
       Make$1];
    caml_register_global(800,Stdlib_weak,"Stdlib__weak");
    function id$0(x){return x}
    var
     String_tag=[248,cst_Stdlib_Format_String_tag,caml_fresh_oo_id(0)],
     size=0,
     unknown=-1;
    function pp_enqueue(state,token)
     {state[13] = state[13] + token[3] | 0;return add(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function format_pp_text(state,size,text)
     {state[9] = state[9] - size | 0;
      pp_output_string(state,text);
      state[11] = 0;
      return 0}
    function format_string(state,s)
     {var _lL_=caml_string_notequal(s,cst$67);
      return _lL_?format_pp_text(state,caml_ml_string_length(s),s):_lL_}
    function break_new_line(state,param,width)
     {var after=param[3],offset=param[2],before=param[1];
      format_string(state,before);
      pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      caml_call1(state[21],state[10]);
      return format_string(state,after)}
    function break_line(state,width){return break_new_line(state,_cd_,width)}
    function break_same_line(state,param)
     {var after=param[3],width=param[2],before=param[1];
      format_string(state,before);
      state[9] = state[9] - width | 0;
      caml_call1(state[20],width);
      return format_string(state,after)}
    function advance_left(state)
     {for(;;)
       {var match$12=peek_opt(state[28]);
        if(match$12)
         {var
           match$13=match$12[1],
           size$0=match$13[1],
           length$0=match$13[3],
           token=match$13[2],
           pending_count=state[13] - state[12] | 0,
           _lJ_=0 <= size$0?1:0,
           _lK_=_lJ_ || (state[9] <= pending_count?1:0);
          if(_lK_)
           {take(state[28]);
            var size$1=0 <= size$0?size$0:pp_infinity;
            if(typeof token === "number")
             switch(token)
              {case 0:
                var match$3=top_opt(state[3]);
                if(match$3)
                 {var
                   match$4=match$3[1],
                   tabs=match$4[1],
                   add_tab=
                    function(n,ls)
                     {if(ls)
                       {var l=ls[2],x=ls[1];
                        return caml_lessthan(n,x)?[0,n,ls]:[0,x,add_tab(n,l)]}
                      return [0,n,0]};
                  tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1])}
                break;
               case 1:pop_opt(state[2]);break;
               case 2:pop_opt(state[3]);break;
               case 3:
                var match$5=top_opt(state[2]);
                if(match$5)
                 {var match$6=match$5[1],width$0=match$6[2];
                  break_line(state,width$0)}
                else
                 pp_output_newline(state);
                break;
               case 4:
                if(state[10] !== (state[6] - state[9] | 0))
                 {var match$1=take_opt(state[28]);
                  if(match$1)
                   {var match$2=match$1[1],size=match$2[1],length=match$2[3];
                    state[12] = state[12] - length | 0;
                    state[9] = state[9] + size | 0}}
                break;
               default:
                var match$7=pop_opt(state[5]);
                if(match$7)
                 {var
                   tag_name=match$7[1],
                   marker=caml_call1(state[25],tag_name);
                  pp_output_string(state,marker)}}
            else
             switch(token[0])
              {case 0:var s=token[1];format_pp_text(state,size$1,s);break;
               case 1:
                var
                 breaks=token[2],
                 fits=token[1],
                 off=breaks[2],
                 before=breaks[1],
                 match$8=top_opt(state[2]);
                if(match$8)
                 {var
                   match$9=match$8[1],
                   width$1=match$9[2],
                   box_type$0=match$9[1];
                  switch(box_type$0)
                   {case 0:break_same_line(state,fits);break;
                    case 1:break_new_line(state,breaks,width$1);break;
                    case 2:break_new_line(state,breaks,width$1);break;
                    case 3:
                     if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                      break_new_line(state,breaks,width$1);
                     else
                      break_same_line(state,fits);
                     break;
                    case 4:
                     if(state[11])
                      break_same_line(state,fits);
                     else
                      if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                       break_new_line(state,breaks,width$1);
                      else
                       if(((state[6] - width$1 | 0) + off | 0) < state[10])
                        break_new_line(state,breaks,width$1);
                       else
                        break_same_line(state,fits);
                     break;
                    default:break_same_line(state,fits)}}
                break;
               case 2:
                var
                 off$0=token[2],
                 n=token[1],
                 insertion_point=state[6] - state[9] | 0,
                 match$10=top_opt(state[3]);
                if(match$10)
                 {var match$11=match$10[1],tabs$0=match$11[1],_lH_=tabs$0[1];
                  if(_lH_)
                   {var first=_lH_[1],param=tabs$0[1];
                    for(;;)
                     {if(param)
                       {var tail=param[2],head=param[1];
                        if(! (insertion_point <= head)){var param=tail;continue}
                        var _lI_=head}
                      else
                       var _lI_=first;
                      var tab=_lI_;
                      break}}
                  else
                   var tab=insertion_point;
                  var offset=tab - insertion_point | 0;
                  if(0 <= offset)
                   break_same_line(state,[0,cst$69,offset + n | 0,cst$68]);
                  else
                   break_new_line
                    (state,[0,cst$71,tab + off$0 | 0,cst$70],state[6])}
                break;
               case 3:
                var
                 ty=token[2],
                 off$1=token[1],
                 insertion_point$0=state[6] - state[9] | 0;
                if(state[8] < insertion_point$0)
                 {var match=top_opt(state[2]);
                  if(match)
                   {var match$0=match[1],width=match$0[2],box_type=match$0[1];
                    if(state[9] < width)
                     {var switcher=box_type - 1 | 0;
                      if(! (3 < switcher >>> 0))break_line(state,width)}}
                  else
                   pp_output_newline(state)}
                var
                 width$2=state[9] - off$1 | 0,
                 box_type$1=1 === ty?1:state[9] < size$1?ty:5;
                push([0,box_type$1,width$2],state[2]);
                break;
               case 4:var tbox=token[1];push(tbox,state[3]);break;
               default:
                var
                 tag_name$0=token[1],
                 marker$0=caml_call1(state[24],tag_name$0);
                pp_output_string(state,marker$0);
                push(tag_name$0,state[5])}
            state[12] = length$0 + state[12] | 0;
            continue}
          return _lK_}
        return 0}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    function initialize_scan_stack(stack)
     {clear(stack);
      var queue_elem=[0,unknown,_ce_,0];
      return push([0,-1,queue_elem],stack)}
    function set_size(state,ty)
     {var match=top_opt(state[1]);
      if(match)
       {var
         match$0=match[1],
         queue_elem=match$0[2],
         left_total=match$0[1],
         _lE_=queue_elem[1];
        if(left_total < state[12])return initialize_scan_stack(state[1]);
        var _lF_=queue_elem[2];
        if(typeof _lF_ !== "number")
         switch(_lF_[0])
          {case 3:
            var _lG_=1 - ty;
            return _lG_
                    ?(queue_elem[1] = state[13] + _lE_ | 0,pop_opt(state[1]),0)
                    :_lG_;
           case 1:
           case 2:
            return ty
                    ?(queue_elem[1] = state[13] + _lE_ | 0,pop_opt(state[1]),0)
                    :ty
           }
        return 0}
      return 0}
    function scan_push(state,b,token)
     {pp_enqueue(state,token);
      if(b)set_size(state,1);
      var elem=[0,state[13],token];
      return push(elem,state[1])}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var size=- state[13] | 0,elem=[0,size,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _lC_=state[14] === state[15]?1:0;
      if(_lC_)
       {var _lD_=state[16];
        return enqueue_string_as(state,caml_ml_string_length(_lD_),_lD_)}
      return _lC_}
    function pp_close_box(state,param)
     {var _lA_=1 < state[14]?1:0;
      if(_lA_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,size,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _lB_=0}
      else
       var _lB_=_lA_;
      return _lB_}
    function pp_open_stag(state,tag_name)
     {if(state[22]){push(tag_name,state[4]);caml_call1(state[26],tag_name)}
      var _lz_=state[23];
      if(_lz_)
       {var token=[5,tag_name];return pp_enqueue(state,[0,size,token,0])}
      return _lz_}
    function pp_close_stag(state,param)
     {if(state[23])pp_enqueue(state,[0,size,5,0]);
      var _lx_=state[22];
      if(_lx_)
       {var match=pop_opt(state[4]);
        if(match){var tag_name=match[1];return caml_call1(state[27],tag_name)}
        var _ly_=0}
      else
       var _ly_=_lx_;
      return _ly_}
    function pp_open_tag(state,s){return pp_open_stag(state,[0,String_tag,s])}
    function pp_close_tag(state,param){return pp_close_stag(state,0)}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_stag_function(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_stag_function(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      clear$0(state[28]);
      initialize_scan_stack(state[1]);
      clear(state[2]);
      clear(state[3]);
      clear(state[4]);
      clear(state[5]);
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _lw_=state[4];
      iter$7(function(param){return pp_close_tag(state,0)},_lw_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _lv_=state[14] < state[15]?1:0;
      return _lv_?enqueue_string_as(state,size,s):_lv_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_string_of_jsbytes("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,to_string(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$1(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _lu_=state[14] < state[15]?1:0;
      return _lu_?enqueue_advance(state,[0,size,3,0]):_lu_}
    function pp_print_if_newline(state,param)
     {var _lt_=state[14] < state[15]?1:0;
      return _lt_?enqueue_advance(state,[0,size,4,0]):_lt_}
    function pp_print_custom_break(state,fits,breaks)
     {var
       after=fits[3],
       width=fits[2],
       before=fits[1],
       _ls_=state[14] < state[15]?1:0;
      if(_ls_)
       {var
         size=- state[13] | 0,
         token=[1,fits,breaks],
         length=
          (caml_ml_string_length(before) + width | 0)
          +
          caml_ml_string_length(after)
          |
          0,
         elem=[0,size,token,length];
        return scan_push(state,1,elem)}
      return _ls_}
    function pp_print_break(state,width,offset)
     {return pp_print_custom_break
              (state,[0,cst$75,width,cst$74],[0,cst$73,offset,cst$72])}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _lr_=state[14] < state[15]?1:0;
      if(_lr_)
       {var elem=[0,size,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _lr_}
    function pp_close_tbox(state,param)
     {var _lo_=1 < state[14]?1:0;
      if(_lo_)
       {var _lp_=state[14] < state[15]?1:0;
        if(_lp_)
         {var elem=[0,size,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _lq_=0}
        else
         var _lq_=_lp_}
      else
       var _lq_=_lo_;
      return _lq_}
    function pp_print_tbreak(state,width,offset)
     {var _ln_=state[14] < state[15]?1:0;
      if(_ln_)
       {var size=- state[13] | 0,elem=[0,size,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _ln_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _lm_=state[14] < state[15]?1:0;
      if(_lm_){var elem=[0,size,0,0];return enqueue_advance(state,elem)}
      return _lm_}
    function pp_set_max_boxes(state,n)
     {var _lk_=1 < n?1:0,_ll_=_lk_?(state[15] = n,0):_lk_;return _ll_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var _lj_=1 < n$0?1:0;
      if(_lj_)
       {var n$1=state[6] - n$0 | 0,_li_=1 <= n$1?1:0;
        if(_li_)
         {var n=pp_limit(n$1);
          state[7] = n;
          state[8] = state[6] - state[7] | 0;
          return pp_rinit(state)}
        return _li_}
      return _lj_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _lh_=1 <= n?1:0;
      if(_lh_)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max(max(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _lh_}
    function validate_geometry(param)
     {var margin=param[2],max_indent=param[1];
      return 2 <= max_indent?margin <= max_indent?_cf_:_cg_:_ch_}
    function check_geometry(geometry)
     {var match=validate_geometry(geometry);return 0 === match[0]?1:0}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_full_geometry(state,param)
     {var margin=param[2],max_indent=param[1];
      pp_set_margin(state,margin);
      pp_set_max_indent(state,max_indent);
      return 0}
    function pp_set_geometry(state,max_indent,margin)
     {var geometry=[0,max_indent,margin],match=validate_geometry(geometry);
      if(0 === match[0])return pp_set_full_geometry(state,geometry);
      var msg=match[1];
      throw [0,Invalid_argument,symbol(cst_Format_pp_set_geometry,msg)]}
    function pp_safe_set_geometry(state,max_indent,margin)
     {var geometry=[0,max_indent,margin],match=validate_geometry(geometry);
      return 0 === match[0]?pp_set_full_geometry(state,geometry):0}
    function pp_get_geometry(state,param){return [0,state[8],state[6]]}
    function pp_update_geometry(state,update)
     {var geometry=pp_get_geometry(state,0);
      return pp_set_full_geometry(state,caml_call1(update,geometry))}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functi(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functi(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$76,0,1)}
    var blank_line=make$1(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _lg_=0 < n$0?1:0;
        if(_lg_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _lg_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_ld_,_le_,_lf_){return output_substring(oc,_ld_,_le_,_lf_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_lc_){return display_newline(state,_lc_)};
      state[20] = function(_lb_){return display_indent(state,_lb_)};
      state[21] = function(_la_){return display_indent(state,_la_)};
      return 0}
    function default_pp_mark_open_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(cst$78,symbol(s,cst$77))}
      return cst$79}
    function default_pp_mark_close_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(cst$81,symbol(s,cst$80))}
      return cst$82}
    function default_pp_print_open_tag(_k$_){return 0}
    function default_pp_print_close_tag(_k__){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=create$1(0),sys_tok=[0,unknown,_ci_,0];
      add(sys_tok,pp_queue);
      var scan_stack=create$0(0);
      initialize_scan_stack(scan_stack);
      push([0,1,sys_tok],scan_stack);
      var _k7_=create$0(0),_k8_=create$0(0),_k9_=create$0(0);
      return [0,
              scan_stack,
              create$0(0),
              _k9_,
              _k8_,
              _k7_,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$83,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _kZ_(_k6_){return 0}
      function _k0_(_k5_){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_k4_){return 0},_k0_,_kZ_);
      ppf[19] = function(_k3_){return display_newline(ppf,_k3_)};
      ppf[20] = function(_k2_){return display_indent(ppf,_k2_)};
      ppf[21] = function(_k1_){return display_indent(ppf,_k1_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _kV_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_kW_,_kX_,_kY_)
                {return output_substring(oc,_kW_,_kX_,_kY_)},
               _kV_)}
    function formatter_of_buffer(b)
     {function _kQ_(_kU_){return 0}
      return make_formatter
              (function(_kR_,_kS_,_kT_)
                {return add_substring(b,_kR_,_kS_,_kT_)},
               _kQ_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$2(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(stdout),
     err_formatter=formatter_of_out_channel(stderr),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_b(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_kP_){return add_symbolic_output_item(sob,0)}
      function h(_kO_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_kN_){return pp_open_hbox(std_formatter,_kN_)}
    function open_vbox(_kM_){return pp_open_vbox(std_formatter,_kM_)}
    function open_hvbox(_kL_){return pp_open_hvbox(std_formatter,_kL_)}
    function open_hovbox(_kK_){return pp_open_hovbox(std_formatter,_kK_)}
    function open_box(_kJ_){return pp_open_box(std_formatter,_kJ_)}
    function close_box(_kI_){return pp_close_box(std_formatter,_kI_)}
    function open_tag(_kH_){return pp_open_tag(std_formatter,_kH_)}
    function close_tag(_kG_){return pp_close_tag(std_formatter,_kG_)}
    function open_stag(_kF_){return pp_open_stag(std_formatter,_kF_)}
    function close_stag(_kE_){return pp_close_stag(std_formatter,_kE_)}
    function print_as(_kC_,_kD_){return pp_print_as(std_formatter,_kC_,_kD_)}
    function print_string$0(_kB_){return pp_print_string(std_formatter,_kB_)}
    function print_int$0(_kA_){return pp_print_int(std_formatter,_kA_)}
    function print_float$0(_kz_){return pp_print_float(std_formatter,_kz_)}
    function print_char$0(_ky_){return pp_print_char(std_formatter,_ky_)}
    function print_bool(_kx_){return pp_print_bool(std_formatter,_kx_)}
    function print_break(_kv_,_kw_)
     {return pp_print_break(std_formatter,_kv_,_kw_)}
    function print_cut(_ku_){return pp_print_cut(std_formatter,_ku_)}
    function print_space(_kt_){return pp_print_space(std_formatter,_kt_)}
    function force_newline(_ks_){return pp_force_newline(std_formatter,_ks_)}
    function print_flush(_kr_){return pp_print_flush(std_formatter,_kr_)}
    function print_newline$0(_kq_)
     {return pp_print_newline(std_formatter,_kq_)}
    function print_if_newline(_kp_)
     {return pp_print_if_newline(std_formatter,_kp_)}
    function open_tbox(_ko_){return pp_open_tbox(std_formatter,_ko_)}
    function close_tbox(_kn_){return pp_close_tbox(std_formatter,_kn_)}
    function print_tbreak(_kl_,_km_)
     {return pp_print_tbreak(std_formatter,_kl_,_km_)}
    function set_tab(_kk_){return pp_set_tab(std_formatter,_kk_)}
    function print_tab(_kj_){return pp_print_tab(std_formatter,_kj_)}
    function set_margin(_ki_){return pp_set_margin(std_formatter,_ki_)}
    function get_margin(_kh_){return std_formatter[6]}
    function set_max_indent(_kg_)
     {return pp_set_max_indent(std_formatter,_kg_)}
    function get_max_indent(_kf_){return std_formatter[8]}
    function set_geometry(_kd_,_ke_)
     {return pp_set_geometry(std_formatter,_kd_,_ke_)}
    function safe_set_geometry(_kb_,_kc_)
     {return pp_safe_set_geometry(std_formatter,_kb_,_kc_)}
    function get_geometry(_ka_){return pp_get_geometry(std_formatter,_ka_)}
    function update_geometry(_j$_)
     {return pp_update_geometry(std_formatter,_j$_)}
    function set_max_boxes(_j__){return pp_set_max_boxes(std_formatter,_j__)}
    function get_max_boxes(_j9_){return std_formatter[15]}
    function over_max_boxes(_j8_)
     {return pp_over_max_boxes(std_formatter,_j8_)}
    function set_ellipsis_text(_j7_)
     {return pp_set_ellipsis_text(std_formatter,_j7_)}
    function get_ellipsis_text(_j6_){return std_formatter[16]}
    function set_formatter_out_channel(_j5_)
     {return pp_set_formatter_out_channel(std_formatter,_j5_)}
    function set_formatter_out_functions(_j4_)
     {return pp_set_formatter_out_functions(std_formatter,_j4_)}
    function get_formatter_out_functions(_j3_)
     {return pp_get_formatter_out_functions(std_formatter,_j3_)}
    function set_formatter_output_functions(_j1_,_j2_)
     {return pp_set_formatter_output_functi(std_formatter,_j1_,_j2_)}
    function get_formatter_output_functions(_j0_)
     {return pp_get_formatter_output_functi(std_formatter,_j0_)}
    function set_formatter_stag_functions(_jZ_)
     {return pp_set_formatter_stag_function(std_formatter,_jZ_)}
    function get_formatter_stag_functions(_jY_)
     {return pp_get_formatter_stag_function(std_formatter,_jY_)}
    function set_print_tags(_jX_)
     {return pp_set_print_tags(std_formatter,_jX_)}
    function get_print_tags(_jW_){return std_formatter[22]}
    function set_mark_tags(_jV_){return pp_set_mark_tags(std_formatter,_jV_)}
    function get_mark_tags(_jU_){return std_formatter[23]}
    function set_tags(_jT_){return pp_set_tags(std_formatter,_jT_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _jS_=param$0[1];
          if(param$0[2])
           {var vs=param$0[2];
            caml_call2(pp_v,ppf,_jS_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=vs;
            continue}
          return caml_call2(pp_v,ppf,_jS_)}
        return 0}}
    function pp_print_seq(opt,pp_v,ppf,seq$1)
     {if(opt)var sth=opt[1],pp_sep=sth;else var pp_sep=pp_print_cut;
      var match$0=caml_call1(seq$1,0);
      if(match$0)
       {var seq$2=match$0[2],v$0=match$0[1];
        caml_call2(pp_v,ppf,v$0);
        var seq=seq$2;
        for(;;)
         {var match=caml_call1(seq,0);
          if(match)
           {var seq$0=match[2],v=match[1];
            caml_call2(pp_sep,ppf,0);
            caml_call2(pp_v,ppf,v);
            var seq=seq$0;
            continue}
          return 0}}
      return 0}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _jR_=left[1] !== len?1:0;
        return _jR_?flush(0):_jR_}}
    function pp_print_option(opt,pp_v,ppf,param)
     {if(opt)
       var sth=opt[1],none=sth;
      else
       var none=function(param,_jQ_){return 0};
      if(param){var v=param[1];return caml_call2(pp_v,ppf,v)}
      return caml_call2(none,ppf,0)}
    function pp_print_result(ok,error,ppf,param)
     {if(0 === param[0]){var v=param[1];return caml_call2(ok,ppf,v)}
      var e=param[1];
      return caml_call2(error,ppf,e)}
    function compute_tag(output,tag_acc)
     {var buf=create$2(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$3(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _jG_=acc[2],_jH_=acc[1];
          if(0 === _jG_[0])
           {var acc$0=_jG_[1];
            output_acc$0(ppf,_jH_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(output_acc$0,acc$0)])}
          var acc$1=_jG_[1];
          output_acc$0(ppf,_jH_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _jI_=acc[1],switch$1=0;
          if(typeof _jI_ !== "number" && 0 === _jI_[0])
           {var _jJ_=_jI_[2],switch$2=0;
            if(typeof _jJ_ !== "number" && 1 === _jJ_[0])
             {var s$0=acc[2],size=_jJ_[2],p$1=_jI_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_jI_;switch$0 = 2}
          break;
         case 3:
          var _jK_=acc[1],switch$3=0;
          if(typeof _jK_ !== "number" && 0 === _jK_[0])
           {var _jL_=_jK_[2],switch$4=0;
            if(typeof _jL_ !== "number" && 1 === _jL_[0])
             {var c$0=acc[2],size$0=_jL_[2],p$3=_jK_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_jK_;switch$0 = 3}
          break;
         case 4:
          var _jM_=acc[1],switch$5=0;
          if(typeof _jM_ !== "number" && 0 === _jM_[0])
           {var _jN_=_jM_[2],switch$6=0;
            if(typeof _jN_ !== "number" && 1 === _jN_[0])
             {var s$0=acc[2],size=_jN_[2],p$1=_jM_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_jM_;switch$0 = 2}
          break;
         case 5:
          var _jO_=acc[1],switch$7=0;
          if(typeof _jO_ === "number" || ! (0 === _jO_[0]))
           switch$7 = 1;
          else
           {var _jP_=_jO_[2],switch$8=0;
            if(typeof _jP_ !== "number" && 1 === _jP_[0])
             {var c$0=acc[2],size$0=_jP_[2],p$3=_jO_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_jO_;switch$0 = 3}
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$1(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _ju_=acc[2],_jv_=acc[1];
          if(0 === _ju_[0])
           {var acc$0=_ju_[1];
            strput_acc$0(ppf,_jv_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(strput_acc$0,acc$0)])}
          var acc$1=_ju_[1];
          strput_acc$0(ppf,_jv_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _jw_=acc[1],switch$1=0;
          if(typeof _jw_ !== "number" && 0 === _jw_[0])
           {var _jx_=_jw_[2],switch$2=0;
            if(typeof _jx_ !== "number" && 1 === _jx_[0])
             {var s$0=acc[2],size=_jx_[2],p$1=_jw_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_jw_;switch$0 = 2}
          break;
         case 3:
          var _jy_=acc[1],switch$3=0;
          if(typeof _jy_ !== "number" && 0 === _jy_[0])
           {var _jz_=_jy_[2],switch$4=0;
            if(typeof _jz_ !== "number" && 1 === _jz_[0])
             {var c$0=acc[2],size$0=_jz_[2],p$3=_jy_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_jy_;switch$0 = 3}
          break;
         case 4:
          var _jA_=acc[1],switch$5=0;
          if(typeof _jA_ !== "number" && 0 === _jA_[0])
           {var _jB_=_jA_[2],switch$6=0;
            if(typeof _jB_ !== "number" && 1 === _jB_[0])
             {var s$0=acc[2],size=_jB_[2],p$1=_jA_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_jA_;switch$0 = 2}
          break;
         case 5:
          var _jC_=acc[1],switch$7=0;
          if(typeof _jC_ === "number" || ! (0 === _jC_[0]))
           switch$7 = 1;
          else
           {var _jD_=_jC_[2],switch$8=0;
            if(typeof _jD_ !== "number" && 1 === _jD_[0])
             {var c$0=acc[2],size$0=_jD_[2],p$3=_jC_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_jC_;switch$0 = 3}
          break;
         case 6:
          var _jE_=acc[1];
          if(typeof _jE_ !== "number" && 0 === _jE_[0])
           {var _jF_=_jE_[2];
            if(typeof _jF_ !== "number" && 1 === _jF_[0])
             {var f$1=acc[2],size$1=_jF_[2],p$4=_jE_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_jE_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$1(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_jt_=0;
      return make_printf
              (function(acc){output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               _jt_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function ifprintf$0(ppf,param)
     {var fmt=param[1],_jr_=0;
      return make_iprintf(function(_js_){return 0},_jr_,fmt)}
    function fprintf$0(ppf)
     {function _jo_(_jq_){return 0}
      return function(_jp_){return kfprintf$0(_jo_,ppf,_jp_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function kdprintf(k,param)
     {var fmt=param[1],_jn_=0;
      return make_printf
              (function(acc)
                {return caml_call1
                         (k,function(ppf){return output_acc$0(ppf,acc)})},
               _jn_,
               fmt)}
    function dprintf(fmt){return kdprintf(function(i){return i},fmt)}
    function kprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function sprintf$0(fmt){return kprintf(id$0,fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function asprintf(fmt){return kasprintf(id$0,fmt)}
    function flush_standard_formatters(param)
     {pp_print_flush(std_formatter,0);return pp_print_flush(err_formatter,0)}
    at_exit(flush_standard_formatters);
    function pp_set_all_formatter_output_fu(state,f,g,h,i)
     {pp_set_formatter_output_functi(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_fu(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_funct(_jj_,_jk_,_jl_,_jm_)
     {return pp_set_all_formatter_output_fu(std_formatter,_jj_,_jk_,_jl_,_jm_)}
    function get_all_formatter_output_funct(_ji_)
     {return pp_get_all_formatter_output_fu(std_formatter,_ji_)}
    function bprintf$0(b,param)
     {var fmt=param[1],ppf=formatter_of_buffer(b);
      function k(acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,0,fmt)}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      function stringify(f,e,param)
       {if(param[1] === String_tag){var s=param[2];return caml_call1(f,s)}
        return e}
      state[24] = function(_jh_){return stringify(mot,cst$84,_jh_)};
      state[25] = function(_jg_){return stringify(mct,cst$85,_jg_)};
      var _jc_=0;
      state[26] = function(_jf_){return stringify(pot,_jc_,_jf_)};
      var _jd_=0;
      state[27] = function(_je_){return stringify(pct,_jd_,_je_)};
      return 0}
    function pp_get_formatter_tag_functions(fmt,param)
     {var funs=pp_get_formatter_stag_function(fmt,0);
      function mark_open_tag(s){return caml_call1(funs[1],[0,String_tag,s])}
      function mark_close_tag(s){return caml_call1(funs[2],[0,String_tag,s])}
      function print_open_tag(s){return caml_call1(funs[3],[0,String_tag,s])}
      function print_close_tag(s){return caml_call1(funs[4],[0,String_tag,s])}
      return [0,mark_open_tag,mark_close_tag,print_open_tag,print_close_tag]}
    function set_formatter_tag_functions(_jb_)
     {return pp_set_formatter_tag_functions(std_formatter,_jb_)}
    function get_formatter_tag_functions(_ja_)
     {return pp_get_formatter_tag_functions(std_formatter,_ja_)}
    var
     Stdlib_format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_update_geometry,
       update_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_list,
       pp_print_seq,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       dprintf,
       ifprintf$0,
       kfprintf$0,
       kdprintf,
       ikfprintf$0,
       kprintf,
       kasprintf,
       bprintf$0,
       kprintf,
       set_all_formatter_output_funct,
       get_all_formatter_output_funct,
       pp_set_all_formatter_output_fu,
       pp_get_all_formatter_output_fu,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions];
    caml_register_global(801,Stdlib_format,"Stdlib__format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_i$_)
       {_i$_ = caml_wrap_exception(_i$_);
        if(_i$_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _i$_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _i__=ib[9];
      if(typeof _i__ === "number")
       return 0 === _i__?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _i__[0])return cst_unnamed_Stdlib_input_chann;
        var fname=_i__[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$4(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$2(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$4(1,next)}
    var _cj_=0;
    function from_function$0(_i9_){return create$4(_cj_,_i9_)}
    var len=1024;
    function scan_close_at_end(ic)
     {caml_ml_close_channel(ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$4(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$86,stdin],stdin);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$87))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    function from_file(_i8_){return open_in_file(open_in,_i8_)}
    function from_file_bin(_i7_){return open_in_file(open_in_bin,_i7_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in$0(ib)
     {var _i6_=ib[9];
      if(typeof _i6_ === "number")
       return 0;
      else
       {if(0 === _i6_[0]){var ic=_i6_[1];return caml_ml_close_channel(ic)}
        var ic$0=_i6_[2];
        return caml_ml_close_channel(ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _i4_=assq(ic,memo[1]);return _i4_}
      catch(_i5_)
       {_i5_ = caml_wrap_exception(_i5_);
        if(_i5_ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _i5_}}
    function memo_from_channel(_i3_)
     {return memo_from_ic(scan_raise_at_end,_i3_)}
    var Scan_failure=[248,cst_Stdlib_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_ck_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_cl_),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_fo)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexad)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_cn_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_i1_=1 - ib[1];
         if(_i1_)
          {var _i2_=c - 9 | 0,switch$0=0;
           if(4 < _i2_ >>> 0)
            {if(23 === _i2_)switch$0 = 1}
           else
            if(1 < (_i2_ - 2 | 0) >>> 0)switch$0 = 1;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _i1_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$3)
              ?caml_string_notequal(s,cst_true$3)
                ?bad_input(caml_call1(sprintf(_co_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_cp_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=symbol(cst_0b,token_string(ib));break;
        case 3:var tok=symbol(cst_0o,token_string(ib));break;
        case 4:var tok=symbol(cst_0u,token_string(ib));break;
        case 5:var tok=symbol(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l && 43 === caml_string_get(tok,0))
       return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib),switcher=c - 48 | 0;
      if(9 < switcher >>> 0)return bad_input(caml_call1(sprintf(_cq_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_cr_),c$0,basis))}
    function is_binary_digit(param)
     {var switcher=param - 48 | 0;return 1 < switcher >>> 0?0:1}
    function scan_binary_int(_iZ_,_i0_)
     {return scan_digit_plus(cst_binary,is_binary_digit,_iZ_,_i0_)}
    function is_octal_digit(param)
     {var switcher=param - 48 | 0;return 7 < switcher >>> 0?0:1}
    function scan_octal_int(_iX_,_iY_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_iX_,_iY_)}
    function is_hexa_digit(param)
     {var _iW_=param - 48 | 0,switch$0=0;
      if(22 < _iW_ >>> 0)
       {if(! (5 < (_iW_ - 49 | 0) >>> 0))switch$0 = 1}
      else
       if(6 < (_iW_ - 10 | 0) >>> 0)switch$0 = 1;
      return switch$0?1:0}
    function scan_hexadecimal_int(_iU_,_iV_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_iU_,_iV_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           var switch$0=0;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             if(120 === c$0)switch$0 = 1}
           else
            if(88 === c$0)
             switch$0 = 1;
            else
             if(98 <= c$0)return scan_binary_int(store_char(width,ib,c$0),ib);
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      var switcher=c - 48 | 0;
      return 9 < switcher >>> 0
              ?width
              :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c && 101 !== c)return width;
      return scan_optionally_signed_decimal(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {var switcher=c - 65 | 0;
        return 25 < switcher >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _iR_=len - 1 | 0,
       _iQ_=0;
      if(! (_iR_ < 0))
       {var i=_iQ_;
        for(;;)
         {var c=peek_char(ib),_iS_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _iS_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _iT_=i + 1 | 0;
          if(_iR_ !== i){var i=_iT_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _iD_=0 === width?1:0,_iE_=_iD_ || end_of_input(ib);
      if(_iE_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _iF_=0 === width$0?1:0,
       _iG_=_iF_ || end_of_input(ib);
      if(_iG_)bad_hex_float(0);
      var c=peek_char(ib),switch$0=0;
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _iH_=0 === width$1?1:0,
             _iI_=_iH_ || end_of_input(ib);
            if(_iI_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}}
        else
         if(26 === switcher)switch$0 = 1}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _iL_=0 === width$3?1:0,
           _iM_=_iL_ || end_of_input(ib);
          if(_iM_)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4 && ! end_of_input(ib))
           {var match=peek_char(ib),_iN_=match - 46 | 0,switch$1=0;
            if(34 < _iN_ >>> 0)
             {if(66 === _iN_)switch$1 = 1}
            else
             if(32 < (_iN_ - 1 | 0) >>> 0)switch$1 = 1;
            var width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
            if(0 !== width$5 && ! end_of_input(ib))
             {var c$0=peek_char(ib);
              if(46 === c$0)
               {var width$6=store_char(width$5,ib,c$0),switch$2=0;
                if(0 !== width$6 && ! end_of_input(ib))
                 {var match$0=peek_char(ib),switch$3=0;
                  if(80 !== match$0 && 112 !== match$0)
                   {var
                     precision$0=min(width$6,precision),
                     width$10=
                      width$6
                      -
                      (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                      |
                      0;
                    switch$3 = 1}
                  if(! switch$3)var width$10=width$6;
                  var width$7=width$10;
                  switch$2 = 1}
                if(! switch$2)var width$7=width$6;
                var width$8=width$7}
              else
               var width$8=width$5;
              if(0 !== width$8 && ! end_of_input(ib))
               {var c$1=peek_char(ib);
                if(80 !== c$1 && 112 !== c$1)return width$8;
                var
                 width$9=store_char(width$8,ib,c$1),
                 _iO_=0 === width$9?1:0,
                 _iP_=_iO_ || end_of_input(ib);
                if(_iP_)bad_hex_float(0);
                return scan_optionally_signed_decimal(width$9,ib)}
              return width$8}
            return width$5}
          return width$4}
        if(73 === c)switch$0 = 1}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _iJ_=0 === width$2?1:0,
         _iK_=_iJ_ || end_of_input(ib);
        if(_iK_)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _iz_=0 === width?1:0,_iA_=_iz_ || end_of_input(ib);
      if(_iA_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _iB_=0 === width$0?1:0,
       _iC_=_iB_ || end_of_input(ib);
      if(_iC_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       {var switcher$0=switcher - 1 | 0;
        if(30 < switcher$0 >>> 0)return scan_exponent_part(width$0,ib)}
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _il_=0 === width?1:0,_im_=_il_ || end_of_input(ib);
      if(_im_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _in_=0 === width$0?1:0,
       _io_=_in_ || end_of_input(ib);
      if(_io_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _ip_=0 === width$1?1:0,
           _iq_=_ip_ || end_of_input(ib);
          if(_iq_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _ir_=0 === width$2?1:0,
          _is_=_ir_ || end_of_input(ib);
         if(_is_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0 && 120 !== c$0)
          return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _it_=0 === width$3?1:0,
          _iu_=_it_ || end_of_input(ib);
         if(_iu_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _iv_=0 === width$4?1:0,
          _iw_=_iv_ || end_of_input(ib);
         if(_iw_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0,switch$0=0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1),switch$1=0;
            if(0 !== width$5 && ! end_of_input(ib))
             {var match=peek_char(ib),switch$2=0;
              if(80 !== match && 112 !== match)
               {var
                 precision$0=min(width$5,precision),
                 width$10=
                  width$5
                  -
                  (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                  |
                  0;
                switch$2 = 1}
              if(! switch$2)var width$10=width$5;
              var width$6=width$10;
              switch$1 = 1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6}
          else
           switch$0 = 1;
         else
          {var switcher$0=switcher - 1 | 0;
           if(30 < switcher$0 >>> 0)var width$7=width$4;else switch$0 = 1}
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8 && ! end_of_input(ib))
          {var c$2=peek_char(ib);
           if(80 !== c$2 && 112 !== c$2)return width$8;
           var
            width$9=store_char(width$8,ib,c$2),
            _ix_=0 === width$9?1:0,
            _iy_=_ix_ || end_of_input(ib);
           if(_iy_)bad_hex_float(0);
           return scan_optionally_signed_decimal(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var _ik_=c - 9 | 0,switch$0=0;
        if(4 < _ik_ >>> 0)
         {if(23 === _ik_)switch$0 = 1}
        else
         if(1 < (_ik_ - 2 | 0) >>> 0)switch$0 = 1;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_cm_),message)):c}
    function check_next_char_for_char(_ii_,_ij_)
     {return check_next_char(cst_a_Char,_ii_,_ij_)}
    function check_next_char_for_string(_ig_,_ih_)
     {return check_next_char(cst_a_String,_ig_,_ih_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib),switch$0=0;
      if(40 <= c0)
       {if(58 <= c0)
         {var switcher$0=c0 - 92 | 0;
          if(! (28 < switcher$0 >>> 0))
           switch(switcher$0)
            {case 28:
              var
               get_digit=
                function(param)
                 {var c=next_char(ib),_if_=c - 48 | 0,switch$0=0;
                  if(22 < _if_ >>> 0)
                   {if(! (5 < (_if_ - 49 | 0) >>> 0))switch$0 = 1}
                  else
                   if(6 < (_if_ - 10 | 0) >>> 0)switch$0 = 1;
                  return switch$0?c:bad_input_escape(c)},
               c1=get_digit(0),
               c2=get_digit(0),
               _ib_=hexadecimal_value_of_char(c2),
               c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _ib_ | 0,
               switch$1=0;
              if(0 <= c$0 && ! (255 < c$0))
               {var _id_=char_of_int(c$0);switch$1 = 1}
              if(! switch$1)
               var _id_=bad_input(caml_call2(sprintf(_ct_),c1,c2));
              return store_char(width - 2 | 0,ib,_id_);
             case 0:
             case 6:
             case 18:
             case 22:
             case 24:switch$0 = 1;break
             }}
        else
         if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib),switcher=c - 48 | 0;
               return 9 < switcher >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0,
            switch$2=0;
           if(0 <= c && ! (255 < c)){var _ie_=char_of_int(c);switch$2 = 1}
           if(! switch$2)
            var _ie_=bad_input(caml_call3(sprintf(_cs_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_ie_)}}
      else
       if(34 === c0 || 39 <= c0)switch$0 = 1;
      if(switch$0)
       {var switch$3=0;
        if(110 <= c0)
         if(117 <= c0)
          switch$3 = 1;
         else
          {var switcher=c0 - 110 | 0;
           switch(switcher)
            {case 0:var _ic_=10;break;
             case 4:var _ic_=13;break;
             case 6:var _ic_=9;break;
             default:switch$3 = 1}}
        else
         if(98 === c0)var _ic_=8;else switch$3 = 1;
        if(switch$3)var _ic_=c0;
        return store_char(width,ib,_ic_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _h$_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_h$_)}
              return caml_trampoline_return(skip_spaces,[0,_h$_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _ia_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_ia_)}
                return caml_trampoline_return(skip_spaces,[0,_ia_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_h7_=0 < i$0?1:0;
          if(_h7_)
           {var _h8_=1 - ib[1];
            if(_h8_)
             var _h9_=is_in_char_set(char_set,c),_h__=_h9_?c !== stp?1:0:_h9_;
            else
             var _h__=_h8_}
          else
           var _h__=_h7_;
          if(_h__)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _h__}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _h6_=1 - ib[1];
        if(_h6_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _h6_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_cv_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _cw_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_h4_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_h4_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_h4_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _h5_=fmt$0[1];
           if(0 === _h5_[0])
            {var
              rest$0=fmt$0[2],
              match=_h5_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_h5_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _hR_=fmt$0[1],_hS_=fmt$0[2];
           if(typeof _hS_ !== "number")
            switch(_hS_[0])
             {case 17:
               var
                rest$2=_hS_[2],
                fmting_lit=_hS_[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$2];
               return pad_prec_scanf
                       (ib,str_rest,readers,_hR_,0,scan$0,token_string);
              case 18:
               var _hT_=_hS_[1];
               if(0 === _hT_[0])
                {var
                  rest$3=_hS_[2],
                  match$0=_hT_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_cx_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$3),
                          readers,
                          _hR_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$4=_hS_[2],
                match$1=_hT_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_cy_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$4),
                        readers,
                        _hR_,
                        0,
                        scan$2,
                        token_string)
              }
           var
            rest$1=fmt$0[2],
            scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,rest$1,readers,_hR_,0,scan,token_string);
          case 3:
           var
            rest$5=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$5,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$6=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$7=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$8=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$9=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$9,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           switch(fmt$0[1][2])
            {case 5:
             case 8:
              var rest$11=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
              return pad_prec_scanf
                      (ib,
                       rest$11,
                       readers,
                       pad$5,
                       prec$4,
                       scan_caml_float,
                       token_float);
             case 6:
             case 7:
              var rest$12=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$12,readers,pad$6,prec$5,scan_hex_float,token_float);
             default:
              var rest$10=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$10,readers,pad$4,prec$3,scan_float,token_float)}
          case 9:
           var
            rest$13=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_h3_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_cu_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$13,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$14=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$14;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$15=fmt$0[2],str$0=fmt$0[1];
           iter$4(function(_h2_){return check_char(ib,_h2_)},str$0);
           var fmt$0=rest$15;
           continue;
          case 12:
           var rest$16=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$16;
           continue;
          case 13:
           var rest$17=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _hU_=format_of_string_fmtty(s,fmtty),fmt$3=_hU_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$17,readers)];
          case 14:
           var rest$18=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _hW_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=fmt$8,
              fmt$4=_hW_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _hV_=bad_input(msg$0),
              fmt$5=_hV_[2],
              fmt$4=_hV_[1]}
           return [0,
                   [0,fmt$4,s$0],
                   make_scanf(ib,concat_fmt(fmt$5,rest$18),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$19=fmt$0[2],
            formatting_lit=fmt$0[1],
            _hX_=string_of_formatting_lit(formatting_lit);
           iter$4(function(_h1_){return check_char(ib,_h1_)},_hX_);
           var fmt$0=rest$19;
           continue;
          case 18:
           var _hY_=fmt$0[1];
           if(0 === _hY_[0])
            {var rest$20=fmt$0[2],match$4=_hY_[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$20),fmt$0=fmt$10;
             continue}
           var rest$21=fmt$0[2],match$5=_hY_[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$21),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _hZ_=fmt$0[1],_h0_=fmt$0[3];
           if(typeof _h0_ !== "number" && 17 === _h0_[0])
            {var
              rest$23=_h0_[2],
              fmting_lit$0=_h0_[1],
              char_set$0=fmt$0[2],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_hZ_);
             scan_chars_in_char_set(char_set$0,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$23];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var
            rest$22=fmt$0[3],
            char_set=fmt$0[2],
            width=width_of_pad_opt(_hZ_);
           scan_chars_in_char_set(char_set,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,rest$22,readers)];
          case 21:
           var
            rest$24=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$24,readers)];
          case 22:
           var rest$25=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$25,readers)];
          case 23:
           var
            rest$26=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$26),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cz_];
          default:return invalid_arg(cst_scanf_bad_conversion_custo)}}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)return invalid_arg(cst_scanf_bad_conversion);
          caml_call3(scan,max_int,max_int,ib);
          var x=caml_call1(token,ib);
          return [0,x,make_scanf(ib,fmt,readers)]}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(pad[1])
           {var _hQ_=pad[2];
            if(typeof prec === "number")
             {if(prec)return invalid_arg(cst_scanf_bad_conversion$0);
              caml_call3(scan,_hQ_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            var p$0=prec[1];
            caml_call3(scan,_hQ_,p$0,ib);
            var x$2=caml_call1(token,ib);
            return [0,x$2,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion$1)}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _hP_=[0,make_scanf(ib,fmt,readers)],_hO_=_hP_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var switch$0=0;
          if
           (exc[1]
            !==
            Scan_failure
            &&
            exc[1]
            !==
            Failure
            &&
            exc
            !==
            End_of_file)
           {if(exc[1] !== Invalid_argument)throw exc;
            var
             msg=exc[2],
             _hN_=
              invalid_arg
               (symbol
                 (msg,symbol(cst_in_format,symbol(escaped$1(str),cst$88))));
            switch$0 = 1}
          if(! switch$0)var _hN_=[1,exc];
          var _hO_=_hN_}
        if(0 === _hO_[0]){var args=_hO_[1];return apply(f,args)}
        var exc=_hO_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _hM_=format_of_string_format(str,format),fmt=_hM_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {function _hL_(x){return x}
      return sscanf_format
              (symbol(cst$90,symbol(escaped$1(s),cst$89)),fmt,_hL_)}
    function unescaped(s)
     {function _hK_(x){return x}
      return caml_call1(sscanf(symbol(cst$92,symbol(s,cst$91)),_cA_),_hK_)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Stdlib_scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in$0,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(802,Stdlib_scanf,"Stdlib__scanf");
    function register(name,v){return caml_register_named_value(name,v)}
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Stdlib_callback=[0,register,register_exception];
    caml_register_global(803,Stdlib_callback,"Stdlib__callback");
    function copy$7(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_hH_=caml_ml_string_length(s) - 1 | 0,_hG_=0;
      if(! (_hH_ < 0))
       {var i=_hG_;
        for(;;)
         {var _hI_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _hI_ | 0;
          var _hJ_=i + 1 | 0;
          if(_hH_ !== i){var i=_hJ_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    function compare$13(x,y){return caml_string_compare(x,y)}
    var Vars=caml_call1(Stdlib_map[1],[0,compare$13]);
    function compare$14(x,y){return caml_string_compare(x,y)}
    var
     Meths=caml_call1(Stdlib_map[1],[0,compare$14]),
     compare$15=caml_int_compare,
     Labs=caml_call1(Stdlib_map[1],[0,compare$15]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _hA_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _hA_;
      var _hC_=len - 1 | 0,_hB_=0;
      if(! (_hC_ < 0))
       {var i=_hB_;
        for(;;)
         {var
           _hE_=(i * 2 | 0) + 3 | 0,
           _hD_=caml_check_bound(pub_labels,i)[1 + i];
          caml_check_bound(methods,_hE_)[1 + _hE_] = _hD_;
          var _hF_=i + 1 | 0;
          if(_hC_ !== i){var i=_hF_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_hy_=old_size < new_size?1:0;
      if(_hy_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _hz_=0}
      else
       var _hz_=_hy_;
      return _hz_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _hw_=caml_call2(Meths[28],name,table[3]);return _hw_}
      catch(_hx_)
       {_hx_ = caml_wrap_exception(_hx_);
        if(_hx_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _hx_}}
    function get_method_labels(table,names)
     {return map$6(function(_hv_){return get_method_label(table,_hv_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[28],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[1 + label]
                =
                element,
                0)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _ht_=assoc(label,table[6]);return _ht_}
      catch(_hu_)
       {_hu_ = caml_wrap_exception(_hu_);
        if(_hu_ === Not_found)
         return caml_check_bound(table[2],label)[1 + label];
        throw _hu_}}
    function to_list$3(arr){return 0 === arr?0:to_list$1(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$3(vars),
       virt_meths$0=to_list$3(virt_meths),
       concr_meths$0=to_list$3(concr_meths),
       virt_meth_labs=
        map$3
         (function(_hs_){return get_method_label(table,_hs_)},virt_meths$0),
       concr_meth_labs=
        map$3
         (function(_hr_){return get_method_label(table,_hr_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _hi_=Vars[1],_hj_=table[7];
      function _hk_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_hk_,_hj_,_hi_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _hn_=by_label[1];
          try
           {var _hp_=caml_call2(Labs[28],label,table[4]),_ho_=_hp_}
          catch(_hq_)
           {_hq_ = caml_wrap_exception(_hq_);
            if(_hq_ !== Not_found)throw _hq_;
            var _ho_=1}
          by_label[1] = caml_call3(Labs[4],label,_ho_,_hn_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _hl_=0,_hm_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _hm_,
        _hl_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left$0
       (function(s,v)
         {var _hh_=caml_call2(Vars[28],v,table[7]);
          return caml_call3(Vars[4],v,_hh_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _hg_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _hg_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _he_=caml_call2(Vars[28],name,table[7]);return _he_}
      catch(_hf_)
       {_hf_ = caml_wrap_exception(_hf_);
        if(_hf_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$93))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _hf_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _g8_=nmeths - 1 | 0,
       _g7_=0;
      if(! (_g8_ < 0))
       {var i$0=_g7_;
        for(;;)
         {var
           _hc_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[1 + i$0]);
          caml_check_bound(res,i$0)[1 + i$0] = _hc_;
          var _hd_=i$0 + 1 | 0;
          if(_g8_ !== i$0){var i$0=_hd_;continue}
          break}}
      var _g__=nvals - 1 | 0,_g9_=0;
      if(! (_g__ < 0))
       {var i=_g9_;
        for(;;)
         {var
           _ha_=i + nmeths | 0,
           _g$_=new_variable(table,caml_check_bound(vals,i)[1 + i]);
          caml_check_bound(res,_ha_)[1 + _ha_] = _g$_;
          var _hb_=i + 1 | 0;
          if(_g__ !== i){var i=_hb_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _g5_=caml_call2(Vars[28],name,table[7]);return _g5_}
      catch(_g6_)
       {_g6_ = caml_wrap_exception(_g6_);
        if(_g6_ === Not_found)throw [0,Assert_failure,_cB_];
        throw _g6_}}
    function get_variables(table,names)
     {return map$6(function(_g4_){return get_variable(table,_g4_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(0 === public_methods)return new_table([0]);
      var
       tags=map$6(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _gZ_=0,
       _g0_=to_array(concr_meths),
       _g1_=
        [0,
         map$6
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_g0_),
         _gZ_],
       _g2_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$6(function(_g3_){return get_variable(cla,_g3_)},_g2_),
                 _g1_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_gY_=0 !== inits?1:0;
      return _gY_?iter_f(obj,inits):_gY_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initiali(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_cF_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_gU_=0;
      if(! (n < 0))
       {var i=_gU_;
        for(;;)
         {var _gW_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[1 + i],_gW_,0];
          var _gX_=i + 1 | 0;
          if(n !== i){var i=_gX_;continue}
          break}}
      var _gV_=r[1];
      if(tables){tables[2] = _gV_;return res}
      throw [0,Assert_failure,_cC_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[1 + i],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cH_]}
                if(tables$0)
                 {var _gT_=tables$0[3];
                  if(_gT_){var tables$0=_gT_;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_cD_]}
                throw [0,Assert_failure,_cG_]}
              throw [0,Assert_failure,_cE_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table),switch$0=0;
      if
       (0
        !==
        (n % 2 | 0)
        &&
        !
        ((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n))
       {var n$0=new_method(table);switch$0 = 1}
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[1 + n$0] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _gN_=i[1],
           label=caml_check_bound(methods,_gN_)[1 + _gN_],
           next=
            function(param)
             {i[1]++;
              var _gS_=i[1];
              return caml_check_bound(methods,_gS_)[1 + _gS_]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[1 + n]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[1 + e][1 + n]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][1 + n],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[1 + n] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[1 + n])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[1 + e][1 + n])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][1 + n],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[1 + n])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[1 + e][1 + n])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][1 + n],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[1 + n],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[1 + e][1 + n],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][1 + n],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + m])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + e][1 + m])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _gQ_=caml_call1(obj[1][1 + m],obj);
                     return caml_call2(obj[1][1 + n],obj,_gQ_)}}
                 (n$15,m$1);
              break;
             case 20:
              var
               m$2=next(0),
               x$9=next(0),
               c=new_cache(table),
               clo$0=
                function(m,x,c)
                  {return function(obj)
                    {return caml_call2(caml_get_public_method(x,m,0),x,c)}}
                 (m$2,x$9,c);
              break;
             case 21:
              var
               m$3=next(0),
               n$16=next(0),
               c$0=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _gP_=obj[1 + n];
                     return caml_call2(caml_get_public_method(_gP_,m,0),_gP_,c)}}
                 (m$3,n$16,c$0);
              break;
             case 22:
              var
               m$4=next(0),
               e$4=next(0),
               n$17=next(0),
               c$1=new_cache(table),
               clo$0=
                function(m,e,n,c)
                  {return function(obj)
                    {var _gO_=obj[1 + e][1 + n];
                     return caml_call2(caml_get_public_method(_gO_,m,0),_gO_,c)}}
                 (m$4,e$4,n$17,c$1);
              break;
             default:
              var
               m$5=next(0),
               n$18=next(0),
               c$2=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _gR_=caml_call1(obj[1][1 + n],obj);
                     return caml_call2(caml_get_public_method(_gR_,m,0),_gR_,c)}}
                 (m$5,n$18,c$2)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$7,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initiali,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(804,CamlinternalOO,"CamlinternalOO");
    var Stdlib_oo=[0,copy$7,public_method_label,public_method_label];
    caml_register_global(805,Stdlib_oo,"Stdlib__oo");
    var
     update_mod=runtime.caml_CamlinternalMod_update_mod,
     init_mod=runtime.caml_CamlinternalMod_init_mod,
     CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(806,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Stdlib_hashtbl[1],0,17);
      iter$2
       (function(s){return caml_call3(Stdlib_hashtbl[5],kwd_table,s,[0,s])},
        keywords);
      function ident_or_keyword(id)
       {try
         {var _gL_=caml_call2(Stdlib_hashtbl[6],kwd_table,id);return _gL_}
        catch(_gM_)
         {_gM_ = caml_wrap_exception(_gM_);
          if(_gM_ === Not_found)return [1,id];
          throw _gM_}}
      function keyword_or_error(c)
       {var s=make$1(1,c);
        try
         {var _gJ_=caml_call2(Stdlib_hashtbl[6],kwd_table,s);return _gJ_}
        catch(_gK_)
         {_gK_ = caml_wrap_exception(_gK_);
          if(_gK_ === Not_found)
           throw [0,Error,symbol(cst_Illegal_character,s)];
          throw _gK_}}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _gI_=match$1[1];
                    if(41 === _gI_){junk(strm);return 0}
                    if(42 === _gI_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _gF_=match[1];
          if(58 <= _gF_)
           {var switcher=_gF_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _gF_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _gG_=match$0[1],switcher$0=_gG_ - 48 | 0;
               if(! (9 < switcher$0 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _gH_=match$1[1],switcher$1=_gH_ - 48 | 0;
                   if(! (9 < switcher$1 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_gF_ - 48 | 0) * 100 | 0)
                               +
                               ((_gG_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_gH_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$99]}}
             throw [0,Error,cst$98]}
          junk(strm);
          return _gF_}
        throw Failure$0}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gE_=match[1],switcher=_gE_ - 48 | 0;
            if(! (9 < switcher >>> 0)){junk(strm);store(_gE_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _gD_=match[1],switch$0=0;
          if(43 !== _gD_ && 45 !== _gD_)switch$0 = 1;
          if(! switch$0)
           {junk(strm);store(_gD_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _gA_=match[1];
            if(58 <= _gA_)
             {var switch$0=0;
              if(69 === _gA_ || 101 === _gA_)switch$0 = 1;
              if(switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _gA_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _gB_=match$0[1],_gC_=_gB_ - 69 | 0;
                    if(32 < _gC_ >>> 0)
                     {var switcher=_gC_ + 21 | 0;
                      if(! (9 < switcher >>> 0)){junk(s);store(_gB_);continue}}
                    else
                     {var switcher$0=_gC_ - 1 | 0;
                      if(30 < switcher$0 >>> 0)
                       {junk(s);store(69);return exponent_part(s)}}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _gA_){junk(s);store(_gA_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gy_=match[1],switch$0=0;
            if(94 <= _gy_)
             {var _gz_=_gy_ - 95 | 0;
              if(30 < _gz_ >>> 0)
               {if(! (32 <= _gz_))switch$0 = 1}
              else
               if(29 === _gz_)switch$0 = 1}
            else
             if(65 <= _gy_)
              {if(92 === _gy_)switch$0 = 1}
             else
              if(33 <= _gy_)
               switch(_gy_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:switch$0 = 1;break
                 }
            if(switch$0){junk(strm);store(_gy_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _gx_=match[1],switcher=_gx_ - 48 | 0;
          if(! (9 < switcher >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_gx_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gv_=match[1],switch$0=0;
            if(91 <= _gv_)
             {var _gw_=_gv_ - 95 | 0;
              if(27 < _gw_ >>> 0)
               {if(97 <= _gw_)switch$0 = 1}
              else
               if(1 !== _gw_)switch$0 = 1}
            else
             if(48 <= _gv_)
              {if(6 < (_gv_ - 58 | 0) >>> 0)switch$0 = 1}
             else
              if(39 === _gv_)switch$0 = 1;
            if(switch$0){junk(strm);store(_gv_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _gl_=match[1],switch$0=0;
            if(124 <= _gl_)
             {if(127 <= _gl_)
               {if(192 <= _gl_)switch$0 = 1}
              else
               if(125 !== _gl_)switch$0 = 2}
            else
             {var _gm_=_gl_ - 65 | 0;
              if(57 < _gm_ >>> 0)
               {if(! (58 <= _gm_))
                 {var switcher=_gm_ + 65 | 0;
                  switch(switcher)
                   {case 34:
                     junk(strm);
                     reset_buffer(0);
                     for(;;)
                      {var match$1=peek$0(strm);
                       if(match$1)
                        {var _go_=match$1[1];
                         if(34 === _go_){junk(strm);return [0,[4,get_string(0)]]}
                         if(92 === _go_)
                          {junk(strm);
                           try
                            {var c$0=escape(strm)}
                           catch(_gu_)
                            {_gu_ = caml_wrap_exception(_gu_);
                             if(_gu_ === Failure$0)throw [0,Error,cst$96];
                             throw _gu_;
                             var _gr_=_gu_}
                           store(c$0);
                           continue}
                         junk(strm);
                         store(_go_);
                         continue}
                       throw Failure$0}
                    case 39:
                     junk(strm);
                     try
                      {var match$2=peek$0(strm);
                       if(! match$2)throw Failure$0;
                       var _gp_=match$2[1];
                       if(92 === _gp_)
                        {junk(strm);
                         try
                          {var _gq_=escape(strm)}
                         catch(_gt_)
                          {_gt_ = caml_wrap_exception(_gt_);
                           if(_gt_ === Failure$0)throw [0,Error,cst$97];
                           throw _gt_}
                         var c=_gq_}
                       else
                        {junk(strm);var c=_gp_}}
                     catch(_gs_)
                      {_gs_ = caml_wrap_exception(_gs_);
                       if(_gs_ === Failure$0)throw [0,Error,cst$94];
                       throw _gs_}
                     var match$0=peek$0(strm);
                     if(match$0 && 39 === match$0[1])
                      {junk(strm);return [0,[5,c]]}
                     throw [0,Error,cst$95];
                    case 40:
                     junk(strm);
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return maybe_comment(counter$0,strm)}
                     return caml_trampoline_return(maybe_comment,[0,strm]);
                    case 45:junk(strm);return neg_number(strm);
                    case 9:
                    case 10:
                    case 12:
                    case 13:
                    case 26:
                    case 32:junk(strm);continue;
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                     junk(strm);reset_buffer(0);store(_gl_);return number(strm);
                    case 33:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 42:
                    case 43:
                    case 47:
                    case 58:
                    case 60:
                    case 61:
                    case 62:
                    case 63:
                    case 64:switch$0 = 2;break
                    }}}
              else
               {var _gn_=_gm_ - 26 | 0;
                if(5 < _gn_ >>> 0)
                 switch$0 = 1;
                else
                 switch(_gn_)
                  {case 4:switch$0 = 1;break;case 1:case 3:switch$0 = 2;break}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_gl_)];
              case 1:
               junk(strm);reset_buffer(0);store(_gl_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_gl_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match && 42 === match[1])
         {junk(strm);
          comment(strm);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return next_token$0(counter$0,strm)}
          return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Stdlib_genlex=[0,make_lexer];
    caml_register_global(807,Stdlib_genlex,"Stdlib__genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_gk_){return caml_call1(_b$_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Stdlib_hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x) && ! (max_array_length < (x * 2 | 0)))
           {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _gi_=caml_obj_tag(prng),
            _gj_=250 === _gi_?prng[1]:246 === _gi_?force_lazy_block(prng):prng,
            seed=caml_call1(_b$_[4],_gj_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_gg_=len - 1 | 0,_gf_=0;
        if(! (_gg_ < 0))
         {var i=_gf_;
          for(;;)
           {caml_check_bound(h[2],i)[1 + i] = 0;
            var _gh_=i + 1 | 0;
            if(_gg_ !== i){var i=_gh_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _gc_=init[4],_gd_=init[3],_ge_=copy$1(init[2]);
        return [0,init[1],_ge_,_gd_,_gc_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hkey=param$0[1],rest=param$0[3],c=param$0[2];
              if(caml_call1(H[7],c))
               {var rest$0=param$0[3],c$0=param$0[2];
                return [0,hkey,c$0,do_bucket(rest$0)]}
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_f$_=d.length - 1 - 1 | 0,_f__=0;
        if(! (_f$_ < 0))
         {var i=_f__;
          for(;;)
           {var _ga_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _ga_;
            var _gb_=i + 1 | 0;
            if(_f$_ !== i){var i=_gb_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _f3_=nsize < max_array_length?1:0,
         _f4_=_f3_?(osize >>> 1 | 0) <= h[1]?1:0:_f3_;
        if(_f4_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var
                 nidx=key_index(h,hkey),
                 _f9_=[0,hkey,data,caml_check_bound(ndata,nidx)[1 + nidx]];
                caml_check_bound(ndata,nidx)[1 + nidx] = _f9_;
                return 0}
              return 0},
           _f6_=osize - 1 | 0,
           _f5_=0;
          if(! (_f6_ < 0))
           {var i=_f5_;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[1 + i]);
              var _f8_=i + 1 | 0;
              if(_f6_ !== i){var i=_f8_;continue}
              break}}
          var _f7_=0}
        else
         var _f7_=_f4_;
        return _f7_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _f2_=h[2].length - 1 << 1 < h[1]?1:0;
        return _f2_?resize(h):_f2_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              var next$0=param$0[3],c$0=param$0[2];
              return [0,hk,c$0,remove_bucket(next$0)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _f1_=remove_bucket(caml_check_bound(h[2],i)[1 + i]);
        caml_check_bound(h[2],i)[1 + i] = _f1_;
        return 0}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _f0_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_f0_)[1 + _f0_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _fZ_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_fZ_)[1 + _fZ_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],rest=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$1=param$0[3],param$0=param$1;
              continue}
            return 0}}
        var _fY_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_fY_)[1 + _fY_])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(match){var param$0=next;continue}
                return caml_call3(H[6],c,key,info)}
              var param$1=param$0[3],param$0=param$1;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[1 + i];
        try
         {var _fW_=replace_bucket(l);return _fW_}
        catch(_fX_)
         {_fX_ = caml_wrap_exception(_fX_);
          if(_fX_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[1 + i] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _fV_=h[2].length - 1 << 1 < h[1]?1:0;
            return _fV_?resize(h):_fV_}
          throw _fX_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _fU_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_fU_)[1 + _fU_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(match){var param=rest;continue}
              return 1}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function iter$0(f,h)
       {var d$0=h[2],_fS_=d$0.length - 1 - 1 | 0,_fR_=0;
        if(! (_fS_ < 0))
         {var i=_fR_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[1 + i],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1];caml_call2(f,k,d);switch$0 = 1}
                var param=rest;
                continue}
              var _fT_=i + 1 | 0;
              if(_fS_ !== i){var i=_fT_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_fO_=d$0.length - 1 - 1 | 0,_fN_=0;
        if(! (_fO_ < 0))
         {var i=_fN_;
          a:
          for(;;)
           {var
             _fP_=accu$1[1],
             b$0=caml_check_bound(d$0,i)[1 + i],
             b=b$0,
             accu=_fP_;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1],accu$0=caml_call3(f,k,d,accu);
                  switch$0 = 1}
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _fQ_=i + 1 | 0;
              if(_fO_ !== i){var i=_fQ_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                if(match$1)
                 {var new_d=match$1[1];
                  caml_call3(H[6],c,k,new_d);
                  return [0,hk,c,do_bucket(rest)]}
                var param$0=rest;
                continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_fK_=d.length - 1 - 1 | 0,_fJ_=0;
        if(! (_fK_ < 0))
         {var i=_fJ_;
          for(;;)
           {var _fL_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _fL_;
            var _fM_=i + 1 | 0;
            if(_fK_ !== i){var i=_fM_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _fF_=h[2],
         _fG_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length(0,b))},_fG_,_fF_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _fH_=h[2];
        iter$5
         (function(b)
           {var
             l=bucket_length(0,b),
             _fI_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
            caml_check_bound(histo,l)[1 + l] = _fI_;
            return 0},
          _fH_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$1=param$0[3],param$0=param$1;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _fB_=h[2],
         _fC_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length_alive(0,b))},_fC_,_fB_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _fD_=h[2];
        iter$5
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            var _fE_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
            caml_check_bound(histo,l)[1 + l] = _fE_;
            return 0},
          _fD_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      function to_seq(tbl)
       {var tbl_data=tbl[2];
        function aux(i,buck,param)
         {var i$0=i,buck$0=buck;
          for(;;)
           {if(buck$0)
             {var
               next=buck$0[3],
               c=buck$0[2],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var data=match$0[1],key=match[1];
                return [0,
                        [0,key,data],
                        function(_fA_){return aux(i$0,next,_fA_)}]}
              var buck$0=next;
              continue}
            if(i$0 === tbl_data.length - 1)return 0;
            var
             buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
             i$1=i$0 + 1 | 0,
             i$0=i$1,
             buck$0=buck$1;
            continue}}
        var _fx_=0,_fy_=0;
        return function(_fz_){return aux(_fy_,_fx_,_fz_)}}
      function to_seq_keys(m)
       {var _ft_=to_seq(m);
        function _fu_(_fw_){return _fw_[1]}
        return function(_fv_){return map(_fu_,_ft_,_fv_)}}
      function to_seq_values(m)
       {var _fp_=to_seq(m);
        function _fq_(_fs_){return _fs_[2]}
        return function(_fr_){return map(_fq_,_fp_,_fr_)}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$0,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_t_[1],1)}
    function get_key$0(t){return caml_call2(_t_[3],t,0)}
    function get_key_copy$0(t){return caml_call2(_t_[4],t,0)}
    function set_key$0(t,k){return caml_call3(_t_[5],t,0,k)}
    function unset_key$0(t){return caml_call2(_t_[6],t,0)}
    function check_key$0(t){return caml_call2(_t_[7],t,0)}
    function blit_key$0(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_t_[9],t)}
    function get_data_copy(t){return caml_call1(_t_[10],t)}
    function set_data(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data(t){return caml_call1(_t_[12],t)}
    function check_data(t){return caml_call1(_t_[13],t)}
    function blit_data(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$5(0);set_data(c,d);set_key$0(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key$0(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key$0(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,
                create,
                hash,
                equal,
                get_data$1,
                get_key$0,
                set_key_data,
                check_key$0])}
    function Make$2(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _fo_=include[1];
      function create(sz){return caml_call2(_fo_,_cI_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$6(param){return caml_call1(_t_[1],2)}
    function get_key1(t){return caml_call2(_t_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_t_[4],t,0)}
    function set_key1(t,k){return caml_call3(_t_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_t_[6],t,0)}
    function check_key1(t){return caml_call2(_t_[7],t,0)}
    function get_key2(t){return caml_call2(_t_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_t_[4],t,1)}
    function set_key2(t,k){return caml_call3(_t_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_t_[6],t,1)}
    function check_key2(t){return caml_call2(_t_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_t_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_t_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_t_[9],t)}
    function get_data_copy$0(t){return caml_call1(_t_[10],t)}
    function set_data$0(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data$0(t){return caml_call1(_t_[12],t)}
    function check_data$0(t){return caml_call1(_t_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$6(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _fn_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _fn_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2$0=match$0[1],k1$0=match[1];
          if(caml_call2(H1[1],k1,k1$0) && caml_call2(H2[1],k2,k2$0))return 0;
          return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _fm_=check_key1(c);return _fm_?check_key2(c):_fm_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$3(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_fk_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_fk_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _fl_=include[1];
      function create(sz){return caml_call2(_fl_,_cJ_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$7(n){return caml_call1(_t_[1],n)}
    function length$6(k){return caml_call1(_t_[2],k)}
    function get_key$1(t,n){return caml_call2(_t_[3],t,n)}
    function get_key_copy$1(t,n){return caml_call2(_t_[4],t,n)}
    function set_key$1(t,n,k){return caml_call3(_t_[5],t,n,k)}
    function unset_key$1(t,n){return caml_call2(_t_[6],t,n)}
    function check_key$1(t,n){return caml_call2(_t_[7],t,n)}
    function blit_key$1(t1,o1,t2,o2,l)
     {return caml_call5(_t_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_t_[9],t)}
    function get_data_copy$1(t){return caml_call1(_t_[10],t)}
    function set_data$1(t,d){return caml_call2(_t_[11],t,d)}
    function unset_data$1(t){return caml_call1(_t_[12],t)}
    function check_data$1(t){return caml_call1(_t_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_t_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$7(k.length - 1);
        set_data$1(c,d);
        var _fi_=k.length - 1 - 1 | 0,_fh_=0;
        if(! (_fi_ < 0))
         {var i=_fh_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _fj_=i + 1 | 0;
            if(_fi_ !== i){var i=_fj_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_fd_=k.length - 1 - 1 | 0,_fc_=0;
        if(! (_fd_ < 0))
         {var i=_fc_;
          for(;;)
           {var _fe_=h[1],_ff_=caml_check_bound(k,i)[1 + i];
            h[1] = (caml_call2(H[2],seed,_ff_) * 65599 | 0) + _fe_ | 0;
            var _fg_=i + 1 | 0;
            if(_fd_ !== i){var i=_fg_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$1(c,i);
            if(match)
             {var ki=match[1],_fb_=caml_check_bound(k,i)[1 + i];
              if(caml_call2(H[1],_fb_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$1(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$1(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[1 + i] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _e$_=k.length - 1 - 1 | 0,_e__=0;
        if(! (_e$_ < 0))
         {var i=_e__;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _fa_=i + 1 | 0;
            if(_e$_ !== i){var i=_fa_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _e7_=i < 0?1:0;
          if(_e7_)
           var _e8_=_e7_;
          else
           {var _e9_=check_key$1(c,i);
            if(_e9_){var i$0=i - 1 | 0,i=i$0;continue}
            var _e8_=_e9_}
          return _e8_}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$4(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _e6_=include[1];
      function create(sz){return caml_call2(_e6_,_cK_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    var
     Stdlib_ephemeron=
      [0,
       [0,
        create$5,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$2,
        MakeSeeded$1],
       [0,
        create$6,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$3,
        MakeSeeded$2],
       [0,
        create$7,
        get_key$1,
        get_key_copy$1,
        set_key$1,
        unset_key$1,
        check_key$1,
        blit_key$1,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$4,
        MakeSeeded$3],
       [0,
        function(_e5_)
         {return MakeSeeded$0
                  ([0,_e5_[3],_e5_[1],_e5_[2],_e5_[5],_e5_[4],_e5_[6],_e5_[7]])}]];
    caml_register_global(808,Stdlib_ephemeron,"Stdlib__ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$100))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$101))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _e3_=caml_ml_string_length(n) < 1?1:0,
       _e4_=_e3_ || (47 !== caml_string_get(n,0)?1:0);
      return _e4_}
    function is_implicit(n)
     {var _eY_=is_relative(n);
      if(_eY_)
       {var
         _eZ_=caml_ml_string_length(n) < 2?1:0,
         _e0_=_eZ_ || caml_string_notequal(sub$0(n,0,2),cst$103);
        if(_e0_)
         var
          _e1_=caml_ml_string_length(n) < 3?1:0,
          _e2_=_e1_ || caml_string_notequal(sub$0(n,0,3),cst$102);
        else
         var _e2_=_e0_}
      else
       var _e2_=_eY_;
      return _e2_}
    function check_suffix(name,suff)
     {var
       _eW_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0,
       _eX_=
        _eW_
         ?caml_string_equal
           (sub$0
             (name,
              caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
              caml_ml_string_length(suff)),
            suff)
         :_eW_;
      return _eX_}
    function chop_suffix_opt(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var r=sub$0(filename,len_f - len_s | 0,len_s);
        return caml_string_equal(r,suffix)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cS_=caml_sys_getenv(cst_TMPDIR),_cL_=_cS_}
    catch(_eV_)
     {_eV_ = caml_wrap_exception(_eV_);
      if(_eV_ !== Not_found)throw _eV_;
      var _cL_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,39);
      var _eT_=l - 1 | 0,_eS_=0;
      if(! (_eT_ < 0))
       {var i=_eS_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _eU_=i + 1 | 0;
          if(_eT_ !== i){var i=_eU_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function quote_command(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _eM_=caml_equal(stderr,stdout)?cst_2_1:symbol(cst_2,quote(f)),
        _eN_=_eM_;
      else
       var _eN_=cst$109;
      if(stdout)
       var f$0=stdout[1],_eO_=symbol(cst$104,quote(f$0));
      else
       var _eO_=cst$108;
      var _eP_=symbol(_eO_,_eN_);
      if(stdin)
       var f$1=stdin[1],_eQ_=symbol(cst$105,quote(f$1));
      else
       var _eQ_=cst$107;
      var _eR_=symbol(_eQ_,_eP_);
      return symbol(concat$0(cst$106,map$3(quote,[0,cmd,args])),_eR_)}
    function basename(_eL_)
     {return generic_basename(is_dir_sep,current_dir_name,_eL_)}
    function dirname(_eK_)
     {return generic_dirname(is_dir_sep,current_dir_name,_eK_)}
    var
     Unix=
      [0,
       null$0,
       current_dir_name,
       parent_dir_name,
       dir_sep,
       is_dir_sep,
       is_relative,
       is_implicit,
       check_suffix,
       chop_suffix_opt,
       _cL_,
       quote,
       quote_command,
       basename,
       dirname];
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_eH_=47 === c?1:0;
      if(_eH_)
       var _eI_=_eH_;
      else
       var _eJ_=92 === c?1:0,_eI_=_eJ_ || (58 === c?1:0);
      return _eI_}
    function is_relative$0(n)
     {var
       _eB_=caml_ml_string_length(n) < 1?1:0,
       _eC_=_eB_ || (47 !== caml_string_get(n,0)?1:0);
      if(_eC_)
       {var
         _eD_=caml_ml_string_length(n) < 1?1:0,
         _eE_=_eD_ || (92 !== caml_string_get(n,0)?1:0);
        if(_eE_)
         var
          _eF_=caml_ml_string_length(n) < 2?1:0,
          _eG_=_eF_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _eG_=_eE_}
      else
       var _eG_=_eC_;
      return _eG_}
    function is_implicit$0(n)
     {var _es_=is_relative$0(n);
      if(_es_)
       {var
         _et_=caml_ml_string_length(n) < 2?1:0,
         _eu_=_et_ || caml_string_notequal(sub$0(n,0,2),cst$113);
        if(_eu_)
         {var
           _ev_=caml_ml_string_length(n) < 2?1:0,
           _ew_=_ev_ || caml_string_notequal(sub$0(n,0,2),cst$112);
          if(_ew_)
           {var
             _ex_=caml_ml_string_length(n) < 3?1:0,
             _ey_=_ex_ || caml_string_notequal(sub$0(n,0,3),cst$111);
            if(_ey_)
             var
              _ez_=caml_ml_string_length(n) < 3?1:0,
              _eA_=_ez_ || caml_string_notequal(sub$0(n,0,3),cst$110);
            else
             var _eA_=_ey_}
          else
           var _eA_=_ew_}
        else
         var _eA_=_eu_}
      else
       var _eA_=_es_;
      return _eA_}
    function check_suffix$0(name,suff)
     {var _ep_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_ep_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _eq_=lowercase_ascii$1(suff),
        _er_=caml_string_equal(lowercase_ascii$1(s),_eq_);
      else
       var _er_=_ep_;
      return _er_}
    function chop_suffix_opt$0(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var
         r=sub$0(filename,len_f - len_s | 0,len_s),
         _eo_=lowercase_ascii$1(suffix);
        return caml_string_equal(lowercase_ascii$1(r),_eo_)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cR_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cR_}
    catch(_en_)
     {_en_ = caml_wrap_exception(_en_);
      if(_en_ !== Not_found)throw _en_;
      var temp_dir_name=cst$114}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _el_=1;
        if(! (n < 1))
         {var j=_el_;
          for(;;)
           {add_char(b,92);
            var _em_=j + 1 | 0;
            if(n !== j){var j=_em_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _ej_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_ej_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_ej_,i$0])}
          if(92 === c)
           {var _ek_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_ek_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_ek_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _ei_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_ei_)}
            return caml_trampoline_return(loop$0,[0,_ei_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function quote_cmd_filename(f)
     {if(! contains$0(f,34) && ! contains$0(f,37))
       return contains$0(f,32)?symbol(cst$116,symbol(f,cst$115)):f;
      return failwith(symbol(cst_Filename_quote_command_bad,f))}
    function quote_command$0(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _d$_=
         caml_equal(stderr,stdout)
          ?cst_2_1$0
          :symbol(cst_2$0,quote_cmd_filename(f)),
        _ea_=_d$_;
      else
       var _ea_=cst$125;
      var _eb_=[0,_ea_,_cM_];
      if(stdout)
       var f$0=stdout[1],_ec_=symbol(cst$117,quote_cmd_filename(f$0));
      else
       var _ec_=cst$124;
      var _ed_=[0,_ec_,_eb_];
      if(stdin)
       var f$1=stdin[1],_ee_=symbol(cst$118,quote_cmd_filename(f$1));
      else
       var _ee_=cst$123;
      var
       s=concat$0(cst$119,map$3(quote$0,args)),
       b=create$2(caml_ml_string_length(s) + 20 | 0),
       _ef_=[0,_ee_,_ed_];
      iter$4
       (function(c)
         {var switch$0=0;
          if(62 <= c)
           {var _eh_=c - 63 | 0;
            if(60 < _eh_ >>> 0)
             {if(! (62 <= _eh_))switch$0 = 1}
            else
             if(31 === _eh_)switch$0 = 1}
          else
           if(42 <= c)
            {if(60 === c)switch$0 = 1}
           else
            if(33 <= c)
             switch(c - 33 | 0)
              {case 2:case 3:case 6:break;default:switch$0 = 1}
          return switch$0?(add_char(b,94),add_char(b,c)):add_char(b,c)},
        s);
      var _eg_=[0,cst$120,[0,contents(b),_ef_]];
      return concat$0(cst$122,[0,cst$121,[0,quote_cmd_filename(cmd),_eg_]])}
    function drive_and_path(s)
     {var _d7_=2 <= caml_ml_string_length(s)?1:0;
      if(_d7_)
       {var param=caml_string_get(s,0),switch$0=0;
        if(91 <= param)
         {if(! (25 < (param - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= param)switch$0 = 1;
        var _d8_=switch$0?1:0,_d9_=_d8_?58 === caml_string_get(s,1)?1:0:_d8_}
      else
       var _d9_=_d7_;
      if(_d9_)
       {var _d__=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_d__]}
      return [0,cst$126,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return symbol(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    var
     Win32=
      [0,
       null$1,
       current_dir_name$0,
       parent_dir_name$0,
       dir_sep$0,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name,
       quote$0,
       quote_command$0,
       basename$0,
       dirname$0];
    function basename$1(_d6_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_d6_)}
    function dirname$1(_d5_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_d5_)}
    var
     Cygwin=
      [0,
       null$2,
       current_dir_name$1,
       parent_dir_name$1,
       dir_sep$1,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       _cL_,
       quote,
       quote_command,
       basename$1,
       dirname$1],
     Sysdeps=
      caml_string_notequal(os_type,cst_Cygwin)
       ?caml_string_notequal(os_type,cst_Win32)?Unix:Win32
       :Cygwin,
     null$3=Sysdeps[1],
     current_dir_name$2=Sysdeps[2],
     parent_dir_name$2=Sysdeps[3],
     dir_sep$2=Sysdeps[4],
     is_dir_sep$1=Sysdeps[5],
     is_relative$1=Sysdeps[6],
     is_implicit$1=Sysdeps[7],
     check_suffix$1=Sysdeps[8],
     chop_suffix_opt$1=Sysdeps[9],
     temp_dir_name$0=Sysdeps[10],
     quote$1=Sysdeps[11],
     quote_command$1=Sysdeps[12],
     basename$2=Sysdeps[13],
     dirname$2=Sysdeps[14];
    function concat$3(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l && ! is_dir_sep$1(dirname,l - 1 | 0))
       return symbol(dirname,symbol(dir_sep$2,filename));
      return symbol(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1 && ! is_dir_sep$1(name,i$1))
         {if(46 === caml_string_get(name,i$1))
           {var i$2=i$1 - 1 | 0,i=i$2;
            for(;;)
             {if(0 <= i && ! is_dir_sep$1(name,i))
               {if(46 === caml_string_get(name,i))
                 {var i$0=i - 1 | 0,i=i$0;continue}
                return caml_ml_string_length(name) - i$1 | 0}
              return 0}}
          var i$3=i$1 - 1 | 0,i$1=i$3;
          continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$127:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_d4_){return caml_call1(_b$_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _d2_=caml_obj_tag(prng$0),
       _d3_=
        250 === _d2_?prng$0[1]:246 === _d2_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_b$_[4],_d3_) & 16777215;
      return concat$3(temp_dir,caml_call3(sprintf(_cN_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cO_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_d0_,_dZ_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cP_;
      if(_d0_)var sth$0=_d0_[1],perms=sth$0;else var perms=384;
      if(_dZ_)
       var sth$1=_dZ_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _d1_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _d1_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Stdlib_filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$3,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       chop_suffix_opt$1,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       null$3,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1,
       quote_command$1];
    caml_register_global(809,Stdlib_filename,"Stdlib__filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$4(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$4,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0.)return i;
      if(i == 0.)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1. + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1. + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0. && x[2] == 0.)return _cQ_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
      if(0. <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0. <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _dY_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_dY_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Stdlib_complex=
      [0,
       zero$4,
       one$4,
       i,
       neg,
       conj,
       add$1,
       sub$4,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(810,Stdlib_complex,"Stdlib__complex");
    var
     Stdlib_arrayLabels=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$1,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$6,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       for_all2$0,
       exists2$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(811,Stdlib_arrayLabels,"Stdlib__arrayLabels");
    var
     Stdlib_listLabels=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons$0,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       equal$5,
       compare$5,
       iter$2,
       iteri,
       map$3,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(812,Stdlib_listLabels,"Stdlib__listLabels");
    var
     Stdlib_bytesLabels=
      [0,
       make$0,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$4,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$6,
       equal$6,
       unsafe_to_string,
       unsafe_of_string,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(813,Stdlib_bytesLabels,"Stdlib__bytesLabels");
    var
     Stdlib_stringLabels=
      [0,
       make$1,
       init$1,
       concat$0,
       equal$7,
       compare$7,
       contains_from$0,
       rcontains_from$0,
       contains$0,
       sub$0,
       split_on_char,
       map$5,
       mapi$1,
       trim$0,
       escaped$1,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       iter$4,
       iteri$1,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       to_seq$3,
       to_seqi$0,
       of_seq$1,
       blit$0,
       copy$0,
       fill,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0];
    caml_register_global(814,Stdlib_stringLabels,"Stdlib__stringLabels");
    var Stdlib_moreLabels=[0,Stdlib_hashtbl,Stdlib_map,Stdlib_set];
    caml_register_global(815,Stdlib_moreLabels,"Stdlib__moreLabels");
    var Stdlib_stdLabels=[0];
    caml_register_global(816,Stdlib_stdLabels,"Stdlib__stdLabels");
    var
     float32=0,
     float64=1,
     int8_signed=2,
     int8_unsigned=3,
     int16_signed=4,
     int16_unsigned=5,
     int32$1=6,
     int64$1=7,
     int$2=8,
     nativeint$1=9,
     complex32=10,
     complex64=11,
     char$0=12;
    function kind_size_in_bytes(param)
     {switch(param)
       {case 0:return 4;
        case 1:return 8;
        case 2:return 1;
        case 3:return 1;
        case 4:return 2;
        case 5:return 2;
        case 6:return 4;
        case 7:return 8;
        case 8:return 4;
        case 9:return 4;
        case 10:return 8;
        case 11:return 16;
        default:return 1}}
    var c_layout=0,fortran_layout=1;
    function cloop(arr,idx,f,col,max)
     {if(col === idx.length - 1)
       return caml_ba_set_generic(arr,idx,caml_call1(f,idx));
      var _dW_=caml_check_bound(max,col)[1 + col] - 1 | 0,_dV_=0;
      if(! (_dW_ < 0))
       {var j=_dV_;
        for(;;)
         {caml_check_bound(idx,col)[1 + col] = j;
          cloop(arr,idx,f,col + 1 | 0,max);
          var _dX_=j + 1 | 0;
          if(_dW_ !== j){var j=_dX_;continue}
          break}}
      return 0}
    function floop(arr,idx,f,col,max)
     {if(0 <= col)
       {var _dT_=caml_check_bound(max,col)[1 + col],_dS_=1;
        if(! (_dT_ < 1))
         {var j=_dS_;
          for(;;)
           {caml_check_bound(idx,col)[1 + col] = j;
            floop(arr,idx,f,col - 1 | 0,max);
            var _dU_=j + 1 | 0;
            if(_dT_ !== j){var j=_dU_;continue}
            break}}
        return 0}
      return caml_ba_set_generic(arr,idx,caml_call1(f,idx))}
    function init$5(kind,layout,dims,f)
     {var arr=caml_ba_create(kind,layout,dims),dlen=dims.length - 1;
      return 0 === dlen
              ?arr
              :layout
                ?(floop(arr,caml_make_vect(dlen,1),f,dlen - 1 | 0,dims),arr)
                :(cloop(arr,caml_make_vect(dlen,0),f,0,dims),arr)}
    function dims(a)
     {var n=caml_ba_num_dims(a),d=caml_make_vect(n,0),_dP_=n - 1 | 0,_dO_=0;
      if(! (_dP_ < 0))
       {var i=_dO_;
        for(;;)
         {var _dQ_=runtime.caml_ba_dim(a,i);
          caml_check_bound(d,i)[1 + i] = _dQ_;
          var _dR_=i + 1 | 0;
          if(_dP_ !== i){var i=_dR_;continue}
          break}}
      return d}
    function size_in_bytes(arr)
     {var _dN_=fold_left$1(caml_mul,1,dims(arr));
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dN_)}
    function create$8(kind,layout){return caml_ba_create(kind,layout,[0])}
    function get$2(arr){return runtime.caml_ba_get_generic(arr,[0])}
    function set$1(arr)
     {var _dL_=[0];
      return function(_dM_){return caml_ba_set_generic(arr,_dL_,_dM_)}}
    function size_in_bytes$0(arr)
     {return kind_size_in_bytes(caml_ba_kind(arr))}
    function of_value(kind,layout,v)
     {var a=create$8(kind,layout);caml_call1(set$1(a),v);return a}
    function create$9(kind,layout,dim)
     {return caml_ba_create(kind,layout,[0,dim])}
    function size_in_bytes$1(arr)
     {var _dK_=caml_ba_dim_1(arr);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dK_)}
    function slice(a,n)
     {var match=runtime.caml_ba_layout(a);
      return match?caml_ba_slice(a,[0,n]):caml_ba_slice(a,[0,n])}
    function init$6(kind,layout,dim,f)
     {var arr=create$9(kind,layout,dim);
      if(layout)
       {var _dI_=1;
        if(! (dim < 1))
         {var i$0=_dI_;
          for(;;)
           {caml_ba_set_1(arr,i$0,caml_call1(f,i$0));
            var _dJ_=i$0 + 1 | 0;
            if(dim !== i$0){var i$0=_dJ_;continue}
            break}}
        return arr}
      var _dG_=dim - 1 | 0,_dF_=0;
      if(! (_dG_ < 0))
       {var i=_dF_;
        for(;;)
         {caml_ba_set_1(arr,i,caml_call1(f,i));
          var _dH_=i + 1 | 0;
          if(_dG_ !== i){var i=_dH_;continue}
          break}}
      return arr}
    function of_array(kind,layout,data)
     {var
       ba=create$9(kind,layout,data.length - 1),
       ofs=layout?1:0,
       _dD_=data.length - 1 - 1 | 0,
       _dC_=0;
      if(! (_dD_ < 0))
       {var i=_dC_;
        for(;;)
         {caml_ba_set_1(ba,i + ofs | 0,caml_check_bound(data,i)[1 + i]);
          var _dE_=i + 1 | 0;
          if(_dD_ !== i){var i=_dE_;continue}
          break}}
      return ba}
    function create$10(kind,layout,dim1,dim2)
     {return caml_ba_create(kind,layout,[0,dim1,dim2])}
    function size_in_bytes$2(arr)
     {var _dA_=caml_ba_dim_2(arr),_dB_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dB_),_dA_)}
    function slice_left(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right(a,n){return caml_ba_slice(a,[0,n])}
    function init$7(kind,layout,dim1,dim2,f)
     {var arr=create$10(kind,layout,dim1,dim2);
      if(layout)
       {var _dw_=1;
        if(! (dim2 < 1))
         {var j$0=_dw_;
          for(;;)
           {var _dx_=1;
            if(! (dim1 < 1))
             {var i$0=_dx_;
              for(;;)
               {caml_ba_set_2(arr,i$0,j$0,caml_call2(f,i$0,j$0));
                var _dz_=i$0 + 1 | 0;
                if(dim1 !== i$0){var i$0=_dz_;continue}
                break}}
            var _dy_=j$0 + 1 | 0;
            if(dim2 !== j$0){var j$0=_dy_;continue}
            break}}
        return arr}
      var _dr_=dim1 - 1 | 0,_dq_=0;
      if(! (_dr_ < 0))
       {var i=_dq_;
        for(;;)
         {var _dt_=dim2 - 1 | 0,_ds_=0;
          if(! (_dt_ < 0))
           {var j=_ds_;
            for(;;)
             {caml_ba_set_2(arr,i,j,caml_call2(f,i,j));
              var _dv_=j + 1 | 0;
              if(_dt_ !== j){var j=_dv_;continue}
              break}}
          var _du_=i + 1 | 0;
          if(_dr_ !== i){var i=_du_;continue}
          break}}
      return arr}
    function of_array$0(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       ba=create$10(kind,layout,dim1,dim2),
       ofs=layout?1:0,
       _dl_=dim1 - 1 | 0,
       _dk_=0;
      if(! (_dl_ < 0))
       {var i=_dk_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array2_of_array_n);
          var _dn_=dim2 - 1 | 0,_dm_=0;
          if(! (_dn_ < 0))
           {var j=_dm_;
            for(;;)
             {caml_ba_set_2
               (ba,i + ofs | 0,j + ofs | 0,caml_check_bound(row,j)[1 + j]);
              var _dp_=j + 1 | 0;
              if(_dn_ !== j){var j=_dp_;continue}
              break}}
          var _do_=i + 1 | 0;
          if(_dl_ !== i){var i=_do_;continue}
          break}}
      return ba}
    function create$11(kind,layout,dim1,dim2,dim3)
     {return caml_ba_create(kind,layout,[0,dim1,dim2,dim3])}
    function size_in_bytes$3(arr)
     {var
       _dh_=runtime.caml_ba_dim_3(arr),
       _di_=caml_ba_dim_2(arr),
       _dj_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul
                (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dj_),_di_),
               _dh_)}
    function slice_left_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_right_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_left_2(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right_2(a,n){return caml_ba_slice(a,[0,n])}
    function init$8(kind,layout,dim1,dim2,dim3,f)
     {var arr=create$11(kind,layout,dim1,dim2,dim3);
      if(layout)
       {var _db_=1;
        if(! (dim3 < 1))
         {var k$0=_db_;
          for(;;)
           {var _dc_=1;
            if(! (dim2 < 1))
             {var j$0=_dc_;
              for(;;)
               {var _de_=1;
                if(! (dim1 < 1))
                 {var i$0=_de_;
                  for(;;)
                   {caml_ba_set_3(arr,i$0,j$0,k$0,caml_call3(f,i$0,j$0,k$0));
                    var _dg_=i$0 + 1 | 0;
                    if(dim1 !== i$0){var i$0=_dg_;continue}
                    break}}
                var _df_=j$0 + 1 | 0;
                if(dim2 !== j$0){var j$0=_df_;continue}
                break}}
            var _dd_=k$0 + 1 | 0;
            if(dim3 !== k$0){var k$0=_dd_;continue}
            break}}
        return arr}
      var _c5_=dim1 - 1 | 0,_c4_=0;
      if(! (_c5_ < 0))
       {var i=_c4_;
        for(;;)
         {var _c7_=dim2 - 1 | 0,_c6_=0;
          if(! (_c7_ < 0))
           {var j=_c6_;
            for(;;)
             {var _c__=dim3 - 1 | 0,_c9_=0;
              if(! (_c__ < 0))
               {var k=_c9_;
                for(;;)
                 {caml_ba_set_3(arr,i,j,k,caml_call3(f,i,j,k));
                  var _da_=k + 1 | 0;
                  if(_c__ !== k){var k=_da_;continue}
                  break}}
              var _c$_=j + 1 | 0;
              if(_c7_ !== j){var j=_c$_;continue}
              break}}
          var _c8_=i + 1 | 0;
          if(_c5_ !== i){var i=_c8_;continue}
          break}}
      return arr}
    function of_array$1(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       dim3=
        0 === dim2
         ?0
         :caml_check_bound(caml_check_bound(data,0)[1],0)[1].length - 1,
       ba=create$11(kind,layout,dim1,dim2,dim3),
       ofs=layout?1:0,
       _cW_=dim1 - 1 | 0,
       _cV_=0;
      if(! (_cW_ < 0))
       {var i=_cV_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array3_of_array_n);
          var _cY_=dim2 - 1 | 0,_cX_=0;
          if(! (_cY_ < 0))
           {var j=_cX_;
            for(;;)
             {var col=caml_check_bound(row,j)[1 + j];
              if(col.length - 1 !== dim3)
               invalid_arg(cst_Bigarray_Array3_of_array_n$0);
              var _c1_=dim3 - 1 | 0,_c0_=0;
              if(! (_c1_ < 0))
               {var k=_c0_;
                for(;;)
                 {caml_ba_set_3
                   (ba,
                    i + ofs | 0,
                    j + ofs | 0,
                    k + ofs | 0,
                    caml_check_bound(col,k)[1 + k]);
                  var _c3_=k + 1 | 0;
                  if(_c1_ !== k){var k=_c3_;continue}
                  break}}
              var _c2_=j + 1 | 0;
              if(_cY_ !== j){var j=_c2_;continue}
              break}}
          var _cZ_=i + 1 | 0;
          if(_cW_ !== i){var i=_cZ_;continue}
          break}}
      return ba}
    function array0_of_genarray(a)
     {return 0 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array0_of_genarra)}
    function array1_of_genarray(a)
     {return 1 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array1_of_genarra)}
    function array2_of_genarray(a)
     {return 2 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array2_of_genarra)}
    function array3_of_genarray(a)
     {return 3 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array3_of_genarra)}
    function reshape_0(a){return caml_ba_reshape(a,[0])}
    function reshape_1(a,dim1){return caml_ba_reshape(a,[0,dim1])}
    function reshape_2(a,dim1,dim2){return caml_ba_reshape(a,[0,dim1,dim2])}
    function reshape_3(a,dim1,dim2,dim3)
     {return caml_ba_reshape(a,[0,dim1,dim2,dim3])}
    var
     Stdlib_bigarray=
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$2,
       int32$1,
       int64$1,
       nativeint$1,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       [0,init$5,dims,size_in_bytes],
       [0,
        create$8,
        of_value,
        caml_ba_change_layout,
        size_in_bytes$0,
        get$2,
        set$1,
        of_value],
       [0,
        create$9,
        init$6,
        caml_ba_change_layout,
        size_in_bytes$1,
        slice,
        of_array],
       [0,
        create$10,
        init$7,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$11,
        init$8,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
    caml_register_global(817,Stdlib_bigarray,"Stdlib__bigarray");
    return}
  (function(){return this}()));


//# 1 ".js/num.core/nums.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     add_nat=runtime.add_nat,
     blit_nat=runtime.blit_nat,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_int64_and=runtime.caml_int64_and,
     caml_int64_neg=runtime.caml_int64_neg,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_to_float=runtime.caml_int64_to_float,
     caml_int64_to_int32=runtime.caml_int64_to_int32,
     caml_ldexp_float=runtime.caml_ldexp_float,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_register_global=runtime.caml_register_global,
     caml_string_get=runtime.caml_string_get,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_wrap_exception=runtime.caml_wrap_exception,
     compare_nat=runtime.compare_nat,
     complement_nat=runtime.complement_nat,
     create_nat=runtime.create_nat,
     decr_nat=runtime.decr_nat,
     div_digit_nat=runtime.div_digit_nat,
     div_nat=runtime.div_nat,
     incr_nat=runtime.incr_nat,
     is_digit_int=runtime.is_digit_int,
     is_digit_zero=runtime.is_digit_zero,
     land_digit_nat=runtime.land_digit_nat,
     mult_digit_nat=runtime.mult_digit_nat,
     mult_nat=runtime.mult_nat,
     nth_digit_nat=runtime.nth_digit_nat,
     nth_digit_nat_native=runtime.nth_digit_nat_native,
     num_digits_nat=runtime.num_digits_nat,
     num_leading_zero_bits_in_digit=runtime.num_leading_zero_bits_in_digit,
     set_digit_nat=runtime.set_digit_nat,
     set_digit_nat_native=runtime.set_digit_nat_native,
     set_to_zero_nat=runtime.set_to_zero_nat,
     shift_right_nat=runtime.shift_right_nat,
     square_nat=runtime.square_nat,
     sub_nat=runtime.sub_nat;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_invalid_digit=caml_string_of_jsbytes("invalid digit"),
     cst_number_too_long=caml_string_of_jsbytes("number too long"),
     cst_power_base_int=caml_string_of_jsbytes("power_base_int"),
     cst_nat_of_int=caml_string_of_jsbytes("nat_of_int"),
     cst_int_of_nat=caml_string_of_jsbytes("int_of_nat"),
     cst_make_nat=caml_string_of_jsbytes("make_nat"),
     cst_xor_big_int=caml_string_of_jsbytes("xor_big_int"),
     cst_or_big_int=caml_string_of_jsbytes("or_big_int"),
     cst_and_big_int=caml_string_of_jsbytes("and_big_int"),
     cst_extract_big_int=caml_string_of_jsbytes("extract_big_int"),
     cst_shift_right_big_int=caml_string_of_jsbytes("shift_right_big_int"),
     cst_two_power_m1_big_int=caml_string_of_jsbytes("two_power_m1_big_int"),
     cst_shift_right_towards_zero_b=
      caml_string_of_jsbytes("shift_right_towards_zero_big_int"),
     cst_shift_left_big_int=caml_string_of_jsbytes("shift_left_big_int"),
     cst_100000000=caml_string_of_jsbytes("100000000"),
     cst_963295986=caml_string_of_jsbytes("963295986"),
     cst$0=caml_string_of_jsbytes("-"),
     sign=caml_string_of_jsbytes(""),
     cst_e=caml_string_of_jsbytes("e"),
     cst_1=caml_string_of_jsbytes("1."),
     cst_e$0=caml_string_of_jsbytes("e"),
     cst$1=caml_string_of_jsbytes("."),
     cst_sqrt_big_int=caml_string_of_jsbytes("sqrt_big_int"),
     cst_base_power_big_int=caml_string_of_jsbytes("base_power_big_int"),
     cst_base_power_big_int$0=caml_string_of_jsbytes("base_power_big_int"),
     cst_base_power_big_int$1=caml_string_of_jsbytes("base_power_big_int"),
     cst_power_big_int_positive_big=
      caml_string_of_jsbytes("power_big_int_positive_big_int"),
     cst_power_int_positive_big_int=
      caml_string_of_jsbytes("power_int_positive_big_int"),
     cst_power_big_int_positive_int=
      caml_string_of_jsbytes("power_big_int_positive_int"),
     cst_power_int_positive_int=
      caml_string_of_jsbytes("power_int_positive_int"),
     cst_sys_big_int_of_string$1=
      caml_string_of_jsbytes("sys_big_int_of_string"),
     cst_sys_big_int_of_string$0=
      caml_string_of_jsbytes("sys_big_int_of_string"),
     cst_sys_big_int_of_string=caml_string_of_jsbytes("sys_big_int_of_string"),
     cst=caml_string_of_jsbytes("-"),
     cst_nat_of_big_int=caml_string_of_jsbytes("nat_of_big_int"),
     cst_int64_of_big_int$1=caml_string_of_jsbytes("int64_of_big_int"),
     cst_int64_of_big_int=caml_string_of_jsbytes("int64_of_big_int"),
     cst_int64_of_big_int$0=caml_string_of_jsbytes("int64_of_big_int"),
     cst_int32_of_big_int=caml_string_of_jsbytes("int32_of_big_int"),
     cst_nativeint_of_big_int=caml_string_of_jsbytes("nativeint_of_big_int"),
     cst_nativeint_of_big_int$0=caml_string_of_jsbytes("nativeint_of_big_int"),
     cst_nativeint_of_big_int$1=caml_string_of_jsbytes("nativeint_of_big_int"),
     cst_int_of_big_int=caml_string_of_jsbytes("int_of_big_int"),
     cst_create_big_int=caml_string_of_jsbytes("create_big_int"),
     cst$5=caml_string_of_jsbytes("/"),
     cst_approx_ratio_exp=caml_string_of_jsbytes("approx_ratio_exp"),
     cst_approx_ratio_exp$0=caml_string_of_jsbytes("approx_ratio_exp"),
     cst_0$0=caml_string_of_jsbytes("+0."),
     cst$4=caml_string_of_jsbytes(""),
     cst_1$1=caml_string_of_jsbytes("-1."),
     cst_1$2=caml_string_of_jsbytes("+1."),
     cst_0$1=caml_string_of_jsbytes("-0."),
     cst_0$2=caml_string_of_jsbytes("+0."),
     cst_approx_ratio_fix=caml_string_of_jsbytes("approx_ratio_fix"),
     cst_0=caml_string_of_jsbytes("+0"),
     cst_1$0=caml_string_of_jsbytes("1"),
     cst_msd_ratio=caml_string_of_jsbytes("msd_ratio"),
     cst_big_int_of_ratio=caml_string_of_jsbytes("big_int_of_ratio"),
     cst_nat_of_ratio$0=caml_string_of_jsbytes("nat_of_ratio"),
     cst_nat_of_ratio=caml_string_of_jsbytes("nat_of_ratio"),
     cst_integer_argument_required=
      caml_string_of_jsbytes("integer argument required"),
     cst_integer_ratio=caml_string_of_jsbytes("integer_ratio"),
     cst_inverse_ratio=caml_string_of_jsbytes("inverse_ratio"),
     cst_create_normalized_ratio=
      caml_string_of_jsbytes("create_normalized_ratio"),
     cst_create_ratio=caml_string_of_jsbytes("create_ratio"),
     cst$3=caml_string_of_jsbytes(""),
     s=caml_string_of_jsbytes("infinite or undefined rational number"),
     cst$2=caml_string_of_jsbytes(" "),
     cst_num_of_string=caml_string_of_jsbytes("num_of_string"),
     cst_power_num=caml_string_of_jsbytes("power_num"),
     cst_Normalization_during_compu=
      caml_string_of_jsbytes("Normalization during computation"),
     cst_returned_by_get_normalize_=
      caml_string_of_jsbytes("     (returned by get_normalize_ratio ())"),
     cst_modifiable_with_set_normal=
      caml_string_of_jsbytes
       ("     (modifiable with set_normalize_ratio <your choice>)"),
     cst_Normalization_when_printin=
      caml_string_of_jsbytes("Normalization when printing"),
     cst_returned_by_get_normalize_$0=
      caml_string_of_jsbytes
       ("     (returned by get_normalize_ratio_when_printing ())"),
     cst_modifiable_with_set_normal$0=
      caml_string_of_jsbytes
       ("     (modifiable with set_normalize_ratio_when_printing <your choice>)"),
     cst_Floating_point_approximati=
      caml_string_of_jsbytes
       ("Floating point approximation when printing rational numbers"),
     cst_returned_by_get_approx_pri=
      caml_string_of_jsbytes("     (returned by get_approx_printing ())"),
     cst_modifiable_with_set_approx=
      caml_string_of_jsbytes
       ("     (modifiable with set_approx_printing <your choice>)"),
     cst_Default_precision=caml_string_of_jsbytes("  Default precision = "),
     cst_returned_by_get_floating_p=
      caml_string_of_jsbytes("     (returned by get_floating_precision ())"),
     cst_modifiable_with_set_floati=
      caml_string_of_jsbytes
       ("     (modifiable with set_floating_precision <your choice>)"),
     cst_Error_when_a_rational_deno=
      caml_string_of_jsbytes("Error when a rational denominator is null"),
     cst_returned_by_get_error_when=
      caml_string_of_jsbytes
       ("     (returned by get_error_when_null_denominator ())"),
     cst_modifiable_with_set_error_=
      caml_string_of_jsbytes
       ("     (modifiable with set_error_when_null_denominator <your choice>)"),
     cst_ON=caml_string_of_jsbytes("ON"),
     cst_OFF=caml_string_of_jsbytes("OFF"),
     cst$6=caml_string_of_jsbytes(" --> "),
     Stdlib=global_data.Stdlib,
     Stdlib_sys=global_data.Stdlib__sys,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Stdlib_char=global_data.Stdlib__char,
     Assert_failure=global_data.Assert_failure,
     Stdlib_int64=global_data.Stdlib__int64,
     Stdlib_nativeint=global_data.Stdlib__nativeint,
     _z_=[0,caml_string_of_jsbytes("nat.ml"),273,9],
     _y_=runtime.caml_int64_create_lo_mi_hi(6553600,11973543,3552),
     _x_=[0,caml_string_of_jsbytes("nat.ml"),280,9],
     _w_=[0,caml_string_of_jsbytes("nat.ml"),287,9],
     _v_=[0,caml_string_of_jsbytes("nat.ml"),293,9],
     _u_=runtime.caml_int64_create_lo_mi_hi(6553600,11973543,3552),
     _l_=[0,caml_string_of_jsbytes("big_int.ml"),879,2],
     _k_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _j_=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     _g_=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     _h_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _i_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _d_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _e_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _f_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _n_=[0,caml_string_of_jsbytes("ratio.ml"),575,11],
     _m_=[0,caml_string_of_jsbytes("e0"),0],
     _r_=[0,1],
     _s_=[0,1],
     _t_=[0,1],
     _o_=[0,1],
     _p_=[0,1],
     _q_=[0,1];
    function gcd_int(i1,i2)
     {var i1$0=i1,i2$0=i2;
      for(;;)
       {if(0 === i2$0)return caml_call1(Stdlib[18],i1$0);
        var i2$1=caml_mod(i1$0,i2$0),i1$0=i2$0,i2$0=i2$1;
        continue}}
    function num_bits_int_aux(n)
     {return 0 === n?0:num_bits_int_aux(n >>> 1 | 0) + 1 | 0}
    function num_bits_int(n)
     {return num_bits_int_aux(caml_call1(Stdlib[18],n))}
    function sign_int(i){return 0 === i?0:0 < i?1:-1}
    var
     length_of_int=Stdlib_sys[10] - 1 | 0,
     monster_int=1 << length_of_int,
     biggest_int=monster_int - 1 | 0,
     least_int=- biggest_int | 0;
    function compare_int(n1,n2)
     {return n1 === n2?0:caml_greaterthan(n1,n2)?1:-1}
    var
     Int_misc=
      [0,
       gcd_int,
       num_bits_int,
       compare_int,
       sign_int,
       length_of_int,
       biggest_int,
       least_int,
       monster_int];
    caml_register_global(122,Int_misc,"Int_misc");
    runtime.initialize_nat(0);
    function length_nat(n){return n.length - 1 - 1 | 0}
    var _a_=Stdlib_sys[9];
    function make_nat(len)
     {if(0 <= len)
       {var res=create_nat(len);set_to_zero_nat(res,0,len);return res}
      return caml_call1(Stdlib[1],cst_make_nat)}
    var a_2=make_nat(2),a_1=make_nat(1),b_2=make_nat(2);
    function copy_nat(nat,off_set,length)
     {var res=create_nat(length);
      blit_nat(res,0,nat,off_set,length);
      return res}
    function is_zero_nat(n,off,len)
     {var _dl_=num_digits_nat(n,off,len);
      return 0 === compare_nat(make_nat(1),0,1,n,off,_dl_)?1:0}
    function is_nat_int(nat,off,len)
     {var
       _dj_=1 === num_digits_nat(nat,off,len)?1:0,
       _dk_=_dj_?is_digit_int(nat,off):_dj_;
      return _dk_}
    function int_of_nat(nat)
     {var len=length_nat(nat);
      return is_nat_int(nat,0,len)
              ?nth_digit_nat(nat,0)
              :caml_call1(Stdlib[2],cst_int_of_nat)}
    function nat_of_int(i)
     {if(0 <= i)
       {var res=make_nat(1);return 0 === i?res:(set_digit_nat(res,0,i),res)}
      return caml_call1(Stdlib[1],cst_nat_of_int)}
    function eq_nat(nat1,off1,len1,nat2,off2,len2)
     {var _di_=num_digits_nat(nat2,off2,len2);
      return 0
              ===
              compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_di_)
              ?1
              :0}
    function le_nat(nat1,off1,len1,nat2,off2,len2)
     {var _dh_=num_digits_nat(nat2,off2,len2);
      return compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_dh_)
              <=
              0
              ?1
              :0}
    function lt_nat(nat1,off1,len1,nat2,off2,len2)
     {var _dg_=num_digits_nat(nat2,off2,len2);
      return compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_dg_)
              <
              0
              ?1
              :0}
    function ge_nat(nat1,off1,len1,nat2,off2,len2)
     {var _df_=num_digits_nat(nat2,off2,len2);
      return 0
              <=
              compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_df_)
              ?1
              :0}
    function gt_nat(nat1,off1,len1,nat2,off2,len2)
     {var _de_=num_digits_nat(nat2,off2,len2);
      return 0
              <
              compare_nat
               (nat1,off1,num_digits_nat(nat1,off1,len1),nat2,off2,_de_)
              ?1
              :0}
    function exchange(r1,r2)
     {var old1=r1[1];r1[1] = r2[1];r2[1] = old1;return 0}
    function gcd_nat(nat1,off1,len1,nat2,off2,len2)
     {if(is_zero_nat(nat1,off1,len1))
       {blit_nat(nat1,off1,nat2,off2,len2);return len2}
      var
       copy1=[0,create_nat(len1 + 1 | 0)],
       copy2=[0,create_nat(len2 + 1 | 0)];
      blit_nat(copy1[1],0,nat1,off1,len1);
      blit_nat(copy2[1],0,nat2,off2,len2);
      set_digit_nat(copy1[1],len1,0);
      set_digit_nat(copy2[1],len2,0);
      if(lt_nat(copy1[1],0,len1,copy2[1],0,len2))exchange(copy1,copy2);
      var
       _dc_=length_nat(copy1[1]),
       real_len1=[0,num_digits_nat(copy1[1],0,_dc_)],
       _dd_=length_nat(copy2[1]),
       real_len2=[0,num_digits_nat(copy2[1],0,_dd_)];
      for(;;)
       {if(is_zero_nat(copy2[1],0,real_len2[1]))
         {blit_nat(nat1,off1,copy1[1],0,real_len1[1]);return real_len1[1]}
        set_digit_nat(copy1[1],real_len1[1],0);
        div_nat(copy1[1],0,real_len1[1] + 1 | 0,copy2[1],0,real_len2[1]);
        exchange(copy1,copy2);
        real_len1[1] = real_len2[1];
        real_len2[1] = num_digits_nat(copy2[1],0,real_len2[1]);
        continue}}
    function sqrt_nat(rad,off,len)
     {var
       len$0=num_digits_nat(rad,off,len),
       len_parity=len$0 % 2 | 0,
       rad_len=(len$0 + 1 | 0) + len_parity | 0,
       rad$0=create_nat(rad_len);
      blit_nat(rad$0,0,rad,off,len$0);
      set_digit_nat(rad$0,len$0,0);
      set_digit_nat(rad$0,rad_len - 1 | 0,0);
      var
       cand_len=(len$0 + 1 | 0) / 2 | 0,
       cand_rest=rad_len - cand_len | 0,
       cand=make_nat(cand_len),
       shift_cand=
        (num_leading_zero_bits_in_digit(rad$0,len$0 - 1 | 0)
         +
         caml_mul(_a_,len_parity)
         |
         0)
        /
        2
        |
        0;
      if(shift_cand === _a_)return cand;
      complement_nat(cand,0,cand_len);
      shift_right_nat(cand,0,1,a_1,0,shift_cand);
      var next_cand=create_nat(rad_len);
      for(;;)
       {blit_nat(next_cand,0,rad$0,0,rad_len);
        div_nat(next_cand,0,rad_len,cand,0,cand_len);
        add_nat(next_cand,cand_len,cand_rest,cand,0,cand_len,0);
        shift_right_nat(next_cand,cand_len,cand_rest,a_1,0,1);
        if(lt_nat(next_cand,cand_len,cand_rest,cand,0,cand_len))
         {blit_nat(cand,0,next_cand,cand_len,cand_len);continue}
        return cand}}
    var power_base_max=make_nat(2);
    if(32 === _a_)
     set_digit_nat(power_base_max,0,1000000000);
    else
     {if(64 !== _a_)throw [0,Assert_failure,_z_];
      set_digit_nat(power_base_max,0,caml_int64_to_int32(_y_));
      mult_digit_nat(power_base_max,0,2,power_base_max,0,1,nat_of_int(9),0)}
    if(32 === _a_)
     var _b_=9;
    else
     {if(64 !== _a_)throw [0,Assert_failure,_x_];var _b_=19}
    if(32 === _a_)
     var _c_=9;
    else
     {if(64 !== _a_)throw [0,Assert_failure,_w_];var _c_=18}
    if(32 === _a_)
     var max_power_10_power_in_int=nat_of_int(1000000000);
    else
     {if(64 !== _a_)throw [0,Assert_failure,_v_];
      var max_power_10_power_in_int=nat_of_int(caml_int64_to_int32(_u_))}
    function raw_string_of_digit(nat,off)
     {if(is_nat_int(nat,off,1))
       {var _c$_=nth_digit_nat(nat,off);return caml_call1(Stdlib[33],_c$_)}
      blit_nat(b_2,0,nat,off,1);
      div_digit_nat(a_2,0,a_1,0,b_2,0,2,max_power_10_power_in_int,0);
      var
       leading_digits=nth_digit_nat(a_2,0),
       _da_=nth_digit_nat(a_1,0),
       s1=caml_call1(Stdlib[33],_da_),
       len=caml_ml_string_length(s1);
      if(10 <= leading_digits)
       {var
         result=caml_call2(Stdlib_bytes[1],_c_ + 2 | 0,48),
         _db_=caml_call1(Stdlib[33],leading_digits);
        caml_call5(Stdlib_string[32],_db_,0,result,0,2);
        caml_call5
         (Stdlib_string[32],
          s1,
          0,
          result,
          caml_ml_bytes_length(result) - len | 0,
          len);
        return caml_call1(Stdlib_bytes[6],result)}
      var result$0=caml_call2(Stdlib_bytes[1],_c_ + 1 | 0,48);
      caml_bytes_set
       (result$0,0,caml_call1(Stdlib_char[1],48 + leading_digits | 0));
      caml_call5
       (Stdlib_string[32],
        s1,
        0,
        result$0,
        caml_ml_bytes_length(result$0) - len | 0,
        len);
      return caml_call1(Stdlib_bytes[6],result$0)}
    function make_power_base(base,power_base)
     {var i=[0,0],j=[0,0];
      set_digit_nat(power_base,0,base);
      for(;;)
       {i[1]++;
        if(is_digit_zero(power_base,i[1]))
         {mult_digit_nat
           (power_base,i[1],2,power_base,i[1] - 1 | 0,1,power_base,0);
          continue}
        for(;;)
         {if(j[1] < (i[1] - 1 | 0) && is_digit_int(power_base,j[1]))
           {j[1]++;continue}
          return [0,i[1] - 2 | 0,j[1]]}}}
    function power_base_int(base,i)
     {if(0 !== i && 1 !== base)
       {if(0 === base)return nat_of_int(0);
        if(0 <= i)
         {var
           power_base=make_nat(_a_ + 1 | 0),
           match=make_power_base(base,power_base),
           pmax=match[1],
           n=caml_div(i,pmax + 1 | 0),
           rem=caml_mod(i,pmax + 1 | 0);
          if(0 < n)
           {var
             newn=i === biggest_int?n:n + 1 | 0,
             res=make_nat(newn),
             res2=make_nat(newn),
             l=num_bits_int(n) - 2 | 0;
            blit_nat(res,0,power_base,pmax,1);
            if(! (l < 0))
             {var i$0=l;
              for(;;)
               {var
                 len=num_digits_nat(res,0,newn),
                 len2=caml_call2(Stdlib[16],n,2 * len | 0),
                 succ_len2=len2 + 1 | 0;
                square_nat(res2,0,len2,res,0,len);
                if(0 < (n & 1 << i$0))
                 {set_to_zero_nat(res,0,len);
                  mult_digit_nat(res,0,succ_len2,res2,0,len2,power_base,pmax)}
                else
                 blit_nat(res,0,res2,0,len2);
                set_to_zero_nat(res2,0,len2);
                var _c__=i$0 - 1 | 0;
                if(0 !== i$0){var i$0=_c__;continue}
                break}}
            return 0 < rem
                    ?(mult_digit_nat(res2,0,newn,res,0,n,power_base,rem - 1 | 0),
                      res2)
                    :res}
          return copy_nat(power_base,rem - 1 | 0,1)}
        return caml_call1(Stdlib[1],cst_power_base_int)}
      return nat_of_int(1)}
    function unadjusted_string_of_nat(nat,off,len_nat)
     {var len=num_digits_nat(nat,off,len_nat);
      if(1 === len)return raw_string_of_digit(nat,off);
      var
       len_copy=[0,len + 1 | 0],
       copy1=create_nat(len_copy[1]),
       copy2=make_nat(len_copy[1]),
       rest_digit=make_nat(2);
      if(caml_div(biggest_int,_b_ + 1 | 0) < len)
       return caml_call1(Stdlib[2],cst_number_too_long);
      var
       len_s=caml_mul(_b_ + 1 | 0,len),
       s=caml_call2(Stdlib_bytes[1],len_s,48),
       pos_ref=[0,len_s];
      len_copy[1] = len_copy[1] - 1 | 0;
      blit_nat(copy1,0,nat,off,len);
      set_digit_nat(copy1,len,0);
      for(;;)
       {if(is_zero_nat(copy1,0,len_copy[1]))
         return caml_call1(Stdlib_bytes[42],s);
        div_digit_nat
         (copy2,0,rest_digit,0,copy1,0,len_copy[1] + 1 | 0,power_base_max,0);
        var str=raw_string_of_digit(rest_digit,0);
        caml_call5
         (Stdlib_string[32],
          str,
          0,
          s,
          pos_ref[1] - caml_ml_string_length(str) | 0,
          caml_ml_string_length(str));
        pos_ref[1] = pos_ref[1] - _b_ | 0;
        len_copy[1] = num_digits_nat(copy2,0,len_copy[1]);
        blit_nat(copy1,0,copy2,0,len_copy[1]);
        set_digit_nat(copy1,len_copy[1],0);
        continue}}
    function string_of_nat(nat)
     {var s=unadjusted_string_of_nat(nat,0,length_nat(nat)),index=[0,0];
      try
       {var _c7_=caml_ml_string_length(s) - 2 | 0,_c6_=0;
        if(! (_c7_ < 0))
         {var i=_c6_;
          for(;;)
           {if(48 !== caml_string_get(s,i)){index[1] = i;throw Stdlib[3]}
            var _c8_=i + 1 | 0;
            if(_c7_ !== i){var i=_c8_;continue}
            break}}}
      catch(_c9_)
       {_c9_ = caml_wrap_exception(_c9_);if(_c9_ !== Stdlib[3])throw _c9_}
      return caml_call3
              (Stdlib_string[9],
               s,
               index[1],
               caml_ml_string_length(s) - index[1] | 0)}
    function sys_nat_of_string(base,s,off,len)
     {var
       power_base=make_nat(_a_ + 1 | 0),
       match=make_power_base(base,power_base),
       pint=match[2],
       pmax=match[1],
       _cY_=1 + caml_div(len,pmax + 1 | 0) | 0,
       current_len=[0,1],
       possible_len=[0,caml_call2(Stdlib[16],2,_cY_)],
       nat1=make_nat(_cY_),
       nat2=make_nat(_cY_),
       digits_read=[0,0],
       bound=(off + len | 0) - 1 | 0,
       int$0=[0,0];
      if(! (bound < off))
       {var i=off;
        for(;;)
         {var n=caml_string_get(s,i),switch$0=0;
          if(32 <= n)
           {if(93 <= n)
             {if(95 === n && off < i)switch$0 = 2}
            else
             if(58 < (n - 33 | 0) >>> 0)switch$0 = 1}
          else
           if(11 <= n){if(13 === n)switch$0 = 1}else if(9 <= n)switch$0 = 1;
          switch(switch$0)
           {case 0:
             var switch$1=0;
             if(48 <= n && n <= (47 + caml_call2(Stdlib[16],base,10) | 0))
              var _c5_=n - 48 | 0;
             else
              switch$1 = 1;
             if(switch$1)
              {var switch$2=0;
               if(65 <= n && n <= ((65 + base | 0) - 11 | 0))
                var _c5_=n - 55 | 0;
               else
                switch$2 = 1;
               if(switch$2)
                {var switch$3=0;
                 if(97 <= n && n <= ((97 + base | 0) - 11 | 0))
                  var _c5_=n - 87 | 0;
                 else
                  switch$3 = 1;
                 if(switch$3)var _c5_=caml_call1(Stdlib[2],cst_invalid_digit)}}
             int$0[1] = caml_mul(int$0[1],base) + _c5_ | 0;
             digits_read[1]++;
             break;
            case 1:break
            }
          var
           _cZ_=digits_read[1] === pint?1:0,
           _c0_=_cZ_ || (i === bound?1:0),
           _c1_=_c0_?1 - (0 === digits_read[1]?1:0):_c0_;
          if(_c1_)
           {set_digit_nat(nat1,0,int$0[1]);
            var
             erase_len=
              _cY_ === current_len[1]?current_len[1] - 1 | 0:current_len[1],
             _c2_=1;
            if(! (erase_len < 1))
             {var j=_c2_;
              for(;;)
               {set_digit_nat(nat1,j,0);
                var _c4_=j + 1 | 0;
                if(erase_len !== j){var j=_c4_;continue}
                break}}
            mult_digit_nat
             (nat1,
              0,
              possible_len[1],
              nat2,
              0,
              current_len[1],
              power_base,
              digits_read[1] - 1 | 0);
            blit_nat(nat2,0,nat1,0,possible_len[1]);
            current_len[1] = num_digits_nat(nat1,0,possible_len[1]);
            possible_len[1]
            =
            caml_call2(Stdlib[16],_cY_,current_len[1] + 1 | 0);
            int$0[1] = 0;
            digits_read[1] = 0}
          var _c3_=i + 1 | 0;
          if(bound !== i){var i=_c3_;continue}
          break}}
      var nat=create_nat(current_len[1]);
      blit_nat(nat,0,nat1,0,current_len[1]);
      return nat}
    function nat_of_string(s)
     {return sys_nat_of_string(10,s,0,caml_ml_string_length(s))}
    function float_of_nat(nat)
     {return runtime.caml_float_of_string(string_of_nat(nat))}
    var
     Nat=
      [0,
       make_nat,
       copy_nat,
       length_nat,
       is_zero_nat,
       is_nat_int,
       int_of_nat,
       nat_of_int,
       eq_nat,
       le_nat,
       lt_nat,
       ge_nat,
       gt_nat,
       gcd_nat,
       sqrt_nat,
       string_of_nat,
       nat_of_string,
       sys_nat_of_string,
       float_of_nat,
       make_power_base,
       power_base_int,
       _a_];
    caml_register_global(127,Nat,"Nat");
    function sign_big_int(bi){return bi[1]}
    var zero_big_int=[0,0,make_nat(1)],unit_big_int=[0,1,nat_of_int(1)];
    function num_digits_big_int(bi)
     {var _cX_=length_nat(bi[2]);return num_digits_nat(bi[2],0,_cX_)}
    function num_bits_big_int(bi)
     {var
       _cW_=length_nat(bi[2]),
       nd=num_digits_nat(bi[2],0,_cW_),
       lz=num_leading_zero_bits_in_digit(bi[2],nd - 1 | 0);
      return caml_mul(nd,_a_) - lz | 0}
    function minus_big_int(bi)
     {var _cU_=num_digits_big_int(bi),_cV_=copy_nat(bi[2],0,_cU_);
      return [0,- bi[1] | 0,_cV_]}
    function abs_big_int(bi)
     {var
       _cR_=num_digits_big_int(bi),
       _cS_=copy_nat(bi[2],0,_cR_),
       _cT_=0 === bi[1]?0:1;
      return [0,_cT_,_cS_]}
    function compare_big_int(bi1,bi2)
     {if(0 === bi1[1] && 0 === bi2[1])return 0;
      if(bi1[1] < bi2[1])return -1;
      if(bi2[1] < bi1[1])return 1;
      if(1 === bi1[1])
       {var
         _cL_=num_digits_big_int(bi2),
         _cM_=bi2[2],
         _cN_=num_digits_big_int(bi1);
        return compare_nat(bi1[2],0,_cN_,_cM_,0,_cL_)}
      var
       _cO_=num_digits_big_int(bi1),
       _cP_=bi1[2],
       _cQ_=num_digits_big_int(bi2);
      return compare_nat(bi2[2],0,_cQ_,_cP_,0,_cO_)}
    function eq_big_int(bi1,bi2){return 0 === compare_big_int(bi1,bi2)?1:0}
    function le_big_int(bi1,bi2){return compare_big_int(bi1,bi2) <= 0?1:0}
    function ge_big_int(bi1,bi2){return 0 <= compare_big_int(bi1,bi2)?1:0}
    function lt_big_int(bi1,bi2){return compare_big_int(bi1,bi2) < 0?1:0}
    function gt_big_int(bi1,bi2){return 0 < compare_big_int(bi1,bi2)?1:0}
    function max_big_int(bi1,bi2){return lt_big_int(bi1,bi2)?bi2:bi1}
    function min_big_int(bi1,bi2){return gt_big_int(bi1,bi2)?bi2:bi1}
    function pred_big_int(bi)
     {var _cJ_=bi[1];
      if(0 === _cJ_)return [0,-1,nat_of_int(1)];
      if(1 === _cJ_)
       {var size_bi=num_digits_big_int(bi),copy_bi=copy_nat(bi[2],0,size_bi);
        decr_nat(copy_bi,0,size_bi,0);
        var _cK_=is_zero_nat(copy_bi,0,size_bi)?0:1;
        return [0,_cK_,copy_bi]}
      var
       size_bi$0=num_digits_big_int(bi),
       size_res=size_bi$0 + 1 | 0,
       copy_bi$0=create_nat(size_res);
      blit_nat(copy_bi$0,0,bi[2],0,size_bi$0);
      set_digit_nat(copy_bi$0,size_bi$0,0);
      incr_nat(copy_bi$0,0,size_res,1);
      return [0,-1,copy_bi$0]}
    function succ_big_int(bi)
     {var _cH_=bi[1];
      if(-1 === _cH_)
       {var size_bi=num_digits_big_int(bi),copy_bi=copy_nat(bi[2],0,size_bi);
        decr_nat(copy_bi,0,size_bi,0);
        var _cI_=is_zero_nat(copy_bi,0,size_bi)?0:-1;
        return [0,_cI_,copy_bi]}
      if(0 === _cH_)return [0,1,nat_of_int(1)];
      var
       size_bi$0=num_digits_big_int(bi),
       size_res=size_bi$0 + 1 | 0,
       copy_bi$0=create_nat(size_res);
      blit_nat(copy_bi$0,0,bi[2],0,size_bi$0);
      set_digit_nat(copy_bi$0,size_bi$0,0);
      incr_nat(copy_bi$0,0,size_res,1);
      return [0,1,copy_bi$0]}
    function add_big_int(bi1,bi2)
     {var size_bi1=num_digits_big_int(bi1),size_bi2=num_digits_big_int(bi2);
      if(bi1[1] === bi2[1])
       {var match=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
        if(-1 === match)
         {var res=create_nat(size_bi2 + 1 | 0);
          blit_nat(res,0,bi2[2],0,size_bi2);
          set_digit_nat(res,size_bi2,0);
          add_nat(res,0,size_bi2 + 1 | 0,bi1[2],0,size_bi1,0);
          var res$0=res}
        else
         {var res$1=create_nat(size_bi1 + 1 | 0);
          blit_nat(res$1,0,bi1[2],0,size_bi1);
          set_digit_nat(res$1,size_bi1,0);
          add_nat(res$1,0,size_bi1 + 1 | 0,bi2[2],0,size_bi2,0);
          var res$0=res$1}
        return [0,bi1[1],res$0]}
      var match$0=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      if(0 === match$0)return zero_big_int;
      if(1 === match$0)
       {var res$2=copy_nat(bi1[2],0,size_bi1);
        sub_nat(res$2,0,size_bi1,bi2[2],0,size_bi2,1);
        return [0,bi1[1],res$2]}
      var res$3=copy_nat(bi2[2],0,size_bi2);
      sub_nat(res$3,0,size_bi2,bi1[2],0,size_bi1,1);
      return [0,bi2[1],res$3]}
    function big_int_of_int(i)
     {var res=create_nat(1);
      if(i === monster_int)
       {set_digit_nat(res,0,biggest_int);incr_nat(res,0,1,1)}
      else
       set_digit_nat(res,0,caml_call1(Stdlib[18],i));
      return [0,sign_int(i),res]}
    function add_int_big_int(i,bi){return add_big_int(big_int_of_int(i),bi)}
    function sub_big_int(bi1,bi2){return add_big_int(bi1,minus_big_int(bi2))}
    function mult_int_big_int(i,bi)
     {var size_bi=num_digits_big_int(bi),size_res=size_bi + 1 | 0;
      if(i === monster_int)
       {var res=create_nat(size_res);
        blit_nat(res,0,bi[2],0,size_bi);
        set_digit_nat(res,size_bi,0);
        var _cE_=nat_of_int(biggest_int);
        mult_digit_nat(res,0,size_res,bi[2],0,size_bi,_cE_,0);
        return [0,- bi[1] | 0,res]}
      var res$0=make_nat(size_res),_cF_=nat_of_int(caml_call1(Stdlib[18],i));
      mult_digit_nat(res$0,0,size_res,bi[2],0,size_bi,_cF_,0);
      var _cG_=bi[1];
      return [0,caml_mul(sign_int(i),_cG_),res$0]}
    function mult_big_int(bi1,bi2)
     {var
       size_bi1=num_digits_big_int(bi1),
       size_bi2=num_digits_big_int(bi2),
       size_res=size_bi1 + size_bi2 | 0,
       res=make_nat(size_res);
      if(size_bi1 < size_bi2)
       mult_nat(res,0,size_res,bi2[2],0,size_bi2,bi1[2],0,size_bi1);
      else
       mult_nat(res,0,size_res,bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      return [0,caml_mul(bi1[1],bi2[1]),res]}
    function quomod_big_int(bi1,bi2)
     {if(0 === bi2[1])throw Stdlib[13];
      var
       size_bi1=num_digits_big_int(bi1),
       size_bi2=num_digits_big_int(bi2),
       match=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      if(-1 === match)
       {if(0 <= bi1[1])return [0,big_int_of_int(0),bi1];
        if(0 <= bi2[1])
         {var _cx_=add_big_int(bi2,bi1);return [0,big_int_of_int(-1),_cx_]}
        var _cy_=sub_big_int(bi1,bi2);
        return [0,big_int_of_int(1),_cy_]}
      if(0 === match)
       return [0,big_int_of_int(caml_mul(bi1[1],bi2[1])),zero_big_int];
      var
       bi1_negatif=-1 === bi1[1]?1:0,
       _cz_=
        bi1_negatif
         ?caml_call2(Stdlib[17],(size_bi1 - size_bi2 | 0) + 1 | 0,1) + 1 | 0
         :caml_call2(Stdlib[17],(size_bi1 - size_bi2 | 0) + 1 | 0,1),
       size_r=caml_call2(Stdlib[17],size_bi1,size_bi2) + 1 | 0,
       q=create_nat(_cz_),
       r=create_nat(size_r);
      blit_nat(r,0,bi1[2],0,size_bi1);
      set_to_zero_nat(r,size_bi1,size_r - size_bi1 | 0);
      div_nat(r,0,size_r,bi2[2],0,size_bi2);
      blit_nat(q,0,r,size_bi2,size_r - size_bi2 | 0);
      var not_null_mod=1 - is_zero_nat(r,0,size_bi2);
      if(bi1_negatif && not_null_mod)
       {var new_r=copy_nat(bi2[2],0,size_bi2);
        sub_nat(new_r,0,size_bi2,r,0,size_bi2,1);
        set_digit_nat(q,_cz_ - 1 | 0,0);
        incr_nat(q,0,_cz_,1);
        return [0,[0,- bi2[1] | 0,q],[0,1,new_r]]}
      if(bi1_negatif)set_digit_nat(q,_cz_ - 1 | 0,0);
      var
       _cA_=copy_nat(r,0,size_bi2),
       _cB_=not_null_mod?1:0,
       _cC_=[0,_cB_,_cA_],
       _cD_=is_zero_nat(q,0,_cz_)?0:caml_mul(bi1[1],bi2[1]);
      return [0,[0,_cD_,q],_cC_]}
    function div_big_int(bi1,bi2){return quomod_big_int(bi1,bi2)[1]}
    function mod_big_int(bi1,bi2){return quomod_big_int(bi1,bi2)[2]}
    function gcd_big_int(bi1,bi2)
     {var size_bi1=num_digits_big_int(bi1),size_bi2=num_digits_big_int(bi2);
      if(is_zero_nat(bi1[2],0,size_bi1))return abs_big_int(bi2);
      if(is_zero_nat(bi2[2],0,size_bi2))return [0,1,bi1[2]];
      var match=compare_nat(bi1[2],0,size_bi1,bi2[2],0,size_bi2);
      if(0 === match)
       var _cw_=bi1[2];
      else
       if(1 === match)
        var
         res=copy_nat(bi1[2],0,size_bi1),
         len=gcd_nat(res,0,size_bi1,bi2[2],0,size_bi2),
         _cw_=copy_nat(res,0,len);
       else
        var
         res$0=copy_nat(bi2[2],0,size_bi2),
         len$0=gcd_nat(res$0,0,size_bi2,bi1[2],0,size_bi1),
         _cw_=copy_nat(res$0,0,len$0);
      return [0,1,_cw_]}
    var
     monster_big_int=big_int_of_int(monster_int),
     monster_nat=monster_big_int[2];
    function is_int_big_int(bi)
     {var _cu_=1 === num_digits_big_int(bi)?1:0;
      if(_cu_)
       {var match=compare_nat(bi[2],0,1,monster_nat,0,1);
        if(-1 !== match)return 0 === match?-1 === bi[1]?1:0:0;
        var _cv_=1}
      else
       var _cv_=_cu_;
      return _cv_}
    function int_of_big_int(bi)
     {try
       {var n=int_of_nat(bi[2]),_cs_=-1 === bi[1]?- n | 0:n;return _cs_}
      catch(_ct_)
       {_ct_ = caml_wrap_exception(_ct_);
        if(_ct_[1] === Stdlib[7])
         return eq_big_int(bi,monster_big_int)
                 ?monster_int
                 :caml_call1(Stdlib[2],cst_int_of_big_int);
        throw _ct_}}
    function int_of_big_int_opt(bi)
     {try
       {var _cq_=[0,int_of_big_int(bi)];return _cq_}
      catch(_cr_)
       {_cr_ = caml_wrap_exception(_cr_);
        if(_cr_[1] === Stdlib[7])return 0;
        throw _cr_}}
    function big_int_of_nativeint(i)
     {if(caml_equal(i,0))return zero_big_int;
      if(caml_greaterthan(i,0))
       {var res=create_nat(1);set_digit_nat_native(res,0,i);return [0,1,res]}
      var res$0=create_nat(1);
      set_digit_nat_native(res$0,0,- i | 0);
      return [0,-1,res$0]}
    function nativeint_of_big_int(bi)
     {if(1 < num_digits_big_int(bi))
       caml_call1(Stdlib[2],cst_nativeint_of_big_int);
      var i=nth_digit_nat_native(bi[2],0);
      if(0 <= bi[1])
       return caml_greaterequal(i,0)
               ?i
               :caml_call1(Stdlib[2],cst_nativeint_of_big_int$0);
      if(! caml_greaterequal(i,0) && ! caml_equal(i,Stdlib_nativeint[11]))
       return caml_call1(Stdlib[2],cst_nativeint_of_big_int$1);
      return - i | 0}
    function nativeint_of_big_int_opt(bi)
     {try
       {var _co_=[0,nativeint_of_big_int(bi)];return _co_}
      catch(_cp_)
       {_cp_ = caml_wrap_exception(_cp_);
        if(_cp_[1] === Stdlib[7])return 0;
        throw _cp_}}
    function big_int_of_int32(i){return big_int_of_nativeint(i)}
    function int32_of_big_int(bi)
     {var i=nativeint_of_big_int(bi);
      if
       (runtime.caml_lessequal(i,2147483647)
        &&
        caml_greaterequal(i,-2147483648))
       return i;
      return caml_call1(Stdlib[2],cst_int32_of_big_int)}
    function int32_of_big_int_opt(bi)
     {try
       {var _cm_=[0,int32_of_big_int(bi)];return _cm_}
      catch(_cn_)
       {_cn_ = caml_wrap_exception(_cn_);
        if(_cn_[1] === Stdlib[7])return 0;
        throw _cn_}}
    function big_int_of_int64(i)
     {if(64 === Stdlib_sys[9])
       return big_int_of_nativeint(caml_int64_to_int32(i));
      if(caml_equal(i,_d_))
       var absi=_e_,sg=0;
      else
       if(caml_greaterthan(i,_f_))
        var absi=i,sg=1;
       else
        var absi$0=caml_int64_neg(i),absi=absi$0,sg=-1;
      var res=create_nat(2);
      set_digit_nat_native(res,0,caml_int64_to_int32(absi));
      set_digit_nat_native
       (res,1,caml_int64_to_int32(runtime.caml_int64_shift_right(absi,32)));
      return [0,sg,res]}
    function int64_of_big_int(bi)
     {if(64 === Stdlib_sys[9])
       return caml_int64_of_int32(nativeint_of_big_int(bi));
      var match=num_digits_big_int(bi);
      if(1 === match)
       var
        i=
         caml_int64_and
          (caml_int64_of_int32(nth_digit_nat_native(bi[2],0)),_g_);
      else
       if(2 === match)
        var
         _cl_=
          runtime.caml_int64_shift_left
           (caml_int64_of_int32(nth_digit_nat_native(bi[2],1)),32),
         i=
          caml_int64_or
           (caml_int64_and
             (caml_int64_of_int32(nth_digit_nat_native(bi[2],0)),_j_),
            _cl_);
       else
        var i=caml_call1(Stdlib[2],cst_int64_of_big_int$1);
      if(0 <= bi[1])
       return caml_greaterequal(i,_h_)
               ?i
               :caml_call1(Stdlib[2],cst_int64_of_big_int);
      if(! caml_greaterequal(i,_i_) && ! caml_equal(i,Stdlib_int64[10]))
       return caml_call1(Stdlib[2],cst_int64_of_big_int$0);
      return caml_int64_neg(i)}
    function int64_of_big_int_opt(bi)
     {try
       {var _cj_=[0,int64_of_big_int(bi)];return _cj_}
      catch(_ck_)
       {_ck_ = caml_wrap_exception(_ck_);
        if(_ck_[1] === Stdlib[7])return 0;
        throw _ck_}}
    function nat_of_big_int(bi)
     {if(-1 === bi[1])return caml_call1(Stdlib[2],cst_nat_of_big_int);
      var _ci_=num_digits_big_int(bi);
      return copy_nat(bi[2],0,_ci_)}
    function sys_big_int_of_nat(nat,off,len)
     {var
       length=num_digits_nat(nat,off,len),
       _cg_=copy_nat(nat,off,length),
       _ch_=is_zero_nat(nat,off,length)?0:1;
      return [0,_ch_,_cg_]}
    function big_int_of_nat(nat)
     {return sys_big_int_of_nat(nat,0,length_nat(nat))}
    function string_of_big_int(bi)
     {if(-1 === bi[1])
       {var _cf_=string_of_nat(bi[2]);return caml_call2(Stdlib[28],cst,_cf_)}
      return string_of_nat(bi[2])}
    function sys_big_int_of_string_aux(s,ofs,len,sgn,base)
     {if(len < 1)caml_call1(Stdlib[2],cst_sys_big_int_of_string);
      var n=sys_nat_of_string(base,s,ofs,len);
      return is_zero_nat(n,0,length_nat(n))?zero_big_int:[0,sgn,n]}
    function sys_big_int_of_string_base(s,ofs,len,sgn)
     {if(len < 1)caml_call1(Stdlib[2],cst_sys_big_int_of_string$0);
      if(2 <= len)
       {var
         match=caml_string_get(s,ofs),
         match$0=caml_string_get(s,ofs + 1 | 0);
        if(48 === match)
         {var switch$0=0;
          if(89 <= match$0)
           {if(98 === match$0)
             switch$0 = 3;
            else
             if(111 === match$0)
              switch$0 = 2;
             else
              if(120 === match$0)switch$0 = 1}
          else
           if(66 === match$0)
            switch$0 = 3;
           else
            if(79 === match$0)switch$0 = 2;else if(88 <= match$0)switch$0 = 1;
          switch(switch$0)
           {case 0:break;
            case 1:
             return sys_big_int_of_string_aux
                     (s,ofs + 2 | 0,len - 2 | 0,sgn,16);
            case 2:
             return sys_big_int_of_string_aux(s,ofs + 2 | 0,len - 2 | 0,sgn,8);
            default:
             return sys_big_int_of_string_aux(s,ofs + 2 | 0,len - 2 | 0,sgn,2)}}
        return sys_big_int_of_string_aux(s,ofs,len,sgn,10)}
      return sys_big_int_of_string_aux(s,ofs,len,sgn,10)}
    function sys_big_int_of_string(s,ofs,len)
     {if(len < 1)caml_call1(Stdlib[2],cst_sys_big_int_of_string$1);
      var match=caml_string_get(s,ofs),switcher=match - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return sys_big_int_of_string_base(s,ofs + 1 | 0,len - 1 | 0,1);
         case 1:break;
         default:
          return sys_big_int_of_string_base(s,ofs + 1 | 0,len - 1 | 0,-1)}
      return sys_big_int_of_string_base(s,ofs,len,1)}
    function big_int_of_string(s)
     {return sys_big_int_of_string(s,0,caml_ml_string_length(s))}
    function big_int_of_string_opt(s)
     {try
       {var _cd_=[0,big_int_of_string(s)];return _cd_}
      catch(_ce_)
       {_ce_ = caml_wrap_exception(_ce_);
        if(_ce_[1] === Stdlib[7])return 0;
        throw _ce_}}
    function power_int_positive_int(i,n)
     {var match=sign_int(n);
      if(-1 === match)return caml_call1(Stdlib[1],cst_power_int_positive_int);
      if(0 === match)return unit_big_int;
      var
       nat=power_base_int(caml_call1(Stdlib[18],i),n),
       _cc_=0 <= i?sign_int(i):0 === (n & 1)?1:-1;
      return [0,_cc_,nat]}
    function power_big_int_positive_int(bi,n)
     {var match=sign_int(n);
      if(-1 === match)
       return caml_call1(Stdlib[1],cst_power_big_int_positive_int);
      if(0 === match)return unit_big_int;
      var
       bi_len=num_digits_big_int(bi),
       res_len=caml_mul(bi_len,n),
       res=make_nat(res_len),
       res2=make_nat(res_len),
       l=num_bits_int(n) - 2 | 0;
      blit_nat(res,0,bi[2],0,bi_len);
      if(! (l < 0))
       {var i=l;
        for(;;)
         {var
           len=num_digits_nat(res,0,res_len),
           len2=caml_call2(Stdlib[16],res_len,2 * len | 0);
          set_to_zero_nat(res2,0,len2);
          square_nat(res2,0,len2,res,0,len);
          if(0 < (n & 1 << i))
           {var lenp=caml_call2(Stdlib[16],res_len,len2 + bi_len | 0);
            set_to_zero_nat(res,0,lenp);
            mult_nat(res,0,lenp,res2,0,len2,bi[2],0,bi_len)}
          else
           blit_nat(res,0,res2,0,len2);
          var _cb_=i - 1 | 0;
          if(0 !== i){var i=_cb_;continue}
          break}}
      var _ca_=0 <= bi[1]?bi[1]:0 === (n & 1)?1:-1;
      return [0,_ca_,res]}
    function power_int_positive_big_int(i$0,bi)
     {var match$1=bi[1];
      if(-1 === match$1)
       return caml_call1(Stdlib[1],cst_power_int_positive_big_int);
      if(0 === match$1)return unit_big_int;
      var
       len$0=num_digits_big_int(bi),
       _b__=bi[2],
       base=caml_call1(Stdlib[18],i$0),
       off=0;
      if(0 === base)
       var nat=nat_of_int(0);
      else
       {var switch$0=0;
        if(is_zero_nat(_b__,off,len$0) || 1 === base)
         switch$0 = 1;
        else
         {var
           power_base=make_nat(_a_ + 1 | 0),
           match=make_power_base(base,power_base),
           pmax=match[1],
           _b8_=big_int_of_int(pmax + 1 | 0),
           match$0=quomod_big_int(sys_big_int_of_nat(_b__,off,len$0),_b8_),
           y=match$0[2],
           x=match$0[1],
           rem=int_of_big_int(y),
           n=int_of_big_int(x);
          if(0 === n)
           var nat=copy_nat(power_base,rem - 1 | 0,1);
          else
           {var
             res=make_nat(n),
             res2=make_nat(n + 1 | 0),
             l=num_bits_int(n) - 2 | 0;
            blit_nat(res,0,power_base,pmax,1);
            if(! (l < 0))
             {var i=l;
              for(;;)
               {var
                 len=num_digits_nat(res,0,n),
                 len2=caml_call2(Stdlib[16],n,2 * len | 0),
                 succ_len2=len2 + 1 | 0;
                square_nat(res2,0,len2,res,0,len);
                if(0 < (n & 1 << i))
                 {set_to_zero_nat(res,0,len);
                  mult_digit_nat(res,0,succ_len2,res2,0,len2,power_base,pmax)}
                else
                 blit_nat(res,0,res2,0,len2);
                set_to_zero_nat(res2,0,len2);
                var _b9_=i - 1 | 0;
                if(0 !== i){var i=_b9_;continue}
                break}}
            var
             nat=
              0 < rem
               ?(mult_digit_nat
                  (res2,0,n + 1 | 0,res,0,n,power_base,rem - 1 | 0),
                 res2)
               :res}}
        if(switch$0)var nat=nat_of_int(1)}
      var _b$_=0 <= i$0?sign_int(i$0):runtime.is_digit_odd(bi[2],0)?-1:1;
      return [0,_b$_,nat]}
    function power_big_int_positive_big_int(bi1,bi2)
     {var match=bi2[1];
      if(-1 === match)
       return caml_call1(Stdlib[1],cst_power_big_int_positive_big);
      if(0 === match)return unit_big_int;
      try
       {var _b5_=power_big_int_positive_int(bi1,int_of_big_int(bi2));
        return _b5_}
      catch(_b6_)
       {_b6_ = caml_wrap_exception(_b6_);
        if(_b6_[1] === Stdlib[7])
         try
          {var _b4_=power_int_positive_big_int(int_of_big_int(bi1),bi2);
           return _b4_}
         catch(_b7_)
          {_b7_ = caml_wrap_exception(_b7_);
           if(_b7_[1] === Stdlib[7])throw Stdlib[9];
           throw _b7_}
        throw _b6_}}
    function base_power_big_int(base,n,bi)
     {var match=sign_int(n);
      if(-1 === match)
       {var
         nat=power_base_int(base,- n | 0),
         len_nat=num_digits_nat(nat,0,length_nat(nat)),
         len_bi=num_digits_big_int(bi);
        if(len_bi < len_nat)
         return caml_call1(Stdlib[1],cst_base_power_big_int);
        if
         (len_bi
          ===
          len_nat
          &&
          -1
          ===
          runtime.compare_digits_nat(bi[2],len_bi,nat,len_nat))
         return caml_call1(Stdlib[1],cst_base_power_big_int$0);
        var copy=create_nat(len_bi + 1 | 0);
        blit_nat(copy,0,bi[2],0,len_bi);
        set_digit_nat(copy,len_bi,0);
        div_nat(copy,0,len_bi + 1 | 0,nat,0,len_nat);
        if(is_zero_nat(copy,0,len_nat))
         {var _b2_=copy_nat(copy,len_nat,1);return [0,bi[1],_b2_]}
        return caml_call1(Stdlib[1],cst_base_power_big_int$1)}
      if(0 === match)return bi;
      var
       nat$0=power_base_int(base,n),
       len_nat$0=num_digits_nat(nat$0,0,length_nat(nat$0)),
       len_bi$0=num_digits_big_int(bi),
       new_len=len_bi$0 + len_nat$0 | 0,
       nat$1=make_nat(new_len);
      if(len_nat$0 < len_bi$0)
       mult_nat(nat$1,0,new_len,bi[2],0,len_bi$0,nat$0,0,len_nat$0);
      else
       mult_nat(nat$1,0,new_len,nat$0,0,len_nat$0,bi[2],0,len_bi$0);
      if(is_zero_nat(nat$1,0,new_len))return zero_big_int;
      var _b3_=bi[1];
      if(1 !== _b3_ && -1 !== _b3_)
       {var switch$0=0;
        if
         (0
          !==
          _b3_
          ||
          !
          is_zero_nat(nat$1,0,num_digits_nat(nat$1,0,length_nat(nat$1))))
         switch$0 = 1;
        if(switch$0)return caml_call1(Stdlib[1],cst_create_big_int)}
      return [0,_b3_,nat$1]}
    function sqrt_big_int(bi)
     {var _b0_=bi[1];
      if(-1 === _b0_)return caml_call1(Stdlib[1],cst_sqrt_big_int);
      if(0 === _b0_)return zero_big_int;
      var _b1_=num_digits_big_int(bi);
      return [0,1,sqrt_nat(bi[2],0,_b1_)]}
    function square_big_int(bi)
     {if(0 === bi[1])return zero_big_int;
      var
       len_bi=num_digits_big_int(bi),
       len_res=2 * len_bi | 0,
       res=make_nat(len_res);
      square_nat(res,0,len_res,bi[2],0,len_bi);
      return [0,1,res]}
    function round_futur_last_digit(s,off_set,length)
     {var l=(length + off_set | 0) - 1 | 0;
      if(53 <= caml_bytes_get(s,l))
       {var l$2=l - 1 | 0,l$0=l$2;
        for(;;)
         {if(l$0 < off_set)return 1;
          var current_char=caml_bytes_get(s,l$0);
          if(57 === current_char)
           {caml_bytes_set(s,l$0,48);var l$1=l$0 - 1 | 0,l$0=l$1;continue}
          caml_bytes_set
           (s,l$0,caml_call1(Stdlib_char[1],current_char + 1 | 0));
          return 0}}
      return 0}
    function approx_big_int(prec,bi)
     {var
       len_bi=num_digits_big_int(bi),
       _bK_=big_int_of_string(cst_100000000),
       _bL_=big_int_of_string(cst_963295986),
       _bM_=
        int_of_big_int
         (add_int_big_int
           (- prec | 0,
            div_big_int
             (mult_big_int(big_int_of_int(len_bi - 1 | 0),_bL_),_bK_))),
       n=caml_call2(Stdlib[17],0,_bM_),
       _bN_=string_of_big_int(div_big_int(bi,power_int_positive_int(10,n))),
       s=caml_call1(Stdlib_bytes[5],_bN_);
      if(45 === caml_bytes_get(s,0))
       var off=1,sign$0=cst$0;
      else
       var off=0,sign$0=sign;
      if(round_futur_last_digit(s,off,prec + 1 | 0))
       {var
         _bO_=
          caml_call1
           (Stdlib[33],((n + 1 | 0) - off | 0) + caml_ml_bytes_length(s) | 0),
         _bP_=caml_call2(Stdlib[28],cst_e,_bO_),
         _bQ_=caml_call2(Stdlib_string[1],prec,48),
         _bR_=caml_call2(Stdlib[28],_bQ_,_bP_),
         _bS_=caml_call2(Stdlib[28],cst_1,_bR_);
        return caml_call2(Stdlib[28],sign$0,_bS_)}
      var
       _bT_=
        caml_call1
         (Stdlib[33],(n - (off + 1 | 0) | 0) + caml_ml_bytes_length(s) | 0),
       _bU_=caml_call2(Stdlib[28],cst_e$0,_bT_),
       _bV_=caml_call3(Stdlib_bytes[8],s,off + 1 | 0,prec - 1 | 0),
       _bW_=caml_call2(Stdlib[28],_bV_,_bU_),
       _bX_=caml_call2(Stdlib[28],cst$1,_bW_),
       _bY_=caml_call3(Stdlib_bytes[8],s,off,1),
       _bZ_=caml_call2(Stdlib[28],_bY_,_bX_);
      return caml_call2(Stdlib[28],sign$0,_bZ_)}
    function shift_left_big_int(bi,n)
     {if(0 <= n)
       {if(0 === n)return bi;
        if(0 === bi[1])return bi;
        var
         size_bi=num_digits_big_int(bi),
         size_res=size_bi + caml_div((n + _a_ | 0) - 1 | 0,_a_) | 0,
         res=create_nat(size_res),
         ndigits=caml_div(n,_a_);
        set_to_zero_nat(res,0,ndigits);
        blit_nat(res,ndigits,bi[2],0,size_bi);
        var nbits=caml_mod(n,_a_);
        if(0 < nbits)
         runtime.shift_left_nat
          (res,ndigits,size_bi,res,ndigits + size_bi | 0,nbits);
        return [0,bi[1],res]}
      return caml_call1(Stdlib[1],cst_shift_left_big_int)}
    function shift_right_towards_zero_big_i(bi,n)
     {if(0 <= n)
       {if(0 === n)return bi;
        if(0 === bi[1])return bi;
        var
         size_bi=num_digits_big_int(bi),
         ndigits=caml_div(n,_a_),
         nbits=caml_mod(n,_a_);
        if(size_bi <= ndigits)return zero_big_int;
        var size_res=size_bi - ndigits | 0,res=create_nat(size_res);
        blit_nat(res,0,bi[2],ndigits,size_res);
        if(0 < nbits)
         {var tmp=create_nat(1);shift_right_nat(res,0,size_res,tmp,0,nbits)}
        return is_zero_nat(res,0,size_res)?zero_big_int:[0,bi[1],res]}
      return caml_call1(Stdlib[1],cst_shift_right_towards_zero_b)}
    function shift_right_big_int(bi,n)
     {if(0 <= n)
       {if(0 <= bi[1])return shift_right_towards_zero_big_i(bi,n);
        if(0 <= n)
         if(0 === n)
          var _bJ_=zero_big_int;
         else
          {var
            idx=caml_div(n,_a_),
            size_res=idx + 1 | 0,
            res=make_nat(size_res);
           set_digit_nat_native(res,idx,1 << caml_mod(n,_a_));
           decr_nat(res,0,size_res,0);
           var _bJ_=[0,1,res]}
        else
         var _bJ_=caml_call1(Stdlib[1],cst_two_power_m1_big_int);
        return shift_right_towards_zero_big_i(sub_big_int(bi,_bJ_),n)}
      return caml_call1(Stdlib[1],cst_shift_right_big_int)}
    function extract_big_int(bi,ofs,n)
     {if(0 <= ofs && 0 <= n)
       {if(0 === bi[1])return bi;
        var
         size_bi=num_digits_big_int(bi),
         size_res=caml_div((n + _a_ | 0) - 1 | 0,_a_),
         ndigits=caml_div(ofs,_a_),
         nbits=caml_mod(ofs,_a_),
         res=make_nat(size_res);
        if(ndigits < size_bi)
         {var _bE_=caml_call2(Stdlib[16],size_res,size_bi - ndigits | 0);
          blit_nat(res,0,bi[2],ndigits,_bE_)}
        if(bi[1] < 0)
         {complement_nat(res,0,size_res);
          var i=0;
          for(;;)
           {var _bF_=ndigits <= i?1:0;
            if(_bF_)
             var _bG_=_bF_;
            else
             {var _bH_=size_bi <= i?1:0;
              if(_bH_)
               var _bG_=_bH_;
              else
               {var _bI_=is_digit_zero(bi[2],i);
                if(_bI_){var i$0=i + 1 | 0,i=i$0;continue}
                var _bG_=_bI_}}
            if(_bG_)incr_nat(res,0,size_res,1);
            break}}
        if(0 < nbits)
         {var tmp=create_nat(1);shift_right_nat(res,0,size_res,tmp,0,nbits)}
        var n$0=caml_mod(n,_a_);
        if(0 < n$0)
         {var tmp$0=create_nat(1);
          set_digit_nat_native(tmp$0,0,-1 >>> (_a_ - n$0 | 0) | 0);
          land_digit_nat(res,size_res - 1 | 0,tmp$0,0)}
        return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
      return caml_call1(Stdlib[1],cst_extract_big_int)}
    function and_big_int(a,b)
     {if(0 <= a[1] && 0 <= b[1])
       {if(0 !== a[1] && 0 !== b[1])
         {var
           size_a=num_digits_big_int(a),
           size_b=num_digits_big_int(b),
           size_res=caml_call2(Stdlib[16],size_a,size_b),
           res=create_nat(size_res);
          blit_nat(res,0,a[2],0,size_res);
          var _bC_=size_res - 1 | 0,_bB_=0;
          if(! (_bC_ < 0))
           {var i=_bB_;
            for(;;)
             {land_digit_nat(res,i,b[2],i);
              var _bD_=i + 1 | 0;
              if(_bC_ !== i){var i=_bD_;continue}
              break}}
          return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
        return zero_big_int}
      return caml_call1(Stdlib[1],cst_and_big_int)}
    function or_big_int(a,b)
     {if(0 <= a[1] && 0 <= b[1])
       {if(0 === a[1])return b;
        if(0 === b[1])return a;
        var
         size_a=num_digits_big_int(a),
         size_b=num_digits_big_int(b),
         size_res=caml_call2(Stdlib[17],size_a,size_b),
         res=create_nat(size_res),
         or_aux=
          function(a,b,size_b)
           {blit_nat(res,0,a[2],0,size_res);
            var _bz_=size_b - 1 | 0,_by_=0;
            if(! (_bz_ < 0))
             {var i=_by_;
              for(;;)
               {runtime.lor_digit_nat(res,i,b[2],i);
                var _bA_=i + 1 | 0;
                if(_bz_ !== i){var i=_bA_;continue}
                break}}
            return 0};
        if(size_b <= size_a)or_aux(a,b,size_b);else or_aux(b,a,size_a);
        return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
      return caml_call1(Stdlib[1],cst_or_big_int)}
    function xor_big_int(a,b)
     {if(0 <= a[1] && 0 <= b[1])
       {if(0 === a[1])return b;
        if(0 === b[1])return a;
        var
         size_a=num_digits_big_int(a),
         size_b=num_digits_big_int(b),
         size_res=caml_call2(Stdlib[17],size_a,size_b),
         res=create_nat(size_res),
         xor_aux=
          function(a,b,size_b)
           {blit_nat(res,0,a[2],0,size_res);
            var _bw_=size_b - 1 | 0,_bv_=0;
            if(! (_bw_ < 0))
             {var i=_bv_;
              for(;;)
               {runtime.lxor_digit_nat(res,i,b[2],i);
                var _bx_=i + 1 | 0;
                if(_bw_ !== i){var i=_bx_;continue}
                break}}
            return 0};
        if(size_b <= size_a)xor_aux(a,b,size_b);else xor_aux(b,a,size_a);
        return is_zero_nat(res,0,size_res)?zero_big_int:[0,1,res]}
      return caml_call1(Stdlib[1],cst_xor_big_int)}
    function round_big_int_to_float(x,exact)
     {var n=num_bits_big_int(x),_bt_=55 <= n?1:0,_bu_=_bt_?n <= 63?1:0:_bt_;
      if(_bu_)
       {var m=int64_of_big_int(x),m$0=exact?m:caml_int64_or(m,_k_);
        return caml_int64_to_float(m$0)}
      throw [0,Assert_failure,_l_]}
    function float_of_big_int(x)
     {var n=num_bits_big_int(x);
      if(63 < n)
       {var
         n$0=n - 55 | 0,
         top=shift_right_big_int(x,n$0),
         exact=eq_big_int(x,shift_left_big_int(top,n$0));
        return caml_ldexp_float(round_big_int_to_float(top,exact),n$0)}
      return caml_int64_to_float(int64_of_big_int(x))}
    var
     Big_int=
      [0,
       zero_big_int,
       unit_big_int,
       minus_big_int,
       abs_big_int,
       add_big_int,
       succ_big_int,
       add_int_big_int,
       sub_big_int,
       pred_big_int,
       mult_big_int,
       mult_int_big_int,
       square_big_int,
       sqrt_big_int,
       quomod_big_int,
       div_big_int,
       mod_big_int,
       gcd_big_int,
       power_int_positive_int,
       power_big_int_positive_int,
       power_int_positive_big_int,
       power_big_int_positive_big_int,
       sign_big_int,
       compare_big_int,
       eq_big_int,
       le_big_int,
       ge_big_int,
       lt_big_int,
       gt_big_int,
       max_big_int,
       min_big_int,
       num_digits_big_int,
       num_bits_big_int,
       string_of_big_int,
       big_int_of_string,
       big_int_of_string_opt,
       big_int_of_int,
       is_int_big_int,
       int_of_big_int,
       int_of_big_int_opt,
       big_int_of_int32,
       big_int_of_nativeint,
       big_int_of_int64,
       int32_of_big_int,
       int32_of_big_int_opt,
       nativeint_of_big_int,
       nativeint_of_big_int_opt,
       int64_of_big_int,
       int64_of_big_int_opt,
       float_of_big_int,
       and_big_int,
       or_big_int,
       xor_big_int,
       shift_left_big_int,
       shift_right_big_int,
       shift_right_towards_zero_big_i,
       extract_big_int,
       nat_of_big_int,
       big_int_of_nat,
       base_power_big_int,
       sys_big_int_of_string,
       round_futur_last_digit,
       approx_big_int,
       round_big_int_to_float];
    caml_register_global(130,Big_int,"Big_int");
    var
     error_when_null_denominator_fl=[0,1],
     normalize_ratio_flag=[0,0],
     normalize_ratio_when_printing_=[0,1],
     floating_precision=[0,12],
     approx_printing_flag=[0,0],
     Arith_flags=
      [0,
       error_when_null_denominator_fl,
       normalize_ratio_flag,
       normalize_ratio_when_printing_,
       floating_precision,
       approx_printing_flag];
    caml_register_global(131,Arith_flags,"Arith_flags");
    function failwith_zero(name)
     {if(0 === caml_ml_string_length(name))
       var s$0=s;
      else
       var
        _bs_=caml_call2(Stdlib[28],cst$2,s),
        s$0=caml_call2(Stdlib[28],name,_bs_);
      return caml_call1(Stdlib[2],s$0)}
    function numerator_ratio(r){return r[1]}
    function denominator_ratio(r){return r[2]}
    function null_denominator(r){return 0 === r[2][1]?1:0}
    function verify_null_denominator(r)
     {return 0 === r[2][1]
              ?error_when_null_denominator_fl[1]?failwith_zero(cst$3):1
              :0}
    function sign_ratio(r){return r[1][1]}
    function normalize_ratio(r)
     {if(r[3])return r;
      if(verify_null_denominator(r))
       {r[1] = big_int_of_int(r[1][1]);r[3] = 1;return r}
      var p=gcd_big_int(r[1],r[2]);
      return eq_big_int(p,unit_big_int)
              ?(r[3] = 1,r)
              :(r[1]
                =
                div_big_int(r[1],p),
                r[2]
                =
                div_big_int(r[2],p),
                r[3]
                =
                1,
                r)}
    function cautious_normalize_ratio(r)
     {return normalize_ratio_flag[1]?normalize_ratio(r):r}
    function cautious_normalize_ratio_when_(r)
     {return normalize_ratio_when_printing_[1]?normalize_ratio(r):r}
    function create_ratio(bi1,bi2)
     {var match=bi2[1];
      if(-1 === match)
       {var _br_=minus_big_int(bi2);
        return cautious_normalize_ratio([0,minus_big_int(bi1),_br_,0])}
      return 0 === match
              ?error_when_null_denominator_fl[1]
                ?failwith_zero(cst_create_ratio)
                :cautious_normalize_ratio([0,bi1,bi2,0])
              :cautious_normalize_ratio([0,bi1,bi2,0])}
    function create_normalized_ratio(bi1,bi2)
     {var match=bi2[1];
      if(-1 === match)
       {var _bq_=minus_big_int(bi2);return [0,minus_big_int(bi1),_bq_,1]}
      return 0 === match
              ?error_when_null_denominator_fl[1]
                ?failwith_zero(cst_create_normalized_ratio)
                :[0,bi1,bi2,1]
              :[0,bi1,bi2,1]}
    function is_normalized_ratio(r){return r[3]}
    function report_sign_ratio(r,bi)
     {return -1 === sign_ratio(r)?minus_big_int(bi):bi}
    function abs_ratio(r)
     {var _bo_=r[3],_bp_=r[2];return [0,abs_big_int(r[1]),_bp_,_bo_]}
    function is_integer_ratio(r)
     {return eq_big_int(normalize_ratio(r)[2],unit_big_int)}
    function add_ratio(r1,r2)
     {if(normalize_ratio_flag[1])
       {var
         _bh_=normalize_ratio(r2)[2],
         p=gcd_big_int(normalize_ratio(r1)[2],_bh_);
        if(eq_big_int(p,unit_big_int))
         {var _bi_=mult_big_int(r1[2],r2[2]),_bj_=mult_big_int(r2[1],r1[2]);
          return [0,add_big_int(mult_big_int(r1[1],r2[2]),_bj_),_bi_,1]}
        var
         d1=div_big_int(r1[2],p),
         d2=div_big_int(r2[2],p),
         _bk_=mult_big_int(d1,r2[1]),
         n=add_big_int(mult_big_int(r1[1],d2),_bk_),
         p$0=gcd_big_int(n,p),
         _bl_=mult_big_int(d1,div_big_int(r2[2],p$0));
        return [0,div_big_int(n,p$0),_bl_,1]}
      var _bm_=mult_big_int(r1[2],r2[2]),_bn_=mult_big_int(r1[2],r2[1]);
      return [0,add_big_int(mult_big_int(r1[1],r2[2]),_bn_),_bm_,0]}
    function minus_ratio(r)
     {var _bf_=r[3],_bg_=r[2];return [0,minus_big_int(r[1]),_bg_,_bf_]}
    function add_int_ratio(i,r)
     {cautious_normalize_ratio(r);
      var _bc_=r[3],_bd_=r[2],_be_=r[1];
      return [0,add_big_int(mult_int_big_int(i,r[2]),_be_),_bd_,_bc_]}
    function add_big_int_ratio(bi,r)
     {cautious_normalize_ratio(r);
      var _a$_=r[3],_ba_=r[2],_bb_=r[1];
      return [0,add_big_int(mult_big_int(bi,r[2]),_bb_),_ba_,_a$_]}
    function sub_ratio(r1,r2){return add_ratio(r1,minus_ratio(r2))}
    function mult_ratio(r1,r2)
     {if(normalize_ratio_flag[1])
       {var
         _a6_=normalize_ratio(r2)[2],
         p1=gcd_big_int(normalize_ratio(r1)[1],_a6_),
         p2=gcd_big_int(r2[1],r1[2]);
        if(eq_big_int(p1,unit_big_int))
         var _a8_=r2[2],_a7_=r1[1];
        else
         var d2=div_big_int(r2[2],p1),_a8_=d2,_a7_=div_big_int(r1[1],p1);
        if(eq_big_int(p2,unit_big_int))
         var d1=r1[2],n2=r2[1];
        else
         var
          d1$0=div_big_int(r1[2],p2),
          n2$0=div_big_int(r2[1],p2),
          d1=d1$0,
          n2=n2$0;
        var _a9_=mult_big_int(d1,_a8_);
        return [0,mult_big_int(_a7_,n2),_a9_,1]}
      var _a__=mult_big_int(r1[2],r2[2]);
      return [0,mult_big_int(r1[1],r2[1]),_a__,0]}
    function mult_int_ratio(i,r)
     {if(normalize_ratio_flag[1])
       {var _a0_=big_int_of_int(i),p=gcd_big_int(normalize_ratio(r)[2],_a0_);
        if(eq_big_int(p,unit_big_int))
         {var _a1_=r[2],_a2_=r[1];
          return [0,mult_big_int(big_int_of_int(i),_a2_),_a1_,1]}
        var _a3_=div_big_int(r[2],p),_a4_=r[1];
        return [0,mult_big_int(div_big_int(big_int_of_int(i),p),_a4_),_a3_,1]}
      var _a5_=r[2];
      return [0,mult_int_big_int(i,r[1]),_a5_,0]}
    function mult_big_int_ratio(bi,r)
     {if(normalize_ratio_flag[1])
       {var p=gcd_big_int(normalize_ratio(r)[2],bi);
        if(eq_big_int(p,unit_big_int))
         {var _aW_=r[2];return [0,mult_big_int(bi,r[1]),_aW_,1]}
        var _aX_=div_big_int(r[2],p),_aY_=r[1];
        return [0,mult_big_int(div_big_int(bi,p),_aY_),_aX_,1]}
      var _aZ_=r[2];
      return [0,mult_big_int(bi,r[1]),_aZ_,0]}
    function square_ratio(r)
     {cautious_normalize_ratio(r);
      var _aU_=r[3],_aV_=square_big_int(r[2]);
      return [0,square_big_int(r[1]),_aV_,_aU_]}
    function inverse_ratio(r)
     {if(error_when_null_denominator_fl[1] && 0 === r[1][1])
       return failwith_zero(cst_inverse_ratio);
      var _aS_=r[3],_aT_=abs_big_int(r[1]);
      return [0,report_sign_ratio(r,r[2]),_aT_,_aS_]}
    function div_ratio(r1,r2){return mult_ratio(r1,inverse_ratio(r2))}
    function integer_ratio(r)
     {if(null_denominator(r))return failwith_zero(cst_integer_ratio);
      if(0 === sign_ratio(r))return zero_big_int;
      var _aR_=abs_big_int(r[2]);
      return report_sign_ratio(r,div_big_int(abs_big_int(r[1]),_aR_))}
    function floor_ratio(r)
     {verify_null_denominator(r);return div_big_int(r[1],r[2])}
    function round_ratio(r)
     {verify_null_denominator(r);
      var
       abs_num=abs_big_int(r[1]),
       bi=div_big_int(abs_num,r[2]),
       _aQ_=r[2],
       bi$0=
        -1
         ===
         sub_big_int
           (mult_int_big_int(2,sub_big_int(abs_num,mult_big_int(r[2],bi))),
            _aQ_)
          [1]
         ?bi
         :succ_big_int(bi);
      return report_sign_ratio(r,bi$0)}
    function ceiling_ratio(r)
     {return is_integer_ratio(r)?r[1]:succ_big_int(floor_ratio(r))}
    function eq_ratio(r1,r2)
     {normalize_ratio(r1);
      normalize_ratio(r2);
      var _aP_=eq_big_int(r1[1],r2[1]);
      return _aP_?eq_big_int(r1[2],r2[2]):_aP_}
    function compare_ratio(r1,r2)
     {if(verify_null_denominator(r1))
       {var sign_num_r1=r1[1][1];
        if(verify_null_denominator(r2))
         {var sign_num_r2=r2[1][1];
          if(1 === sign_num_r1 && -1 === sign_num_r2)return 1;
          if(-1 === sign_num_r1 && 1 === sign_num_r2)return -1;
          return 0}
        return sign_num_r1}
      if(verify_null_denominator(r2))return - r2[1][1] | 0;
      var match=compare_int(r1[1][1],r2[1][1]),switcher=match + 1 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher){case 0:return -1;case 1:break;default:return 1}
      if(eq_big_int(r1[2],r2[2]))return compare_big_int(r1[1],r2[1]);
      var _aO_=mult_big_int(r1[2],r2[1]);
      return compare_big_int(mult_big_int(r1[1],r2[2]),_aO_)}
    function lt_ratio(r1,r2){return compare_ratio(r1,r2) < 0?1:0}
    function le_ratio(r1,r2){return compare_ratio(r1,r2) <= 0?1:0}
    function gt_ratio(r1,r2){return 0 < compare_ratio(r1,r2)?1:0}
    function ge_ratio(r1,r2){return 0 <= compare_ratio(r1,r2)?1:0}
    function max_ratio(r1,r2){return lt_ratio(r1,r2)?r2:r1}
    function min_ratio(r1,r2){return gt_ratio(r1,r2)?r2:r1}
    function eq_big_int_ratio(bi,r)
     {var _aN_=is_integer_ratio(r);return _aN_?eq_big_int(bi,r[1]):_aN_}
    function compare_big_int_ratio(bi,r)
     {normalize_ratio(r);
      if(verify_null_denominator(r))return - r[1][1] | 0;
      var _aM_=r[1];
      return compare_big_int(mult_big_int(bi,r[2]),_aM_)}
    function lt_big_int_ratio(bi,r)
     {return compare_big_int_ratio(bi,r) < 0?1:0}
    function le_big_int_ratio(bi,r)
     {return compare_big_int_ratio(bi,r) <= 0?1:0}
    function gt_big_int_ratio(bi,r)
     {return 0 < compare_big_int_ratio(bi,r)?1:0}
    function ge_big_int_ratio(bi,r)
     {return 0 <= compare_big_int_ratio(bi,r)?1:0}
    function int_of_ratio(r)
     {if(is_integer_ratio(r) && is_int_big_int(r[1]))
       return int_of_big_int(r[1]);
      return caml_call1(Stdlib[2],cst_integer_argument_required)}
    function ratio_of_int(i){return [0,big_int_of_int(i),unit_big_int,1]}
    function ratio_of_nat(nat){return [0,big_int_of_nat(nat),unit_big_int,1]}
    function nat_of_ratio(r)
     {normalize_ratio(r);
      return is_integer_ratio(r)
              ?-1 < r[1][1]
                ?nat_of_big_int(r[1])
                :caml_call1(Stdlib[2],cst_nat_of_ratio)
              :caml_call1(Stdlib[2],cst_nat_of_ratio$0)}
    function ratio_of_big_int(bi){return [0,bi,unit_big_int,1]}
    function big_int_of_ratio(r)
     {normalize_ratio(r);
      return is_integer_ratio(r)
              ?r[1]
              :caml_call1(Stdlib[2],cst_big_int_of_ratio)}
    function div_int_ratio(i,r)
     {verify_null_denominator(r);return mult_int_ratio(i,inverse_ratio(r))}
    function div_ratio_int(r,i){return div_ratio(r,ratio_of_int(i))}
    function div_big_int_ratio(bi,r)
     {verify_null_denominator(r);
      return mult_big_int_ratio(bi,inverse_ratio(r))}
    function div_ratio_big_int(r,bi){return div_ratio(r,ratio_of_big_int(bi))}
    function approx_ratio_fix(n,r)
     {if(null_denominator(r))return failwith_zero(cst_approx_ratio_fix);
      var sign_r=sign_ratio(r);
      if(0 === sign_r)return cst_0;
      if(0 <= n)
       {var
         _aG_=r[2],
         s1=
          string_of_nat
           (nat_of_big_int
             (div_big_int
               (base_power_big_int(10,n + 1 | 0,abs_big_int(r[1])),_aG_))),
         s1$0=caml_call1(Stdlib_bytes[5],s1);
        if(round_futur_last_digit(s1$0,0,caml_ml_bytes_length(s1$0)))
         var
          _aH_=caml_call1(Stdlib_bytes[5],cst_1$0),
          s2=caml_call2(Stdlib_bytes[14],_aH_,s1$0);
        else
         var s2=s1$0;
        var l2=caml_ml_bytes_length(s2) - 1 | 0;
        if(n < l2)
         {var
           s=caml_call2(Stdlib_bytes[1],l2 + 2 | 0,48),
           _aI_=-1 === sign_r?45:43;
          caml_bytes_set(s,0,_aI_);
          caml_call5(Stdlib_bytes[11],s2,0,s,1,l2 - n | 0);
          caml_bytes_set(s,(l2 - n | 0) + 1 | 0,46);
          caml_call5(Stdlib_bytes[11],s2,l2 - n | 0,s,(l2 - n | 0) + 2 | 0,n);
          return caml_call1(Stdlib_bytes[42],s)}
        var
         s$0=caml_call2(Stdlib_bytes[1],n + 3 | 0,48),
         _aJ_=-1 === sign_r?45:43;
        caml_bytes_set(s$0,0,_aJ_);
        caml_bytes_set(s$0,2,46);
        caml_call5(Stdlib_bytes[11],s2,0,s$0,(n + 3 | 0) - l2 | 0,l2);
        return caml_call1(Stdlib_bytes[42],s$0)}
      var
       _aK_=base_power_big_int(10,- n | 0,r[2]),
       s$1=string_of_big_int(div_big_int(abs_big_int(r[1]),_aK_)),
       len=caml_ml_string_length(s$1) + 1 | 0,
       s$2=caml_call2(Stdlib_bytes[1],len,48),
       _aL_=-1 === sign_r?45:43;
      caml_bytes_set(s$2,0,_aL_);
      caml_call5(Stdlib_string[32],s$1,0,s$2,1,len - 1 | 0);
      return caml_call1(Stdlib_bytes[42],s$2)}
    function num_decimal_digits_int(n)
     {return caml_ml_string_length(caml_call1(Stdlib[33],n))}
    function approx_ratio_exp(n,r)
     {if(null_denominator(r))return failwith_zero(cst_approx_ratio_exp);
      if(0 < n)
       {var sign_r=sign_ratio(r),i$4=[0,n + 3 | 0];
        if(0 === sign_r)
         {var _ar_=[0,cst_0$0,[0,caml_call2(Stdlib_string[1],n,48),_m_]];
          return caml_call2(Stdlib_string[3],cst$4,_ar_)}
        var r$0=abs_ratio(r);
        cautious_normalize_ratio(r$0);
        if(null_denominator(r$0))
         var msd=failwith_zero(cst_msd_ratio);
        else
         if(0 === r$0[1][1])
          var msd=0;
         else
          {var
            s1=string_of_big_int(r$0[1]),
            s=string_of_big_int(r$0[2]),
            size_num=caml_ml_string_length(s1),
            lim=caml_ml_string_length(s),
            i$3=caml_call2(Stdlib[16],size_num,lim),
            m=size_num - lim | 0,
            i=0;
           for(;;)
            {if(i$3 <= i)
              var cmp=0;
             else
              {var
                c1=caml_string_get(s1,i),
                c2=caml_string_get(s,i),
                c=compare_int(c1,c2);
               if(0 === c){var i$0=i + 1 | 0,i=i$0;continue}
               var cmp=c}
             var switcher=cmp + 1 | 0,switch$0=0;
             if(2 < switcher >>> 0)
              switch$0 = 1;
             else
              switch(switcher)
               {case 0:var msd=m - 1 | 0;break;
                case 1:switch$0 = 1;break;
                default:var msd=m}
             if(switch$0)
              if(0 <= m)
               var msd=m;
              else
               {var i$1=i$3;
                for(;;)
                 {var _ao_=lim <= i$1?1:0;
                  if(_ao_)
                   var _ap_=_ao_;
                  else
                   {var _aq_=48 === caml_string_get(s,i$1)?1:0;
                    if(_aq_){var i$2=i$1 + 1 | 0,i$1=i$2;continue}
                    var _ap_=_aq_}
                  var msd=_ap_?m:m - 1 | 0;
                  break}}
             break}}
        var k=n - msd | 0;
        if(0 <= k)
         var
          _as_=r[2],
          _at_=div_big_int(base_power_big_int(10,k,abs_big_int(r[1])),_as_);
        else
         var
          _aF_=base_power_big_int(10,- k | 0,r[2]),
          _at_=div_big_int(abs_big_int(r[1]),_aF_);
        var
         nat=nat_of_big_int(_at_),
         s$0=string_of_nat(nat),
         s$1=caml_call1(Stdlib_bytes[5],s$0);
        if(round_futur_last_digit(s$1,0,caml_ml_bytes_length(s$1)))
         {var
           m$0=num_decimal_digits_int(msd + 1 | 0),
           str=caml_call2(Stdlib_bytes[1],(n + m$0 | 0) + 4 | 0,48),
           _au_=3,
           _av_=0,
           _aw_=0,
           _ax_=-1 === sign_r?cst_1$1:cst_1$2;
          caml_call5(Stdlib_string[32],_ax_,_aw_,str,_av_,_au_);
          caml_bytes_set(str,i$4[1],101);
          i$4[1]++;
          if(0 === m$0)
           caml_bytes_set(str,i$4[1],48);
          else
           {var _ay_=i$4[1],_az_=caml_call1(Stdlib[33],msd + 1 | 0);
            caml_call5(Stdlib_string[32],_az_,0,str,_ay_,m$0)}
          return caml_call1(Stdlib_bytes[42],str)}
        var
         m$1=num_decimal_digits_int(msd + 1 | 0),
         p=n + 3 | 0,
         str$0=caml_call2(Stdlib_bytes[1],(m$1 + p | 0) + 1 | 0,48),
         _aA_=3,
         _aB_=0,
         _aC_=0,
         _aD_=-1 === sign_r?cst_0$1:cst_0$2;
        caml_call5(Stdlib_string[32],_aD_,_aC_,str$0,_aB_,_aA_);
        caml_call5(Stdlib_bytes[11],s$1,0,str$0,3,n);
        caml_bytes_set(str$0,p,101);
        if(0 === m$1)
         caml_bytes_set(str$0,p + 1 | 0,48);
        else
         {var _aE_=caml_call1(Stdlib[33],msd + 1 | 0);
          caml_call5(Stdlib_string[32],_aE_,0,str$0,p + 1 | 0,m$1)}
        return caml_call1(Stdlib_bytes[42],str$0)}
      return caml_call1(Stdlib[1],cst_approx_ratio_exp$0)}
    function float_of_rational_string(r)
     {var s=approx_ratio_exp(floating_precision[1],r);
      return 43 === caml_string_get(s,0)
              ?caml_call3
                (Stdlib_string[9],s,1,caml_ml_string_length(s) - 1 | 0)
              :s}
    function string_of_ratio(r)
     {cautious_normalize_ratio_when_(r);
      if(approx_printing_flag[1])return float_of_rational_string(r);
      var
       _al_=string_of_big_int(r[2]),
       _am_=caml_call2(Stdlib[28],cst$5,_al_),
       _an_=string_of_big_int(r[1]);
      return caml_call2(Stdlib[28],_an_,_am_)}
    function ratio_of_string(s)
     {try
       {var
         n=caml_call2(Stdlib_string[25],s,47),
         _ai_=
          sys_big_int_of_string
           (s,n + 1 | 0,(caml_ml_string_length(s) - n | 0) - 1 | 0),
         _aj_=create_ratio(sys_big_int_of_string(s,0,n),_ai_);
        return _aj_}
      catch(_ak_)
       {_ak_ = caml_wrap_exception(_ak_);
        if(_ak_ === Stdlib[8])return [0,big_int_of_string(s),unit_big_int,1];
        throw _ak_}}
    function float_of_ratio(r)
     {var p=r[1],q=r[2];
      if(0 === q[1])
       {var match=p[1],switcher=match + 1 | 0;
        if(2 < switcher >>> 0)throw [0,Assert_failure,_n_];
        switch(switcher)
         {case 0:return Stdlib[23];
          case 1:return Stdlib[24];
          default:return Stdlib[22]}}
      if(0 === p[1])return 0.;
      var np=num_bits_big_int(p),nq=num_bits_big_int(q);
      if(! (53 < np) && ! (53 < nq))
       {var _ah_=caml_int64_to_float(int64_of_big_int(q));
        return caml_int64_to_float(int64_of_big_int(p)) / _ah_}
      var ap=abs_big_int(p),n=55 - (np - nq | 0) | 0;
      if(0 <= n)
       var q$0=q,p$0=shift_left_big_int(ap,n);
      else
       var q$1=shift_left_big_int(q,- n | 0),q$0=q$1,p$0=ap;
      var
       match$0=quomod_big_int(p$0,q$0),
       rem=match$0[2],
       quo=match$0[1],
       f=round_big_int_to_float(quo,0 === rem[1]?1:0),
       f$0=caml_ldexp_float(f,- n | 0);
      return 0 <= p[1]?f$0:- f$0}
    function power_ratio_positive_int(r,n)
     {var _ag_=power_big_int_positive_int(r[2],n);
      return create_ratio(power_big_int_positive_int(r[1],n),_ag_)}
    function power_ratio_positive_big_int(r,bi)
     {var _af_=power_big_int_positive_big_int(r[2],bi);
      return create_ratio(power_big_int_positive_big_int(r[1],bi),_af_)}
    var
     Ratio=
      [0,
       null_denominator,
       numerator_ratio,
       denominator_ratio,
       sign_ratio,
       normalize_ratio,
       cautious_normalize_ratio,
       cautious_normalize_ratio_when_,
       create_ratio,
       create_normalized_ratio,
       is_normalized_ratio,
       report_sign_ratio,
       abs_ratio,
       is_integer_ratio,
       add_ratio,
       minus_ratio,
       add_int_ratio,
       add_big_int_ratio,
       sub_ratio,
       mult_ratio,
       mult_int_ratio,
       mult_big_int_ratio,
       square_ratio,
       inverse_ratio,
       div_ratio,
       integer_ratio,
       floor_ratio,
       round_ratio,
       ceiling_ratio,
       eq_ratio,
       compare_ratio,
       lt_ratio,
       le_ratio,
       gt_ratio,
       ge_ratio,
       max_ratio,
       min_ratio,
       eq_big_int_ratio,
       compare_big_int_ratio,
       lt_big_int_ratio,
       le_big_int_ratio,
       gt_big_int_ratio,
       ge_big_int_ratio,
       int_of_ratio,
       ratio_of_int,
       ratio_of_nat,
       nat_of_ratio,
       ratio_of_big_int,
       big_int_of_ratio,
       div_int_ratio,
       div_ratio_int,
       div_big_int_ratio,
       div_ratio_big_int,
       approx_ratio_fix,
       approx_ratio_exp,
       float_of_rational_string,
       string_of_ratio,
       ratio_of_string,
       float_of_ratio,
       power_ratio_positive_int,
       power_ratio_positive_big_int];
    caml_register_global(132,Ratio,"Ratio");
    var
     biggest_INT=big_int_of_int(biggest_int),
     least_INT=big_int_of_int(least_int);
    function num_of_big_int(bi)
     {if(le_big_int(bi,biggest_INT) && ge_big_int(bi,least_INT))
       return [0,int_of_big_int(bi)];
      return [1,bi]}
    function num_of_ratio(r)
     {normalize_ratio(r);
      return is_integer_ratio(r)
              ?is_int_big_int(r[1])?[0,int_of_big_int(r[1])]:[1,r[1]]
              :[2,r]}
    function add_num(a,match)
     {switch(a[0])
       {case 0:
         var _ab_=a[1];
         switch(match[0])
          {case 0:
            var int2=match[1],r=_ab_ + int2 | 0;
            if(0 <= (_ab_ ^ int2 | _ab_ ^ r ^ -1))
             {var _ac_=big_int_of_int(int2);
              return [1,add_big_int(big_int_of_int(_ab_),_ac_)]}
            return [0,r];
           case 1:
            var bi=match[1];return num_of_big_int(add_int_big_int(_ab_,bi));
           default:var r$0=match[1];return [2,add_int_ratio(_ab_,r$0)]}
        case 1:
         var _ad_=a[1];
         switch(match[0])
          {case 0:
            var i=match[1];return num_of_big_int(add_int_big_int(i,_ad_));
           case 1:
            var bi2=match[1];return num_of_big_int(add_big_int(_ad_,bi2));
           default:var r$1=match[1];return [2,add_big_int_ratio(_ad_,r$1)]}
        default:
         var _ae_=a[1];
         switch(match[0])
          {case 0:var i$0=match[1];return [2,add_int_ratio(i$0,_ae_)];
           case 1:var bi$0=match[1];return [2,add_big_int_ratio(bi$0,_ae_)];
           default:var r2=match[1];return num_of_ratio(add_ratio(_ae_,r2))}}}
    function minus_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === monster_int
                 ?[1,minus_big_int(big_int_of_int(i))]
                 :[0,- i | 0];
        case 1:var bi=param[1];return [1,minus_big_int(bi)];
        default:var r=param[1];return [2,minus_ratio(r)]}}
    function sub_num(n1,n2){return add_num(n1,minus_num(n2))}
    function mult_num(a,match)
     {switch(a[0])
       {case 0:
         var _Y_=a[1];
         switch(match[0])
          {case 0:
            var int2=match[1],_Z_=num_bits_int(int2);
            if((num_bits_int(_Y_) + _Z_ | 0) < length_of_int)
             return [0,caml_mul(_Y_,int2)];
            var ___=big_int_of_int(int2);
            return num_of_big_int(mult_big_int(big_int_of_int(_Y_),___));
           case 1:
            var bi=match[1];return num_of_big_int(mult_int_big_int(_Y_,bi));
           default:var r=match[1];return num_of_ratio(mult_int_ratio(_Y_,r))}
        case 1:
         var _$_=a[1];
         switch(match[0])
          {case 0:
            var i=match[1];return num_of_big_int(mult_int_big_int(i,_$_));
           case 1:
            var bi2=match[1];return num_of_big_int(mult_big_int(_$_,bi2));
           default:
            var r$0=match[1];return num_of_ratio(mult_big_int_ratio(_$_,r$0))}
        default:
         var _aa_=a[1];
         switch(match[0])
          {case 0:
            var i$0=match[1];return num_of_ratio(mult_int_ratio(i$0,_aa_));
           case 1:
            var bi$0=match[1];
            return num_of_ratio(mult_big_int_ratio(bi$0,_aa_));
           default:var r2=match[1];return num_of_ratio(mult_ratio(_aa_,r2))}}}
    function square_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return (2 * num_bits_int(i) | 0) < length_of_int
                 ?[0,caml_mul(i,i)]
                 :num_of_big_int(square_big_int(big_int_of_int(i)));
        case 1:var bi=param[1];return [1,square_big_int(bi)];
        default:var r=param[1];return [2,square_ratio(r)]}}
    function div_num(n1,n2)
     {switch(n1[0])
       {case 0:
         var i1=n1[1];
         switch(n2[0])
          {case 0:
            var i2=n2[1],_X_=big_int_of_int(i2);
            return num_of_ratio(create_ratio(big_int_of_int(i1),_X_));
           case 1:
            var bi2=n2[1];
            return num_of_ratio(create_ratio(big_int_of_int(i1),bi2));
           default:var r2=n2[1];return num_of_ratio(div_int_ratio(i1,r2))}
        case 1:
         var bi1=n1[1];
         switch(n2[0])
          {case 0:
            var i2$0=n2[1];
            return num_of_ratio(create_ratio(bi1,big_int_of_int(i2$0)));
           case 1:
            var bi2$0=n2[1];return num_of_ratio(create_ratio(bi1,bi2$0));
           default:
            var r2$0=n2[1];return num_of_ratio(div_big_int_ratio(bi1,r2$0))}
        default:
         var r1=n1[1];
         switch(n2[0])
          {case 0:var i2$1=n2[1];return num_of_ratio(div_ratio_int(r1,i2$1));
           case 1:
            var bi2$1=n2[1];return num_of_ratio(div_ratio_big_int(r1,bi2$1));
           default:var r2$1=n2[1];return num_of_ratio(div_ratio(r1,r2$1))}}}
    function floor_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(floor_ratio(r))}}
    function ratio_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return ratio_of_int(i);
        case 1:var bi=param[1];return ratio_of_big_int(bi);
        default:var r=param[1];return r}}
    function quo_num(n1,n2)
     {switch(n1[0])
       {case 0:
         var _V_=n1[1];
         switch(n2[0])
          {case 0:
            var
             i2=n2[1],
             q=caml_div(_V_,i2),
             r=caml_mod(_V_,i2),
             q$0=0 <= r?q:0 < i2?q - 1 | 0:q + 1 | 0;
            return [0,q$0];
           case 1:
            var bi2=n2[1];
            return num_of_big_int(div_big_int(big_int_of_int(_V_),bi2));
           default:
            var r2=n2[1];
            return num_of_big_int
                    (report_sign_ratio
                      (r2,floor_ratio(div_int_ratio(_V_,abs_ratio(r2)))))}
        case 1:
         var _W_=n1[1];
         switch(n2[0])
          {case 0:
            var i2$0=n2[1];
            return num_of_big_int(div_big_int(_W_,big_int_of_int(i2$0)));
           case 1:
            var bi2$0=n2[1];return num_of_big_int(div_big_int(_W_,bi2$0));
           default:
            var r2$0=n2[1];
            return num_of_big_int
                    (report_sign_ratio
                      (r2$0,floor_ratio(div_big_int_ratio(_W_,abs_ratio(r2$0)))))}
        default:
         var r1=n1[1],r2$1=ratio_of_num(n2);
         return num_of_big_int
                 (report_sign_ratio
                   (r2$1,floor_ratio(div_ratio(r1,abs_ratio(r2$1)))))}}
    function mod_num(n1,n2)
     {switch(n1[0])
       {case 0:
         var _T_=n1[1];
         switch(n2[0])
          {case 0:
            var
             i2=n2[1],
             r=caml_mod(_T_,i2),
             r$0=0 <= r?r:0 < i2?r + i2 | 0:r - i2 | 0;
            return [0,r$0];
           case 1:
            var bi2=n2[1];
            return num_of_big_int(mod_big_int(big_int_of_int(_T_),bi2))
           }
         break;
        case 1:
         var _U_=n1[1];
         switch(n2[0])
          {case 0:
            var i2$0=n2[1];
            return num_of_big_int(mod_big_int(_U_,big_int_of_int(i2$0)));
           case 1:
            var bi2$0=n2[1];return num_of_big_int(mod_big_int(_U_,bi2$0))
           }
         break
        }
      return sub_num(n1,mult_num(n2,quo_num(n1,n2)))}
    function power_num(n,match$5)
     {switch(match$5[0])
       {case 0:
         var i$1=match$5[1];
         switch(n[0])
          {case 0:
            var i=n[1],match=sign_int(i$1);
            return 0 === match
                    ?_o_
                    :1 === match
                      ?num_of_big_int(power_int_positive_int(i,i$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,power_int_positive_int(i,- i$1 | 0))];
           case 1:
            var bi=n[1],match$0=sign_int(i$1);
            return 0 === match$0
                    ?_p_
                    :1 === match$0
                      ?num_of_big_int(power_big_int_positive_int(bi,i$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,power_big_int_positive_int(bi,- i$1 | 0))];
           default:
            var r=n[1],match$1=sign_int(i$1);
            return 0 === match$1
                    ?_q_
                    :1 === match$1
                      ?[2,power_ratio_positive_int(r,i$1)]
                      :[2,power_ratio_positive_int(inverse_ratio(r),- i$1 | 0)]}
        case 1:
         var bi$1=match$5[1];
         switch(n[0])
          {case 0:
            var i$0=n[1],match$2=bi$1[1];
            return 0 === match$2
                    ?_r_
                    :1 === match$2
                      ?num_of_big_int(power_int_positive_big_int(i$0,bi$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,
                          power_int_positive_big_int(i$0,minus_big_int(bi$1)))];
           case 1:
            var bi$0=n[1],match$3=bi$1[1];
            return 0 === match$3
                    ?_s_
                    :1 === match$3
                      ?num_of_big_int(power_big_int_positive_big_int(bi$0,bi$1))
                      :[2,
                        create_normalized_ratio
                         (unit_big_int,
                          power_big_int_positive_big_int(bi$0,minus_big_int(bi$1)))];
           default:
            var r$0=n[1],match$4=bi$1[1];
            if(0 === match$4)return _t_;
            if(1 === match$4)
             return [2,power_ratio_positive_big_int(r$0,bi$1)];
            var _S_=minus_big_int(bi$1);
            return [2,power_ratio_positive_big_int(inverse_ratio(r$0),_S_)]}
        default:return caml_call1(Stdlib[1],cst_power_num)}}
    function is_integer_num(param)
     {switch(param[0])
       {case 0:return 1;
        case 1:return 1;
        default:var r=param[1];return is_integer_ratio(r)}}
    function integer_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(integer_ratio(r))}}
    function round_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(round_ratio(r))}}
    function ceiling_num(n)
     {switch(n[0])
       {case 0:return n;
        case 1:return n;
        default:var r=n[1];return num_of_big_int(ceiling_ratio(r))}}
    function sign_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return sign_int(i);
        case 1:var bi=param[1];return bi[1];
        default:var r=param[1];return sign_ratio(r)}}
    function eq_num(a,match)
     {switch(a[0])
       {case 0:
         var _P_=a[1];
         switch(match[0])
          {case 0:var int2=match[1];return _P_ === int2?1:0;
           case 1:var bi=match[1];return eq_big_int(big_int_of_int(_P_),bi);
           default:
            var r=match[1];return eq_big_int_ratio(big_int_of_int(_P_),r)}
        case 1:
         var _Q_=a[1];
         switch(match[0])
          {case 0:var i=match[1];return eq_big_int(big_int_of_int(i),_Q_);
           case 1:var bi2=match[1];return eq_big_int(_Q_,bi2);
           default:var r$0=match[1];return eq_big_int_ratio(_Q_,r$0)}
        default:
         var _R_=a[1];
         switch(match[0])
          {case 0:
            var i$0=match[1];return eq_big_int_ratio(big_int_of_int(i$0),_R_);
           case 1:var bi$0=match[1];return eq_big_int_ratio(bi$0,_R_);
           default:var r2=match[1];return eq_ratio(_R_,r2)}}}
    function symbol(a,b){return 1 - eq_num(a,b)}
    function compare_num(a,match)
     {switch(a[0])
       {case 0:
         var _M_=a[1];
         switch(match[0])
          {case 0:var int2=match[1];return compare_int(_M_,int2);
           case 1:
            var bi=match[1];return compare_big_int(big_int_of_int(_M_),bi);
           default:
            var r=match[1];return compare_big_int_ratio(big_int_of_int(_M_),r)}
        case 1:
         var _N_=a[1];
         switch(match[0])
          {case 0:
            var i=match[1];return compare_big_int(_N_,big_int_of_int(i));
           case 1:var bi2=match[1];return compare_big_int(_N_,bi2);
           default:var r$0=match[1];return compare_big_int_ratio(_N_,r$0)}
        default:
         var _O_=a[1];
         switch(match[0])
          {case 0:
            var i$0=match[1];
            return - compare_big_int_ratio(big_int_of_int(i$0),_O_) | 0;
           case 1:
            var bi$0=match[1];return - compare_big_int_ratio(bi$0,_O_) | 0;
           default:var r2=match[1];return compare_ratio(_O_,r2)}}}
    function lt_num(num1,num2){return compare_num(num1,num2) < 0?1:0}
    function le_num(num1,num2){return compare_num(num1,num2) <= 0?1:0}
    function gt_num(num1,num2){return 0 < compare_num(num1,num2)?1:0}
    function ge_num(num1,num2){return 0 <= compare_num(num1,num2)?1:0}
    function max_num(num1,num2){return lt_num(num1,num2)?num2:num1}
    function min_num(num1,num2){return gt_num(num1,num2)?num2:num1}
    function int_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return i;
        case 1:var bi=param[1];return int_of_big_int(bi);
        default:var r=param[1];return int_of_ratio(r)}}
    function int_of_num_opt(param)
     {switch(param[0])
       {case 0:var i=param[1];return [0,i];
        case 1:var bi=param[1];return int_of_big_int_opt(bi);
        default:
         var r=param[1];
         try
          {var _K_=[0,int_of_ratio(r)];return _K_}
         catch(_L_)
          {_L_ = caml_wrap_exception(_L_);
           if(_L_[1] === Stdlib[7])return 0;
           throw _L_}}}
    function num_of_int(i)
     {return i === monster_int?[1,big_int_of_int(i)]:[0,i]}
    function nat_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return nat_of_int(i);
        case 1:var bi=param[1];return nat_of_big_int(bi);
        default:var r=param[1];return nat_of_ratio(r)}}
    function num_of_nat(nat)
     {return is_nat_int(nat,0,length_nat(nat))
              ?[0,nth_digit_nat(nat,0)]
              :[1,big_int_of_nat(nat)]}
    function nat_of_num_opt(x)
     {try
       {var _I_=[0,nat_of_num(x)];return _I_}
      catch(_J_)
       {_J_ = caml_wrap_exception(_J_);
        if(_J_[1] === Stdlib[7])return 0;
        throw _J_}}
    function big_int_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return big_int_of_int(i);
        case 1:var bi=param[1];return bi;
        default:var r=param[1];return big_int_of_ratio(r)}}
    function big_int_of_num_opt(x)
     {try
       {var _G_=[0,big_int_of_num(x)];return _G_}
      catch(_H_)
       {_H_ = caml_wrap_exception(_H_);
        if(_H_[1] === Stdlib[7])return 0;
        throw _H_}}
    function string_of_num(n)
     {if(normalize_ratio_when_printing_[1])
       switch(n[0])
        {case 0:var i=n[1],_F_=[0,i];break;
         case 1:var bi=n[1],_F_=num_of_big_int(bi);break;
         default:var r=n[1],_F_=is_integer_ratio(r)?num_of_big_int(r[1]):[2,r]}
      else
       var _F_=n;
      switch(_F_[0])
       {case 0:var i$0=_F_[1];return caml_call1(Stdlib[33],i$0);
        case 1:
         var bi$0=_F_[1];
         return approx_printing_flag[1]
                 ?approx_big_int(floating_precision[1],bi$0)
                 :string_of_big_int(bi$0);
        default:var r$0=_F_[1];return string_of_ratio(r$0)}}
    function num_of_string(s)
     {try
       {var flag=normalize_ratio_flag[1];
        normalize_ratio_flag[1] = 1;
        var r=ratio_of_string(s);
        normalize_ratio_flag[1] = flag;
        var _D_=eq_big_int(r[2],unit_big_int)?num_of_big_int(r[1]):[2,r];
        return _D_}
      catch(_E_)
       {_E_ = caml_wrap_exception(_E_);
        if(_E_[1] === Stdlib[7])
         return caml_call1(Stdlib[2],cst_num_of_string);
        throw _E_}}
    function num_of_string_opt(s)
     {try
       {var _B_=[0,num_of_string(s)];return _B_}
      catch(_C_)
       {_C_ = caml_wrap_exception(_C_);
        if(_C_[1] === Stdlib[7])return 0;
        throw _C_}}
    function float_of_num(param)
     {switch(param[0])
       {case 0:var i=param[1];return i;
        case 1:var bi=param[1];return float_of_big_int(bi);
        default:var r=param[1];return float_of_ratio(r)}}
    function succ_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === biggest_int
                 ?[1,succ_big_int(big_int_of_int(i))]
                 :[0,i + 1 | 0];
        case 1:var bi=param[1];return num_of_big_int(succ_big_int(bi));
        default:var r=param[1];return [2,add_int_ratio(1,r)]}}
    function pred_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === monster_int
                 ?[1,pred_big_int(big_int_of_int(i))]
                 :[0,i - 1 | 0];
        case 1:var bi=param[1];return num_of_big_int(pred_big_int(bi));
        default:var r=param[1];return [2,add_int_ratio(-1,r)]}}
    function abs_num(param)
     {switch(param[0])
       {case 0:
         var i=param[1];
         return i === monster_int
                 ?[1,minus_big_int(big_int_of_int(i))]
                 :[0,caml_call1(Stdlib[18],i)];
        case 1:var bi=param[1];return [1,abs_big_int(bi)];
        default:var r=param[1];return [2,abs_ratio(r)]}}
    function approx_num_fix(n,num)
     {return approx_ratio_fix(n,ratio_of_num(num))}
    function approx_num_exp(n,num)
     {return approx_ratio_exp(n,ratio_of_num(num))}
    function incr_num(r){r[1] = succ_num(r[1]);return 0}
    function decr_num(r){r[1] = pred_num(r[1]);return 0}
    var
     Num=
      [0,
       add_num,
       add_num,
       minus_num,
       sub_num,
       sub_num,
       mult_num,
       mult_num,
       square_num,
       div_num,
       div_num,
       quo_num,
       mod_num,
       power_num,
       power_num,
       abs_num,
       succ_num,
       pred_num,
       incr_num,
       decr_num,
       is_integer_num,
       integer_num,
       floor_num,
       round_num,
       ceiling_num,
       sign_num,
       eq_num,
       lt_num,
       gt_num,
       le_num,
       ge_num,
       symbol,
       eq_num,
       lt_num,
       le_num,
       gt_num,
       ge_num,
       compare_num,
       max_num,
       min_num,
       string_of_num,
       approx_num_fix,
       approx_num_exp,
       num_of_string,
       num_of_string_opt,
       int_of_num,
       int_of_num_opt,
       num_of_int,
       nat_of_num,
       nat_of_num_opt,
       num_of_nat,
       num_of_big_int,
       big_int_of_num,
       big_int_of_num_opt,
       ratio_of_num,
       num_of_ratio,
       float_of_num];
    caml_register_global(133,Num,"Num");
    function get_error_when_null_denominato(param)
     {return error_when_null_denominator_fl[1]}
    function set_error_when_null_denominato(choice)
     {error_when_null_denominator_fl[1] = choice;return 0}
    function get_normalize_ratio(param){return normalize_ratio_flag[1]}
    function set_normalize_ratio(choice)
     {normalize_ratio_flag[1] = choice;return 0}
    function get_normalize_ratio_when_print(param)
     {return normalize_ratio_when_printing_[1]}
    function set_normalize_ratio_when_print(choice)
     {normalize_ratio_when_printing_[1] = choice;return 0}
    function get_floating_precision(param){return floating_precision[1]}
    function set_floating_precision(i){floating_precision[1] = i;return 0}
    function get_approx_printing(param){return approx_printing_flag[1]}
    function set_approx_printing(b){approx_printing_flag[1] = b;return 0}
    function arith_print_string(s)
     {caml_call1(Stdlib[42],s);return caml_call1(Stdlib[42],cst$6)}
    function arith_print_bool(param)
     {return param
              ?caml_call1(Stdlib[42],cst_ON)
              :caml_call1(Stdlib[42],cst_OFF)}
    function arith_status(param)
     {caml_call1(Stdlib[47],0);
      arith_print_string(cst_Normalization_during_compu);
      arith_print_bool(get_normalize_ratio(0));
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_returned_by_get_normalize_);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_modifiable_with_set_normal);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[47],0);
      arith_print_string(cst_Normalization_when_printin);
      arith_print_bool(get_normalize_ratio_when_print(0));
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_returned_by_get_normalize_$0);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_modifiable_with_set_normal$0);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[47],0);
      arith_print_string(cst_Floating_point_approximati);
      arith_print_bool(get_approx_printing(0));
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_returned_by_get_approx_pri);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_modifiable_with_set_approx);
      caml_call1(Stdlib[47],0);
      if(get_approx_printing(0))
       {caml_call1(Stdlib[42],cst_Default_precision);
        var _A_=get_floating_precision(0);
        caml_call1(Stdlib[44],_A_);
        caml_call1(Stdlib[47],0);
        caml_call1(Stdlib[42],cst_returned_by_get_floating_p);
        caml_call1(Stdlib[47],0);
        caml_call1(Stdlib[42],cst_modifiable_with_set_floati);
        caml_call1(Stdlib[47],0);
        caml_call1(Stdlib[47],0)}
      else
       caml_call1(Stdlib[47],0);
      arith_print_string(cst_Error_when_a_rational_deno);
      arith_print_bool(get_error_when_null_denominato(0));
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_returned_by_get_error_when);
      caml_call1(Stdlib[47],0);
      caml_call1(Stdlib[42],cst_modifiable_with_set_error_);
      return caml_call1(Stdlib[47],0)}
    var
     Arith_status=
      [0,
       arith_status,
       get_error_when_null_denominato,
       set_error_when_null_denominato,
       get_normalize_ratio,
       set_normalize_ratio,
       get_normalize_ratio_when_print,
       set_normalize_ratio_when_print,
       get_approx_printing,
       set_approx_printing,
       get_floating_precision,
       set_floating_precision];
    caml_register_global(134,Arith_status,"Arith_status");
    return}
  (function(){return this}()));


//# 1 ".js/str/str.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_make_vect=runtime.caml_make_vect,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst=caml_string_of_jsbytes(""),
     cst$0=caml_string_of_jsbytes(""),
     cst$5=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_Str_matched_group=caml_string_of_jsbytes("Str.matched_group"),
     cst_Str_group_end=caml_string_of_jsbytes("Str.group_end"),
     cst_Str_group_beginning=caml_string_of_jsbytes("Str.group_beginning"),
     cst_group_not_closed_by=
      caml_string_of_jsbytes("\\( group not closed by \\)"),
     cst_class_not_closed_by=caml_string_of_jsbytes("[ class not closed by ]"),
     cst_spurious_in_regular_expres=
      caml_string_of_jsbytes("spurious \\) in regular expression"),
     cst_too_many_r_or_r_where_r_is=
      caml_string_of_jsbytes("too many r* or r+ where r is nullable"),
     cst$1=caml_string_of_jsbytes(""),
     cst$2=caml_string_of_jsbytes(""),
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib=global_data.Stdlib,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Assert_failure=global_data.Assert_failure,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib_char=global_data.Stdlib__char,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_map=global_data.Stdlib__map,
     _b_=[0,92],
     _c_=[0,caml_string_of_jsbytes("str.ml"),520,10],
     _a_=[0,caml_string_of_jsbytes("str.ml"),213,11];
    function string_before(s,n){return caml_call3(Stdlib_string[9],s,0,n)}
    function string_after(s,n)
     {return caml_call3(Stdlib_string[9],s,n,caml_ml_string_length(s) - n | 0)}
    function first_chars(s,n){return caml_call3(Stdlib_string[9],s,0,n)}
    function last_chars(s,n)
     {return caml_call3(Stdlib_string[9],s,caml_ml_string_length(s) - n | 0,n)}
    var full=caml_call2(Stdlib_bytes[1],32,255);
    function make_empty(param){return caml_call2(Stdlib_bytes[1],32,0)}
    function add(s,i)
     {var _ao_=caml_bytes_get(s,i >>> 3 | 0) | 1 << (i & 7);
      return caml_bytes_set(s,i >>> 3 | 0,caml_call1(Stdlib_char[1],_ao_))}
    function singleton(c){var s=make_empty(0);add(s,c);return s}
    function complement(s)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _am_=caml_bytes_get(s,i) ^ 255;
        caml_bytes_set(r,i,caml_call1(Stdlib_char[1],_am_));
        var _an_=i + 1 | 0;
        if(31 !== i){var i=_an_;continue}
        return r}}
    function union(s1,s2)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _aj_=caml_bytes_get(s2,i),_ak_=caml_bytes_get(s1,i) | _aj_;
        caml_bytes_set(r,i,caml_call1(Stdlib_char[1],_ak_));
        var _al_=i + 1 | 0;
        if(31 !== i){var i=_al_;continue}
        return r}}
    function disjoint(s1,s2)
     {try
       {var i=0;
        for(;;)
         {var _ag_=caml_bytes_get(s2,i);
          if(0 !== (caml_bytes_get(s1,i) & _ag_))throw Stdlib[3];
          var _ah_=i + 1 | 0;
          if(31 !== i){var i=_ah_;continue}
          var _af_=1;
          return _af_}}
      catch(_ai_)
       {_ai_ = caml_wrap_exception(_ai_);
        if(_ai_ === Stdlib[3])return 0;
        throw _ai_}}
    function iter(fn,s)
     {var i=0;
      for(;;)
       {var c=caml_bytes_get(s,i);
        if(0 !== c)
         {var j=0;
          for(;;)
           {if(0 !== (c & 1 << j))
             caml_call1(fn,caml_call1(Stdlib_char[1],(i << 3) + j | 0));
            var _ae_=j + 1 | 0;
            if(7 !== j){var j=_ae_;continue}
            break}}
        var _ad_=i + 1 | 0;
        if(31 !== i){var i=_ad_;continue}
        return 0}}
    function fold_case(s)
     {var r=make_empty(0);
      iter
       (function(c)
         {add(r,caml_call1(Stdlib_char[3],c));
          return add(r,caml_call1(Stdlib_char[4],c))},
        s);
      return r}
    var
     op_CHAR=0,
     op_CHARNORM=1,
     op_STRING=2,
     op_STRINGNORM=3,
     op_CHARCLASS=4,
     op_BOL=5,
     op_EOL=6,
     op_WORDBOUNDARY=7,
     op_BEGGROUP=8,
     op_ENDGROUP=9,
     op_REFGROUP=10,
     op_ACCEPT=11,
     op_SIMPLEOPT=12,
     op_SIMPLESTAR=13,
     op_SIMPLEPLUS=14,
     op_GOTO=15,
     op_PUSHBACK=16,
     op_SETMARK=17,
     op_CHECKPROGRESS=18;
    function instr(opc,arg){return opc | arg << 8}
    function displ(dest,from){return (dest - from | 0) - 1 | 0}
    function is_nullable(param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0){case 0:return 1;case 1:return 1;default:return 1}
       else
        switch(param$0[0])
         {case 0:return 0;
          case 1:var s=param$0[1];return caml_string_equal(s,cst);
          case 2:return 0;
          case 3:
           var rl=param$0[1];
           return caml_call2(Stdlib_list[32],is_nullable,rl);
          case 4:
           var r2=param$0[2],r1=param$0[1],_ac_=is_nullable(r1);
           if(_ac_)return _ac_;
           var param$0=r2;
           continue;
          case 5:return 1;
          case 6:var param$1=param$0[1],param$0=param$1;continue;
          case 7:return 1;
          case 8:var param$2=param$0[2],param$0=param$2;continue;
          default:return 1}}
    function first$0(counter,param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0)
         {case 0:return full;case 1:return full;default:return full}
       else
        switch(param$0[0])
         {case 0:var c=param$0[1];return singleton(c);
          case 1:
           var s=param$0[1];
           return caml_string_equal(s,cst$0)
                   ?full
                   :singleton(caml_string_get(s,0));
          case 2:
           var cmpl=param$0[2],cl=param$0[1];return cmpl?complement(cl):cl;
          case 3:
           var rl=param$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;return first_seq$0(counter$0,rl)}
           return caml_trampoline_return(first_seq$0,[0,rl]);
          case 4:
           var r2=param$0[2],r1=param$0[1],_ab_=first(r2);
           return union(first(r1),_ab_);
          case 5:return full;
          case 6:var param$1=param$0[1],param$0=param$1;continue;
          case 7:return full;
          case 8:var param$2=param$0[2],param$0=param$2;continue;
          default:return full}}
    function first_seq$0(counter,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var ___=param$0[1];
          if(typeof ___ === "number")
           {var param$1=param$0[2],param$0=param$1;continue}
          else
           switch(___[0])
            {case 5:
              var rl=param$0[2],r=___[1],_$_=first_seq(rl);
              return union(first(r),_$_);
             case 7:
              var rl$0=param$0[2],r$0=___[1],_aa_=first_seq(rl$0);
              return union(first(r$0),_aa_);
             default:
              if(counter < 50)
               {var counter$0=counter + 1 | 0;return first$0(counter$0,___)}
              return caml_trampoline_return(first$0,[0,___])}}
        return full}}
    function first(param){return caml_trampoline(first$0(0,param))}
    function first_seq(param){return caml_trampoline(first_seq$0(0,param))}
    function charclass_of_regexp(fold_case$0,re)
     {var switch$0=0;
      if(typeof re !== "number")
       switch(re[0])
        {case 0:var c=re[1],compl=0,cl1=singleton(c);switch$0 = 1;break;
         case 2:
          var compl$0=re[2],cl=re[1],compl=compl$0,cl1=cl;switch$0 = 1;break
         }
      if(switch$0)
       {var cl2=fold_case$0?fold_case(cl1):cl1,_Z_=compl?complement(cl2):cl2;
        return caml_call1(Stdlib_bytes[6],_Z_)}
      throw [0,Assert_failure,_a_]}
    var t=caml_create_bytes(256),i=0;
    for(;;)
     {var _d_=caml_call1(Stdlib_char[1],i);
      caml_bytes_set(t,i,caml_call1(Stdlib_char[3],_d_));
      var _e_=i + 1 | 0;
      if(255 !== i){var i=_e_;continue}
      var
       fold_case_table=caml_call1(Stdlib_bytes[6],t),
       compare=function(x,y){return runtime.caml_string_compare(x,y)},
       StringMap=caml_call1(Stdlib_map[1],[0,compare]),
       compile=
        function(fold_case$0,re)
         {var
           prog=[0,caml_make_vect(32,0)],
           progpos=[0,0],
           cpool=[0,StringMap[1]],
           cpoolpos=[0,0],
           numgroups=[0,1],
           numregs=[0,0];
          function emit_instr(opc,arg)
           {if(prog[1].length - 1 <= progpos[1])
             {var newlen=[0,prog[1].length - 1];
              for(;;)
               {if(newlen[1] <= progpos[1])
                 {newlen[1] = newlen[1] * 2 | 0;continue}
                var nprog=caml_make_vect(newlen[1],0);
                caml_call5
                 (Stdlib_array[10],prog[1],0,nprog,0,prog[1].length - 1);
                prog[1] = nprog;
                break}}
            var _X_=instr(opc,arg),_Y_=progpos[1];
            caml_check_bound(prog[1],_Y_)[1 + _Y_] = _X_;
            progpos[1]++;
            return 0}
          function emit_hole(param)
           {var p=progpos[1];emit_instr(op_CHAR,0);return p}
          function patch_instr(pos,opc,dest)
           {var _W_=instr(opc,displ(dest,pos));
            caml_check_bound(prog[1],pos)[1 + pos] = _W_;
            return 0}
          function cpool_index(s)
           {try
             {var _U_=caml_call2(StringMap[28],s,cpool[1]);return _U_}
            catch(_V_)
             {_V_ = caml_wrap_exception(_V_);
              if(_V_ === Stdlib[8])
               {var p=cpoolpos[1];
                cpool[1] = caml_call3(StringMap[4],s,p,cpool[1]);
                cpoolpos[1]++;
                return p}
              throw _V_}}
          function allocate_register_if_nullable(r)
           {if(is_nullable(r))
             {var n=numregs[1];
              if(64 <= n)caml_call1(Stdlib[2],cst_too_many_r_or_r_where_r_is);
              numregs[1]++;
              return n}
            return -1}
          function disjoint_modulo_case(c1,c2)
           {if(fold_case$0)
             {var _T_=fold_case(c2);return disjoint(fold_case(c1),_T_)}
            return disjoint(c1,c2)}
          function emit_code(param)
           {if(typeof param === "number")
             switch(param)
              {case 0:return emit_instr(op_BOL,0);
               case 1:return emit_instr(op_EOL,0);
               default:return emit_instr(op_WORDBOUNDARY,0)}
            else
             switch(param[0])
              {case 0:
                var c=param[1];
                return fold_case$0
                        ?emit_instr(op_CHARNORM,caml_call1(Stdlib_char[3],c))
                        :emit_instr(op_CHAR,c);
               case 1:
                var s=param[1],match=caml_ml_string_length(s);
                if(0 === match)return 0;
                if(1 === match)
                 {if(fold_case$0)
                   {var _Q_=caml_string_get(s,0);
                    return emit_instr
                            (op_CHARNORM,caml_call1(Stdlib_char[3],_Q_))}
                  return emit_instr(op_CHAR,caml_string_get(s,0))}
                try
                 {var i=caml_call2(Stdlib_string[25],s,0);
                  emit_code([1,string_before(s,i)]);
                  emit_instr(op_CHAR,0);
                  var _R_=emit_code([1,string_after(s,i + 1 | 0)]);
                  return _R_}
                catch(_S_)
                 {_S_ = caml_wrap_exception(_S_);
                  if(_S_ === Stdlib[8])
                   return fold_case$0
                           ?emit_instr
                             (op_STRINGNORM,cpool_index(caml_call1(Stdlib_string[36],s)))
                           :emit_instr(op_STRING,cpool_index(s));
                  throw _S_}
               case 2:
                var
                 compl=param[2],
                 cl=param[1],
                 cl1=fold_case$0?fold_case(cl):cl,
                 cl2=compl?complement(cl1):cl1;
                return emit_instr
                        (op_CHARCLASS,cpool_index(caml_call1(Stdlib_bytes[6],cl2)));
               case 3:var rl=param[1];return emit_seq_code(rl);
               case 4:
                var r2=param[2],r1=param[1],pos_pushback=emit_hole(0);
                emit_code(r1);
                var pos_goto_end=emit_hole(0),lbl1=progpos[1];
                emit_code(r2);
                var lbl2=progpos[1];
                patch_instr(pos_pushback,op_PUSHBACK,lbl1);
                return patch_instr(pos_goto_end,op_GOTO,lbl2);
               case 5:
                var
                 r=param[1],
                 regno=allocate_register_if_nullable(r),
                 lbl1$0=emit_hole(0);
                if(0 <= regno)emit_instr(op_SETMARK,regno);
                emit_code(r);
                if(0 <= regno)emit_instr(op_CHECKPROGRESS,regno);
                emit_instr(op_GOTO,displ(lbl1$0,progpos[1]));
                var lbl2$0=progpos[1];
                return patch_instr(lbl1$0,op_PUSHBACK,lbl2$0);
               case 6:
                var
                 r$0=param[1],
                 regno$0=allocate_register_if_nullable(r$0),
                 lbl1$1=progpos[1];
                emit_code(r$0);
                if(0 <= regno$0)emit_instr(op_CHECKPROGRESS,regno$0);
                var pos_pushback$0=emit_hole(0);
                if(0 <= regno$0)emit_instr(op_SETMARK,regno$0);
                emit_instr(op_GOTO,displ(lbl1$1,progpos[1]));
                var lbl2$1=progpos[1];
                return patch_instr(pos_pushback$0,op_PUSHBACK,lbl2$1);
               case 7:
                var r$1=param[1],pos_pushback$1=emit_hole(0);
                emit_code(r$1);
                var lbl=progpos[1];
                return patch_instr(pos_pushback$1,op_PUSHBACK,lbl);
               case 8:
                var r$2=param[2],n=param[1];
                emit_instr(op_BEGGROUP,n);
                emit_code(r$2);
                emit_instr(op_ENDGROUP,n);
                numgroups[1] = caml_call2(Stdlib[17],numgroups[1],n + 1 | 0);
                return 0;
               default:
                var n$0=param[1];
                emit_instr(op_REFGROUP,n$0);
                numgroups[1]
                =
                caml_call2(Stdlib[17],numgroups[1],n$0 + 1 | 0);
                return 0}}
          function emit_seq_code(param)
           {var param$0=param;
            for(;;)
             {if(param$0)
               {var _J_=param$0[1];
                if(typeof _J_ !== "number")
                 switch(_J_[0])
                  {case 5:
                    var _K_=_J_[1],switch$0=0;
                    if(typeof _K_ === "number")
                     switch$0 = 1;
                    else
                     switch(_K_[0])
                      {case 0:
                       case 2:
                        var rl$0=param$0[2],_L_=first_seq(rl$0);
                        if(disjoint_modulo_case(first(_K_),_L_))
                         {emit_instr
                           (op_SIMPLESTAR,
                            cpool_index(charclass_of_regexp(fold_case$0,_K_)));
                          var param$0=rl$0;
                          continue}
                        break;
                       default:switch$0 = 1}
                    break;
                   case 6:
                    var _M_=_J_[1],switch$1=0;
                    if(typeof _M_ === "number")
                     switch$1 = 1;
                    else
                     switch(_M_[0])
                      {case 0:
                       case 2:
                        var rl$1=param$0[2],_N_=first_seq(rl$1);
                        if(disjoint_modulo_case(first(_M_),_N_))
                         {emit_instr
                           (op_SIMPLEPLUS,
                            cpool_index(charclass_of_regexp(fold_case$0,_M_)));
                          var param$0=rl$1;
                          continue}
                        break;
                       default:switch$1 = 1}
                    break;
                   case 7:
                    var _O_=_J_[1],switch$2=0;
                    if(typeof _O_ === "number")
                     switch$2 = 1;
                    else
                     switch(_O_[0])
                      {case 0:
                       case 2:
                        var rl$2=param$0[2],_P_=first_seq(rl$2);
                        if(disjoint_modulo_case(first(_O_),_P_))
                         {emit_instr
                           (op_SIMPLEOPT,
                            cpool_index(charclass_of_regexp(fold_case$0,_O_)));
                          var param$0=rl$2;
                          continue}
                        break;
                       default:switch$2 = 1}
                    break
                   }
                var rl=param$0[2];
                emit_code(_J_);
                var param$0=rl;
                continue}
              return 0}}
          emit_code(re);
          emit_instr(op_ACCEPT,0);
          var start=first(re),start$0=fold_case$0?fold_case(start):start;
          if(runtime.caml_bytes_equal(start,full))
           var start_pos=-1;
          else
           {var r=caml_call2(Stdlib_bytes[1],256,0);
            iter(function(c){return caml_bytes_set(r,c,1)},start$0);
            var start_pos=cpool_index(caml_call1(Stdlib_bytes[6],r))}
          var constantpool=caml_make_vect(cpoolpos[1],cst$1),_F_=cpool[1];
          function _G_(str,idx)
           {caml_check_bound(constantpool,idx)[1 + idx] = str;return 0}
          caml_call2(StringMap[12],_G_,_F_);
          var
           _H_=numregs[1],
           _I_=numgroups[1],
           fold_case_table$0=fold_case$0?fold_case_table:cst$2;
          return [0,
                  caml_call3(Stdlib_array[7],prog[1],0,progpos[1]),
                  constantpool,
                  fold_case_table$0,
                  _I_,
                  _H_,
                  start_pos]},
       flush=
        function(buf)
         {var s=caml_call1(Stdlib_buffer[2],buf[1]);
          caml_call1(Stdlib_buffer[8],buf[1]);
          var match=caml_ml_string_length(s);
          if(0 === match)return 0;
          if(1 === match)
           {var _E_=buf[2];buf[2] = [0,[0,caml_string_get(s,0)],_E_];return 0}
          buf[2] = [0,[1,s],buf[2]];
          return 0},
       dotclass=complement(singleton(10)),
       parse=
        function(s)
         {var len=caml_ml_string_length(s),group_counter=[0,1];
          function regexpclass1(start)
           {var c=make_empty(0),i$0=start;
            for(;;)
             {if(len <= i$0)caml_call1(Stdlib[2],cst_class_not_closed_by);
              if(93 === caml_string_get(s,i$0) && start < i$0)
               {var j=i$0 + 1 | 0;return [0,c,j]}
              var c1=caml_string_get(s,i$0);
              if
               ((i$0 + 2 | 0)
                <
                len
                &&
                45
                ===
                caml_string_get(s,i$0 + 1 | 0)
                &&
                93
                !==
                caml_string_get(s,i$0 + 2 | 0))
               {var c2=caml_string_get(s,i$0 + 2 | 0);
                if(! (c2 < c1))
                 {var i=c1;
                  for(;;)
                   {add(c,caml_call1(Stdlib_char[1],i));
                    var _D_=i + 1 | 0;
                    if(c2 !== i){var i=_D_;continue}
                    break}}
                var i$2=i$0 + 3 | 0,i$0=i$2;
                continue}
              add(c,c1);
              var i$1=i$0 + 1 | 0,i$0=i$1;
              continue}}
          function regexp1(i)
           {var sb=[0,caml_call1(Stdlib_buffer[1],16),0],i$0=i;
            a:
            for(;;)
             {if(! (len <= i$0))
               {var switch$0=0;
                if((i$0 + 2 | 0) <= len && 92 === caml_string_get(s,i$0))
                 {var
                   c$0=caml_string_get(s,i$0 + 1 | 0),
                   _A_=124 === c$0?1:0,
                   _B_=_A_ || (41 === c$0?1:0);
                  if(_B_)switch$0 = 1}
                if(! switch$0)
                 {var c$1=caml_string_get(s,i$0);
                  if(36 === c$1)
                   var match=[0,1,i$0 + 1 | 0];
                  else
                   {var switch$1=0;
                    if(91 <= c$1)
                     if(95 <= c$1)
                      switch$1 = 1;
                     else
                      {var switcher$0=c$1 - 91 | 0;
                       switch(switcher$0)
                        {case 0:
                          var i$4=i$0 + 1 | 0,switch$2=0;
                          if(i$4 < len && 94 === caml_string_get(s,i$4))
                           {var
                             match$3=regexpclass1(i$4 + 1 | 0),
                             j$3=match$3[2],
                             c$4=match$3[1],
                             match$1=[0,c$4,1,j$3];
                            switch$2 = 1}
                          if(! switch$2)
                           var
                            match$4=regexpclass1(i$4),
                            j$4=match$4[2],
                            c$5=match$4[1],
                            match$1=[0,c$5,0,j$4];
                          var
                           j$1=match$1[3],
                           compl=match$1[2],
                           c$2=match$1[1],
                           match=[0,[2,c$2,compl],j$1];
                          break;
                         case 1:
                          var i$5=i$0 + 1 | 0;
                          if(len <= i$5)
                           var _C_=[0,_b_,i$5];
                          else
                           {var c$3=caml_string_get(s,i$5),switch$3=0;
                            if(58 <= c$3)
                             if(98 === c$3)
                              var _C_=[0,2,i$5 + 1 | 0];
                             else
                              if(124 === c$3)switch$3 = 2;else switch$3 = 1;
                            else
                             {var switcher$1=c$3 - 40 | 0;
                              if(1 < switcher$1 >>> 0)
                               if(9 <= switcher$1)
                                var _C_=[0,[9,c$3 - 48 | 0],i$5 + 1 | 0];
                               else
                                switch$3 = 1;
                              else
                               if(switcher$1)
                                switch$3 = 2;
                               else
                                {var group_no=group_counter[1];
                                 group_counter[1]++;
                                 var
                                  match$2=regexp0(i$5 + 1 | 0),
                                  j$2=match$2[2],
                                  r$4=match$2[1],
                                  switch$4=0;
                                 if
                                  ((j$2 + 1 | 0)
                                   <
                                   len
                                   &&
                                   92
                                   ===
                                   caml_string_get(s,j$2)
                                   &&
                                   41
                                   ===
                                   caml_string_get(s,j$2 + 1 | 0))
                                  {var _C_=[0,[8,group_no,r$4],j$2 + 2 | 0];switch$4 = 1}
                                 if(! switch$4)
                                  var _C_=caml_call1(Stdlib[2],cst_group_not_closed_by)}}
                            switch(switch$3)
                             {case 1:var _C_=[0,[0,c$3],i$5 + 1 | 0];break;
                              case 2:throw [0,Assert_failure,_c_]
                              }}
                          var match=_C_;
                          break;
                         case 2:switch$1 = 1;break;
                         default:var match=[0,0,i$0 + 1 | 0]}}
                    else
                     if(46 === c$1)
                      var match=[0,[2,dotclass,0],i$0 + 1 | 0];
                     else
                      switch$1 = 1;
                    if(switch$1)var match=[0,[0,c$1],i$0 + 1 | 0]}
                  var j=match[2],r=match[1],r$0=r,j$0=j;
                  for(;;)
                   {if(! (len <= j$0))
                     {var
                       match$0=caml_string_get(s,j$0),
                       switcher=match$0 - 42 | 0;
                      if(! (1 < switcher >>> 0))
                       {if(switcher)
                         {var i$2=j$0 + 1 | 0,r$2=[6,r$0],r$0=r$2,j$0=i$2;continue}
                        var i$3=j$0 + 1 | 0,r$3=[5,r$0],r$0=r$3,j$0=i$3;
                        continue}
                      if(21 === switcher)
                       {var i$1=j$0 + 1 | 0,r$1=[7,r$0],r$0=r$1,j$0=i$1;continue}}
                    var switch$5=0;
                    if(typeof r$0 !== "number" && 0 === r$0[0])
                     {var c=r$0[1];
                      caml_call2(Stdlib_buffer[10],sb[1],c);
                      switch$5 = 1}
                    if(! switch$5){flush(sb);sb[2] = [0,r$0,sb[2]]}
                    var i$0=j$0;
                    continue a}}}
              flush(sb);
              return [0,[3,caml_call1(Stdlib_list[9],sb[2])],i$0]}}
          function regexp0(i)
           {var match=regexp1(i),j=match[2],r=match[1],r1=r,i$0=j;
            for(;;)
             {if
               ((i$0 + 2 | 0)
                <=
                len
                &&
                92
                ===
                caml_string_get(s,i$0)
                &&
                124
                ===
                caml_string_get(s,i$0 + 1 | 0))
               {var
                 match$0=regexp1(i$0 + 2 | 0),
                 i$1=match$0[2],
                 r2=match$0[1],
                 r1$0=[4,r1,r2],
                 r1=r1$0,
                 i$0=i$1;
                continue}
              return [0,r1,i$0]}}
          var match=regexp0(0),j=match[2],r=match[1];
          return j === len
                  ?r
                  :caml_call1(Stdlib[2],cst_spurious_in_regular_expres)},
       regexp=function(e){return compile(0,parse(e))},
       regexp_case_fold=function(e){return compile(1,parse(e))},
       quote=
        function(s)
         {var
           len=caml_ml_string_length(s),
           buf=caml_create_bytes(2 * len | 0),
           pos=[0,0],
           _w_=len - 1 | 0,
           _v_=0;
          if(! (_w_ < 0))
           {var i=_v_;
            for(;;)
             {var c=caml_string_get(s,i),_x_=c - 63 | 0,switch$0=0;
              if(31 < _x_ >>> 0)
               {var _y_=_x_ + 27 | 0;
                if(! (10 < _y_ >>> 0))
                 switch(_y_){case 0:case 6:case 7:case 10:switch$0 = 1;break}}
              else
               if(26 < (_x_ - 1 | 0) >>> 0)switch$0 = 1;
              if(switch$0)
               {caml_bytes_set(buf,pos[1],92);
                caml_bytes_set(buf,pos[1] + 1 | 0,c);
                pos[1] = pos[1] + 2 | 0}
              else
               {caml_bytes_set(buf,pos[1],c);pos[1] = pos[1] + 1 | 0}
              var _z_=i + 1 | 0;
              if(_w_ !== i){var i=_z_;continue}
              break}}
          return caml_call3(Stdlib_bytes[8],buf,0,pos[1])},
       regexp_string=function(s){return compile(0,[1,s])},
       regexp_string_case_fold=function(s){return compile(1,[1,s])},
       last_search_result=[0,[0]],
       string_match=
        function(re,s,pos)
         {var res=runtime.re_string_match(re,s,pos);
          last_search_result[1] = res;
          return 0 < res.length - 1?1:0},
       string_partial_match=
        function(re,s,pos)
         {var res=runtime.re_partial_match(re,s,pos);
          last_search_result[1] = res;
          return 0 < res.length - 1?1:0},
       search_forward=
        function(re,s,pos)
         {var res=runtime.re_search_forward(re,s,pos);
          last_search_result[1] = res;
          if(0 === res.length - 1)throw Stdlib[8];
          return caml_check_bound(res,0)[1]},
       search_backward=
        function(re,s,pos)
         {var res=runtime.re_search_backward(re,s,pos);
          last_search_result[1] = res;
          if(0 === res.length - 1)throw Stdlib[8];
          return caml_check_bound(res,0)[1]},
       group_beginning=
        function(n)
         {var n2=n + n | 0;
          if(0 <= n && ! (last_search_result[1].length - 1 <= n2))
           {var pos=caml_check_bound(last_search_result[1],n2)[1 + n2];
            if(-1 === pos)throw Stdlib[8];
            return pos}
          return caml_call1(Stdlib[1],cst_Str_group_beginning)},
       group_end=
        function(n)
         {var n2=n + n | 0;
          if(0 <= n && ! (last_search_result[1].length - 1 <= n2))
           {var
             _u_=n2 + 1 | 0,
             pos=caml_check_bound(last_search_result[1],_u_)[1 + _u_];
            if(-1 === pos)throw Stdlib[8];
            return pos}
          return caml_call1(Stdlib[1],cst_Str_group_end)},
       matched_group=
        function(n,txt)
         {var n2=n + n | 0;
          if(0 <= n && ! (last_search_result[1].length - 1 <= n2))
           {var
             b=caml_check_bound(last_search_result[1],n2)[1 + n2],
             _t_=n2 + 1 | 0,
             e=caml_check_bound(last_search_result[1],_t_)[1 + _t_];
            if(-1 === b)throw Stdlib[8];
            return caml_call3(Stdlib_string[9],txt,b,e - b | 0)}
          return caml_call1(Stdlib[1],cst_Str_matched_group)},
       match_beginning=function(param){return group_beginning(0)},
       match_end=function(param){return group_end(0)},
       matched_string=function(txt){return matched_group(0,txt)},
       replace_matched=
        function(repl,matched)
         {return runtime.re_replacement_text
                  (repl,last_search_result[1],matched)},
       substitute_first=
        function(expr,repl_fun,text)
         {try
           {var
             pos=search_forward(expr,text,0),
             _o_=[0,string_after(text,match_end(0)),0],
             _p_=[0,caml_call1(repl_fun,text),_o_],
             _q_=[0,string_before(text,pos),_p_],
             _r_=caml_call2(Stdlib_string[3],cst$3,_q_);
            return _r_}
          catch(_s_)
           {_s_ = caml_wrap_exception(_s_);
            if(_s_ === Stdlib[8])return text;
            throw _s_}},
       opt_search_forward=
        function(re,s,pos)
         {try
           {var _m_=[0,search_forward(re,s,pos)];return _m_}
          catch(_n_)
           {_n_ = caml_wrap_exception(_n_);
            if(_n_ === Stdlib[8])return 0;
            throw _n_}},
       global_substitute=
        function(expr,repl_fun,text)
         {var accu=0,start=0,last_was_empty=0;
          for(;;)
           {var startpos=last_was_empty?start + 1 | 0:start;
            if(caml_ml_string_length(text) < startpos)
             var _k_=[0,string_after(text,start),accu];
            else
             {var match=opt_search_forward(expr,text,startpos);
              if(match)
               {var
                 pos=match[1],
                 start$0=match_end(0),
                 repl_text=caml_call1(repl_fun,text),
                 last_was_empty$0=start$0 === pos?1:0,
                 accu$0=
                  [0,
                   repl_text,
                   [0,
                    caml_call3(Stdlib_string[9],text,start,pos - start | 0),
                    accu]],
                 accu=accu$0,
                 start=start$0,
                 last_was_empty=last_was_empty$0;
                continue}
              var _k_=[0,string_after(text,start),accu]}
            var _l_=caml_call1(Stdlib_list[9],_k_);
            return caml_call2(Stdlib_string[3],cst$4,_l_)}},
       global_replace=
        function(expr,repl,text)
         {return global_substitute
                  (expr,function(_j_){return replace_matched(repl,_j_)},text)},
       replace_first=
        function(expr,repl,text)
         {return substitute_first
                  (expr,function(_i_){return replace_matched(repl,_i_)},text)},
       opt_search_forward_progress=
        function(expr,text,start)
         {var match=opt_search_forward(expr,text,start);
          if(match)
           {var pos=match[1];
            return start < match_end(0)
                    ?[0,pos]
                    :start < caml_ml_string_length(text)
                      ?opt_search_forward(expr,text,start + 1 | 0)
                      :0}
          return 0},
       bounded_split=
        function(expr,text,num)
         {var
           start=string_match(expr,text,0)?match_end(0):0,
           accu=0,
           start$0=start,
           n=num;
          for(;;)
           {if(caml_ml_string_length(text) <= start$0)
             var _h_=accu;
            else
             if(1 === n)
              var _h_=[0,string_after(text,start$0),accu];
             else
              {var match=opt_search_forward_progress(expr,text,start$0);
               if(match)
                {var
                  pos=match[1],
                  n$0=n - 1 | 0,
                  start$1=match_end(0),
                  accu$0=
                   [0,
                    caml_call3(Stdlib_string[9],text,start$0,pos - start$0 | 0),
                    accu],
                  accu=accu$0,
                  start$0=start$1,
                  n=n$0;
                 continue}
               var _h_=[0,string_after(text,start$0),accu]}
            return caml_call1(Stdlib_list[9],_h_)}},
       split=function(expr,text){return bounded_split(expr,text,0)},
       bounded_split_delim=
        function(expr,text,num)
         {if(caml_string_equal(text,cst$5))return 0;
          var accu=0,start=0,n=num;
          for(;;)
           {if(caml_ml_string_length(text) < start)
             var _g_=accu;
            else
             if(1 === n)
              var _g_=[0,string_after(text,start),accu];
             else
              {var match=opt_search_forward_progress(expr,text,start);
               if(match)
                {var
                  pos=match[1],
                  n$0=n - 1 | 0,
                  start$0=match_end(0),
                  accu$0=
                   [0,
                    caml_call3(Stdlib_string[9],text,start,pos - start | 0),
                    accu],
                  accu=accu$0,
                  start=start$0,
                  n=n$0;
                 continue}
               var _g_=[0,string_after(text,start),accu]}
            return caml_call1(Stdlib_list[9],_g_)}},
       split_delim=
        function(expr,text){return bounded_split_delim(expr,text,0)},
       bounded_full_split=
        function(expr,text,num)
         {var accu=0,start=0,n=num;
          for(;;)
           {if(caml_ml_string_length(text) <= start)
             var _f_=accu;
            else
             if(1 === n)
              var _f_=[0,[0,string_after(text,start)],accu];
             else
              {var match=opt_search_forward_progress(expr,text,start);
               if(match)
                {var pos=match[1],s=matched_string(text);
                 if(start < pos)
                  {var
                    n$0=n - 1 | 0,
                    start$0=match_end(0),
                    accu$0=
                     [0,
                      [1,s],
                      [0,
                       [0,caml_call3(Stdlib_string[9],text,start,pos - start | 0)],
                       accu]],
                    accu=accu$0,
                    start=start$0,
                    n=n$0;
                   continue}
                 var
                  n$1=n - 1 | 0,
                  start$1=match_end(0),
                  accu$1=[0,[1,s],accu],
                  accu=accu$1,
                  start=start$1,
                  n=n$1;
                 continue}
               var _f_=[0,[0,string_after(text,start)],accu]}
            return caml_call1(Stdlib_list[9],_f_)}},
       full_split=function(expr,text){return bounded_full_split(expr,text,0)},
       Str=
        [0,
         regexp,
         regexp_case_fold,
         quote,
         regexp_string,
         regexp_string_case_fold,
         string_match,
         search_forward,
         search_backward,
         string_partial_match,
         matched_string,
         match_beginning,
         match_end,
         matched_group,
         group_beginning,
         group_end,
         global_replace,
         replace_first,
         global_substitute,
         substitute_first,
         replace_matched,
         split,
         bounded_split,
         split_delim,
         bounded_split_delim,
         full_split,
         bounded_full_split,
         string_before,
         string_after,
         first_chars,
         last_chars];
      runtime.caml_register_global(26,Str,"Str");
      return}}
  (function(){return this}()));


//# 1 ".js/uutf/uutf.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_UTF_8$0=caml_string_of_jsbytes("UTF-8"),
     cst_US_ASCII$0=caml_string_of_jsbytes("US-ASCII"),
     cst_ISO_8859_1$1=caml_string_of_jsbytes("ISO-8859-1"),
     cst_UTF_16$0=caml_string_of_jsbytes("UTF-16"),
     cst_UTF_16LE$0=caml_string_of_jsbytes("UTF-16LE"),
     cst_UTF_16BE$0=caml_string_of_jsbytes("UTF-16BE"),
     cst_ISO646_US=caml_string_of_jsbytes("ISO646-US"),
     cst_CSISOLATIN1=caml_string_of_jsbytes("CSISOLATIN1"),
     cst_ANSI_X3_4_1968=caml_string_of_jsbytes("ANSI_X3.4-1968"),
     cst_ANSI_X3_4_1986=caml_string_of_jsbytes("ANSI_X3.4-1986"),
     cst_ASCII=caml_string_of_jsbytes("ASCII"),
     cst_CP367=caml_string_of_jsbytes("CP367"),
     cst_CP819=caml_string_of_jsbytes("CP819"),
     cst_CSASCII=caml_string_of_jsbytes("CSASCII"),
     cst_IBM367=caml_string_of_jsbytes("IBM367"),
     cst_IBM819=caml_string_of_jsbytes("IBM819"),
     cst_ISO_8859_1$0=caml_string_of_jsbytes("ISO-8859-1"),
     cst_ISO_IR_100=caml_string_of_jsbytes("ISO-IR-100"),
     cst_ISO_IR_6=caml_string_of_jsbytes("ISO-IR-6"),
     cst_US=caml_string_of_jsbytes("US"),
     cst_ISO_646_IRV_1991=caml_string_of_jsbytes("ISO_646.IRV:1991"),
     cst_ISO_8859_1=caml_string_of_jsbytes("ISO_8859-1"),
     cst_ISO_8859_1_1987=caml_string_of_jsbytes("ISO_8859-1:1987"),
     cst_L1=caml_string_of_jsbytes("L1"),
     cst_LATIN1=caml_string_of_jsbytes("LATIN1"),
     cst_US_ASCII=caml_string_of_jsbytes("US-ASCII"),
     cst_UTF_16=caml_string_of_jsbytes("UTF-16"),
     cst_UTF_16BE=caml_string_of_jsbytes("UTF-16BE"),
     cst_UTF_16LE=caml_string_of_jsbytes("UTF-16LE"),
     cst_UTF_8=caml_string_of_jsbytes("UTF-8"),
     cst_expected_Await_encode=
      caml_string_of_jsbytes("expected `Await encode"),
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Stdlib=global_data.Stdlib,
     Assert_failure=global_data.Assert_failure,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_format=global_data.Stdlib__format,
     _a_=Stdlib_format[126],
     _B_=[0,caml_string_of_jsbytes("src/uutf.ml"),364,9],
     _u_=
      [0,
       [11,caml_string_of_jsbytes("`Await"),0],
       caml_string_of_jsbytes("`Await")],
     _v_=
      [0,[11,caml_string_of_jsbytes("`End"),0],caml_string_of_jsbytes("`End")],
     _w_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,caml_string_of_jsbytes("`Uchar U+"),[4,8,[0,2,4],0,[17,0,0]]]],
       caml_string_of_jsbytes("@[`Uchar U+%04X@]")],
     _x_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,caml_string_of_jsbytes("`Malformed ("),0]],
       caml_string_of_jsbytes("@[`Malformed (")],
     _y_=[0,[4,8,[0,2,2],0,0],caml_string_of_jsbytes("%02X")],
     _A_=[0,[12,32,[4,8,[0,2,2],0,0]],caml_string_of_jsbytes(" %02X")],
     _z_=[0,[12,41,[17,0,0]],caml_string_of_jsbytes(")@]")],
     _p_=[0,-211555818,3299808],
     _k_=[0,-211558048,3299808],
     _q_=[0,684370880,3299808],
     _o_=[0,684370880,427938126],
     _l_=[0,-211558048,427938126],
     _m_=[0,caml_string_of_jsbytes("src/uutf.ml"),154,55],
     _n_=[0,684370880,427938126],
     _r_=[0,caml_string_of_jsbytes("src/uutf.ml"),153,55],
     _s_=[0,caml_string_of_jsbytes("src/uutf.ml"),155,55],
     _t_=[0,684370880,3455931],
     _j_=[0,caml_string_of_jsbytes("src/uutf.ml"),121,9],
     _c_=[0,684370880],
     _d_=[0,-211555818],
     _e_=[0,-211558048],
     _f_=[0,143365725],
     _g_=[0,423112016],
     _h_=[0,338302576],
     _b_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid bounds (index "),
        [4,0,0,0,[11,caml_string_of_jsbytes(", length "),[4,0,0,0,[12,41,0]]]]],
       caml_string_of_jsbytes("invalid bounds (index %d, length %d)")],
     _i_=
      [0,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       4,
       4,
       4,
       4,
       4,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0];
    function invalid_bounds(j,l)
     {var _aF_=caml_call3(Stdlib_printf[4],_b_,j,l);
      return caml_call1(Stdlib[1],_aF_)}
    function unsafe_set_byte(s,j,byte$0)
     {runtime.caml_bytes_unsafe_set(s,j,byte$0);return 0}
    var
     u_bom=caml_call1(Stdlib_uchar[9],65279),
     u_rep=caml_call1(Stdlib_uchar[9],65533);
    function encoding_of_string(s)
     {var
       match=caml_call1(Stdlib_string[35],s),
       _aD_=caml_string_compare(match,cst_ISO646_US),
       switch$1=0;
      if(0 <= _aD_)
       {if(0 < _aD_)
         {var switch$0=caml_string_compare(match,cst_US);
          if(0 <= switch$0)
           {if(0 < switch$0 && caml_string_notequal(match,cst_US_ASCII))
             {if(! caml_string_notequal(match,cst_UTF_16))return _f_;
              if(! caml_string_notequal(match,cst_UTF_16BE))return _e_;
              if(! caml_string_notequal(match,cst_UTF_16LE))return _d_;
              if(! caml_string_notequal(match,cst_UTF_8))return _c_;
              switch$1 = 2}}
          else
           if(caml_string_notequal(match,cst_ISO_646_IRV_1991))
            if
             (caml_string_notequal(match,cst_ISO_8859_1)
              &&
              caml_string_notequal(match,cst_ISO_8859_1_1987)
              &&
              caml_string_notequal(match,cst_L1)
              &&
              caml_string_notequal(match,cst_LATIN1))
             switch$1 = 2;
            else
             switch$1 = 1}}
      else
       {var _aE_=caml_string_compare(match,cst_CSISOLATIN1);
        if(0 <= _aE_)
         if(0 < _aE_)
          {if(caml_string_notequal(match,cst_IBM367))
            if
             (caml_string_notequal(match,cst_IBM819)
              &&
              caml_string_notequal(match,cst_ISO_8859_1$0)
              &&
              caml_string_notequal(match,cst_ISO_IR_100))
             {if(caml_string_notequal(match,cst_ISO_IR_6))switch$1 = 2}
            else
             switch$1 = 1}
         else
          switch$1 = 1;
        else
         if
          (caml_string_notequal(match,cst_ANSI_X3_4_1968)
           &&
           caml_string_notequal(match,cst_ANSI_X3_4_1986)
           &&
           caml_string_notequal(match,cst_ASCII)
           &&
           caml_string_notequal(match,cst_CP367))
          if(caml_string_notequal(match,cst_CP819))
           {if(caml_string_notequal(match,cst_CSASCII))switch$1 = 2}
          else
           switch$1 = 1}
      switch(switch$1){case 2:return 0;case 0:return _g_;default:return _h_}}
    function encoding_to_string(param)
     {return 143365725 <= param
              ?423112016 <= param
                ?684370880 <= param?cst_UTF_8$0:cst_US_ASCII$0
                :338302576 <= param?cst_ISO_8859_1$1:cst_UTF_16$0
              :-211555818 <= param?cst_UTF_16LE$0:cst_UTF_16BE$0}
    function malformed(s,j,l)
     {return [0,659980059,caml_call3(Stdlib_bytes[8],s,j,l)]}
    function malformed_pair(be,hi,s,j,l)
     {var bs1=caml_call3(Stdlib_bytes[7],s,j,l),bs0=caml_create_bytes(2);
      if(be)var j1=1,j0=0;else var j1=0,j0=1;
      unsafe_set_byte(bs0,j0,hi >>> 8 | 0);
      unsafe_set_byte(bs0,j1,hi & 255);
      var _aC_=caml_call2(Stdlib_bytes[14],bs0,bs1);
      return [0,659980059,caml_call1(Stdlib_bytes[42],_aC_)]}
    var utf_8_len=_i_.slice();
    function r_utf_8(s,j,l)
     {function uchar(c){return [0,852405675,caml_call1(Stdlib_uchar[9],c)]}
      var switcher=l - 1 | 0;
      if(3 < switcher >>> 0)throw [0,Assert_failure,_j_];
      switch(switcher)
       {case 0:return uchar(caml_bytes_unsafe_get(s,j));
        case 1:
         var
          b0=caml_bytes_unsafe_get(s,j),
          b1=caml_bytes_unsafe_get(s,j + 1 | 0);
         return 2 === (b1 >>> 6 | 0)
                 ?uchar((b0 & 31) << 6 | b1 & 63)
                 :malformed(s,j,l);
        case 2:
         var
          b0$0=caml_bytes_unsafe_get(s,j),
          b1$0=caml_bytes_unsafe_get(s,j + 1 | 0),
          b2=caml_bytes_unsafe_get(s,j + 2 | 0),
          c=(b0$0 & 15) << 12 | (b1$0 & 63) << 6 | b2 & 63;
         if(2 === (b2 >>> 6 | 0))
          {if(224 === b0$0)
            {if(160 <= b1$0 && ! (191 < b1$0))return uchar(c);
             return malformed(s,j,l)}
           if(237 === b0$0)
            {if(128 <= b1$0 && ! (159 < b1$0))return uchar(c);
             return malformed(s,j,l)}
           return 2 === (b1$0 >>> 6 | 0)?uchar(c):malformed(s,j,l)}
         return malformed(s,j,l);
        default:
         var
          b0$1=caml_bytes_unsafe_get(s,j),
          b1$1=caml_bytes_unsafe_get(s,j + 1 | 0),
          b2$0=caml_bytes_unsafe_get(s,j + 2 | 0),
          b3=caml_bytes_unsafe_get(s,j + 3 | 0),
          c$0=
           (b0$1 & 7)
           <<
           18
           |
           (b1$1 & 63)
           <<
           12
           |
           (b2$0 & 63)
           <<
           6
           |
           b3
           &
           63;
         if(2 === (b3 >>> 6 | 0) && 2 === (b2$0 >>> 6 | 0))
          {if(240 === b0$1)
            {if(144 <= b1$1 && ! (191 < b1$1))return uchar(c$0);
             return malformed(s,j,l)}
           if(244 === b0$1)
            {if(128 <= b1$1 && ! (143 < b1$1))return uchar(c$0);
             return malformed(s,j,l)}
           return 2 === (b1$1 >>> 6 | 0)?uchar(c$0):malformed(s,j,l)}
         return malformed(s,j,l)}}
    function r_utf_16(s,j0,j1)
     {var
       b0=caml_bytes_unsafe_get(s,j0),
       b1=caml_bytes_unsafe_get(s,j1),
       u=b0 << 8 | b1;
      if(55296 <= u && ! (57343 < u))
       return 56319 < u
               ?malformed(s,caml_call2(Stdlib[16],j0,j1),2)
               :[0,16161,u];
      return [0,852405675,caml_call1(Stdlib_uchar[9],u)]}
    function r_utf_16_lo(hi,s,j0,j1)
     {var
       b0=caml_bytes_unsafe_get(s,j0),
       b1=caml_bytes_unsafe_get(s,j1),
       lo=b0 << 8 | b1;
      if(56320 <= lo && ! (57343 < lo))
       return [0,
               852405675,
               caml_call1
                (Stdlib_uchar[9],((hi & 1023) << 10 | lo & 1023) + 65536 | 0)];
      return malformed_pair(j0 < j1?1:0,hi,s,caml_call2(Stdlib[16],j0,j1),2)}
    function r_encoding(s,j,l)
     {function some(i){return i < l?[0,caml_bytes_unsafe_get(s,j + i | 0)]:0}
      var match=some(0),match$0=some(1),match$1=some(2);
      if(match)
       {var _aB_=match[1],switch$0=0;
        if(240 <= _aB_)
         if(254 === _aB_)
          {if(match$0){if(255 === match$0[1])return _k_;switch$0 = 1}}
         else
          if(255 === _aB_)
           {if(match$0){if(254 === match$0[1])return _p_;switch$0 = 1}}
          else
           switch$0 = 1;
        else
         if(0 === _aB_)
          {if(match$0)
            {var p=match$0[1];
             if(0 < p)return [0,-211558048,[0,605782321,p]];
             switch$0 = 1}}
         else
          if(239 <= _aB_)
           {if(match$0)
             if(187 === match$0[1])
              {if(match$1 && 191 === match$1[1])return _q_}
             else
              switch$0 = 1}
          else
           switch$0 = 1;
        if(switch$0 && match$0 && 0 === match$0[1] && 0 < _aB_)
         return [0,-211555818,[0,605782321,_aB_]];
        if(0 === caml_check_bound(utf_8_len,_aB_)[1 + _aB_])
         {if(match$0)return _l_;
          if(match$1)throw [0,Assert_failure,_m_];
          return _n_}
        return _o_}
      if(match$0)throw [0,Assert_failure,_r_];
      if(match$1)throw [0,Assert_failure,_s_];
      return _t_}
    function pp_decode(ppf,param)
     {if(typeof param === "number")
       return 1006505782 <= param
               ?caml_call2(_a_,ppf,_u_)
               :caml_call2(_a_,ppf,_v_);
      if(852405675 <= param[1])
       {var u=param[2];
        return caml_call3(_a_,ppf,_w_,caml_call1(Stdlib_uchar[10],u))}
      var bs=param[2],l=caml_ml_string_length(bs);
      caml_call2(_a_,ppf,_x_);
      if(0 < l)caml_call3(_a_,ppf,_y_,caml_string_get(bs,0));
      var _az_=l - 1 | 0,_ay_=1;
      if(! (_az_ < 1))
       {var i=_ay_;
        for(;;)
         {caml_call3(_a_,ppf,_A_,caml_string_get(bs,i));
          var _aA_=i + 1 | 0;
          if(_az_ !== i){var i=_aA_;continue}
          break}}
      return caml_call2(_a_,ppf,_z_)}
    function i_rem(d){return (d[7] - d[6] | 0) + 1 | 0}
    function eoi(d)
     {d[5] = Stdlib_bytes[3];d[6] = 0;d[7] = Stdlib[20];return 0}
    function src(d,s,j,l)
     {if(0 <= j && 0 <= l && ! (caml_ml_bytes_length(s) < (j + l | 0)))
       return 0 === l?eoi(d):(d[5] = s,d[6] = j,d[7] = (j + l | 0) - 1 | 0,0);
      return invalid_bounds(j,l)}
    function refill(k,d)
     {var _ax_=d[1];
      if(typeof _ax_ === "number"){d[18] = k;return 1006505782}
      if(438511779 <= _ax_[1])
       {var
         ic=_ax_[2],
         rc=caml_call4(Stdlib[84],ic,d[5],0,caml_ml_bytes_length(d[5]));
        src(d,d[5],0,rc);
        return caml_call1(k,d)}
      eoi(d);
      return caml_call1(k,d)}
    function t_need(d,need){d[9] = 0;d[10] = need;return 0}
    function t_fill(k,d)
     {function blit(d,l)
       {caml_blit_bytes(d[5],d[6],d[8],d[9],l);
        d[6] = d[6] + l | 0;
        d[9] = d[9] + l | 0;
        return 0}
      var rem=i_rem(d);
      if(0 <= rem)
       {var need=d[10] - d[9] | 0;
        return rem < need
                ?(blit(d,rem),refill(function(_aw_){return t_fill(k,_aw_)},d))
                :(blit(d,need),caml_call1(k,d))}
      return caml_call1(k,d)}
    function ret(k,v,byte_count,d)
     {d[18] = k;d[15] = d[15] + byte_count | 0;return caml_call2(d[17],d,v)}
    function decode_us_ascii(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var j=d[6];
        d[6] = d[6] + 1 | 0;
        var
         _au_=d[5],
         b0=caml_bytes_unsafe_get(_au_,j),
         _at_=1,
         _av_=
          127 < b0
           ?malformed(_au_,j,1)
           :[0,852405675,caml_call1(Stdlib_uchar[9],b0)];
        return ret(decode_us_ascii,_av_,_at_,d)}
      return 0 <= rem?refill(decode_us_ascii,d):3455931}
    function decode_iso_8859_1(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var j=d[6];
        d[6] = d[6] + 1 | 0;
        return ret
                (decode_iso_8859_1,
                 [0,
                  852405675,
                  caml_call1(Stdlib_uchar[9],caml_bytes_unsafe_get(d[5],j))],
                 1,
                 d)}
      return 0 <= rem?refill(decode_iso_8859_1,d):3455931}
    function t_decode_utf_8(d)
     {if(d[9] < d[10])
       {var _ar_=d[9];return ret(decode_utf_8,malformed(d[8],0,d[9]),_ar_,d)}
      var _as_=d[9];
      return ret(decode_utf_8,r_utf_8(d[8],0,d[9]),_as_,d)}
    function decode_utf_8(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var need=utf_8_len[1 + caml_bytes_unsafe_get(d[5],d[6])];
        if(rem < need){t_need(d,need);return t_fill(t_decode_utf_8,d)}
        var j=d[6];
        return 0 === need
                ?(d[6]
                  =
                  d[6]
                  +
                  1
                  |
                  0,
                  ret(decode_utf_8,malformed(d[5],j,1),1,d))
                :(d[6]
                  =
                  d[6]
                  +
                  need
                  |
                  0,
                  ret(decode_utf_8,r_utf_8(d[5],j,need),need,d))}
      return 0 <= rem?refill(decode_utf_8,d):3455931}
    function t_decode_utf_16be_lo(hi,d)
     {var bcount=d[9] + 2 | 0;
      return d[9] < d[10]
              ?ret(decode_utf_16be,malformed_pair(1,hi,d[8],0,d[9]),bcount,d)
              :ret(decode_utf_16be,r_utf_16_lo(hi,d[8],0,1),bcount,d)}
    function decode_utf_16be_lo(v,d)
     {if(659980059 <= v[1])return ret(decode_utf_16be,v,2,d);
      var hi=v[2],rem=i_rem(d);
      if(2 <= rem)
       {var j=d[6];
        d[6] = d[6] + 2 | 0;
        return ret(decode_utf_16be,r_utf_16_lo(hi,d[5],j,j + 1 | 0),4,d)}
      t_need(d,2);
      return t_fill(function(_aq_){return t_decode_utf_16be_lo(hi,_aq_)},d)}
    function t_decode_utf_16be(d)
     {if(d[9] < d[10])
       {var _ap_=d[9];
        return ret(decode_utf_16be,malformed(d[8],0,d[9]),_ap_,d)}
      return decode_utf_16be_lo(r_utf_16(d[8],0,1),d)}
    function decode_utf_16be(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {if(2 <= rem)
         {var j=d[6];
          d[6] = d[6] + 2 | 0;
          return decode_utf_16be_lo(r_utf_16(d[5],j,j + 1 | 0),d)}
        t_need(d,2);
        return t_fill(t_decode_utf_16be,d)}
      return 0 <= rem?refill(decode_utf_16be,d):3455931}
    function t_decode_utf_16_lo(hi,d)
     {var bcount=d[9] + 2 | 0;
      return d[9] < d[10]
              ?ret(decode_utf_16,malformed_pair(0,hi,d[8],0,d[9]),bcount,d)
              :ret(decode_utf_16,r_utf_16_lo(hi,d[8],1,0),bcount,d)}
    function decode_utf_16le_lo(v,d)
     {if(659980059 <= v[1])return ret(decode_utf_16,v,2,d);
      var hi=v[2],rem=i_rem(d);
      if(2 <= rem)
       {var j=d[6];
        d[6] = d[6] + 2 | 0;
        return ret(decode_utf_16,r_utf_16_lo(hi,d[5],j + 1 | 0,j),4,d)}
      t_need(d,2);
      return t_fill(function(_ao_){return t_decode_utf_16_lo(hi,_ao_)},d)}
    function t_decode_utf_16(d)
     {if(d[9] < d[10])
       {var _an_=d[9];return ret(decode_utf_16,malformed(d[8],0,d[9]),_an_,d)}
      return decode_utf_16le_lo(r_utf_16(d[8],1,0),d)}
    function decode_utf_16(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {if(2 <= rem)
         {var j=d[6];
          d[6] = d[6] + 2 | 0;
          return decode_utf_16le_lo(r_utf_16(d[5],j + 1 | 0,j),d)}
        t_need(d,2);
        return t_fill(t_decode_utf_16,d)}
      return 0 <= rem?refill(decode_utf_16,d):3455931}
    function guessed_utf_16(d,be,v)
     {if(be)
       var
        j1=1,
        j0=0,
        t_decode_utf_16_lo$0=t_decode_utf_16be_lo,
        t_decode_utf_16$0=t_decode_utf_16be,
        decode_utf_16$0=decode_utf_16be;
      else
       var
        j1=0,
        j0=1,
        t_decode_utf_16_lo$0=t_decode_utf_16_lo,
        t_decode_utf_16$0=t_decode_utf_16,
        decode_utf_16$0=decode_utf_16;
      function b3(k,d)
       {return 3 <= d[9]
                ?(d[10]
                  =
                  2,
                  d[9]
                  =
                  1,
                  unsafe_set_byte(d[8],0,caml_bytes_unsafe_get(d[8],2)),
                  t_fill(k,d))
                :decode_utf_16$0(d)}
      if(typeof v === "number")
       {if(427938126 <= v)
         {var v$0=r_utf_16(d[8],j0,j1);
          if(659980059 <= v$0[1])
           {var _ad_=2;
            return ret
                    (function(_am_){return b3(t_decode_utf_16$0,_am_)},
                     v$0,
                     _ad_,
                     d)}
          var hi=v$0[2];
          if(3 <= d[9])
           return b3(function(_al_){return t_decode_utf_16_lo$0(hi,_al_)},d);
          var _ae_=d[9];
          return ret
                  (decode_utf_16$0,
                   malformed_pair(be,hi,Stdlib_bytes[3],0,0),
                   _ae_,
                   d)}
        var _af_=2,_ag_=[0,852405675,u_bom];
        return ret
                (function(_ak_){return b3(t_decode_utf_16$0,_ak_)},
                 _ag_,
                 _af_,
                 d)}
      var u=v[2],_ah_=2,_ai_=[0,852405675,caml_call1(Stdlib_uchar[9],u)];
      return ret
              (function(_aj_){return b3(t_decode_utf_16$0,_aj_)},_ai_,_ah_,d)}
    function k(d)
     {function setup(d)
       {var match=r_encoding(d[8],0,d[9]),_ac_=match[1];
        if(-211555818 === _ac_)
         {var r=match[2];
          d[2] = -211555818;
          d[18] = decode_utf_16;
          return guessed_utf_16(d,0,r)}
        if(684370880 <= _ac_)
         {var r$0=match[2];
          d[2] = 684370880;
          d[18] = decode_utf_8;
          if(3455931 === r$0)return 3455931;
          if(427938126 <= r$0)
           {var
             b3=
              function(d)
               {var
                 b3=caml_bytes_unsafe_get(d[8],2),
                 n=caml_check_bound(utf_8_len,b3)[1 + b3];
                return 0 === n
                        ?ret(decode_utf_8,malformed(d[8],2,1),1,d)
                        :(d[10]
                          =
                          n,
                          d[9]
                          =
                          1,
                          unsafe_set_byte(d[8],0,b3),
                          t_fill(t_decode_utf_8,d))},
             b2=
              function(d)
               {var
                 b2=caml_bytes_unsafe_get(d[8],1),
                 b3$0=2 < d[9]?b3:decode_utf_8,
                 n=caml_check_bound(utf_8_len,b2)[1 + b2];
                if(0 === n)return ret(b3$0,malformed(d[8],1,1),1,d);
                if(1 === n)return ret(b3$0,r_utf_8(d[8],1,1),1,d);
                d[10] = n;
                unsafe_set_byte(d[8],0,b2);
                if(3 <= d[9])
                 {d[9] = 2;
                  unsafe_set_byte(d[8],1,caml_bytes_unsafe_get(d[8],2))}
                else
                 d[9] = 1;
                return t_fill(t_decode_utf_8,d)},
             b1=caml_bytes_unsafe_get(d[8],0),
             b2$0=1 < d[9]?b2:decode_utf_8,
             n=caml_check_bound(utf_8_len,b1)[1 + b1];
            if(4 < n >>> 0)throw [0,Assert_failure,_B_];
            switch(n)
             {case 0:return ret(b2$0,malformed(d[8],0,1),1,d);
              case 1:return ret(b2$0,r_utf_8(d[8],0,1),1,d);
              case 2:
               return 2 <= d[9]
                       ?3 <= d[9]
                         ?ret(b3,r_utf_8(d[8],0,2),2,d)
                         :ret(decode_utf_8,r_utf_8(d[8],0,2),2,d)
                       :ret(decode_utf_8,malformed(d[8],0,1),1,d);
              case 3:
               if(3 <= d[9])return ret(decode_utf_8,r_utf_8(d[8],0,3),3,d);
               var _aa_=d[9];
               return ret(decode_utf_8,malformed(d[8],0,d[9]),_aa_,d);
              default:
               if(3 <= d[9]){d[10] = 4;return t_fill(t_decode_utf_8,d)}
               var _ab_=d[9];
               return ret(decode_utf_8,malformed(d[8],0,d[9]),_ab_,d)}}
          return ret(decode_utf_8,[0,852405675,u_bom],3,d)}
        var r$1=match[2];
        d[2] = -211558048;
        d[18] = decode_utf_16be;
        return guessed_utf_16(d,1,r$1)}
      t_need(d,3);
      return t_fill(setup,d)}
    function nline(d){d[14] = 0;d[13] = d[13] + 1 | 0;return 0}
    function ncol(d){d[14] = d[14] + 1 | 0;return 0}
    function ncount(d){d[16] = d[16] + 1 | 0;return 0}
    function cr(d,b){d[12] = b;return 0}
    function pp(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         _$_=match - 133 | 0,
         switch$0=0;
        if(8100 < _$_ >>> 0)
         {var switcher=_$_ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              ncount(d);
              return last_cr?v:(nline(d),v);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return v}}
        else
         if(8097 < (_$_ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_readline(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         ___=match - 133 | 0,
         switch$0=0;
        if(8100 < ___ >>> 0)
         {var switcher=___ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(8097 < (___ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),[0,852405675,d[4]])
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_nlf(d,v)
     {if(852405675 <= v[1])
       {var u=v[2],match=caml_call1(Stdlib_uchar[10],u),switch$0=0;
        if(14 <= match)
         {if(8232 <= match)
           {if(! (8234 <= match))switch$0 = 1}
          else
           if(133 === match)
            {cr(d,0);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(10 <= match)
          {var switcher=match - 10 | 0;
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_ascii(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         _Z_=match - 133 | 0,
         switch$0=0;
        if(8100 < _Z_ >>> 0)
         {var switcher=_Z_ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(8097 < (_Z_ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function decode_fun(param)
     {return 143365725 <= param
              ?423112016 <= param
                ?684370880 <= param?decode_utf_8:decode_us_ascii
                :338302576 <= param?decode_iso_8859_1:decode_utf_16be
              :-211555818 <= param?decode_utf_16:decode_utf_16be}
    function decoder(nln,encoding,src)
     {if(nln)
       {var _X_=nln[1],_Y_=_X_[1];
        if(3895880 === _Y_)
         var nl=_X_[2],nl$0=nl,pp$0=pp_nln_nlf;
        else
         if(605782321 <= _Y_)
          var nl$1=_X_[2],nl$0=nl$1,pp$0=pp_nln_ascii;
         else
          var nl$2=_X_[2],nl$0=nl$2,pp$0=pp_nln_readline}
      else
       var nl$3=caml_call1(Stdlib_uchar[9],10),nl$0=nl$3,pp$0=pp;
      if(encoding)
       var e=encoding[1],k$0=decode_fun(e),encoding$0=e;
      else
       var k$0=k,encoding$0=684370880;
      if(typeof src === "number")
       var i_max=0,i_pos=1,i=Stdlib_bytes[3];
      else
       if(438511779 <= src[1])
        var i_max=0,i_pos=1,i=caml_create_bytes(65536);
       else
        var
         s=src[2],
         i_max$0=caml_ml_string_length(s) - 1 | 0,
         i$0=caml_call1(Stdlib_bytes[43],s),
         i_max=i_max$0,
         i_pos=0,
         i=i$0;
      var utf16=143365725 === encoding$0?1:0;
      return [0,
              src,
              encoding$0,
              nln,
              nl$0,
              i,
              i_pos,
              i_max,
              caml_create_bytes(4),
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              function(d,v)
               {if(852405675 <= v[1])
                 {var u=v[2],match=caml_call1(Stdlib_uchar[10],u);
                  if(65279 === match)
                   {if(utf16){d[2] = -211558048;d[18] = decode_utf_16be}
                    d[11] = 1;
                    d[17] = pp$0;
                    return caml_call1(d[18],d)}
                  if(65534 === match && utf16)
                   {d[2] = -211555818;
                    d[18] = decode_utf_16;
                    d[11] = 1;
                    d[17] = pp$0;
                    return caml_call1(d[18],d)}
                  d[11] = 0;
                  d[17] = pp$0;
                  return caml_call2(d[17],d,v)}
                d[11] = 0;
                d[17] = pp$0;
                return caml_call2(d[17],d,v)},
              k$0]}
    function decode(d){return caml_call1(d[18],d)}
    function decoder_line(d){return d[13]}
    function decoder_col(d){return d[14]}
    function decoder_byte_count(d){return d[15]}
    function decoder_count(d){return d[16]}
    function decoder_removed_bom(d){return d[11]}
    function decoder_src(d){return d[1]}
    function decoder_nln(d){return d[3]}
    function decoder_encoding(d){return d[2]}
    function set_decoder_encoding(d,e)
     {d[2] = e;d[18] = decode_fun(e);return 0}
    function o_rem(e){return (e[5] - e[4] | 0) + 1 | 0}
    function dst(e,s,j,l)
     {var _U_=j < 0?1:0;
      if(_U_)
       var _V_=_U_;
      else
       var
        _W_=l < 0?1:0,
        _V_=_W_ || (caml_ml_bytes_length(s) < (j + l | 0)?1:0);
      if(_V_)invalid_bounds(j,l);
      e[3] = s;
      e[4] = j;
      e[5] = (j + l | 0) - 1 | 0;
      return 0}
    function flush(k,e)
     {var _T_=e[1];
      if(typeof _T_ === "number")
       {e[9]
        =
        function(e,param)
         {if(typeof param === "number" && 1006505782 <= param)
           return caml_call1(k,e);
          return caml_call1(Stdlib[1],cst_expected_Await_encode)};
        return 939392865}
      if(438511779 <= _T_[1])
       {var oc=_T_[2];
        caml_call4(Stdlib[68],oc,e[3],0,e[4]);
        e[4] = 0;
        return caml_call1(k,e)}
      var b=_T_[2],o=caml_call1(Stdlib_bytes[42],e[3]);
      caml_call4(Stdlib_buffer[16],b,o,0,e[4]);
      e[4] = 0;
      return caml_call1(k,e)}
    function t_range(e,max){e[7] = 0;e[8] = max;return 0}
    function t_flush(k,e)
     {function blit(e,l)
       {caml_blit_bytes(e[6],e[7],e[3],e[4],l);
        e[4] = e[4] + l | 0;
        e[7] = e[7] + l | 0;
        return 0}
      var rem=o_rem(e),len=(e[8] - e[7] | 0) + 1 | 0;
      return rem < len
              ?(blit(e,rem),flush(function(_S_){return t_flush(k,_S_)},e))
              :(blit(e,len),caml_call1(k,e))}
    function encode_utf_8(e,v)
     {function k(e){e[9] = encode_utf_8;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(127 < u$0)
       {if(2047 < u$0)
         {if(65535 < u$0)
           {if(4 <= rem)
             {var j=e[4];e[4] = e[4] + 4 | 0;var k$0=k,j$0=j,s=e[3]}
            else
             {t_range(e,3);
              var
               _M_=function(_R_){return t_flush(k,_R_)},
               k$0=_M_,
               j$0=0,
               s=e[6]}
            unsafe_set_byte(s,j$0,240 | u$0 >>> 18 | 0);
            unsafe_set_byte(s,j$0 + 1 | 0,128 | (u$0 >>> 12 | 0) & 63);
            unsafe_set_byte(s,j$0 + 2 | 0,128 | (u$0 >>> 6 | 0) & 63);
            unsafe_set_byte(s,j$0 + 3 | 0,128 | u$0 & 63);
            return k$0(e)}
          if(3 <= rem)
           {var j$1=e[4];e[4] = e[4] + 3 | 0;var k$1=k,j$2=j$1,s$0=e[3]}
          else
           {t_range(e,2);
            var
             _N_=function(_Q_){return t_flush(k,_Q_)},
             k$1=_N_,
             j$2=0,
             s$0=e[6]}
          unsafe_set_byte(s$0,j$2,224 | u$0 >>> 12 | 0);
          unsafe_set_byte(s$0,j$2 + 1 | 0,128 | (u$0 >>> 6 | 0) & 63);
          unsafe_set_byte(s$0,j$2 + 2 | 0,128 | u$0 & 63);
          return k$1(e)}
        if(2 <= rem)
         {var j$3=e[4];e[4] = e[4] + 2 | 0;var k$2=k,j$4=j$3,s$1=e[3]}
        else
         {t_range(e,1);
          var _O_=function(_P_){return t_flush(k,_P_)},k$2=_O_,j$4=0,s$1=e[6]}
        unsafe_set_byte(s$1,j$4,192 | u$0 >>> 6 | 0);
        unsafe_set_byte(s$1,j$4 + 1 | 0,128 | u$0 & 63);
        return k$2(e)}
      return 1 <= rem
              ?(unsafe_set_byte(e[3],e[4],u$0),e[4] = e[4] + 1 | 0,k(e))
              :flush(function(e){return encode_utf_8(e,v)},e)}
    function encode_utf_16be(e,v)
     {function k(e){e[9] = encode_utf_16be;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(65536 <= u$0)
       {if(4 <= rem)
         {var j=e[4];e[4] = e[4] + 4 | 0;var k$0=k,j$0=j,s=e[3]}
        else
         {t_range(e,3);
          var _I_=function(_L_){return t_flush(k,_L_)},k$0=_I_,j$0=0,s=e[6]}
        var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        unsafe_set_byte(s,j$0,hi >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 1 | 0,hi & 255);
        unsafe_set_byte(s,j$0 + 2 | 0,lo >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 3 | 0,lo & 255);
        return k$0(e)}
      if(2 <= rem)
       {var j$1=e[4];e[4] = e[4] + 2 | 0;var k$1=k,j$2=j$1,s$0=e[3]}
      else
       {t_range(e,1);
        var _J_=function(_K_){return t_flush(k,_K_)},k$1=_J_,j$2=0,s$0=e[6]}
      unsafe_set_byte(s$0,j$2,u$0 >>> 8 | 0);
      unsafe_set_byte(s$0,j$2 + 1 | 0,u$0 & 255);
      return k$1(e)}
    function encode_utf_16le(e,v)
     {function k(e){e[9] = encode_utf_16le;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(65536 <= u$0)
       {if(4 <= rem)
         {var j=e[4];e[4] = e[4] + 4 | 0;var k$0=k,j$0=j,s=e[3]}
        else
         {t_range(e,3);
          var _E_=function(_H_){return t_flush(k,_H_)},k$0=_E_,j$0=0,s=e[6]}
        var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        unsafe_set_byte(s,j$0,hi & 255);
        unsafe_set_byte(s,j$0 + 1 | 0,hi >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 2 | 0,lo & 255);
        unsafe_set_byte(s,j$0 + 3 | 0,lo >>> 8 | 0);
        return k$0(e)}
      if(2 <= rem)
       {var j$1=e[4];e[4] = e[4] + 2 | 0;var k$1=k,j$2=j$1,s$0=e[3]}
      else
       {t_range(e,1);
        var _F_=function(_G_){return t_flush(k,_G_)},k$1=_F_,j$2=0,s$0=e[6]}
      unsafe_set_byte(s$0,j$2,u$0 & 255);
      unsafe_set_byte(s$0,j$2 + 1 | 0,u$0 >>> 8 | 0);
      return k$1(e)}
    function encoder(encoding,dst)
     {if(typeof dst === "number")
       var o_max=0,o_pos=1,o=Stdlib_bytes[3];
      else
       var o$0=caml_create_bytes(65536),o_max=65535,o_pos=0,o=o$0;
      var
       _D_=
        143365725 <= encoding
         ?684370880 <= encoding?encode_utf_8:encode_utf_16be
         :-211555818 <= encoding?encode_utf_16le:encode_utf_16be;
      return [0,dst,encoding,o,o_pos,o_max,caml_create_bytes(4),1,0,_D_]}
    function encode(e,v){return caml_call2(e[9],e,v)}
    function encoder_encoding(e){return e[2]}
    function encoder_dst(e){return e[1]}
    var Manual=[0,src,dst,o_rem];
    function encoding_guess(s)
     {var
       s$0=caml_call1(Stdlib_bytes[43],s),
       match=
        r_encoding(s$0,0,caml_call2(Stdlib[17],caml_ml_bytes_length(s$0),3)),
       _C_=match[1];
      if(-211555818 === _C_)
       {var d=match[2];return [0,-211555818,3299808 === d?1:0]}
      if(684370880 <= _C_)
       {var d$0=match[2];return [0,684370880,3299808 === d$0?1:0]}
      var d$1=match[2];
      return [0,-211558048,3299808 === d$1?1:0]}
    function fold_utf_8(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var need=utf_8_len[1 + caml_bytes_unsafe_get(s$0,i)];
        if(0 === need)
         {var
           i$0=i + 1 | 0,
           acc$1=caml_call3(f,acc$0,i,malformed(s$0,i,1)),
           acc$0=acc$1,
           i=i$0;
          continue}
        var rem=(last - i | 0) + 1 | 0;
        if(rem < need)return caml_call3(f,acc$0,i,malformed(s$0,i,rem));
        var
         i$1=i + need | 0,
         acc$2=caml_call3(f,acc$0,i,r_utf_8(s$0,i,need)),
         acc$0=acc$2,
         i=i$1;
        continue}}
    function fold_utf_16be(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var rem=(last - i | 0) + 1 | 0;
        if(2 <= rem)
         {var v=r_utf_16(s$0,i,i + 1 | 0);
          if(659980059 <= v[1])
           {var i$0=i + 2 | 0,acc$1=caml_call3(f,acc$0,i,v),acc$0=acc$1,i=i$0;
            continue}
          var hi=v[2];
          if(4 <= rem)
           {var
             i$1=i + 4 | 0,
             acc$2=
              caml_call3(f,acc$0,i,r_utf_16_lo(hi,s$0,i + 2 | 0,i + 3 | 0)),
             acc$0=acc$2,
             i=i$1;
            continue}
          return caml_call3(f,acc$0,i,malformed(s$0,i,rem))}
        return caml_call3(f,acc$0,i,malformed(s$0,i,1))}}
    function fold_utf_16le(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var rem=(last - i | 0) + 1 | 0;
        if(2 <= rem)
         {var v=r_utf_16(s$0,i + 1 | 0,i);
          if(659980059 <= v[1])
           {var i$0=i + 2 | 0,acc$1=caml_call3(f,acc$0,i,v),acc$0=acc$1,i=i$0;
            continue}
          var hi=v[2];
          if(4 <= rem)
           {var
             i$1=i + 4 | 0,
             acc$2=
              caml_call3(f,acc$0,i,r_utf_16_lo(hi,s$0,i + 3 | 0,i + 2 | 0)),
             acc$0=acc$2,
             i=i$1;
            continue}
          return caml_call3(f,acc$0,i,malformed(s$0,i,rem))}
        return caml_call3(f,acc$0,i,malformed(s$0,i,1))}}
    var String=[0,encoding_guess,fold_utf_8,fold_utf_16be,fold_utf_16le];
    function add_utf_8(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      return 127 < u$0
              ?2047 < u$0
                ?65535 < u$0
                  ?(w(240 | u$0 >>> 18 | 0),
                    w(128 | (u$0 >>> 12 | 0) & 63),
                    w(128 | (u$0 >>> 6 | 0) & 63),
                    w(128 | u$0 & 63))
                  :(w(224 | u$0 >>> 12 | 0),
                    w(128 | (u$0 >>> 6 | 0) & 63),
                    w(128 | u$0 & 63))
                :(w(192 | u$0 >>> 6 | 0),w(128 | u$0 & 63))
              :w(u$0)}
    function add_utf_16be(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      if(65536 <= u$0)
       {var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        w(hi >>> 8 | 0);
        w(hi & 255);
        w(lo >>> 8 | 0);
        return w(lo & 255)}
      w(u$0 >>> 8 | 0);
      return w(u$0 & 255)}
    function add_utf_16le(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      if(65536 <= u$0)
       {var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        w(hi & 255);
        w(hi >>> 8 | 0);
        w(lo & 255);
        return w(lo >>> 8 | 0)}
      w(u$0 & 255);
      return w(u$0 >>> 8 | 0)}
    var
     Buffer=[0,add_utf_8,add_utf_16be,add_utf_16le],
     Uutf=
      [0,
       u_bom,
       u_rep,
       encoding_of_string,
       encoding_to_string,
       decoder,
       decode,
       decoder_encoding,
       set_decoder_encoding,
       decoder_line,
       decoder_col,
       decoder_byte_count,
       decoder_count,
       decoder_removed_bom,
       decoder_src,
       decoder_nln,
       pp_decode,
       encoder,
       encode,
       encoder_encoding,
       encoder_dst,
       Manual,
       String,
       Buffer];
    runtime.caml_register_global(66,Uutf,"Uutf");
    return}
  (function(){return this}()));


//# 1 ".ace_common.objs/ace_common.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int64_and=runtime.caml_int64_and,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call8(f,a0,a1,a2,a3,a4,a5,a6,a7)
     {return f.length == 8
              ?f(a0,a1,a2,a3,a4,a5,a6,a7)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7])}
    function caml_call9(f,a0,a1,a2,a3,a4,a5,a6,a7,a8)
     {return f.length == 9
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8])}
    function caml_call11(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
     {return f.length == 11
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Not_a_valid_int32=caml_string_of_jsbytes("Not a valid int32."),
     cst_abc=caml_string_of_jsbytes("abc"),
     cst_eng=caml_string_of_jsbytes("eng"),
     cst_fra=caml_string_of_jsbytes("fra"),
     cst_ger=caml_string_of_jsbytes("ger"),
     cst_ita=caml_string_of_jsbytes("ita"),
     cst_jap=caml_string_of_jsbytes("jap"),
     cst_spa=caml_string_of_jsbytes("spa"),
     cst_1=caml_string_of_jsbytes("1"),
     cst_2=caml_string_of_jsbytes("2"),
     cst_3=caml_string_of_jsbytes("3"),
     cst_4=caml_string_of_jsbytes("4"),
     cst_5=caml_string_of_jsbytes("5"),
     cst_1$0=caml_string_of_jsbytes("1"),
     cst_2$0=caml_string_of_jsbytes("2"),
     cst_3$0=caml_string_of_jsbytes("3"),
     cst_Unknown_answer=caml_string_of_jsbytes("Unknown answer."),
     cst_Old_rod=caml_string_of_jsbytes("Old rod"),
     cst_Good_rod=caml_string_of_jsbytes("Good rod"),
     cst_Super_rod=caml_string_of_jsbytes("Super rod"),
     cst_Save_InvalidSave=caml_string_of_jsbytes("Save.InvalidSave"),
     cst_Preprocess_VarNotFound=
      caml_string_of_jsbytes("Preprocess.VarNotFound"),
     partial=[12,32,[5,0,0,0,[17,4,0]]],
     cst_Not_implemented$0=caml_string_of_jsbytes("Not implemented"),
     cst_Not_implemented=caml_string_of_jsbytes("Not implemented"),
     cst_Arm_InvalidCommand=caml_string_of_jsbytes("Arm.InvalidCommand"),
     spacing_char=caml_string_of_jsbytes("_"),
     invalid_char=caml_string_of_jsbytes("\xe2\x9c\x96"),
     cst$1=caml_string_of_jsbytes(" "),
     cst=caml_string_of_jsbytes(""),
     cst$0=caml_string_of_jsbytes(" "),
     cst_Not_implemented$2=caml_string_of_jsbytes("Not implemented"),
     cst_Not_implemented$1=caml_string_of_jsbytes("Not implemented"),
     cst_Optimizer_CannotOptimize=
      caml_string_of_jsbytes("Optimizer.CannotOptimize"),
     cst_B$0=caml_string_of_jsbytes("B"),
     cst_MOV=caml_string_of_jsbytes("MOV"),
     cst_ADC=caml_string_of_jsbytes("ADC"),
     cst_ADD=caml_string_of_jsbytes("ADD"),
     cst_AND=caml_string_of_jsbytes("AND"),
     cst_BIC=caml_string_of_jsbytes("BIC"),
     cst_EOR=caml_string_of_jsbytes("EOR"),
     cst_LDR=caml_string_of_jsbytes("LDR"),
     cst_MVN=caml_string_of_jsbytes("MVN"),
     cst_ORR=caml_string_of_jsbytes("ORR"),
     cst_SBC=caml_string_of_jsbytes("SBC"),
     cst_STR=caml_string_of_jsbytes("STR"),
     cst_SUB=caml_string_of_jsbytes("SUB"),
     cst_r15=caml_string_of_jsbytes("r15"),
     cst_r1=caml_string_of_jsbytes("r1"),
     cst_fp=caml_string_of_jsbytes("fp"),
     cst_ip=caml_string_of_jsbytes("ip"),
     cst_lr=caml_string_of_jsbytes("lr"),
     cst_pc=caml_string_of_jsbytes("pc"),
     cst_r0=caml_string_of_jsbytes("r0"),
     cst_r10=caml_string_of_jsbytes("r10"),
     cst_r11=caml_string_of_jsbytes("r11"),
     cst_r12=caml_string_of_jsbytes("r12"),
     cst_r13=caml_string_of_jsbytes("r13"),
     cst_r14=caml_string_of_jsbytes("r14"),
     cst_r7=caml_string_of_jsbytes("r7"),
     cst_r2=caml_string_of_jsbytes("r2"),
     cst_r3=caml_string_of_jsbytes("r3"),
     cst_r4=caml_string_of_jsbytes("r4"),
     cst_r5=caml_string_of_jsbytes("r5"),
     cst_r6=caml_string_of_jsbytes("r6"),
     cst_r8=caml_string_of_jsbytes("r8"),
     cst_r9=caml_string_of_jsbytes("r9"),
     cst_sb=caml_string_of_jsbytes("sb"),
     cst_sl=caml_string_of_jsbytes("sl"),
     cst_sp=caml_string_of_jsbytes("sp"),
     cst_L$0=caml_string_of_jsbytes("L"),
     cst_S$0=caml_string_of_jsbytes("S"),
     cst_X$0=caml_string_of_jsbytes("X"),
     mods=[0,0,0,0,0,0],
     cst_L=caml_string_of_jsbytes("L"),
     cst_S=caml_string_of_jsbytes("S"),
     cst_X=caml_string_of_jsbytes("X"),
     cst_BT=caml_string_of_jsbytes("BT"),
     cst_SB=caml_string_of_jsbytes("SB"),
     cst_SH=caml_string_of_jsbytes("SH"),
     cst_B=caml_string_of_jsbytes("B"),
     cst_H=caml_string_of_jsbytes("H"),
     cst_T=caml_string_of_jsbytes("T"),
     cst_W=caml_string_of_jsbytes("W"),
     cst_LE=caml_string_of_jsbytes("LE"),
     cst_AL=caml_string_of_jsbytes("AL"),
     cst_CC=caml_string_of_jsbytes("CC"),
     cst_CS=caml_string_of_jsbytes("CS"),
     cst_EQ=caml_string_of_jsbytes("EQ"),
     cst_GE=caml_string_of_jsbytes("GE"),
     cst_GT=caml_string_of_jsbytes("GT"),
     cst_HI=caml_string_of_jsbytes("HI"),
     cst_HS=caml_string_of_jsbytes("HS"),
     cst_LO=caml_string_of_jsbytes("LO"),
     cst_LS=caml_string_of_jsbytes("LS"),
     cst_LT=caml_string_of_jsbytes("LT"),
     cst_MI=caml_string_of_jsbytes("MI"),
     cst_NE=caml_string_of_jsbytes("NE"),
     cst_PL=caml_string_of_jsbytes("PL"),
     cst_VC=caml_string_of_jsbytes("VC"),
     cst_VS=caml_string_of_jsbytes("VS"),
     cst_Parser_ast_CommandError=
      caml_string_of_jsbytes("Parser_ast.CommandError"),
     cst_Parser_ast_StructError=
      caml_string_of_jsbytes("Parser_ast.StructError"),
     cst_Parser_MenhirBasics_Error=
      caml_string_of_jsbytes("Parser.MenhirBasics.Error"),
     cst_Unexpected_char=caml_string_of_jsbytes("Unexpected char: "),
     cst_String_cannot_be_multiline=
      caml_string_of_jsbytes("String cannot be multiline"),
     cst_String_is_not_terminated=
      caml_string_of_jsbytes("String is not terminated"),
     cst_Illegal_string_character=
      caml_string_of_jsbytes("Illegal string character: "),
     cst_Lexer_SyntaxError=caml_string_of_jsbytes("Lexer.SyntaxError"),
     ocaml_lex_tables=
      [0,
       caml_string_of_jsbytes
        ("\0\0\xd7\xff\xd8\xff\xd9\xff\xda\xff\xdf\xff\xe0\xff\xe1\xff\xe2\xff\xe3\xff\xe4\xff\xe5\xff\xe7\xff\xe8\xff\xe9\xff\xea\xff\xeb\xff\xec\xff\xee\xffO\0\x9a\0\xa4\0\xf1\xff\x01\0\x02\0\x07\x001\0\xf4\xff\t\0c\0\x0e\0N\0N\0Q\0\xed\x008\x01\x83\x01N\0R\0m\0n\0o\0p\0\xfe\xff\xce\x01\x19\x02d\x02\xaf\x02\xfa\x02E\x03\x90\x03\xdb\x03&\x04q\x04\xfa\xff\xf9\xff\xf7\xff\xf6\xff\xf5\xff\xf2\xff\x04\0\xae\0\xb7\0\xbc\x04\xb9\0\xd3\x04\xc4\0\xd7\0\xec\x04\xf5\xff\xf6\xff\x07\0\xed\x04\xcc\x04\xff\xff\xf8\xff\xf9\xff\xfa\xff\xfb\xff\xfc\xff\xfd\xff\xfe\xff\x0f\0\xfd\xff\xfe\xff\xff\xff\b\0"),
       caml_string_of_jsbytes
        ('\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x10\0\x0f\0\x0f\0\xff\xff\x0e\0(\0\f\0!\0\xff\xff"\0#\0$\0\x19\0(\0(\0\x10\0\x10\0\x10\0\x0b\0\x12\0\x07\0\xff\xff\xff\xff\0\0\xff\xff\x10\0\x10\0\x02\0\x10\0\x10\0\x03\0\x10\0\x10\0\x10\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\r\0\xff\xff\xff\xff\xff\xff\xff\xff\x0f\0\x0f\0\x0f\0\xff\xff\xff\xff\xff\xff\t\0\b\0\x0b\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0'),
       caml_string_of_jsbytes
        ("\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffH\0\0\0\0\0\xff\xffH\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0S\0\0\0\0\0\0\0\xff\xff"),
       caml_string_of_jsbytes
        ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x19\0\x16\0\x16\0;\0\x17\0;\0<\0\x19\0F\0U\0\0\0\0\0\0\0\0\0\0\0\0\0U\0\0\0\0\0V\0\0\0\0\0\0\0\x19\0\x1f\0\x12\0\x11\0\0\0\x1c\0\x1d\0\x19\0\t\0\b\0\x05\0\x07\0\f\0\x06\0\x1b\0\x1a\0\x15\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\n\0\x1b\0!\0&\0 \0\x0b\0%\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x10\0\x18\0\x0f\0\x04\0\x13\0\x1b\0\x13\0\x13\0\x13\0\x13\0\x13\0\"\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0$\0\x13\0\x13\0\x13\0\x13\0\x13\0#\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x0e\0\x1e\0\r\0\x03\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0:\x009\x008\x007\x006\0+\0'\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0(\0)\0*\0*\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0C\0C\0C\0C\0C\0C\0C\0C\0>\0B\0B\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0=\0B\0B\0\0\0\0\0\0\0@\0\0\0\0\0?\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\0\0\0\0>\0C\0C\0C\0C\0C\0C\0C\0C\0T\0\0\0\0\0\0\0=\0\0\0\0\0\0\0\0\0\0\0@\0\0\0\0\0?\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\x002\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0/\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0,\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0-\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0.\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\x000\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\x001\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\x003\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\x004\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\x005\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\0\0\0\0\0\0\0\0\x13\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0F\0\xff\xff\0\0G\0\xff\xffQ\0\0\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0\0\0J\0\xff\xff\0\0\0\0\0\0\0\0A\0A\0A\0A\0A\0A\0\0\0\0\0\0\0A\0A\0A\0A\0A\0A\0\0\0\0\0\0\0\0\0\0\0P\0\0\0\0\0\0\0\0\0\0\0O\0\0\0\0\0\0\0N\0\0\0A\0A\0A\0A\0A\0A\0M\0\0\0\0\0\0\0L\0\0\0K\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0I\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0E\0\xff\xff"),
       caml_string_of_jsbytes
        ('\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\x17\0\x18\0\0\0<\0\x18\0\x19\0G\0V\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffR\0\xff\xff\xff\xffR\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\x19\0\0\0\0\0\0\0\0\0\0\0\0\0\x1c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1a\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x1d\0\x1e\0\x1f\0 \0!\0%\0&\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\'\0(\0)\0*\0\x13\0\xff\xff\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x13\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x14\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0=\0=\0=\0=\0=\0=\0=\0=\0\x15\0>\0>\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0\x15\0B\0B\0\xff\xff\xff\xff\xff\xff\x15\0\xff\xff\xff\xff\x15\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x15\0C\0C\0C\0C\0C\0C\0C\0C\0R\0\xff\xff\xff\xff\xff\xff\x15\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x15\0\xff\xff\xff\xff\x15\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0\xff\xff\xff\xff\xff\xff\xff\xff"\0\xff\xff"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0"\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0\xff\xff\xff\xff\xff\xff\xff\xff#\0\xff\xff#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0#\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0\xff\xff\xff\xff\xff\xff\xff\xff$\0\xff\xff$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0$\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0\xff\xff\xff\xff\xff\xff\xff\xff,\0\xff\xff,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0\xff\xff\xff\xff\xff\xff\xff\xff-\0\xff\xff-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0-\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0\xff\xff\xff\xff\xff\xff\xff\xff.\0\xff\xff.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0.\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0\xff\xff\xff\xff\xff\xff\xff\xff/\0\xff\xff/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\0/\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\0\xff\xff\xff\xff\xff\xff\xff\xff0\0\xff\xff0\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff1\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\0\xff\xff\xff\xff\xff\xff\xff\xff1\0\xff\xff1\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff2\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0\xff\xff\xff\xff\xff\xff\xff\xff2\0\xff\xff2\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff3\0\xff\xff3\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xff\xff\xff\xff\xff\xff\xff\xff4\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0\xff\xff\xff\xff\xff\xff\xff\xff5\0\xff\xff5\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0?\0?\0?\0?\0?\0?\0?\0?\0?\0?\0D\0H\0\xff\xffD\0H\0I\0\xff\xff?\0?\0?\0?\0?\0?\0A\0A\0A\0A\0A\0A\0A\0A\0A\0A\0\xff\xffD\0H\0\xff\xff\xff\xff\xff\xff\xff\xffA\0A\0A\0A\0A\0A\0\xff\xff\xff\xff\xff\xff?\0?\0?\0?\0?\0?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffI\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffI\0\xff\xff\xff\xff\xff\xffI\0\xff\xffA\0A\0A\0A\0A\0A\0I\0\xff\xff\xff\xff\xff\xffI\0\xff\xffI\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffD\0H\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffD\0H\0'),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes("")],
     cst_Parse_InvalidContent=caml_string_of_jsbytes("Parse.InvalidContent"),
     cst_filename=caml_string_of_jsbytes("filename"),
     cst_Please_specify_the_filenam=
      caml_string_of_jsbytes
       ("Please specify the 'filename' header everywhere."),
     cst_Invalid_headers=caml_string_of_jsbytes("Invalid headers."),
     cst_start=caml_string_of_jsbytes("start"),
     cst_Exit_code_has_invalid_head=
      caml_string_of_jsbytes("Exit code has invalid headers."),
     cst_txt=caml_string_of_jsbytes(".txt"),
     cst_Exit_codes_cannot_be_tweak=
      caml_string_of_jsbytes
       ("Exit codes cannot be tweaked (please remove interrogation marks)."),
     cst_Exit_NoExitCode=caml_string_of_jsbytes("Exit.NoExitCode"),
     cst_Cannot_pad_the_required_am=
      caml_string_of_jsbytes
       ("Cannot pad the required amount. Is starting position valid?"),
     cst_Some_codes_cannot_be_posit=
      caml_string_of_jsbytes
       ("Some codes cannot be positionned due to non-consecutive 0xFF bytes."),
     cst_Result_is_inconsistent_Ple=
      caml_string_of_jsbytes
       ("Result is inconsistent. Please check the fillers."),
     cst_Result_is_inconsistent_Ple$0=
      caml_string_of_jsbytes
       ("Result is inconsistent. Please check the fillers."),
     cst_Boxes_BoxFittingError=caml_string_of_jsbytes("Boxes.BoxFittingError"),
     cst_ADC$0=caml_string_of_jsbytes("ADC"),
     cst_SBC$0=caml_string_of_jsbytes("SBC"),
     cst_BIC$0=caml_string_of_jsbytes("BIC"),
     cst_AND$0=caml_string_of_jsbytes("AND"),
     cst_ADD$0=caml_string_of_jsbytes("ADD"),
     cst_SUB$0=caml_string_of_jsbytes("SUB"),
     cst_ORR$0=caml_string_of_jsbytes("ORR"),
     cst_EOR$0=caml_string_of_jsbytes("EOR"),
     cst_MVN$0=caml_string_of_jsbytes("MVN"),
     cst_MOV$0=caml_string_of_jsbytes("MOV"),
     cst_STR$0=caml_string_of_jsbytes("STR"),
     cst_LDR$0=caml_string_of_jsbytes("LDR"),
     cst$8=caml_string_of_jsbytes("!"),
     cst$9=caml_string_of_jsbytes(""),
     cst_Not_implemented$4=caml_string_of_jsbytes("Not implemented"),
     cst_Not_implemented$3=caml_string_of_jsbytes("Not implemented"),
     cst_L$1=caml_string_of_jsbytes("L"),
     cst$7=caml_string_of_jsbytes(""),
     cst_S$1=caml_string_of_jsbytes("S"),
     cst$6=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes("-"),
     cst$5=caml_string_of_jsbytes(""),
     cst_B$1=caml_string_of_jsbytes("B"),
     cst_SB$0=caml_string_of_jsbytes("SB"),
     cst_H$0=caml_string_of_jsbytes("H"),
     cst_SH$0=caml_string_of_jsbytes("SH"),
     cst$3=caml_string_of_jsbytes(""),
     cst_T$0=caml_string_of_jsbytes("T"),
     cst_BT$0=caml_string_of_jsbytes("BT"),
     cst_EQ$0=caml_string_of_jsbytes("EQ"),
     cst_NE$0=caml_string_of_jsbytes("NE"),
     cst_CS$0=caml_string_of_jsbytes("CS"),
     cst_HS$0=caml_string_of_jsbytes("HS"),
     cst_CC$0=caml_string_of_jsbytes("CC"),
     cst_LO$0=caml_string_of_jsbytes("LO"),
     cst_MI$0=caml_string_of_jsbytes("MI"),
     cst_PL$0=caml_string_of_jsbytes("PL"),
     cst_VS$0=caml_string_of_jsbytes("VS"),
     cst_VC$0=caml_string_of_jsbytes("VC"),
     cst_HI$0=caml_string_of_jsbytes("HI"),
     cst_LS$0=caml_string_of_jsbytes("LS"),
     cst_GE$0=caml_string_of_jsbytes("GE"),
     cst_LT$0=caml_string_of_jsbytes("LT"),
     cst_GT$0=caml_string_of_jsbytes("GT"),
     cst_LE$0=caml_string_of_jsbytes("LE"),
     cst$2=caml_string_of_jsbytes(""),
     cst_Invalid_filler=caml_string_of_jsbytes("Invalid filler."),
     cst_Invalid_headers$0=caml_string_of_jsbytes("Invalid headers."),
     cst_onlyraw=caml_string_of_jsbytes("onlyraw"),
     cst_Invalid_headers$5=caml_string_of_jsbytes("Invalid headers."),
     cst_Only_raw_mode_does_not_sup=
      caml_string_of_jsbytes("Only-raw mode does not support exit codes."),
     cst_start$0=caml_string_of_jsbytes("start"),
     cst_Invalid_headers$4=caml_string_of_jsbytes("Invalid headers."),
     cst_filler0=caml_string_of_jsbytes("filler0"),
     cst_Invalid_headers$3=caml_string_of_jsbytes("Invalid headers."),
     cst_filler0_alt=caml_string_of_jsbytes("filler0_alt"),
     cst_Invalid_headers$2=caml_string_of_jsbytes("Invalid headers."),
     cst_fill=caml_string_of_jsbytes("fill"),
     cst_fill$0=caml_string_of_jsbytes("fill"),
     cst_The_fill_header_has_a_diff=
      caml_string_of_jsbytes
       ("The 'fill' header has a different value in the main code and in the exit code."),
     cst_Invalid_headers$1=caml_string_of_jsbytes("Invalid headers."),
     cst_The_exit_code_overlaps_thi=
      caml_string_of_jsbytes
       ("The exit code overlaps this code (too long?).@."),
     Stdlib_format=global_data.Stdlib__format,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_int32=global_data.Stdlib__int32,
     Assert_failure=global_data.Assert_failure,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_int64=global_data.Stdlib__int64,
     Stdlib=global_data.Stdlib,
     Stdlib_filename=global_data.Stdlib__filename,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Big_int=global_data.Big_int,
     Stdlib_scanf=global_data.Stdlib__scanf,
     Stdlib_map=global_data.Stdlib__map,
     Stdlib_set=global_data.Stdlib__set,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_lexing=global_data.Stdlib__lexing,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Uutf=global_data.Uutf,
     _f_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _g_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _c_=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     _b_=[0,caml_string_of_jsbytes("IO/utils.ml"),21,45],
     _a_=runtime.caml_int64_create_lo_mi_hi(0,16776960,65535),
     _h_=
      [0,
       caml_string_of_jsbytes("GAEM"),
       caml_string_of_jsbytes("GAME"),
       caml_string_of_jsbytes("GEAM"),
       caml_string_of_jsbytes("GEMA"),
       caml_string_of_jsbytes("GMAE"),
       caml_string_of_jsbytes("GMEA"),
       caml_string_of_jsbytes("AGEM"),
       caml_string_of_jsbytes("AGME"),
       caml_string_of_jsbytes("AEGM"),
       caml_string_of_jsbytes("AEMG"),
       caml_string_of_jsbytes("AMGE"),
       caml_string_of_jsbytes("AMEG"),
       caml_string_of_jsbytes("EGAM"),
       caml_string_of_jsbytes("EGMA"),
       caml_string_of_jsbytes("EAGM"),
       caml_string_of_jsbytes("EAMG"),
       caml_string_of_jsbytes("EMGA"),
       caml_string_of_jsbytes("EMAG"),
       caml_string_of_jsbytes("MGAE"),
       caml_string_of_jsbytes("MGEA"),
       caml_string_of_jsbytes("MAGE"),
       caml_string_of_jsbytes("MAEG"),
       caml_string_of_jsbytes("MEGA"),
       caml_string_of_jsbytes("MEAG")],
     _w_=[0,caml_string_of_jsbytes("Pokemon/seed.ml"),66,2],
     _o_=runtime.caml_int64_create_lo_mi_hi(12996205,65,0),
     _p_=runtime.caml_int64_create_lo_mi_hi(24691,0,0),
     _q_=runtime.caml_int64_create_lo_mi_hi(12184421,238,0),
     _r_=runtime.caml_int64_create_lo_mi_hi(3498401,10,0),
     _s_=runtime.caml_int64_create_lo_mi_hi(0,256,0),
     _t_=runtime.caml_int64_create_lo_mi_hi(12141755,833,0),
     _v_=runtime.caml_int64_create_lo_mi_hi(16777215,255,0),
     _z_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Please enter your seed (use 0x prefix if hexadecimal): "),
        [17,2,0]],
       caml_string_of_jsbytes
        ("Please enter your seed (use 0x prefix if hexadecimal): @?")],
     _A_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Do you want to obtain this seed using the freeze PRNG ACE code ?"),
        [17,4,0]],
       caml_string_of_jsbytes
        ("Do you want to obtain this seed using the freeze PRNG ACE code ?@.")],
     _B_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("1. Yes, for method H1 (wild pokemon) using sweet scent."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("1. Yes, for method H1 (wild pokemon) using sweet scent.@.")],
     _C_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("2. Yes, for mass outbreaks (method H1, using sweet scent)."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("2. Yes, for mass outbreaks (method H1, using sweet scent).@.")],
     _D_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("3. Yes, for method H1 (wild pokemon) using a rod."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("3. Yes, for method H1 (wild pokemon) using a rod.@.")],
     _E_=
      [0,
       [11,
        caml_string_of_jsbytes("4. Yes, for method 1 (stationnary pokemon)."),
        [17,4,0]],
       caml_string_of_jsbytes("4. Yes, for method 1 (stationnary pokemon).@.")],
     _F_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("5. No, but please show me the seeds in the vicinity."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("5. No, but please show me the seeds in the vicinity.@.")],
     _G_=
      [0,
       [11,caml_string_of_jsbytes("6. No (quit)."),[17,4,0]],
       caml_string_of_jsbytes("6. No (quit).@.")],
     _H_=
      [0,
       [11,caml_string_of_jsbytes("Cycle from seed 0: "),[5,12,0,0,[17,4,0]]],
       caml_string_of_jsbytes("Cycle from seed 0: %lu@.")],
     _I_=
      [0,
       [4,
        3,
        0,
        0,
        [11,
         caml_string_of_jsbytes(": "),
         [5,
          12,
          0,
          0,
          [11,caml_string_of_jsbytes(" ("),[5,7,0,0,[12,41,[17,4,0]]]]]]],
       caml_string_of_jsbytes("%i: %lu (%#lx)@.")],
     _J_=
      [0,
       [11,
        caml_string_of_jsbytes("Please enter the range (example: -25 5):"),
        [17,4,0]],
       caml_string_of_jsbytes("Please enter the range (example: -25 5):@.")],
     _K_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("For most legendaries, you should use the seed at cycle -3."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("For most legendaries, you should use the seed at cycle -3.@.")],
     _L_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Please refer to the instructions on the freeze PRNG ACE code for other stationnary pokemons."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("Please refer to the instructions on the freeze PRNG ACE code for other stationnary pokemons.@.")],
     _M_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("You should start the battle as soon as you can"),
        0],
       caml_string_of_jsbytes
        ("You should start the battle as soon as you can")],
     _N_=
      [0,
       [11,
        caml_string_of_jsbytes
         (" (just after having executed the ACE and closed the menu)."),
        [17,4,0]],
       caml_string_of_jsbytes
        (" (just after having executed the ACE and closed the menu).@.")],
     _O_=
      [0,
       [11,
        caml_string_of_jsbytes("Please select your configuration:"),
        [17,4,0]],
       caml_string_of_jsbytes("Please select your configuration:@.")],
     _P_=
      [0,
       [11,
        caml_string_of_jsbytes("1. I will not be fishing on route 119."),
        [17,4,0]],
       caml_string_of_jsbytes("1. I will not be fishing on route 119.@.")],
     _Q_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("2. I will be fishing on route 119, but not for a feebas."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("2. I will be fishing on route 119, but not for a feebas.@.")],
     _R_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("3. I will be fishing for feebas on a feebas tile."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("3. I will be fishing for feebas on a feebas tile.@.")],
     _S_=
      [0,
       [11,
        caml_string_of_jsbytes("You should use the seed "),
        [5,
         7,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" (1 cycle before your target)."),
          [17,4,0]]]],
       caml_string_of_jsbytes
        ("You should use the seed %#lx (1 cycle before your target).@.")],
     _T_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("You should use sweet scent directly after triggering the ACE,"),
        0],
       caml_string_of_jsbytes
        ("You should use sweet scent directly after triggering the ACE,")],
     _U_=
      [0,
       [11,
        caml_string_of_jsbytes(" without closing the pokemon menu."),
        [17,4,0]],
       caml_string_of_jsbytes(" without closing the pokemon menu.@.")],
     _V_=
      [0,
       [11,
        caml_string_of_jsbytes("You should use the seed "),
        [5,
         7,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" (2 cycles before your target)."),
          [17,4,0]]]],
       caml_string_of_jsbytes
        ("You should use the seed %#lx (2 cycles before your target).@.")],
     _W_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("You should use sweet scent directly after triggering the ACE,"),
        0],
       caml_string_of_jsbytes
        ("You should use sweet scent directly after triggering the ACE,")],
     _X_=
      [0,
       [11,
        caml_string_of_jsbytes(" without closing the pokemon menu."),
        [17,4,0]],
       caml_string_of_jsbytes(" without closing the pokemon menu.@.")],
     _Y_=
      [0,
       [12,32,[4,3,0,0,[12,32,[4,3,0,0,0]]]],
       caml_string_of_jsbytes(" %i %i")],
     _ag_=[0,caml_string_of_jsbytes("Main/seed_tools_common.ml"),82,13],
     _aa_=[0,[2,0,[12,58,[17,4,0]]],caml_string_of_jsbytes("%s:@.")],
     _ab_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("\tWith lead: Must have Suction Cup or Sticky Hold lead"),
        [17,4,0]],
       caml_string_of_jsbytes
        ("\tWith lead: Must have Suction Cup or Sticky Hold lead@.")],
     _ac_=
      [0,
       [11,
        caml_string_of_jsbytes("\tUse seed "),
        [5,
         7,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" to generate target on advancement "),
          [4,3,0,0,[17,4,0]]]]],
       caml_string_of_jsbytes
        ("\tUse seed %#lx to generate target on advancement %i@.")],
     _ad_=
      [0,
       [11,caml_string_of_jsbytes("\tWith lead: No lead necessary"),[17,4,0]],
       caml_string_of_jsbytes("\tWith lead: No lead necessary@.")],
     _ae_=
      [0,
       [11,
        caml_string_of_jsbytes("\tUse seed "),
        [5,
         7,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" to generate target on advancement "),
          [4,3,0,0,[17,4,0]]]]],
       caml_string_of_jsbytes
        ("\tUse seed %#lx to generate target on advancement %i@.")],
     _af_=
      [0,
       [11,caml_string_of_jsbytes("\tNo matches found"),[17,4,0]],
       caml_string_of_jsbytes("\tNo matches found@.")],
     _Z_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("You should use the rod directly after triggering the ACE"),
        0],
       caml_string_of_jsbytes
        ("You should use the rod directly after triggering the ACE")],
     ___=
      [0,
       [11,
        caml_string_of_jsbytes(" (leave the pokemon menu and enter the bag)."),
        [17,4,0]],
       caml_string_of_jsbytes
        (" (leave the pokemon menu and enter the bag).@.")],
     _$_=
      [0,
       [11,caml_string_of_jsbytes("Thanks to Shao for this script."),[17,4,0]],
       caml_string_of_jsbytes("Thanks to Shao for this script.@.")],
     _ah_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(" = "),
         [5,
          3,
          0,
          0,
          [11,caml_string_of_jsbytes(" ("),[5,7,0,0,[12,41,[17,4,0]]]]]]],
       caml_string_of_jsbytes("%s = %li (%#lx)@.")],
     _ai_=[0,[17,4,0],caml_string_of_jsbytes("@.")],
     _aj_=
      [0,
       [11,caml_string_of_jsbytes("Please enter low-PID: "),[17,2,0]],
       caml_string_of_jsbytes("Please enter low-PID: @?")],
     _ak_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _al_=
      [0,
       [11,caml_string_of_jsbytes("Please enter high-PID: "),[17,2,0]],
       caml_string_of_jsbytes("Please enter high-PID: @?")],
     _am_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _an_=
      [0,
       [11,
        caml_string_of_jsbytes("Please enter original trainer visible TID: "),
        [17,2,0]],
       caml_string_of_jsbytes("Please enter original trainer visible TID: @?")],
     _ao_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _ap_=
      [0,
       [11,
        caml_string_of_jsbytes("Please enter original trainer secret TID: "),
        [17,2,0]],
       caml_string_of_jsbytes("Please enter original trainer secret TID: @?")],
     _aq_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _ar_=
      [0,
       [11,
        caml_string_of_jsbytes("Misc substructure position: "),
        [4,0,0,0,[17,4,0]]],
       caml_string_of_jsbytes("Misc substructure position: %d@.")],
     _as_=
      [0,
       [11,caml_string_of_jsbytes("IVEA offset: "),[4,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("IVEA offset: %#x@.")],
     _at_=
      [0,
       [11,caml_string_of_jsbytes("Please enter low-IVEA: "),[17,2,0]],
       caml_string_of_jsbytes("Please enter low-IVEA: @?")],
     _au_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _av_=
      [0,
       [11,caml_string_of_jsbytes("Please enter high-IVEA: "),[17,2,0]],
       caml_string_of_jsbytes("Please enter high-IVEA: @?")],
     _aw_=[0,[12,32,[5,3,0,0,0]],caml_string_of_jsbytes(" %li")],
     _ax_=
      [0,
       [11,
        caml_string_of_jsbytes("Unencrypted IVEA data: "),
        [5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("Unencrypted IVEA data: %#lx@.")],
     _ay_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Pokemon IVs (hp atk def speed sp_atk sp_def): "),
        [5,
         0,
         0,
         0,
         [12,
          32,
          [5,
           0,
           0,
           0,
           [12,32,[5,0,0,0,[12,32,[5,0,0,0,[12,32,[5,0,0,0,partial]]]]]]]]]],
       caml_string_of_jsbytes
        ("Pokemon IVs (hp atk def speed sp_atk sp_def): %ld %ld %ld %ld %ld %ld@.")],
     _az_=
      [0,
       [11,caml_string_of_jsbytes("Maxing IVs..."),[17,4,0]],
       caml_string_of_jsbytes("Maxing IVs...@.")],
     _aA_=
      [0,
       [11,
        caml_string_of_jsbytes("New unencrypted IVEA data: "),
        [5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("New unencrypted IVEA data: %#lx@.")],
     _aB_=
      [0,
       [11,caml_string_of_jsbytes("New low-IVEA: "),[5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("New low-IVEA: %#lx@.")],
     _aC_=
      [0,
       [11,caml_string_of_jsbytes("New high-IVEA: "),[5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("New high-IVEA: %#lx@.")],
     _aD_=
      [0,
       [11,caml_string_of_jsbytes("Checksum diff: "),[5,7,0,0,[17,4,0]]],
       caml_string_of_jsbytes("Checksum diff: %#lx@.")],
     _aE_=[0,1,0],
     _aF_=[0,1,1],
     _aG_=[0,0,0],
     _aH_=
      [0,
       [2,caml_string_of_jsbytes("_")],
       [1,caml_string_of_jsbytes("\xc3\x80")],
       [1,caml_string_of_jsbytes("\xc3\x81")],
       [1,caml_string_of_jsbytes("\xc3\x82")],
       [1,caml_string_of_jsbytes("\xc3\x87")],
       [1,caml_string_of_jsbytes("\xc3\x88")],
       [1,caml_string_of_jsbytes("\xc3\x89")],
       [1,caml_string_of_jsbytes("\xc3\x8a")],
       [1,caml_string_of_jsbytes("\xc3\x8b")],
       [1,caml_string_of_jsbytes("\xc3\x8c")],
       0,
       [1,caml_string_of_jsbytes("\xc3\x8e")],
       [1,caml_string_of_jsbytes("\xc3\x8f")],
       [1,caml_string_of_jsbytes("\xc3\x92")],
       [1,caml_string_of_jsbytes("\xc3\x93")],
       [1,caml_string_of_jsbytes("\xc3\x94")],
       [1,caml_string_of_jsbytes("\xc5\x92")],
       [1,caml_string_of_jsbytes("\xc3\x99")],
       [1,caml_string_of_jsbytes("\xc3\x9a")],
       [1,caml_string_of_jsbytes("\xc3\x9b")],
       [1,caml_string_of_jsbytes("\xc3\x91")],
       [1,caml_string_of_jsbytes("\xc3\x9f")],
       [1,caml_string_of_jsbytes("\xc3\xa0")],
       [1,caml_string_of_jsbytes("\xc3\xa1")],
       0,
       [1,caml_string_of_jsbytes("\xc3\xa7")],
       [1,caml_string_of_jsbytes("\xc3\xa8")],
       [1,caml_string_of_jsbytes("\xc3\xa9")],
       [1,caml_string_of_jsbytes("\xc3\xaa")],
       [1,caml_string_of_jsbytes("\xc3\xab")],
       [1,caml_string_of_jsbytes("\xc3\xac")],
       0,
       [1,caml_string_of_jsbytes("\xc3\xae")],
       [1,caml_string_of_jsbytes("\xc3\xaf")],
       [1,caml_string_of_jsbytes("\xc3\xb2")],
       [1,caml_string_of_jsbytes("\xc3\xb3")],
       [1,caml_string_of_jsbytes("\xc3\xb4")],
       [1,caml_string_of_jsbytes("\xc5\x93")],
       [1,caml_string_of_jsbytes("\xc3\xb9")],
       [1,caml_string_of_jsbytes("\xc3\xba")],
       [1,caml_string_of_jsbytes("\xc3\xbb")],
       [1,caml_string_of_jsbytes("\xc3\xb1")],
       [1,caml_string_of_jsbytes("\xc2\xba")],
       [1,caml_string_of_jsbytes("\xc2\xaa")],
       [1,caml_string_of_jsbytes("\xe1\xb5\x89\xca\xb3")],
       [1,caml_string_of_jsbytes("&")],
       [1,caml_string_of_jsbytes("+")],
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("Lv")],
       [1,caml_string_of_jsbytes("=")],
       [1,caml_string_of_jsbytes(";")],
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xe2\x96\xaf")],
       [1,caml_string_of_jsbytes("\xc2\xbf")],
       [1,caml_string_of_jsbytes("\xc2\xa1")],
       [1,caml_string_of_jsbytes("PK")],
       [1,caml_string_of_jsbytes("MN")],
       [1,caml_string_of_jsbytes("PO")],
       [1,caml_string_of_jsbytes("K\xc3\xa9")],
       [0,caml_string_of_jsbytes("0x57")],
       [0,caml_string_of_jsbytes("0x58")],
       [0,caml_string_of_jsbytes("0x59")],
       [1,caml_string_of_jsbytes("\xc3\x8d")],
       [1,caml_string_of_jsbytes("%")],
       [1,caml_string_of_jsbytes("(")],
       [1,caml_string_of_jsbytes(")")],
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xc3\xa2")],
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xc3\xad")],
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xe2\xac\x86")],
       [1,caml_string_of_jsbytes("\xe2\xac\x87")],
       [1,caml_string_of_jsbytes("\xe2\xac\x85")],
       [1,caml_string_of_jsbytes("\xe2\x9e\xa1")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("*")],
       [1,caml_string_of_jsbytes("\xe1\xb5\x89")],
       [1,caml_string_of_jsbytes("<")],
       [1,caml_string_of_jsbytes(">")],
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       [1,caml_string_of_jsbytes("\xca\xb3\xe1\xb5\x89")],
       [2,caml_string_of_jsbytes("0")],
       [2,caml_string_of_jsbytes("1")],
       [2,caml_string_of_jsbytes("2")],
       [2,caml_string_of_jsbytes("3")],
       [2,caml_string_of_jsbytes("4")],
       [2,caml_string_of_jsbytes("5")],
       [2,caml_string_of_jsbytes("6")],
       [2,caml_string_of_jsbytes("7")],
       [2,caml_string_of_jsbytes("8")],
       [2,caml_string_of_jsbytes("9")],
       [2,caml_string_of_jsbytes("!")],
       [2,caml_string_of_jsbytes("?")],
       [2,caml_string_of_jsbytes(".")],
       [2,caml_string_of_jsbytes("\xe2\x80\x93")],
       [1,caml_string_of_jsbytes("\xe3\x83\xbb")],
       [2,caml_string_of_jsbytes("\xe2\x80\xa6")],
       [2,caml_string_of_jsbytes("\xe2\x80\x9c")],
       [2,caml_string_of_jsbytes("\xe2\x80\x9d")],
       [2,caml_string_of_jsbytes("\xe2\x80\x98")],
       [2,caml_string_of_jsbytes("\xe2\x80\x99")],
       [2,caml_string_of_jsbytes("\xe2\x99\x82")],
       [2,caml_string_of_jsbytes("\xe2\x99\x80")],
       [1,caml_string_of_jsbytes("Pk$")],
       [2,caml_string_of_jsbytes(",")],
       [1,caml_string_of_jsbytes("\xc3\x97")],
       [2,caml_string_of_jsbytes("/")],
       [2,caml_string_of_jsbytes("A")],
       [2,caml_string_of_jsbytes("B")],
       [2,caml_string_of_jsbytes("C")],
       [2,caml_string_of_jsbytes("D")],
       [2,caml_string_of_jsbytes("E")],
       [2,caml_string_of_jsbytes("F")],
       [2,caml_string_of_jsbytes("G")],
       [2,caml_string_of_jsbytes("H")],
       [2,caml_string_of_jsbytes("I")],
       [2,caml_string_of_jsbytes("J")],
       [2,caml_string_of_jsbytes("K")],
       [2,caml_string_of_jsbytes("L")],
       [2,caml_string_of_jsbytes("M")],
       [2,caml_string_of_jsbytes("N")],
       [2,caml_string_of_jsbytes("O")],
       [2,caml_string_of_jsbytes("P")],
       [2,caml_string_of_jsbytes("Q")],
       [2,caml_string_of_jsbytes("R")],
       [2,caml_string_of_jsbytes("S")],
       [2,caml_string_of_jsbytes("T")],
       [2,caml_string_of_jsbytes("U")],
       [2,caml_string_of_jsbytes("V")],
       [2,caml_string_of_jsbytes("W")],
       [2,caml_string_of_jsbytes("X")],
       [2,caml_string_of_jsbytes("Y")],
       [2,caml_string_of_jsbytes("Z")],
       [2,caml_string_of_jsbytes("a")],
       [2,caml_string_of_jsbytes("b")],
       [2,caml_string_of_jsbytes("c")],
       [2,caml_string_of_jsbytes("d")],
       [2,caml_string_of_jsbytes("e")],
       [2,caml_string_of_jsbytes("f")],
       [2,caml_string_of_jsbytes("g")],
       [2,caml_string_of_jsbytes("h")],
       [2,caml_string_of_jsbytes("i")],
       [2,caml_string_of_jsbytes("j")],
       [2,caml_string_of_jsbytes("k")],
       [2,caml_string_of_jsbytes("l")],
       [2,caml_string_of_jsbytes("m")],
       [2,caml_string_of_jsbytes("n")],
       [2,caml_string_of_jsbytes("o")],
       [2,caml_string_of_jsbytes("p")],
       [2,caml_string_of_jsbytes("q")],
       [2,caml_string_of_jsbytes("r")],
       [2,caml_string_of_jsbytes("s")],
       [2,caml_string_of_jsbytes("t")],
       [2,caml_string_of_jsbytes("u")],
       [2,caml_string_of_jsbytes("v")],
       [2,caml_string_of_jsbytes("w")],
       [2,caml_string_of_jsbytes("x")],
       [2,caml_string_of_jsbytes("y")],
       [2,caml_string_of_jsbytes("z")],
       [1,caml_string_of_jsbytes("\xe2\x96\xb6")],
       [1,caml_string_of_jsbytes(":")],
       [1,caml_string_of_jsbytes("\xc3\x84")],
       [1,caml_string_of_jsbytes("\xc3\x96")],
       [1,caml_string_of_jsbytes("\xc3\x9c")],
       [1,caml_string_of_jsbytes("\xc3\xa4")],
       [1,caml_string_of_jsbytes("\xc3\xb6")],
       [1,caml_string_of_jsbytes("\xc3\xbc")],
       0,
       0,
       0,
       [0,caml_string_of_jsbytes("0xFA")],
       [0,caml_string_of_jsbytes("0xFB")],
       [0,caml_string_of_jsbytes("0xFC")],
       [0,caml_string_of_jsbytes("0xFD")],
       [0,caml_string_of_jsbytes("0xFE")],
       [0,caml_string_of_jsbytes("0xFF")]],
     _aI_=[2,caml_string_of_jsbytes("\xe2\x80\x9e")],
     _aJ_=[2,caml_string_of_jsbytes("\xe2\x80\x9c")],
     _d1_=[0,caml_string_of_jsbytes("Boxes/charset.ml"),98,13],
     _aK_=[2,caml_string_of_jsbytes("\xc2\xab")],
     _aL_=[2,caml_string_of_jsbytes("\xc2\xbb")],
     _aM_=
      [0,
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("\xe3\x81\x82")],
       [2,caml_string_of_jsbytes("\xe3\x81\x84")],
       [2,caml_string_of_jsbytes("\xe3\x81\x86")],
       [2,caml_string_of_jsbytes("\xe3\x81\x88")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8a")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8b")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8d")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8f")],
       [2,caml_string_of_jsbytes("\xe3\x81\x91")],
       [2,caml_string_of_jsbytes("\xe3\x81\x93")],
       [2,caml_string_of_jsbytes("\xe3\x81\x95")],
       [2,caml_string_of_jsbytes("\xe3\x81\x97")],
       [2,caml_string_of_jsbytes("\xe3\x81\x99")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9b")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9d")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9f")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa1")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa4")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa6")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa8")],
       [2,caml_string_of_jsbytes("\xe3\x81\xaa")],
       [2,caml_string_of_jsbytes("\xe3\x81\xab")],
       [2,caml_string_of_jsbytes("\xe3\x81\xac")],
       [2,caml_string_of_jsbytes("\xe3\x81\xad")],
       [2,caml_string_of_jsbytes("\xe3\x81\xae")],
       [2,caml_string_of_jsbytes("\xe3\x81\xaf")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb2")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb5")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb8")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbb")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbe")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbf")],
       [2,caml_string_of_jsbytes("\xe3\x82\x80")],
       [2,caml_string_of_jsbytes("\xe3\x82\x81")],
       [2,caml_string_of_jsbytes("\xe3\x82\x82")],
       [2,caml_string_of_jsbytes("\xe3\x82\x84")],
       [2,caml_string_of_jsbytes("\xe3\x82\x86")],
       [2,caml_string_of_jsbytes("\xe3\x82\x88")],
       [2,caml_string_of_jsbytes("\xe3\x82\x89")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8a")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8b")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8c")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8d")],
       [2,caml_string_of_jsbytes("\xe3\x82\x8f")],
       [2,caml_string_of_jsbytes("\xe3\x82\x92")],
       [2,caml_string_of_jsbytes("\xe3\x82\x93")],
       [2,caml_string_of_jsbytes("\xe3\x81\x81")],
       [2,caml_string_of_jsbytes("\xe3\x81\x83")],
       [2,caml_string_of_jsbytes("\xe3\x81\x85")],
       [2,caml_string_of_jsbytes("\xe3\x81\x87")],
       [2,caml_string_of_jsbytes("\xe3\x81\x89")],
       [2,caml_string_of_jsbytes("\xe3\x82\x83")],
       [2,caml_string_of_jsbytes("\xe3\x82\x85")],
       [2,caml_string_of_jsbytes("\xe3\x82\x87")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8c")],
       [2,caml_string_of_jsbytes("\xe3\x81\x8e")],
       [2,caml_string_of_jsbytes("\xe3\x81\x90")],
       [2,caml_string_of_jsbytes("\xe3\x81\x92")],
       [2,caml_string_of_jsbytes("\xe3\x81\x94")],
       [2,caml_string_of_jsbytes("\xe3\x81\x96")],
       [2,caml_string_of_jsbytes("\xe3\x81\x98")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9a")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9c")],
       [2,caml_string_of_jsbytes("\xe3\x81\x9e")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa0")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa2")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa5")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa7")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa9")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb0")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb3")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb6")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb9")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbc")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb1")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb4")],
       [2,caml_string_of_jsbytes("\xe3\x81\xb7")],
       [2,caml_string_of_jsbytes("\xe3\x81\xba")],
       [2,caml_string_of_jsbytes("\xe3\x81\xbd")],
       [2,caml_string_of_jsbytes("\xe3\x81\xa3")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa2")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa4")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa6")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa8")],
       [2,caml_string_of_jsbytes("\xe3\x82\xaa")],
       [2,caml_string_of_jsbytes("\xe3\x82\xab")],
       [2,caml_string_of_jsbytes("\xe3\x82\xad")],
       [2,caml_string_of_jsbytes("\xe3\x82\xaf")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb1")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb3")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb5")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb7")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb9")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbb")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbd")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbf")],
       [2,caml_string_of_jsbytes("\xe3\x83\x81")],
       [2,caml_string_of_jsbytes("\xe3\x83\x84")],
       [2,caml_string_of_jsbytes("\xe3\x83\x86")],
       [2,caml_string_of_jsbytes("\xe3\x83\x88")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8a")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8b")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8c")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8d")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8e")],
       [2,caml_string_of_jsbytes("\xe3\x83\x8f")],
       [2,caml_string_of_jsbytes("\xe3\x83\x92")],
       [2,caml_string_of_jsbytes("\xe3\x83\x95")],
       [2,caml_string_of_jsbytes("\xe3\x83\x98")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9b")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9e")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9f")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa0")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa1")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa2")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa4")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa6")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa8")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa9")],
       [2,caml_string_of_jsbytes("\xe3\x83\xaa")],
       [2,caml_string_of_jsbytes("\xe3\x83\xab")],
       [2,caml_string_of_jsbytes("\xe3\x83\xac")],
       [2,caml_string_of_jsbytes("\xe3\x83\xad")],
       [2,caml_string_of_jsbytes("\xe3\x83\xaf")],
       [2,caml_string_of_jsbytes("\xe3\x83\xb2")],
       [2,caml_string_of_jsbytes("\xe3\x83\xb3")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa1")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa3")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa5")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa7")],
       [2,caml_string_of_jsbytes("\xe3\x82\xa9")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa3")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa5")],
       [2,caml_string_of_jsbytes("\xe3\x83\xa7")],
       [2,caml_string_of_jsbytes("\xe3\x82\xac")],
       [2,caml_string_of_jsbytes("\xe3\x82\xae")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb0")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb2")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb4")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb6")],
       [2,caml_string_of_jsbytes("\xe3\x82\xb8")],
       [2,caml_string_of_jsbytes("\xe3\x82\xba")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbc")],
       [2,caml_string_of_jsbytes("\xe3\x82\xbe")],
       [2,caml_string_of_jsbytes("\xe3\x83\x80")],
       [2,caml_string_of_jsbytes("\xe3\x83\x82")],
       [2,caml_string_of_jsbytes("\xe3\x83\x85")],
       [2,caml_string_of_jsbytes("\xe3\x83\x87")],
       [2,caml_string_of_jsbytes("\xe3\x83\x89")],
       [2,caml_string_of_jsbytes("\xe3\x83\x90")],
       [2,caml_string_of_jsbytes("\xe3\x83\x93")],
       [2,caml_string_of_jsbytes("\xe3\x83\x96")],
       [2,caml_string_of_jsbytes("\xe3\x83\x99")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9c")],
       [2,caml_string_of_jsbytes("\xe3\x83\x91")],
       [2,caml_string_of_jsbytes("\xe3\x83\x94")],
       [2,caml_string_of_jsbytes("\xe3\x83\x97")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9a")],
       [2,caml_string_of_jsbytes("\xe3\x83\x9d")],
       [2,caml_string_of_jsbytes("\xe3\x83\x83")],
       [2,caml_string_of_jsbytes("0")],
       [2,caml_string_of_jsbytes("1")],
       [2,caml_string_of_jsbytes("2")],
       [2,caml_string_of_jsbytes("3")],
       [2,caml_string_of_jsbytes("4")],
       [2,caml_string_of_jsbytes("5")],
       [2,caml_string_of_jsbytes("6")],
       [2,caml_string_of_jsbytes("7")],
       [2,caml_string_of_jsbytes("8")],
       [2,caml_string_of_jsbytes("9")],
       [2,caml_string_of_jsbytes("\xef\xbc\x81")],
       [2,caml_string_of_jsbytes("\xef\xbc\x9f")],
       [2,caml_string_of_jsbytes("\xe3\x80\x82")],
       [2,caml_string_of_jsbytes("\xe3\x83\xbc")],
       [2,caml_string_of_jsbytes("\xe3\x83\xbb")],
       [2,caml_string_of_jsbytes("\xe2\x80\xa5")],
       [2,caml_string_of_jsbytes("\xe3\x80\x8e")],
       [2,caml_string_of_jsbytes("\xe3\x80\x8f")],
       [2,caml_string_of_jsbytes("\xe3\x80\x8c")],
       [2,caml_string_of_jsbytes("\xe3\x80\x8d")],
       [2,caml_string_of_jsbytes("\xe2\x99\x82")],
       [2,caml_string_of_jsbytes("\xe2\x99\x80")],
       [1,caml_string_of_jsbytes("\xe5\x86\x86")],
       [1,caml_string_of_jsbytes(".")],
       [1,caml_string_of_jsbytes("\xc3\x97")],
       [2,caml_string_of_jsbytes("/")],
       [2,caml_string_of_jsbytes("A")],
       [2,caml_string_of_jsbytes("B")],
       [2,caml_string_of_jsbytes("C")],
       [2,caml_string_of_jsbytes("D")],
       [2,caml_string_of_jsbytes("E")],
       [2,caml_string_of_jsbytes("F")],
       [2,caml_string_of_jsbytes("G")],
       [2,caml_string_of_jsbytes("H")],
       [2,caml_string_of_jsbytes("I")],
       [2,caml_string_of_jsbytes("J")],
       [2,caml_string_of_jsbytes("K")],
       [2,caml_string_of_jsbytes("L")],
       [2,caml_string_of_jsbytes("M")],
       [2,caml_string_of_jsbytes("N")],
       [2,caml_string_of_jsbytes("O")],
       [2,caml_string_of_jsbytes("P")],
       [2,caml_string_of_jsbytes("Q")],
       [2,caml_string_of_jsbytes("R")],
       [2,caml_string_of_jsbytes("S")],
       [2,caml_string_of_jsbytes("T")],
       [2,caml_string_of_jsbytes("U")],
       [2,caml_string_of_jsbytes("V")],
       [2,caml_string_of_jsbytes("W")],
       [2,caml_string_of_jsbytes("X")],
       [2,caml_string_of_jsbytes("Y")],
       [2,caml_string_of_jsbytes("Z")],
       [2,caml_string_of_jsbytes("a")],
       [2,caml_string_of_jsbytes("b")],
       [2,caml_string_of_jsbytes("c")],
       [2,caml_string_of_jsbytes("d")],
       [2,caml_string_of_jsbytes("e")],
       [2,caml_string_of_jsbytes("f")],
       [2,caml_string_of_jsbytes("g")],
       [2,caml_string_of_jsbytes("h")],
       [2,caml_string_of_jsbytes("i")],
       [2,caml_string_of_jsbytes("j")],
       [2,caml_string_of_jsbytes("k")],
       [2,caml_string_of_jsbytes("l")],
       [2,caml_string_of_jsbytes("m")],
       [2,caml_string_of_jsbytes("n")],
       [2,caml_string_of_jsbytes("o")],
       [2,caml_string_of_jsbytes("p")],
       [2,caml_string_of_jsbytes("q")],
       [2,caml_string_of_jsbytes("r")],
       [2,caml_string_of_jsbytes("s")],
       [2,caml_string_of_jsbytes("t")],
       [2,caml_string_of_jsbytes("u")],
       [2,caml_string_of_jsbytes("v")],
       [2,caml_string_of_jsbytes("w")],
       [2,caml_string_of_jsbytes("x")],
       [2,caml_string_of_jsbytes("y")],
       [2,caml_string_of_jsbytes("z")],
       [1,caml_string_of_jsbytes("\xe2\x96\xb6")],
       [1,caml_string_of_jsbytes(":")],
       [1,caml_string_of_jsbytes("\xc3\x84")],
       [1,caml_string_of_jsbytes("\xc3\x96")],
       [1,caml_string_of_jsbytes("\xc3\x9c")],
       [1,caml_string_of_jsbytes("\xc3\xa4")],
       [1,caml_string_of_jsbytes("\xc3\xb6")],
       [1,caml_string_of_jsbytes("\xc3\xbc")],
       0,
       0,
       0,
       [0,caml_string_of_jsbytes("0xFA")],
       [0,caml_string_of_jsbytes("0xFB")],
       [0,caml_string_of_jsbytes("0xFC")],
       [0,caml_string_of_jsbytes("0xFD")],
       [0,caml_string_of_jsbytes("0xFE")],
       [0,caml_string_of_jsbytes("0xFF")]],
     _aN_=
      [0,
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("0")],
       [2,caml_string_of_jsbytes("1")],
       [2,caml_string_of_jsbytes("2")],
       [2,caml_string_of_jsbytes("3")],
       [2,caml_string_of_jsbytes("4")],
       [2,caml_string_of_jsbytes("5")],
       [2,caml_string_of_jsbytes("6")],
       [2,caml_string_of_jsbytes("7")],
       [2,caml_string_of_jsbytes("8")],
       [2,caml_string_of_jsbytes("9")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("A")],
       [2,caml_string_of_jsbytes("B")],
       [2,caml_string_of_jsbytes("C")],
       [2,caml_string_of_jsbytes("D")],
       [2,caml_string_of_jsbytes("E")],
       [2,caml_string_of_jsbytes("F")],
       [2,caml_string_of_jsbytes("G")],
       [2,caml_string_of_jsbytes("H")],
       [2,caml_string_of_jsbytes("I")],
       [2,caml_string_of_jsbytes("J")],
       [2,caml_string_of_jsbytes("K")],
       [2,caml_string_of_jsbytes("L")],
       [2,caml_string_of_jsbytes("M")],
       [2,caml_string_of_jsbytes("N")],
       [2,caml_string_of_jsbytes("O")],
       [2,caml_string_of_jsbytes("P")],
       [2,caml_string_of_jsbytes("Q")],
       [2,caml_string_of_jsbytes("R")],
       [2,caml_string_of_jsbytes("S")],
       [2,caml_string_of_jsbytes("T")],
       [2,caml_string_of_jsbytes("U")],
       [2,caml_string_of_jsbytes("V")],
       [2,caml_string_of_jsbytes("W")],
       [2,caml_string_of_jsbytes("X")],
       [2,caml_string_of_jsbytes("Y")],
       [2,caml_string_of_jsbytes("Z")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")],
       [2,caml_string_of_jsbytes("_")]],
     _aQ_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _aP_=[0,[2,0,[2,0,0]],caml_string_of_jsbytes("%s%s")],
     _aO_=[0,caml_string_of_jsbytes("Boxes/name.ml"),34,9],
     _a2_=[0,caml_string_of_jsbytes("ARM/optimizer.ml"),199,2],
     _a1_=[0,caml_string_of_jsbytes("ARM/optimizer.ml"),228,11],
     _a0_=[0,caml_string_of_jsbytes("ARM/optimizer.ml"),195,11],
     _aZ_=[0,65536,65536,65536,512,64,8,1],
     _bs_=[0,0,0,0,0,1],
     _bt_=[0,0,0,1,0,0],
     _bu_=[0,0,0,0,1,0],
     _bp_=[0,caml_string_of_jsbytes("X")],
     _bq_=[0,caml_string_of_jsbytes("S")],
     _br_=[0,caml_string_of_jsbytes("L")],
     _bm_=[0,3],
     _bn_=[0,1],
     _bo_=[0,6],
     _bi_=[0,4],
     _bj_=[0,5],
     _bk_=[0,2],
     _bl_=[0,0],
     _ba_=[0,3],
     _bb_=[0,10],
     _bc_=[0,14],
     _bd_=[0,12],
     _be_=[0,0],
     _bf_=[0,2],
     _bg_=[0,4],
     _bh_=[0,16],
     _a3_=[0,8],
     _a4_=[0,9],
     _a5_=[0,7],
     _a6_=[0,1],
     _a7_=[0,6],
     _a8_=[0,13],
     _a9_=[0,11],
     _a__=[0,5],
     _a$_=[0,15],
     _bv_=[0,caml_string_of_jsbytes("IO/parser.ml"),143,8],
     _bw_=[0,caml_string_of_jsbytes("IO/parser.ml"),167,8],
     _bx_=[0,caml_string_of_jsbytes("IO/parser.ml"),191,8],
     _by_=[0,caml_string_of_jsbytes("IO/parser.ml"),215,8],
     _bz_=[0,caml_string_of_jsbytes("IO/parser.ml"),239,8],
     _bA_=[0,caml_string_of_jsbytes("IO/parser.ml"),263,8],
     _bB_=[0,caml_string_of_jsbytes("IO/parser.ml"),287,8],
     _bC_=[0,caml_string_of_jsbytes("IO/parser.ml"),311,8],
     _bD_=[0,caml_string_of_jsbytes("IO/parser.ml"),335,8],
     _bE_=[0,caml_string_of_jsbytes("IO/parser.ml"),359,8],
     _bF_=[0,caml_string_of_jsbytes("IO/parser.ml"),383,8],
     _bG_=[0,caml_string_of_jsbytes("IO/parser.ml"),407,8],
     _bH_=[0,caml_string_of_jsbytes("IO/parser.ml"),431,8],
     _bI_=[0,caml_string_of_jsbytes("IO/parser.ml"),455,8],
     _bJ_=[0,caml_string_of_jsbytes("IO/parser.ml"),479,8],
     _bK_=[0,caml_string_of_jsbytes("IO/parser.ml"),503,8],
     _bL_=[0,caml_string_of_jsbytes("IO/parser.ml"),540,16],
     _bM_=[0,caml_string_of_jsbytes("IO/parser.ml"),546,12],
     _bN_=[0,caml_string_of_jsbytes("IO/parser.ml"),1320,8],
     _bO_=[0,caml_string_of_jsbytes("IO/parser.ml"),1367,12],
     _bP_=[0,caml_string_of_jsbytes("IO/parser.ml"),1266,8],
     _bQ_=[0,caml_string_of_jsbytes("IO/parser.ml"),1313,12],
     _bR_=[0,caml_string_of_jsbytes("IO/parser.ml"),1139,8],
     _bS_=[0,caml_string_of_jsbytes("IO/parser.ml"),1176,12],
     _bT_=[0,caml_string_of_jsbytes("IO/parser.ml"),1093,8],
     _bU_=[0,caml_string_of_jsbytes("IO/parser.ml"),1132,12],
     _bV_=[0,caml_string_of_jsbytes("IO/parser.ml"),1043,8],
     _bW_=[0,caml_string_of_jsbytes("IO/parser.ml"),1086,12],
     _bX_=[0,caml_string_of_jsbytes("IO/parser.ml"),979,8],
     _bZ_=[0,caml_string_of_jsbytes("IO/parser.ml"),1008,16],
     _bY_=[0,caml_string_of_jsbytes("IO/parser.ml"),1036,12],
     _b0_=[0,caml_string_of_jsbytes("IO/parser.ml"),937,8],
     _b1_=[0,caml_string_of_jsbytes("IO/parser.ml"),972,12],
     _b2_=[0,caml_string_of_jsbytes("IO/parser.ml"),899,8],
     _b3_=[0,caml_string_of_jsbytes("IO/parser.ml"),930,12],
     _b4_=[0,caml_string_of_jsbytes("IO/parser.ml"),865,8],
     _b5_=[0,caml_string_of_jsbytes("IO/parser.ml"),892,12],
     _b6_=[0,caml_string_of_jsbytes("IO/parser.ml"),835,8],
     _b7_=[0,caml_string_of_jsbytes("IO/parser.ml"),858,12],
     _b8_=[0,caml_string_of_jsbytes("IO/parser.ml"),801,8],
     _b9_=[0,caml_string_of_jsbytes("IO/parser.ml"),828,12],
     _b__=[0,caml_string_of_jsbytes("IO/parser.ml"),775,8],
     _b$_=[0,caml_string_of_jsbytes("IO/parser.ml"),794,12],
     _ca_=[0,caml_string_of_jsbytes("IO/parser.ml"),729,8],
     _cb_=[0,caml_string_of_jsbytes("IO/parser.ml"),748,12],
     _cc_=[0,caml_string_of_jsbytes("IO/parser.ml"),699,8],
     _cd_=[0,caml_string_of_jsbytes("IO/parser.ml"),722,12],
     _ce_=[0,caml_string_of_jsbytes("IO/parser.ml"),649,8],
     _cf_=[0,caml_string_of_jsbytes("IO/parser.ml"),682,12],
     _cg_=[0,caml_string_of_jsbytes("IO/parser.ml"),597,8],
     _ch_=[0,caml_string_of_jsbytes("IO/parser.ml"),642,12],
     _ci_=[0,caml_string_of_jsbytes("IO/parser.ml"),1213,8],
     _cj_=[0,caml_string_of_jsbytes("IO/parser.ml"),1259,12],
     _ck_=[0,caml_string_of_jsbytes("IO/parser.ml"),1379,4],
     _cl_=[0,caml_string_of_jsbytes("IO/parser.ml"),1402,12],
     _cm_=[0,caml_string_of_jsbytes("IO/parser.ml"),1406,8],
     _cn_=[0,caml_string_of_jsbytes("IO/parser.ml"),1554,8],
     _co_=[0,caml_string_of_jsbytes("IO/parser.ml"),1588,8],
     _cq_=[0,caml_string_of_jsbytes("IO/parser.ml"),1650,12],
     _cr_=[0,caml_string_of_jsbytes("IO/parser.ml"),1633,12],
     _cp_=[0,caml_string_of_jsbytes("IO/parser.ml"),1654,8],
     _cs_=[0,caml_string_of_jsbytes("IO/parser.ml"),1662,4],
     _cu_=[0,caml_string_of_jsbytes("IO/parser.ml"),1681,12],
     _ct_=[0,caml_string_of_jsbytes("IO/parser.ml"),1694,8],
     _cv_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Internal failure -- please contact the parser generator's developers.\n"),
        [10,0]],
       caml_string_of_jsbytes
        ("Internal failure -- please contact the parser generator's developers.\n%!")],
     _cw_=[0,caml_string_of_jsbytes("IO/parser.ml"),1703,4],
     _cx_=[0,caml_string_of_jsbytes("IO/parser.ml"),1726,8],
     _cy_=[0,caml_string_of_jsbytes("IO/parser.ml"),1772,8],
     _cz_=[0,caml_string_of_jsbytes("IO/parser.ml"),1797,8],
     _cA_=[0,caml_string_of_jsbytes("IO/parser.ml"),1822,8],
     _cB_=[0,caml_string_of_jsbytes("IO/parser.ml"),1868,8],
     _cC_=[0,caml_string_of_jsbytes("IO/parser.ml"),1876,4],
     _cD_=[0,caml_string_of_jsbytes("IO/parser.ml"),1889,12],
     _cE_=[0,caml_string_of_jsbytes("IO/parser.ml"),1893,8],
     _cF_=[0,caml_string_of_jsbytes("IO/parser.ml"),1925,4],
     _cH_=[0,caml_string_of_jsbytes("IO/parser.ml"),1981,12],
     _cG_=[0,caml_string_of_jsbytes("IO/parser.ml"),2006,8],
     _cL_=[0,caml_string_of_jsbytes("IO/parser.ml"),2065,16],
     _cK_=[0,caml_string_of_jsbytes("IO/parser.ml"),2091,20],
     _cJ_=[0,caml_string_of_jsbytes("IO/parser.ml"),2123,16],
     _cM_=[0,caml_string_of_jsbytes("IO/parser.ml"),2129,12],
     _cI_=[0,caml_string_of_jsbytes("IO/parser.ml"),2135,8],
     _cN_=[0,caml_string_of_jsbytes("IO/parser.ml"),2162,8],
     _cO_=[0,caml_string_of_jsbytes("IO/parser.ml"),2198,8],
     _cP_=[0,caml_string_of_jsbytes("IO/parser.ml"),2241,8],
     _cR_=[0,caml_string_of_jsbytes("IO/parser.ml"),2283,16],
     _cQ_=[0,caml_string_of_jsbytes("IO/parser.ml"),2291,12],
     _cS_=[0,caml_string_of_jsbytes("IO/parser.ml"),2296,8],
     _cV_=[0,caml_string_of_jsbytes("IO/parser.ml"),2414,24],
     _cW_=[0,caml_string_of_jsbytes("IO/parser.ml"),2419,20],
     _cU_=[0,caml_string_of_jsbytes("IO/parser.ml"),2424,16],
     _cZ_=[0,caml_string_of_jsbytes("IO/parser.ml"),2456,20],
     _cX_=[0,caml_string_of_jsbytes("IO/parser.ml"),2484,24],
     _cY_=[0,caml_string_of_jsbytes("IO/parser.ml"),2488,20],
     _c0_=[0,caml_string_of_jsbytes("IO/parser.ml"),2493,16],
     _cT_=[0,caml_string_of_jsbytes("IO/parser.ml"),2498,12],
     _c1_=[0,caml_string_of_jsbytes("IO/parser.ml"),2686,8],
     _c2_=[0,caml_string_of_jsbytes("IO/parser.ml"),2719,8],
     _c3_=[0,caml_string_of_jsbytes("IO/parser.ml"),2740,8],
     _c4_=[3,1],
     _c5_=[3,0],
     _c9_=
      [0,
       [15,[11,caml_string_of_jsbytes(": command error\n"),0]],
       caml_string_of_jsbytes("%a: command error\n")],
     _c7_=
      [0,
       [15,[11,caml_string_of_jsbytes(": "),[2,0,[12,10,0]]]],
       caml_string_of_jsbytes("%a: %s\n")],
     _c8_=
      [0,
       [15,[11,caml_string_of_jsbytes(": parser error\n"),0]],
       caml_string_of_jsbytes("%a: parser error\n")],
     _c6_=
      [0,
       [2,0,[12,58,[4,0,0,0,[12,58,[4,0,0,0,0]]]]],
       caml_string_of_jsbytes("%s:%d:%d")],
     _c__=
      [0,
       [11,caml_string_of_jsbytes("Available characters: "),[17,4,0]],
       caml_string_of_jsbytes("Available characters: @.")],
     _c$_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _da_=
      [0,
       [17,
        4,
        [11,caml_string_of_jsbytes("Please enter text to encode: "),[17,2,0]]],
       caml_string_of_jsbytes("@.Please enter text to encode: @?")],
     _db_=
      [0,
       [4,8,[0,2,2],0,[4,8,[0,2,2],0,[12,32,0]]],
       caml_string_of_jsbytes("%02X%02X ")],
     _dc_=[0,caml_string_of_jsbytes("Main/encoder_common.ml"),34,11],
     _dd_=
      [0,
       [4,
        8,
        [0,2,2],
        0,
        [4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[12,32,0]]]]],
       caml_string_of_jsbytes("%02X%02X%02X%02X ")],
     _de_=[0,caml_string_of_jsbytes("Main/encoder_common.ml"),42,11],
     _dg_=
      [0,
       [11,caml_string_of_jsbytes("Encoded data (1-byte): "),[17,4,0]],
       caml_string_of_jsbytes("Encoded data (1-byte): @.")],
     _dh_=[0,[4,8,[0,2,2],0,[12,32,0]],caml_string_of_jsbytes("%02X ")],
     _dm_=[0,0,0],
     _di_=
      [0,
       [17,4,[11,caml_string_of_jsbytes("Encoded data (2-bytes): "),[17,4,0]]],
       caml_string_of_jsbytes("@.Encoded data (2-bytes): @.")],
     _dl_=[0,0,[0,0,0]],
     _dj_=
      [0,
       [17,4,[11,caml_string_of_jsbytes("Encoded data (4-bytes): "),[17,4,0]]],
       caml_string_of_jsbytes("@.Encoded data (4-bytes): @.")],
     _dk_=[0,[17,4,0],caml_string_of_jsbytes("@.")],
     _df_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("An error occured. Please check you only use available characters."),
        0],
       caml_string_of_jsbytes
        ("An error occured. Please check you only use available characters.")],
     _du_=[0,0],
     _dA_=
      [0,[4,8,[0,2,2],0,[12,32,[17,2,0]]],caml_string_of_jsbytes("%02X @?")],
     _dz_=
      [0,
       [11,
        caml_string_of_jsbytes("Box "),
        [4,
         3,
         [0,1,2],
         0,
         [11,
          caml_string_of_jsbytes(": "),
          [15,[11,caml_string_of_jsbytes("\t["),[15,[12,93,[17,4,0]]]]]]]],
       caml_string_of_jsbytes("Box %2i: %a\t[%a]@.")],
     _dx_=[0,[4,8,0,0,0],caml_string_of_jsbytes("%X")],
     _dy_=[0,[4,8,0,0,0],caml_string_of_jsbytes("%X")],
     _dw_=[0,1],
     _dv_=[0,0],
     _dt_=[0,caml_string_of_jsbytes("Boxes/boxes.ml"),37,12],
     _dn_=[0,0,[0,0,[0,0,[0,255,0]]]],
     _do_=[0,0,[0,0,[0,255,[0,0,0]]]],
     _dp_=[0,0,[0,255,[0,0,[0,0,0]]]],
     _dq_=[0,255,[0,0,[0,0,[0,0,0]]]],
     _dr_=[0,0,[0,0,[0,0,[0,176,0]]]],
     _ds_=[0,0,[0,0,[0,0,[0,0,0]]]],
     _dK_=
      [0,
       [2,0,[2,0,[2,0,[12,32,[15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]],
       caml_string_of_jsbytes("%s%s%s %a, %a")],
     _dL_=
      [0,
       [2,0,[2,0,[2,0,[12,32,[15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]],
       caml_string_of_jsbytes("%s%s%s %a, %a")],
     _dM_=
      [0,
       [2,
        0,
        [2,
         0,
         [2,
          0,
          [12,
           32,
           [15,
            [11,
             caml_string_of_jsbytes(", "),
             [15,[11,caml_string_of_jsbytes(", "),[15,0]]]]]]]]],
       caml_string_of_jsbytes("%s%s%s %a, %a, %a")],
     _dN_=
      [0,
       [12,66,[2,0,[2,0,[12,32,[15,0]]]]],
       caml_string_of_jsbytes("B%s%s %a")],
     _dO_=
      [0,
       [12,66,[2,0,[12,88,[2,0,[12,32,[15,0]]]]]],
       caml_string_of_jsbytes("B%sX%s %a")],
     _dG_=
      [0,
       [12,91,[15,[11,caml_string_of_jsbytes("], "),[15,0]]]],
       caml_string_of_jsbytes("[%a], %a")],
     _dH_=
      [0,
       [12,91,[15,[11,caml_string_of_jsbytes(", "),[15,[12,93,[2,0,0]]]]]],
       caml_string_of_jsbytes("[%a, %a]%s")],
     _dI_=
      [0,
       [12,91,[15,[11,caml_string_of_jsbytes("], "),[2,0,[15,0]]]]],
       caml_string_of_jsbytes("[%a], %s%a")],
     _dJ_=
      [0,
       [12,
        91,
        [15,[11,caml_string_of_jsbytes(", "),[2,0,[15,[12,93,[2,0,0]]]]]]],
       caml_string_of_jsbytes("[%a, %s%a]%s")],
     _dF_=[0,[12,35,[2,0,[5,7,0,0,0]]],caml_string_of_jsbytes("#%s%#lx")],
     _dE_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _dD_=[0,[12,35,[5,7,0,0,0]],caml_string_of_jsbytes("#%#lx")],
     _dC_=[0,[12,114,[4,0,0,0,0]],caml_string_of_jsbytes("r%d")],
     _dB_=[0,[5,8,[0,2,8],0,0],caml_string_of_jsbytes("%08lX")],
     _dQ_=
      [0,
       [11,caml_string_of_jsbytes("filler"),[21,1,0]],
       caml_string_of_jsbytes("filler%n")],
     _dR_=
      [0,
       [17,
        4,
        [11,caml_string_of_jsbytes("Raw data (in hexadecimal):"),[17,4,0]]],
       caml_string_of_jsbytes("@.Raw data (in hexadecimal):@.")],
     _dS_=
      [0,[4,8,[0,2,2],0,[12,32,[17,2,0]]],caml_string_of_jsbytes("%02X @?")],
     _dT_=[0,[17,4,0],caml_string_of_jsbytes("@.")],
     _dU_=[0,[17,4,[15,[17,4,0]]],caml_string_of_jsbytes("@.%a@.")],
     _dV_=
      [0,
       [11,
        caml_string_of_jsbytes("Warning: Not enough space... Need "),
        [21,1,[12,47,[21,1,[11,caml_string_of_jsbytes(" boxes."),[17,4,0]]]]]],
       caml_string_of_jsbytes
        ("Warning: Not enough space... Need %n/%n boxes.@.")],
     _dW_=
      [0,
       [11,
        caml_string_of_jsbytes("Warning: Contains unwritable characters..."),
        [17,4,0]],
       caml_string_of_jsbytes("Warning: Contains unwritable characters...@.")],
     _d0_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("Warning: A box name cannot be written (only contains spaces)..."),
        [17,4,0]],
       caml_string_of_jsbytes
        ("Warning: A box name cannot be written (only contains spaces)...@.")],
     _dX_=
      [0,
       [11,caml_string_of_jsbytes("Raw data (in hexadecimal):"),[17,4,0]],
       caml_string_of_jsbytes("Raw data (in hexadecimal):@.")],
     _dY_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _dZ_=[0,[17,4,0],caml_string_of_jsbytes("@.")],
     _dP_=
      [0,
       [15,[11,caml_string_of_jsbytes(" \t"),[15,[12,9,[15,[17,4,0]]]]]],
       caml_string_of_jsbytes("%a \t%a\t%a@.")];
    function enumerate_files(dirname,ext)
     {var
       _m6_=runtime.caml_sys_read_directory(dirname),
       _m7_=caml_call1(Stdlib_array[11],_m6_);
      function _m8_(x)
       {return caml_string_equal(caml_call1(Stdlib_filename[10],x),ext)}
      return caml_call2(Stdlib_list[41],_m8_,_m7_)}
    function uint32_of_str(str)
     {var
       str$0=caml_call1(Stdlib_string[16],str),
       i64=runtime.caml_int64_of_string(str$0);
      if(caml_call2(Stdlib_int64[17],Stdlib_int64[1],caml_int64_and(_a_,i64)))
       return runtime.caml_int64_to_int32(i64);
      throw [0,Stdlib[7],cst_Not_a_valid_int32]}
    function uint32_to_int(v)
     {var match=caml_call1(Stdlib_int32[12],v);
      if(match){var i=match[1];return i}
      throw [0,Assert_failure,_b_]}
    function int64_of_uint32(x)
     {return caml_int64_and(_c_,caml_int64_of_int32(x))}
    function _d_(param){return 0}
    function _e_(param,_m5_,_m4_){return 0}
    var dummy_fmt=caml_call2(Stdlib_format[113],_e_,_d_);
    function concat_strings(lst)
     {function pp(fmt,lst)
       {function _m3_(str){return caml_call3(Stdlib_format[126],fmt,_f_,str)}
        return caml_call2(Stdlib_list[17],_m3_,lst)}
      return caml_call3(Stdlib_format[130],_g_,pp,lst)}
    var
     Utils=
      [0,
       enumerate_files,
       uint32_of_str,
       uint32_to_int,
       int64_of_uint32,
       dummy_fmt,
       concat_strings];
    caml_register_global(478,Utils,"Utils");
    function int32_from_low_high(l,h){return l | h << 16}
    function int32_to_low_high(i)
     {var l=65535 & i,h=i >>> 16 | 0;return [0,l,h]}
    var
     substructures_order=_h_.slice(),
     data_offset=32,
     len=48,
     pid_offset=0,
     otid_offset=4,
     checksum_offset=28;
    function pkmn_from_bytes(buf)
     {var
       pid=caml_call2(Stdlib_bytes[57],buf,pid_offset),
       otid=caml_call2(Stdlib_bytes[57],buf,otid_offset);
      return [0,pid,otid]}
    function substructure_position(param,ss)
     {var
       pid=param[1],
       i=uint32_to_int(caml_call2(Stdlib_int32[5],pid,24)),
       order=caml_check_bound(substructures_order,i)[1 + i],
       i$0=0;
      for(;;)
       {if(runtime.caml_string_get(order,i$0) === ss)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function substructure_offset(pkmn,ss)
     {var p=substructure_position(pkmn,ss);return 32 + (12 * p | 0) | 0}
    function encrypt_aligned_int32(pkmn,i)
     {var otid=pkmn[2],pid=pkmn[1],key=pid ^ otid;return i ^ key}
    function checksum_diff_for_aligned_int3(o,n)
     {var
       match=int32_to_low_high(o),
       ho=match[2],
       lo=match[1],
       match$0=int32_to_low_high(n),
       hn=match$0[2],
       ln=match$0[1],
       diff=(ln - lo | 0) + (hn - ho | 0) | 0;
      return diff & 65535}
    function enc_dec(pkmn,buf,offset,len)
     {var offset$0=offset;
      for(;;)
       {if((offset + len | 0) <= offset$0)return 0;
        var
         i=caml_call2(Stdlib_bytes[57],buf,offset$0),
         i$0=encrypt_aligned_int32(pkmn,i);
        caml_call3(Stdlib_bytes[71],buf,offset$0,i$0);
        var offset$1=offset$0 + 4 | 0,offset$0=offset$1;
        continue}}
    function extract_data(buf)
     {var
       pkmn=pkmn_from_bytes(buf),
       res=caml_call3(Stdlib_bytes[7],buf,data_offset,len);
      enc_dec(pkmn,res,0,len);
      return res}
    function update_with_data(buf,data)
     {var pkmn=pkmn_from_bytes(buf),acc=Stdlib_int32[1],i=0;
      for(;;)
       {if(48 <= i)
         {var low=acc & 65535,checksum=uint32_to_int(low);
          caml_call5(Stdlib_bytes[11],data,0,buf,data_offset,len);
          enc_dec(pkmn,buf,data_offset,len);
          return caml_call3(Stdlib_bytes[65],buf,checksum_offset,checksum)}
        var
         nb=caml_call2(Stdlib_bytes[51],data,i),
         i$0=i + 2 | 0,
         acc$0=acc + nb | 0,
         acc=acc$0,
         i=i$0;
        continue}}
    function species_offset(pkmn){return substructure_offset(pkmn,71)}
    function species_offset_relative_to_dat(pkmn)
     {return substructure_offset(pkmn,71) - 32 | 0}
    function ivea_offset(pkmn){return substructure_offset(pkmn,77) + 4 | 0}
    function ivea_data_to_ivs(data)
     {var
       hp=31 & data,
       data$0=data >>> 5 | 0,
       atk=31 & data$0,
       data$1=data$0 >>> 5 | 0,
       def=31 & data$1,
       data$2=data$1 >>> 5 | 0,
       speed=31 & data$2,
       data$3=data$2 >>> 5 | 0,
       sp_atk=31 & data$3,
       data$4=data$3 >>> 5 | 0,
       sp_def=31 & data$4,
       data$5=data$4 >>> 5 | 0;
      return [0,hp,atk,def,speed,sp_atk,sp_def,data$5]}
    function ivs_to_ivea_data(param)
     {var
       data=param[7],
       sp_def=param[6],
       sp_atk=param[5],
       speed=param[4],
       def=param[3],
       atk=param[2],
       hp=param[1],
       data$0=data << 5,
       data$1=data$0 | sp_def,
       data$2=data$1 << 5,
       data$3=data$2 | sp_atk,
       data$4=data$3 << 5,
       data$5=data$4 | speed,
       data$6=data$5 << 5,
       data$7=data$6 | def,
       data$8=data$7 << 5,
       data$9=data$8 | atk,
       data$10=data$9 << 5,
       data$11=data$10 | hp;
      return data$11}
    var
     Structure=
      [0,
       int32_from_low_high,
       int32_to_low_high,
       pkmn_from_bytes,
       substructure_position,
       substructure_offset,
       extract_data,
       update_with_data,
       encrypt_aligned_int32,
       encrypt_aligned_int32,
       checksum_diff_for_aligned_int3,
       species_offset,
       species_offset_relative_to_dat,
       ivea_offset,
       ivea_data_to_ivs,
       ivs_to_ivea_data];
    caml_register_global(480,Structure,"Structure");
    var lang=[0,0],tweaker_mode=[0,1],hex_box_mode=[0,0];
    function configure(language)
     {tweaker_mode[1] = 1;
      hex_box_mode[1] = 0;
      return caml_string_notequal(language,cst_abc)
              ?caml_string_notequal(language,cst_eng)
                ?caml_string_notequal(language,cst_fra)
                  ?caml_string_notequal(language,cst_ger)
                    ?caml_string_notequal(language,cst_ita)
                      ?caml_string_notequal(language,cst_jap)
                        ?caml_string_notequal(language,cst_spa)
                          ?(lang[1] = 0,0)
                          :(lang[1] = 3,0)
                        :(lang[1] = 5,tweaker_mode[1] = 0,0)
                      :(lang[1] = 2,0)
                    :(lang[1] = 4,0)
                  :(lang[1] = 1,0)
                :(lang[1] = 0,0)
              :(lang[1] = 6,tweaker_mode[1] = 0,hex_box_mode[1] = 1,0)}
    var Settings=[0,lang,tweaker_mode,hex_box_mode,configure];
    caml_register_global(481,Settings,"Settings");
    function mult_mod(x,y,m)
     {var _m2_=caml_call2(Big_int[10],x,y);
      return caml_call2(Big_int[16],_m2_,m)}
    var
     _i_=Big_int[9],
     _k_=Big_int[11],
     _l_=Big_int[50],
     _m_=Big_int[53],
     _j_=Big_int[6],
     _n_=Big_int[54],
     two_big_int=caml_call1(Big_int[36],2);
    caml_call1(Big_int[36],3);
    caml_call1(Big_int[36],4);
    var
     a=caml_call1(Big_int[42],_o_),
     b=caml_call1(Big_int[42],_p_),
     a_inv=caml_call1(Big_int[42],_q_),
     b_inv=caml_call1(Big_int[42],_r_),
     m=caml_call1(Big_int[42],_s_),
     b_1=caml_call1(Big_int[42],_t_),
     _u_=caml_call2(_k_,4,m),
     cycle_part_product=mult_mod(caml_call1(_i_,a),b_1,_u_),
     mask32=caml_call1(Big_int[42],_v_);
    function even(n)
     {var _m1_=caml_call2(_l_,n,Big_int[2]);
      return caml_call2(Big_int[24],Big_int[1],_m1_)}
    function odd(n){return 1 - even(n)}
    function mpow(base,exp,n)
     {var base$0=base,exp$0=exp;
      for(;;)
       {var base$1=caml_call2(Big_int[16],base$0,n);
        if(caml_call2(Big_int[24],exp$0,Big_int[1]))return Big_int[2];
        if(caml_call2(Big_int[24],exp$0,Big_int[2]))return base$1;
        if(even(exp$0))
         {var
           exp$1=caml_call2(Big_int[15],exp$0,two_big_int),
           base$2=caml_call2(Big_int[10],base$1,base$1),
           base$0=base$2,
           exp$0=exp$1;
          continue}
        return mult_mod(base$1,mpow(base$1,caml_call1(_i_,exp$0),n),n)}}
    function pow(base,exp)
     {var base$0=base,exp$0=exp;
      for(;;)
       {if(caml_call2(Big_int[24],exp$0,Big_int[1]))return Big_int[2];
        if(caml_call2(Big_int[24],exp$0,Big_int[2]))return base$0;
        if(even(exp$0))
         {var
           exp$1=caml_call2(Big_int[15],exp$0,two_big_int),
           base$1=caml_call2(Big_int[10],base$0,base$0),
           base$0=base$1,
           exp$0=exp$1;
          continue}
        var _m0_=pow(base$0,caml_call1(_i_,exp$0));
        return caml_call2(Big_int[10],base$0,_m0_)}}
    caml_fresh_oo_id(0);
    function _x_(seed)
     {var _mZ_=caml_call2(Big_int[10],seed,a);
      return caml_call2(_l_,mask32,caml_call2(Big_int[5],b,_mZ_))}
    function _y_(seed)
     {var _mY_=caml_call2(Big_int[10],seed,a_inv);
      return caml_call2(_l_,mask32,caml_call2(Big_int[5],b_inv,_mY_))}
    function big_int_of_uint32(i32)
     {var _mX_=int64_of_uint32(i32);return caml_call1(Big_int[42],_mX_)}
    function uint32_of_bigint(bi)
     {var
       maxint32=caml_call1(Big_int[40],Stdlib_int32[9]),
       minint32=caml_call1(Big_int[40],Stdlib_int32[10]),
       _mW_=caml_call2(Big_int[8],maxint32,minint32),
       total=caml_call1(Big_int[6],_mW_),
       bi$0=
        caml_call2(Big_int[28],bi,maxint32)?caml_call2(Big_int[8],bi,total):bi;
      return caml_call1(Big_int[43],bi$0)}
    function rng_of(seed)
     {var _mV_=caml_call2(_n_,seed,16);return caml_call1(Big_int[38],_mV_)}
    var
     aPresses=[0,1,3,6],
     moreAPresses=[0,0,10,30],
     old_rod=0,
     good_rod=1,
     super_rod=2;
    function next_seed(seed)
     {return uint32_of_bigint(_x_(big_int_of_uint32(seed)))}
    function prev_seed(seed)
     {return uint32_of_bigint(_y_(big_int_of_uint32(seed)))}
    function cycle_to(seed)
     {var
       seed$0=big_int_of_uint32(seed),
       y=caml_call2(_k_,4,m),
       x=caml_call1(_j_,mult_mod(seed$0,cycle_part_product,y)),
       power=caml_call2(Big_int[26],x,y)?caml_call2(Big_int[8],x,y):x,
       m$0=pow(two_big_int,caml_call1(Big_int[36],34));
      if(odd(a) && odd(power))
       {var
         bitmask=caml_call1(_i_,pow(two_big_int,caml_call1(Big_int[36],31))),
         ls=runtime.caml_make_vect(32,power),
         i=1,
         l=power;
        for(;;)
         {if(i < 32)
           {var l$0=mult_mod(l,l,m$0);
            caml_check_bound(ls,i)[1 + i] = l$0;
            var i$0=i + 1 | 0,i=i$0,l=l$0;
            continue}
          var i$1=31,b=Big_int[1],bit=Big_int[2];
          for(;;)
           {if(0 <= i$1)
             {var
               _mT_=mpow(a,caml_call2(_l_,bitmask,caml_call2(_m_,b,i$1)),m$0),
               _mU_=caml_check_bound(ls,i$1)[1 + i$1],
               b$0=
                1 - caml_call2(Big_int[24],_mU_,_mT_)
                 ?caml_call2(Big_int[5],b,bit)
                 :b,
               bit$0=caml_call2(_m_,bit,1),
               i$2=i$1 - 1 | 0,
               i$1=i$2,
               b=b$0,
               bit=bit$0;
              continue}
            return uint32_of_bigint(b)}}}
      throw [0,Assert_failure,_w_]}
    function seed_at(cycle)
     {var
       cycle$0=big_int_of_uint32(cycle),
       _mR_=caml_call1(_i_,a),
       y=caml_call2(Big_int[10],_mR_,m),
       x=caml_call1(_i_,mpow(a,cycle$0,y)),
       op1=caml_call2(Big_int[26],x,Big_int[1])?x:caml_call2(Big_int[5],x,y),
       _mS_=caml_call1(_i_,a),
       aux=caml_call2(Big_int[15],op1,_mS_);
      return uint32_of_bigint(mult_mod(aux,b,m))}
    function best_seed_for_rod(route119,feebas,target_seed,rod)
     {var
       target_seed$0=big_int_of_uint32(target_seed),
       maxAdditionalOffsets=[0,0,1,4],
       bestResults=[0,0],
       starting_seed=[0,_y_(target_seed$0)],
       for$2=1;
      for(;;)
       {starting_seed[1] = _y_(starting_seed[1]);
        var _mQ_=for$2 + 1 | 0;
        if(8 !== for$2){var for$2=_mQ_;continue}
        var switch$0=0;
        if(route119 && ! feebas)
         {starting_seed[1] = _y_(starting_seed[1]);
          var offset119=1;
          switch$0 = 1}
        if(! switch$0)var offset119=0;
        var _mF_=caml_check_bound(maxAdditionalOffsets,rod)[1 + rod],_mE_=0;
        if(! (_mF_ < 0))
         {var additionalOffset=_mE_;
          a:
          for(;;)
           {var seed=[0,starting_seed[1]],for$1=1;
            for(;;)
             {seed[1] = _x_(seed[1]);
              var _mD_=for$1 + 1 | 0;
              if(7 !== for$1){var for$1=_mD_;continue}
              var
               _my_=caml_check_bound(aPresses,rod)[1 + rod],
               minRounds=caml_mod(rng_of(seed[1]),_my_) + 1 | 0;
              seed[1] = _x_(seed[1]);
              seed[1] = _x_(seed[1]);
              var
               biteRoll=rng_of(seed[1]) % 100 | 0,
               biteResult=0 === (biteRoll & 1)?0:14 < biteRoll?1:2,
               _mA_=minRounds - 1 | 0,
               _mz_=1;
              if(! (_mA_ < 1))
               {var for$0=_mz_;
                for(;;)
                 {seed[1] = _x_(seed[1]);
                  var _mC_=for$0 + 1 | 0;
                  if(_mA_ !== for$0){var for$0=_mC_;continue}
                  break}}
              var advancement=[0,7 + minRounds | 0];
              if(1 === minRounds)
               {seed[1] = _x_(seed[1]);
                advancement[1] = advancement[1] + 1 | 0;
                var biteRoll$0=rng_of(seed[1]) % 100 | 0;
                if(biteRoll$0 < caml_check_bound(moreAPresses,rod)[1 + rod])
                 {seed[1] = _x_(seed[1]);
                  advancement[1] = advancement[1] + 1 | 0}}
              seed[1] = _x_(seed[1]);
              var
               feebasResult=(rng_of(seed[1]) % 100 | 0) < 50?1:0,
               _mB_=route119?1 - feebas:route119;
              if(_mB_)advancement[1] = advancement[1] + 1 | 0;
              var advancement$0=advancement[1];
              starting_seed[1] = _y_(starting_seed[1]);
              var _mH_=biteResult < 2?1:0;
              if(_mH_)
               var
                _mI_=1 - feebas,
                _mJ_=_mI_ || feebasResult,
                _mK_=
                 _mJ_
                  ?((9 + additionalOffset | 0) + offset119 | 0)
                    ===
                    advancement$0
                    ?1
                    :0
                  :_mJ_;
              else
               var _mK_=_mH_;
              if(_mK_)
               {var _mL_=bestResults[1];
                if(_mL_)
                 {var
                   match=_mL_[1],
                   br=match[1],
                   s=match[3],
                   adv=match[2],
                   switch$1=0;
                  if(0 === br && 1 === biteResult)
                   {var _mM_=[0,[0,br,adv,s]];switch$1 = 1}
                  if(! switch$1)
                   {var s$0=match[3],adv$0=match[2],switch$2=0;
                    if(br === biteResult && adv$0 < advancement$0)
                     {var _mP_=[0,[0,br,adv$0,s$0]];switch$2 = 1}
                    if(! switch$2)
                     var
                      _mP_=
                       [0,[0,biteResult,advancement$0,_x_(starting_seed[1])]];
                    var _mM_=_mP_}
                  var _mN_=_mM_}
                else
                 var
                  _mN_=
                   [0,[0,biteResult,advancement$0,_x_(starting_seed[1])]];
                bestResults[1] = _mN_}
              var _mO_=additionalOffset + 1 | 0;
              if(_mF_ !== additionalOffset)
               {var additionalOffset=_mO_;continue a}
              break}
            break}}
        var _mG_=bestResults[1];
        if(_mG_)
         {var match$0=_mG_[1],s$1=match$0[3],i=match$0[2],b=match$0[1];
          return [0,[0,1 === b?1:0,i,uint32_of_bigint(s$1)]]}
        return 0}}
    var
     Seed=
      [0,
       prev_seed,
       next_seed,
       cycle_to,
       seed_at,
       old_rod,
       good_rod,
       super_rod,
       best_seed_for_rod];
    caml_register_global(483,Seed,"Seed");
    function main(fmt)
     {caml_call2(Stdlib_format[126],fmt,_z_);return [0,main_1]}
    function main_3(seed,fmt,str)
     {if(caml_string_notequal(str,cst_1$0))
       if(caml_string_notequal(str,cst_2$0))
        if(caml_string_notequal(str,cst_3$0))
         var
          _mu_=caml_call1(Stdlib[2],cst_Unknown_answer),
          feebas=_mu_[2],
          route119=_mu_[1];
        else
         var feebas=1,route119=1;
       else
        var feebas=0,route119=1;
      else
       var feebas=0,route119=0;
      var rod=old_rod;
      for(;;)
       {if(rod === 0)
         var rodname=cst_Old_rod;
        else
         {if(rod === 1)
           var _mx_=cst_Good_rod;
          else
           {if(rod !== 2)throw [0,Assert_failure,_ag_];var _mx_=cst_Super_rod}
          var rodname=_mx_}
        caml_call3(Stdlib_format[126],fmt,_aa_,rodname);
        var match=best_seed_for_rod(route119,feebas,seed,rod);
        if(match)
         {var _mv_=match[1];
          if(_mv_[1])
           {var seed$0=_mv_[3],adv=_mv_[2];
            caml_call2(Stdlib_format[126],fmt,_ab_);
            caml_call4(Stdlib_format[126],fmt,_ac_,seed$0,adv)}
          else
           {var seed$1=_mv_[3],adv$0=_mv_[2];
            caml_call2(Stdlib_format[126],fmt,_ad_);
            caml_call4(Stdlib_format[126],fmt,_ae_,seed$1,adv$0)}}
        else
         caml_call2(Stdlib_format[126],fmt,_af_);
        var _mw_=rod + 1 | 0;
        if(2 !== rod){var rod=_mw_;continue}
        caml_call2(Stdlib_format[126],fmt,_Z_);
        caml_call2(Stdlib_format[126],fmt,___);
        caml_call2(Stdlib_format[126],fmt,_$_);
        return 0}}
    function show_vicinity(fmt,print_cycle,seed,start,stop)
     {var cycle=cycle_to(seed);
      if(print_cycle)caml_call3(Stdlib_format[126],fmt,_H_,cycle);
      var start_seed=[0,seed_at(cycle + start | 0)];
      if(! (stop < start))
       {var i=start;
        for(;;)
         {caml_call5(Stdlib_format[126],fmt,_I_,i,start_seed[1],start_seed[1]);
          start_seed[1] = next_seed(start_seed[1]);
          var _mt_=i + 1 | 0;
          if(stop !== i){var i=_mt_;continue}
          break}}
      return 0}
    function main_vicinity(seed,fmt,str)
     {function _ms_(i,j){return [0,i,j]}
      var
       match=caml_call3(Stdlib_scanf[4],str,_Y_,_ms_),
       stop=match[2],
       start=match[1];
      show_vicinity(fmt,1,seed,start,stop);
      return 0}
    function main_2(seed,fmt,str)
     {if(caml_string_notequal(str,cst_1))
       {if(caml_string_notequal(str,cst_2))
         return caml_string_notequal(str,cst_3)
                 ?caml_string_notequal(str,cst_4)
                   ?caml_string_notequal(str,cst_5)
                     ?0
                     :(caml_call2(Stdlib_format[126],fmt,_J_),
                       [0,
                        function(_mo_,_mp_){return main_vicinity(seed,_mo_,_mp_)}])
                   :(caml_call2(Stdlib_format[126],fmt,_K_),
                     caml_call2(Stdlib_format[126],fmt,_L_),
                     caml_call2(Stdlib_format[126],fmt,_M_),
                     caml_call2(Stdlib_format[126],fmt,_N_),
                     show_vicinity(fmt,0,seed,-10,0),
                     0)
                 :(caml_call2(Stdlib_format[126],fmt,_O_),
                   caml_call2(Stdlib_format[126],fmt,_P_),
                   caml_call2(Stdlib_format[126],fmt,_Q_),
                   caml_call2(Stdlib_format[126],fmt,_R_),
                   [0,function(_mq_,_mr_){return main_3(seed,_mq_,_mr_)}]);
        var _mm_=prev_seed(seed);
        caml_call3(Stdlib_format[126],fmt,_S_,_mm_);
        caml_call2(Stdlib_format[126],fmt,_T_);
        caml_call2(Stdlib_format[126],fmt,_U_);
        return 0}
      var _mn_=prev_seed(prev_seed(seed));
      caml_call3(Stdlib_format[126],fmt,_V_,_mn_);
      caml_call2(Stdlib_format[126],fmt,_W_);
      caml_call2(Stdlib_format[126],fmt,_X_);
      return 0}
    function main_1(fmt,str)
     {var seed=uint32_of_str(str);
      caml_call2(Stdlib_format[126],fmt,_A_);
      caml_call2(Stdlib_format[126],fmt,_B_);
      caml_call2(Stdlib_format[126],fmt,_C_);
      caml_call2(Stdlib_format[126],fmt,_D_);
      caml_call2(Stdlib_format[126],fmt,_E_);
      caml_call2(Stdlib_format[126],fmt,_F_);
      caml_call2(Stdlib_format[126],fmt,_G_);
      return [0,function(_mk_,_ml_){return main_2(seed,_mk_,_ml_)}]}
    var
     Seed_tools_common=
      [0,main,main_1,show_vicinity,main_2,main_vicinity,main_3];
    caml_register_global(485,Seed_tools_common,"Seed_tools_common");
    var
     InvalidSave=[248,cst_Save_InvalidSave,caml_fresh_oo_id(0)],
     game_save_A=0,
     game_save_B=57344,
     section_size=4096,
     section_id_offset=4084,
     checksum_offset$0=4086,
     save_index_offset=4092,
     box_names_section_id=13,
     box_names_section_data_length=2000,
     box_names_offset=1860,
     box_names_length=126,
     team_items_section_id=1,
     team_items_section_data_length=3968,
     team_size_offset=564,
     pkmn_data_size=100;
    function read_section(inc,section_id)
     {var rbuf=caml_create_bytes(4096);
      function aux(base,i)
       {var i$0=i;
        for(;;)
         {if(14 <= i$0)throw InvalidSave;
          var addr=base + (i$0 * 4096 | 0) | 0;
          caml_call2(Stdlib[90],inc,addr);
          caml_call4(Stdlib[85],inc,rbuf,0,section_size);
          var
           id=caml_call2(Stdlib_bytes[51],rbuf,section_id_offset),
           index=caml_call2(Stdlib_bytes[57],rbuf,save_index_offset);
          if(id === section_id)return [0,addr,index];
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      var
       match=aux(game_save_A,0),
       indexa=match[2],
       addra=match[1],
       match$0=aux(game_save_B,0),
       indexb=match$0[2],
       addrb=match$0[1],
       addr=0 <= caml_call2(Stdlib_int32[16],indexa,indexb)?addra:addrb,
       res=caml_create_bytes(4096);
      caml_call2(Stdlib[90],inc,addr);
      caml_call4(Stdlib[85],inc,res,0,section_size);
      return [0,addr,res]}
    function write_section(oc,addr,buf)
     {caml_call2(Stdlib[73],oc,addr);
      caml_call2(Stdlib[67],oc,buf);
      return caml_call1(Stdlib[63],oc)}
    function compute_checksum(buf,start,len)
     {var acc=Stdlib_int32[1],i=start;
      for(;;)
       {if((start + len | 0) <= i)
         {var high=acc >>> 16 | 0,low=acc & 65535,res=high + low | 0;
          return uint32_to_int(res & 65535)}
        var
         nb=caml_call2(Stdlib_bytes[57],buf,i),
         i$0=i + 4 | 0,
         acc$0=acc + nb | 0,
         acc=acc$0,
         i=i$0;
        continue}}
    function extract_box_names_from_section(buf)
     {return caml_call3(Stdlib_bytes[7],buf,box_names_offset,box_names_length)}
    function update_box_names(buf,box_names)
     {var len=runtime.caml_ml_bytes_length(box_names);
      caml_call5(Stdlib_bytes[11],box_names,0,buf,box_names_offset,len);
      var checksum=compute_checksum(buf,0,box_names_section_data_length);
      return caml_call3(Stdlib_bytes[65],buf,checksum_offset$0,checksum)}
    function empty_pkmn(param){return caml_create_bytes(100)}
    function extract_team_from_section(buf)
     {var acc=0,i=5;
      for(;;)
       {if(0 <= i)
         {var
           addr=568 + (100 * i | 0) | 0,
           pkmn=caml_call3(Stdlib_bytes[7],buf,addr,pkmn_data_size),
           i$0=i - 1 | 0,
           acc$0=[0,pkmn,acc],
           acc=acc$0,
           i=i$0;
          continue}
        return acc}}
    function update_team(buf,pkmns)
     {var len=caml_call1(Stdlib_list[1],pkmns);
      caml_call3(Stdlib_bytes[71],buf,team_size_offset,len);
      function update_pkmn(i,pkmn)
       {var addr=568 + (100 * i | 0) | 0;
        return caml_call5(Stdlib_bytes[11],pkmn,0,buf,addr,pkmn_data_size)}
      caml_call2(Stdlib_list[18],update_pkmn,pkmns);
      var checksum=compute_checksum(buf,0,team_items_section_data_length);
      return caml_call3(Stdlib_bytes[65],buf,checksum_offset$0,checksum)}
    var
     Save=
      [0,
       InvalidSave,
       box_names_section_id,
       team_items_section_id,
       extract_box_names_from_section,
       update_box_names,
       empty_pkmn,
       extract_team_from_section,
       update_team,
       write_section,
       read_section];
    caml_register_global(486,Save,"Save");
    var
     StrMap=caml_call1(Stdlib_map[1],[0,Stdlib_string[5]]),
     VarNotFound=[248,cst_Preprocess_VarNotFound,caml_fresh_oo_id(0)];
    function get_param(lst,name)
     {var lst$0=lst;
      for(;;)
       {if(lst$0)
         {var _mj_=lst$0[1];
          if(0 === _mj_[0])
           {var n=_mj_[1],v=_mj_[2];
            if(caml_call2(Stdlib_string[4],n,name))return v;
            var lst$1=lst$0[2],lst$0=lst$1;
            continue}
          var lst$2=lst$0[2],lst$0=lst$2;
          continue}
        return 0}}
    function eval_meta_expr(env,e)
     {function aux(e)
       {var e$0=e;
        for(;;)
         switch(e$0[0])
          {case 0:var i=e$0[1];return i;
           case 1:
            var e2=e$0[3],e1=e$0[2],op=e$0[1],i1=aux(e1),i2=aux(e2);
            switch(op)
             {case 0:return i1 + i2 | 0;
              case 1:return i1 - i2 | 0;
              case 2:return runtime.caml_mul(i1,i2);
              case 3:return caml_call2(Stdlib_int32[4],i1,i2);
              case 4:return caml_call2(Stdlib_int32[5],i1,i2);
              case 5:return i1 & i2;
              case 6:return i1 ^ i2;
              case 7:return i1 | i2;
              case 8:return i1 << uint32_to_int(i2);
              case 9:return i1 >>> uint32_to_int(i2) | 0;
              case 10:
               return caml_call2(Stdlib_int32[17],i1,i2)
                       ?Stdlib_int32[2]
                       :Stdlib_int32[1];
              case 11:
               return caml_call2(Stdlib_int32[17],i1,i2)
                       ?Stdlib_int32[1]
                       :Stdlib_int32[2];
              case 12:
               if
                (caml_call2(Stdlib_int32[17],i1,Stdlib_int32[1])
                 &&
                 caml_call2(Stdlib_int32[17],i2,Stdlib_int32[1]))
                return Stdlib_int32[1];
               return Stdlib_int32[2];
              default:
               if
                (!
                 caml_call2(Stdlib_int32[17],i1,Stdlib_int32[1])
                 &&
                 !
                 caml_call2(Stdlib_int32[17],i2,Stdlib_int32[1]))
                return Stdlib_int32[2];
               return Stdlib_int32[1]}
           case 2:
            var e$1=e$0[2],op$0=e$0[1],i$0=aux(e$1);
            switch(op$0)
             {case 0:return i$0;
              case 1:return - i$0 | 0;
              case 2:return caml_call1(Stdlib_int32[11],i$0);
              default:
               return caml_call2(Stdlib_int32[17],i$0,Stdlib_int32[1])
                       ?Stdlib_int32[2]
                       :Stdlib_int32[1]}
           case 3:
            var str=e$0[1];
            if(caml_call2(StrMap[3],str,env))
             return caml_call2(StrMap[28],str,env);
            throw [0,VarNotFound,str];
           default:
            var e2$0=e$0[3],e1$0=e$0[2],e0=e$0[1],i0=aux(e0);
            if(caml_call2(Stdlib_int32[17],i0,Stdlib_int32[1]))
             {var e$0=e2$0;continue}
            var e$0=e1$0;
            continue}}
      return aux(e)}
    var empty_env=StrMap[1];
    function env_from_headers(fmt,headers)
     {function treat_def(param,def)
       {var acc=param[2],printed=param[1];
        if(0 === def[0])return [0,printed,acc];
        var expr=def[3],print=def[2],str=def[1],i=eval_meta_expr(acc,expr);
        if(print)caml_call5(Stdlib_format[126],fmt,_ah_,str,i,i);
        var _mi_=caml_call3(StrMap[4],str,i,acc),printed$0=printed || print;
        return [0,printed$0,_mi_]}
      var
       match=caml_call3(Stdlib_list[25],treat_def,[0,0,StrMap[1]],headers),
       res=match[2],
       printed=match[1];
      if(printed)caml_call2(Stdlib_format[126],fmt,_ai_);
      return res}
    function concat_env(env1,env2)
     {function _mh_(k,v,acc){return caml_call3(StrMap[4],k,v,acc)}
      return caml_call3(StrMap[13],_mh_,env2,env1)}
    var
     Preprocess=
      [0,
       VarNotFound,
       get_param,
       eval_meta_expr,
       empty_env,
       env_from_headers,
       concat_env];
    caml_register_global(488,Preprocess,"Preprocess");
    function main$0(fmt)
     {caml_call2(Stdlib_format[126],fmt,_aj_);return [0,main_1$0]}
    function main_6(pkmn,livea,fmt,str)
     {function _mg_(i){return i}
      var
       hivea=caml_call3(Stdlib_scanf[4],str,_aw_,_mg_),
       ivea=int32_from_low_high(livea,hivea),
       uivea=encrypt_aligned_int32(pkmn,ivea);
      caml_call3(Stdlib_format[126],fmt,_ax_,uivea);
      var
       match=ivea_data_to_ivs(uivea),
       data=match[7],
       sp_def=match[6],
       sp_atk=match[5],
       speed=match[4],
       def=match[3],
       atk=match[2],
       hp=match[1];
      caml_call8(Stdlib_format[126],fmt,_ay_,hp,atk,def,speed,sp_atk,sp_def);
      caml_call2(Stdlib_format[126],fmt,_az_);
      var uivea$0=ivs_to_ivea_data([0,31,31,31,31,31,31,data]);
      caml_call3(Stdlib_format[126],fmt,_aA_,uivea$0);
      var
       ivea$0=encrypt_aligned_int32(pkmn,uivea$0),
       match$0=int32_to_low_high(ivea$0),
       hivea$0=match$0[2],
       livea$0=match$0[1];
      caml_call3(Stdlib_format[126],fmt,_aB_,livea$0);
      caml_call3(Stdlib_format[126],fmt,_aC_,hivea$0);
      var checksum_diff=checksum_diff_for_aligned_int3(uivea,uivea$0);
      caml_call3(Stdlib_format[126],fmt,_aD_,checksum_diff);
      return 0}
    function main_5(pkmn,fmt,str)
     {function _md_(i){return i}
      var livea=caml_call3(Stdlib_scanf[4],str,_au_,_md_);
      caml_call2(Stdlib_format[126],fmt,_av_);
      return [0,function(_me_,_mf_){return main_6(pkmn,livea,_me_,_mf_)}]}
    function main_4(pid,vid,fmt,str)
     {function _ma_(i){return i}
      var
       sid=caml_call3(Stdlib_scanf[4],str,_aq_,_ma_),
       tid=int32_from_low_high(vid,sid),
       pkmn=[0,pid,tid],
       misc_pos=substructure_position(pkmn,77),
       ivea_offset$0=ivea_offset(pkmn);
      caml_call3(Stdlib_format[126],fmt,_ar_,misc_pos + 1 | 0);
      caml_call3(Stdlib_format[126],fmt,_as_,ivea_offset$0);
      caml_call2(Stdlib_format[126],fmt,_at_);
      return [0,function(_mb_,_mc_){return main_5(pkmn,_mb_,_mc_)}]}
    function main_3$0(pid,fmt,str)
     {function _l9_(i){return i}
      var vid=caml_call3(Stdlib_scanf[4],str,_ao_,_l9_);
      caml_call2(Stdlib_format[126],fmt,_ap_);
      return [0,function(_l__,_l$_){return main_4(pid,vid,_l__,_l$_)}]}
    function main_2$0(lpid,fmt,str)
     {function _l6_(i){return i}
      var
       hpid=caml_call3(Stdlib_scanf[4],str,_am_,_l6_),
       pid=int32_from_low_high(lpid,hpid);
      caml_call2(Stdlib_format[126],fmt,_an_);
      return [0,function(_l7_,_l8_){return main_3$0(pid,_l7_,_l8_)}]}
    function main_1$0(fmt,str)
     {function _l3_(i){return i}
      var lpid=caml_call3(Stdlib_scanf[4],str,_ak_,_l3_);
      caml_call2(Stdlib_format[126],fmt,_al_);
      return [0,function(_l4_,_l5_){return main_2$0(lpid,_l4_,_l5_)}]}
    var
     Pkmn_data_common=
      [0,main$0,main_1$0,main_2$0,main_3$0,main_4,main_5,main_6];
    caml_register_global(489,Pkmn_data_common,"Pkmn_data_common");
    var
     InvalidCommand=[248,cst_Arm_InvalidCommand,caml_fresh_oo_id(0)],
     a1=0,
     a2=1,
     a3=2,
     a4=3,
     v1=4,
     v2=5,
     v3=6,
     v4=7,
     v5=8,
     v6=9,
     v7=10,
     v8=11,
     sb=9,
     sl=10,
     fp=11,
     ip=12,
     sp=13,
     lr=14,
     pc=15,
     sign_plus=1,
     sign_minus=0,
     mask8=255,
     mask9=511,
     mask12=4095;
    function add_condition_code(c,v)
     {switch(c)
       {case 0:var _l2_=0;break;
        case 1:var _l2_=1;break;
        case 6:var _l2_=4;break;
        case 7:var _l2_=5;break;
        case 8:var _l2_=6;break;
        case 9:var _l2_=7;break;
        case 10:var _l2_=8;break;
        case 11:var _l2_=9;break;
        case 12:var _l2_=10;break;
        case 13:var _l2_=11;break;
        case 14:var _l2_=12;break;
        case 15:var _l2_=13;break;
        case 16:var _l2_=14;break;
        case 2:
        case 3:var _l2_=2;break;
        default:var _l2_=3}
      return v | _l2_ << 28}
    function add_rn_code(rn,v){return v | rn << 16}
    function add_rd_code(rd,v){return v | rd << 12}
    function rotate_right(v)
     {var lb=v & 1,v$0=v >>> 1 | 0;return v$0 | lb << 31}
    function rotate_left(v)
     {var hb=v & -2147483648,v$0=v << 1;return v$0 | hb >>> 31 | 0}
    function addr_mode_1(rs)
     {switch(rs[0])
       {case 0:
         var
          i=rs[1],
          aux=
           function(n,imm)
            {if(15 < n)return 0;
             var
              others=aux(n + 1 | 0,rotate_left(rotate_left(imm))),
              imm8=imm & 255;
             return caml_call2(Stdlib_int32[17],imm8,imm)
                     ?[0,[0,n,imm8],others]
                     :others},
          res=aux(0,i);
         if(0 === res)throw InvalidCommand;
         var
          _l0_=
           function(param)
            {var imm8=param[2],rr=param[1];return [0,1,imm8 | rr << 8]},
          possibilities=caml_call2(Stdlib_list[19],_l0_,res);
         break;
        case 1:var rm=rs[1],possibilities=[0,[0,0,rm],0];break;
        default:var possibilities=caml_call1(Stdlib[2],cst_Not_implemented)}
      function _l1_(param)
       {var v=param[2],imm=param[1],i=imm << 25;return v | i}
      return caml_call2(Stdlib_list[19],_l1_,possibilities)}
    function p_and_w(addr_typ)
     {switch(addr_typ)
       {case 0:return _aE_;case 1:return _aF_;default:return _aG_}}
    function arm_to_binary(arm)
     {switch(arm[0])
       {case 0:var i$3=arm[1];return [0,i$3,0];
        case 1:
         var
          ro=arm[5],
          rd=arm[4],
          cond=arm[3],
          typ=arm[2],
          instr=arm[1],
          addr_typ=ro[2],
          rn=ro[1],
          check_post_addr=
           function(param){if(2 <= addr_typ)return 0;throw InvalidCommand};
         if(instr)
          switch(typ)
           {case 0:var opcode=71303168;break;
            case 1:throw InvalidCommand;
            case 2:var opcode=176;break;
            case 3:throw InvalidCommand;
            case 4:var opcode=67108864;break;
            case 5:check_post_addr(0);var opcode=69206016;break;
            default:check_post_addr(0);var opcode=73400320}
         else
          switch(typ)
           {case 0:var opcode=72351744;break;
            case 1:var opcode=1048784;break;
            case 2:var opcode=1048752;break;
            case 3:var opcode=1048816;break;
            case 4:var opcode=68157440;break;
            case 5:check_post_addr(0);var opcode=70254592;break;
            default:check_post_addr(0);var opcode=74448896}
         var
          _lV_=add_condition_code(cond,opcode),
          v$3=add_rd_code(rd,add_rn_code(rn[1],_lV_)),
          switcher=typ - 1 | 0;
         if(2 < switcher >>> 0)
          {switch(rn[0])
            {case 0:
              var v=rn[3],sign=rn[2];
              if(0 < caml_call2(Stdlib_int32[16],v,mask12))
               throw InvalidCommand;
              var v$0=v,reg=0,sign$0=sign;
              break;
             case 1:
              var rm=rn[3],sign$1=rn[2],v$0=rm,reg=1,sign$0=sign$1;break;
             default:
              var
               _lU_=caml_call1(Stdlib[2],cst_Not_implemented$0),
               v$0=_lU_[3],
               reg=_lU_[2],
               sign$0=_lU_[1]}
           var
            match=p_and_w(addr_typ),
            w=match[2],
            p=match[1],
            i=reg << 25,
            u=sign$0 << 23,
            p$0=p << 24,
            w$0=w << 21,
            addr_mode=i | w$0 | p$0 | v$0 | u}
         else
          {switch(rn[0])
            {case 0:
              var v$1=rn[3],sign$2=rn[2];
              if(0 < caml_call2(Stdlib_int32[16],v$1,mask8))
               throw InvalidCommand;
              var
               immedL=15 & v$1,
               immedH=15 & (v$1 >>> 4 | 0),
               v$2=immedL | immedH << 8,
               imm=1,
               sign$3=sign$2;
              break;
             case 1:
              var rm$0=rn[3],sign$4=rn[2],v$2=rm$0,imm=0,sign$3=sign$4;break;
             default:throw InvalidCommand}
           var
            match$0=p_and_w(addr_typ),
            w$1=match$0[2],
            p$1=match$0[1],
            i$0=imm << 22,
            u$0=sign$3 << 23,
            p$2=p$1 << 24,
            w$2=w$1 << 21,
            addr_mode=i$0 | w$2 | p$2 | v$2 | u$0}
         return [0,v$3 | addr_mode,0];
        case 2:
         var
          rs=arm[5],
          rd$0=arm[4],
          cond$0=arm[3],
          s=arm[2],
          instr$0=arm[1],
          opcode$0=instr$0?31457280:27262976,
          scode=s?1:0,
          scode$0=scode << 20,
          v$4=scode$0 | add_rd_code(rd$0,add_condition_code(cond$0,opcode$0)),
          _lW_=addr_mode_1(rs),
          _lX_=function(addr_mode){return v$4 | addr_mode};
         return caml_call2(Stdlib_list[19],_lX_,_lW_);
        case 3:
         var
          op2=arm[6],
          rn$0=arm[5],
          rd$1=arm[4],
          cond$1=arm[3],
          s$0=arm[2],
          instr$1=arm[1];
         switch(instr$1)
          {case 0:var opcode$1=10485760;break;
           case 1:var opcode$1=12582912;break;
           case 2:var opcode$1=29360128;break;
           case 3:var opcode$1=0;break;
           case 4:var opcode$1=8388608;break;
           case 5:var opcode$1=4194304;break;
           case 6:var opcode$1=25165824;break;
           default:var opcode$1=2097152}
         var
          scode$1=s$0?1:0,
          scode$2=scode$1 << 20,
          v$5=
           scode$2
           |
           add_rn_code
            (rn$0,add_rd_code(rd$1,add_condition_code(cond$1,opcode$1))),
          _lY_=addr_mode_1(op2),
          _lZ_=function(addr_mode){return v$5 | addr_mode};
         return caml_call2(Stdlib_list[19],_lZ_,_lY_);
        case 4:
         var
          target=arm[3],
          cond$2=arm[2],
          l=arm[1],
          opcode$2=l?184549376:167772160,
          v$6=add_condition_code(cond$2,opcode$2),
          i$2=target - 8 | 0;
         if(caml_call2(Stdlib_int32[17],i$2 & 3,Stdlib_int32[1]))
          {var i$1=i$2 >> 2,ms9=i$1 >>> 23 | 0;
           if
            (!
             caml_call2(Stdlib_int32[17],ms9,mask9)
             &&
             !
             caml_call2(Stdlib_int32[17],ms9,Stdlib_int32[1]))
            throw InvalidCommand;
           var imm$0=i$1 & 16777215;
           return [0,v$6 | imm$0,0]}
         throw InvalidCommand;
        default:
         var
          rm$1=arm[3],
          cond$3=arm[2],
          l$0=arm[1],
          opcode$3=l$0?19922736:19922704,
          v$7=add_condition_code(cond$3,opcode$3);
         return [0,v$7 | rm$1,0]}}
    function reverse_endianness(v)
     {var
       v1=(255 & v) << 24,
       v$0=v >>> 8 | 0,
       v2=(255 & v$0) << 16,
       v$1=v$0 >>> 8 | 0,
       v3=(255 & v$1) << 8,
       v$2=v$1 >>> 8 | 0,
       v4=255 & v$2;
      return v4 | v3 | v1 | v2}
    var
     Arm=
      [0,
       InvalidCommand,
       sign_plus,
       sign_minus,
       a1,
       a2,
       a3,
       a4,
       v1,
       v2,
       v3,
       v4,
       v5,
       v6,
       v7,
       v8,
       sb,
       sl,
       fp,
       ip,
       sp,
       lr,
       pc,
       arm_to_binary,
       reverse_endianness,
       rotate_right,
       rotate_left];
    caml_register_global(490,Arm,"Arm");
    var
     charset_eng=_aH_.slice(),
     charset_ita=caml_call1(Stdlib_array[8],charset_eng),
     charset_spa=caml_call1(Stdlib_array[8],charset_eng),
     cs=caml_call1(Stdlib_array[8],charset_eng);
    caml_check_bound(cs,177)[178] = _aI_;
    caml_check_bound(cs,178)[179] = _aJ_;
    var i$4=241;
    for(;;)
     {var match$0=caml_check_bound(cs,i$4)[1 + i$4];
      if(typeof match$0 !== "number" && 1 === match$0[0])
       {var c=match$0[1];
        caml_check_bound(cs,i$4)[1 + i$4] = [2,c];
        var _d2_=i$4 + 1 | 0;
        if(246 !== i$4){var i$4=_d2_;continue}
        var charset_fra=caml_call1(Stdlib_array[8],charset_eng);
        caml_check_bound(charset_fra,177)[178] = _aK_;
        caml_check_bound(charset_fra,178)[179] = _aL_;
        var
         charset_jap=_aM_.slice(),
         charset_full=_aN_.slice(),
         charset=
          function(param)
           {switch(lang[1])
             {case 0:return charset_eng;
              case 1:return charset_fra;
              case 2:return charset_ita;
              case 3:return charset_spa;
              case 4:return cs;
              case 5:return charset_jap;
              default:return charset_full}},
         is_code_available=
          function(code)
           {var match=caml_check_bound(charset(0),code)[1 + code];
            if(typeof match !== "number" && 2 === match[0])return 1;
            return 0},
         is_code_readable=
          function(code)
           {var match=caml_check_bound(charset(0),code)[1 + code];
            if(typeof match !== "number" && 0 !== match[0])return 1;
            return 0},
         is_code_used=
          function(code)
           {var match=caml_check_bound(charset(0),code)[1 + code];
            return typeof match === "number"?0:1},
         char_at=
          function(code)
           {var match=caml_check_bound(charset(0),code)[1 + code];
            if(typeof match === "number")return invalid_char;
            var str=match[1];
            return str},
         readable_char_at=
          function(code)
           {var match=caml_check_bound(charset(0),code)[1 + code];
            if(typeof match !== "number" && 0 !== match[0])
             {var str=match[1];return str}
            return invalid_char},
         writable_char_at=
          function(code)
           {var match=caml_check_bound(charset(0),code)[1 + code];
            if(typeof match !== "number" && 2 === match[0])
             {var str=match[1];return str}
            return invalid_char},
         acc=0,
         i=255;
        for(;;)
         {if(0 <= i)
           {var match=caml_check_bound(charset(0),i)[1 + i];
            if(typeof match !== "number" && 2 === match[0])
             {var
               str=match[1],
               i$1=i - 1 | 0,
               acc$0=[0,str,acc],
               acc=acc$0,
               i=i$1;
              continue}
            var i$0=i - 1 | 0,i=i$0;
            continue}
          var
           encode_writable_char=
            function(str)
             {var i=255;
              for(;;)
               {if(0 <= i)
                 {var match=caml_check_bound(charset(0),i)[1 + i];
                  if(typeof match !== "number" && 2 === match[0])
                   {var str$0=match[1];
                    if(caml_call2(Stdlib_string[4],str,str$0))return i}
                  var i$0=i - 1 | 0,i=i$0;
                  continue}
                throw Stdlib[8]}},
           Charset=
            [0,
             is_code_available,
             is_code_readable,
             is_code_used,
             spacing_char,
             invalid_char,
             char_at,
             readable_char_at,
             writable_char_at,
             acc,
             encode_writable_char];
          caml_register_global(491,Charset,"Charset");
          var
           eof=255,
           space=0,
           codes_for_command=
            function(v)
             {var
               v1=255 & v,
               v$0=v >>> 8 | 0,
               v2=255 & v$0,
               v$1=v$0 >>> 8 | 0,
               v3=255 & v$1,
               v$2=v$1 >>> 8 | 0,
               v4=255 & v$2,
               _lR_=[0,uint32_to_int(v4),0],
               _lS_=[0,uint32_to_int(v3),_lR_],
               _lT_=[0,uint32_to_int(v2),_lS_];
              return [0,uint32_to_int(v1),_lT_]},
           command_for_codes=
            function(codes)
             {if(codes)
               {var _lO_=codes[2];
                if(_lO_)
                 {var _lP_=_lO_[2];
                  if(_lP_)
                   {var _lQ_=_lP_[2];
                    if(_lQ_ && ! _lQ_[2])
                     {var
                       c4=_lQ_[1],
                       c3=_lP_[1],
                       c2=_lO_[1],
                       c1=codes[1],
                       v=c4 << 8,
                       v$0=v | c3,
                       v$1=v$0 << 8,
                       v$2=v$1 | c2,
                       v$3=v$2 << 8;
                      return v$3 | c1}}}}
              throw [0,Assert_failure,_aO_]},
           codes_to_chars=
            function(c){return caml_call2(Stdlib_list[19],writable_char_at,c)},
           chars_for_command=
            function(v){return codes_to_chars(codes_for_command(v))},
           pp_chars=
            function(fmt,lst)
             {function _lM_(i,str)
               {var _lN_=0 === i?cst:cst$0;
                return caml_call4(Stdlib_format[126],fmt,_aP_,_lN_,str)}
              return caml_call2(Stdlib_list[18],_lM_,lst)},
           pp_chars_raw=
            function(fmt,lst)
             {function _lL_(str)
               {var str$0=caml_string_equal(str,spacing_char)?cst$1:str;
                return caml_call3(Stdlib_format[126],fmt,_aQ_,str$0)}
              return caml_call2(Stdlib_list[17],_lL_,lst)},
           is_code_writable=
            function(codes)
             {return caml_call2(Stdlib_list[32],is_code_available,codes)},
           first_code=
            function(f,codes)
             {var codes$0=codes;
              for(;;)
               {if(codes$0)
                 {var codes$1=codes$0[2],code=codes$0[1];
                  if(caml_call1(f,code))return code;
                  var codes$0=codes$1;
                  continue}
                throw Stdlib[8]}},
           first_writable_code=
            function(codes){return first_code(is_code_writable,codes)},
           is_code_writable_or_one_eof=
            function(code)
             {function _lG_(c){return c !== 255?1:0}
              var
               _lH_=
                is_code_writable(caml_call2(Stdlib_list[41],_lG_,code));
              if(_lH_)
               var
                _lI_=0,
                _lJ_=function(nb,c){return c === 255?nb + 1 | 0:nb},
                _lK_=caml_call3(Stdlib_list[25],_lJ_,_lI_,code) <= 1?1:0;
              else
               var _lK_=_lH_;
              return _lK_},
           preferred_code=
            function(codes)
             {try
               {var _lD_=first_writable_code(codes);return _lD_}
              catch(_lE_)
               {_lE_ = caml_wrap_exception(_lE_);
                if(_lE_ === Stdlib[8])
                 try
                  {var _lC_=first_code(is_code_writable_or_one_eof,codes);
                   return _lC_}
                 catch(_lF_)
                  {_lF_ = caml_wrap_exception(_lF_);
                   if(_lF_ === Stdlib[8])
                    return caml_call1(Stdlib_list[5],codes);
                   throw _lF_}
                throw _lE_}},
           is_full_of_spaces=
            function(codes)
             {function _lB_(c){return c === 0?1:0}
              return caml_call2(Stdlib_list[32],_lB_,codes)},
           Name=
            [0,
             eof,
             space,
             codes_for_command,
             command_for_codes,
             chars_for_command,
             codes_to_chars,
             pp_chars,
             pp_chars_raw,
             is_code_writable,
             first_writable_code,
             preferred_code,
             is_full_of_spaces];
          caml_register_global(492,Name,"Name");
          var
           CannotOptimize=
            [248,cst_Optimizer_CannotOptimize,caml_fresh_oo_id(0)],
           compare=Stdlib_int32[16],
           UInt32=[0,compare],
           UInt32Set=caml_call1(Stdlib_set[1],UInt32),
           padding_code=[0,Stdlib_int32[1]],
           acc$1=0,
           i$2=Stdlib_int32[1],
           max=255;
          for(;;)
           {if(caml_call2(Stdlib_int32[17],i$2,max))
             {var
               immed8=[0,i$2,acc$1],
               _aR_=
                function(i){return is_code_writable([0,uint32_to_int(i),0])},
               immed8$0=caml_call2(Stdlib_list[41],_aR_,immed8),
               _aS_=
                function(i$1)
                 {var acc$1=[0,i$1,0],acc=acc$1,i=i$1;
                  for(;;)
                   {var i$0=rotate_right(rotate_right(i));
                    if(caml_call2(Stdlib_int32[17],i$0,i$1))return acc;
                    var acc$0=[0,i$0,acc],acc=acc$0,i=i$0;
                    continue}},
               _aT_=caml_call2(Stdlib_list[19],_aS_,immed8$0),
               _aU_=caml_call1(Stdlib_list[14],_aT_),
               constants_set=caml_call1(UInt32Set[37],_aU_),
               _aV_=
                function(i)
                 {return 1
                         -
                         (caml_call2(Stdlib_int32[15],i,Stdlib_int32[1]) < 0?1:0)},
               constants_set_no_carry=
                caml_call2(UInt32Set[19],_aV_,constants_set),
               constants=caml_call1(UInt32Set[23],constants_set),
               rev_constants=caml_call1(Stdlib_list[9],constants),
               nset=caml_call2(UInt32Set[15],Stdlib_int32[11],constants_set),
               _aW_=caml_call2(UInt32Set[7],constants_set_no_carry,nset),
               _aX_=caml_call2(UInt32Set[6],Stdlib_int32[1],_aW_),
               constants_mov_mvn=caml_call1(UInt32Set[23],_aX_),
               nset$0=caml_call2(UInt32Set[15],Stdlib_int32[11],constants_set),
               _aY_=caml_call2(UInt32Set[7],constants_set,nset$0),
               constants_mov_mvn_strict=caml_call1(UInt32Set[23],_aY_),
               rev_constants_mov_mvn=
                caml_call1(Stdlib_list[9],constants_mov_mvn),
               rev_constants_mov_mvn_strict=
                caml_call1(Stdlib_list[9],constants_mov_mvn_strict),
               tad0=_aZ_.slice(),
               remove_while=
                function(f,lst)
                 {var lst$0=lst;
                  for(;;)
                   {if(lst$0)
                     {var lst$1=lst$0[2],i=lst$0[1];
                      if(caml_call1(f,i)){var lst$0=lst$1;continue}
                      return lst$0}
                    return 0}},
               synthesis=
                function
                 (constants_cat,
                  additive,
                  incr,
                  max_card,
                  i,
                  is_valid_fst,
                  is_valid)
                 {var tad0_len=tad0.length - 1;
                  if(tad0_len < max_card)
                   var
                    _lq_=tad0_len - 1 | 0,
                    tad0$0=caml_check_bound(tad0,_lq_)[1 + _lq_];
                  else
                   var
                    _ls_=max_card - 1 | 0,
                    tad0$0=caml_check_bound(tad0,_ls_)[1 + _ls_];
                  function remove(i)
                   {function _lz_(j)
                     {return caml_call2(Stdlib_int32[16],i,j) < 0?1:0}
                    return function(_lA_){return remove_while(_lz_,_lA_)}}
                  function next(acc,rc,i)
                   {var rc$0=rc;
                    for(;;)
                     {if(caml_call2(Stdlib_int32[17],i,Stdlib_int32[1]))
                       return [0,acc];
                      var depth=caml_call1(Stdlib_list[1],acc);
                      if(max_card <= depth)return 0;
                      var
                       rem_depth=caml_int64_of_int32(max_card - depth | 0),
                       i64=int64_of_uint32(i),
                       ii=incr?caml_call1(Stdlib_int32[7],i):i,
                       match=caml_call1(remove(ii),rc$0);
                      if(match)
                       {var
                         fst=match[1],
                         _lx_=incr?caml_call1(Stdlib_int32[6],fst):fst,
                         _ly_=runtime.caml_int64_mul(int64_of_uint32(_lx_),rem_depth);
                        if(0 <= caml_call2(Stdlib_int64[16],_ly_,i64))
                         {var
                           rc$1=match[2],
                           remainder=ii - fst | 0,
                           match$0=next([0,fst,acc],[0,fst,rc$1],remainder);
                          if(match$0){var res=match$0[1];return [0,res]}
                          var rc$0=rc$1;
                          continue}
                        return 0}
                      return 0}}
                  var
                   filtered_rev_constants=
                    caml_call2(Stdlib_list[41],is_valid,rev_constants),
                   remove_init=
                    additive
                     ?remove
                     :function(i)
                       {function _lv_(j)
                         {return 0 < caml_call2(Stdlib_int32[16],i,j)?1:0}
                        return function(_lw_){return remove_while(_lv_,_lw_)}},
                   op_init=
                    additive
                     ?function(_lu_,_lt_){return _lu_ - _lt_ | 0}
                     :function(x,y){return y - x | 0};
                  if(additive)
                   switch(constants_cat)
                    {case 0:var init_rc=rev_constants;break;
                     case 1:var init_rc=rev_constants_mov_mvn;break;
                     default:var init_rc=rev_constants_mov_mvn_strict}
                  else
                   switch(constants_cat)
                    {case 0:var init_rc=constants;break;
                     case 1:var init_rc=constants_mov_mvn;break;
                     default:var init_rc=constants_mov_mvn_strict}
                  var
                   rc$1=caml_call2(Stdlib_list[41],is_valid_fst,init_rc),
                   try_nb=0,
                   rc=rc$1;
                  for(;;)
                   {if(tad0$0 <= try_nb)
                     var _lr_=0;
                    else
                     {var match=caml_call1(remove_init(i),rc);
                      if(match)
                       {var
                         rc$0=match[2],
                         fst=match[1],
                         remainder=op_init(i,fst),
                         match$0=next([0,fst,0],filtered_rev_constants,remainder);
                        if(! match$0)
                         {var try_nb$0=try_nb + 1 | 0,try_nb=try_nb$0,rc=rc$0;
                          continue}
                        var res=match$0[1],_lr_=[0,res]}
                      else
                       var _lr_=0}
                    if(_lr_)
                     {var lst=_lr_[1];return [0,caml_call1(Stdlib_list[9],lst)]}
                    return 0}},
               synthesis_optimal=
                function
                 (constants_cat,
                  incr_add,
                  incr_sub,
                  max_card,
                  i,
                  is_valid_fst,
                  is_valid)
                 {var card=1;
                  for(;;)
                   {if(max_card < card)return 0;
                    var
                     match=
                      synthesis
                       (constants_cat,
                        1,
                        incr_add,
                        card,
                        i,
                        is_valid_fst,
                        caml_call1(is_valid,1));
                    if(match){var lst=match[1];return [0,[0,lst,1]]}
                    var
                     match$0=
                      synthesis
                       (constants_cat,
                        0,
                        incr_sub,
                        card,
                        i,
                        is_valid_fst,
                        caml_call1(is_valid,0));
                    if(match$0){var lst$0=match$0[1];return [0,[0,lst$0,0]]}
                    var card$0=card + 1 | 0,card=card$0;
                    continue}},
               synthesis_test=
                function(max_card,i)
                 {function _lo_(param,_lp_){return 1}
                  return synthesis_optimal
                          (1,0,1,max_card,i,function(param){return 1},_lo_)},
               is_command_valid=
                function(arm)
                 {try
                   {var
                     _lk_=arm_to_binary(arm),
                     _ll_=
                      function(i){return is_code_writable(codes_for_command(i))},
                     _lm_=caml_call2(Stdlib_list[33],_ll_,_lk_);
                    return _lm_}
                  catch(_ln_)
                   {_ln_ = caml_wrap_exception(_ln_);
                    if(_ln_ === InvalidCommand)return 0;
                    throw _ln_}},
               tweak_command=
                function(param)
                 {var
                   optimize=param[2],
                   arm=param[1],
                   strict=tweaker_mode[1]?0:1;
                  function optimize_with_card(arm,n,pad)
                   {var switch$0=0;
                    switch(arm[0])
                     {case 2:
                       var
                        rs=arm[5],
                        rd=arm[4],
                        cond=arm[3],
                        s=arm[2],
                        instr=arm[1],
                        cmd=[2,instr,s,cond,rd,rs];
                       switch(rs[0])
                        {case 0:
                          var
                           i=rs[1],
                           mk_cmd_first=
                            function(fst)
                             {var
                               nfst=caml_call1(Stdlib_int32[11],fst),
                               constant_set_mov=strict?constants_set:constants_set_no_carry,
                               _li_=0 === instr?1:0,
                               _lj_=_li_?caml_call2(UInt32Set[3],fst,constant_set_mov):_li_,
                               is_mov=
                                _lj_
                                ||
                                1
                                -
                                caml_call2(UInt32Set[3],nfst,constants_set);
                              return is_mov
                                      ?strict?[2,0,s,cond,rd,[0,fst]]:[2,0,1,cond,rd,[0,fst]]
                                      :strict?[2,1,s,cond,rd,[0,nfst]]:[2,1,0,cond,rd,[0,nfst]]},
                           mk_cmd=
                            function(additive,i)
                             {if(additive)
                               {if(strict)return [3,4,s,cond,rd,rd,[0,i]];
                                var
                                 _lg_=15 === rd?1:0,
                                 _lf_=[0,i],
                                 _lh_=_lg_ || (0 === rd?1:0);
                                return [3,0,_lh_,cond,rd,rd,_lf_]}
                              return strict
                                      ?[3,5,s,cond,rd,rd,[0,i]]
                                      :[3,1,0,cond,rd,rd,[0,i]]},
                           i$0=0 === instr?i:caml_call1(Stdlib_int32[11],i),
                           _kL_=function(add,i){return is_command_valid(mk_cmd(add,i))},
                           _kM_=function(i){return is_command_valid(mk_cmd_first(i))},
                           _kN_=1 - strict,
                           _kO_=0,
                           _kP_=strict?2:1,
                           match=synthesis_optimal(_kP_,_kO_,_kN_,n,i$0,_kM_,_kL_);
                          if(match)
                           {var _kQ_=match[1],_kR_=_kQ_[1];
                            if(! _kR_)throw [0,Assert_failure,_a0_];
                            var
                             additive=_kQ_[2],
                             lst=_kR_[2],
                             fst=_kR_[1],
                             _kS_=function(_le_){return mk_cmd(additive,_le_)},
                             _kT_=caml_call2(Stdlib_list[19],_kS_,lst),
                             _k6_=[0,mk_cmd_first(fst),_kT_]}
                          else
                           var _k6_=[0,cmd,0];
                          break;
                         case 1:var _k6_=[0,cmd,0];break;
                         default:var _k6_=caml_call1(Stdlib[2],cst_Not_implemented$1)}
                       var res=_k6_;
                       break;
                      case 3:
                       var
                        op2=arm[6],
                        rn=arm[5],
                        rd$0=arm[4],
                        cond$0=arm[3],
                        s$0=arm[2],
                        instr$0=arm[1],
                        switch$1=0;
                       if
                        (0
                         !==
                         instr$0
                         &&
                         1
                         !==
                         instr$0
                         &&
                         4
                         !==
                         instr$0
                         &&
                         5
                         !==
                         instr$0)
                        {switch$0 = 1;switch$1 = 1}
                       if(! switch$1)
                        {if
                          (0
                           !==
                           instr$0
                           &&
                           1
                           !==
                           instr$0
                           &&
                           4
                           !==
                           instr$0
                           &&
                           5
                           !==
                           instr$0)
                          throw [0,Assert_failure,_a2_];
                         var cmd$0=[3,instr$0,s$0,cond$0,rd$0,rn,op2];
                         switch(op2[0])
                          {case 0:
                            var i$1=op2[1],switch$2=0;
                            if(! strict && 5 === instr$0)
                             {var i$2=caml_call1(Stdlib_int32[7],i$1);switch$2 = 1}
                            if(! switch$2)var i$2=i$1;
                            var
                             _kU_=0 === instr$0?1:0,
                             is_addition=_kU_ || (4 === instr$0?1:0),
                             mk_cmd_first$0=
                              function(fst)
                               {if(strict)return [3,instr$0,s$0,cond$0,rd$0,rn,[0,fst]];
                                if(is_addition)
                                 {var
                                   _lc_=15 === rn?1:0,
                                   _lb_=[0,fst],
                                   _ld_=_lc_ || (0 === rn?1:0);
                                  return [3,0,_ld_,cond$0,rd$0,rn,_lb_]}
                                return [3,1,0,cond$0,rd$0,rn,[0,fst]]},
                             mk_cmd$0=
                              function(additive,i)
                               {var is_addition$0=additive?is_addition:additive;
                                if(is_addition$0)
                                 var must_add=is_addition$0;
                                else
                                 var _la_=1 - additive,must_add=_la_?1 - is_addition:_la_;
                                if(must_add)
                                 {if(strict)return [3,4,s$0,cond$0,rd$0,rd$0,[0,i]];
                                  var
                                   _k__=15 === rd$0?1:0,
                                   _k9_=[0,i],
                                   _k$_=_k__ || (0 === rd$0?1:0);
                                  return [3,0,_k$_,cond$0,rd$0,rd$0,_k9_]}
                                return strict
                                        ?[3,5,s$0,cond$0,rd$0,rd$0,[0,i]]
                                        :[3,1,0,cond$0,rd$0,rd$0,[0,i]]},
                             _kV_=
                              function(add,i){return is_command_valid(mk_cmd$0(add,i))},
                             _kW_=function(i){return is_command_valid(mk_cmd_first$0(i))},
                             _kX_=is_addition?1 - strict:is_addition,
                             _kY_=1 - is_addition,
                             _kZ_=_kY_?1 - strict:_kY_,
                             match$0=synthesis_optimal(0,_kZ_,_kX_,n,i$2,_kW_,_kV_);
                            if(match$0)
                             {var _k0_=match$0[1],_k1_=_k0_[1];
                              if(! _k1_)throw [0,Assert_failure,_a1_];
                              var
                               additive$0=_k0_[2],
                               lst$0=_k1_[2],
                               fst$0=_k1_[1],
                               _k2_=function(_k8_){return mk_cmd$0(additive$0,_k8_)},
                               _k3_=caml_call2(Stdlib_list[19],_k2_,lst$0),
                               _k7_=[0,mk_cmd_first$0(fst$0),_k3_]}
                            else
                             var _k7_=[0,cmd$0,0];
                            break;
                           case 1:var _k7_=[0,cmd$0,0];break;
                           default:var _k7_=caml_call1(Stdlib[2],cst_Not_implemented$2)}
                         var res=_k7_}
                       break;
                      default:switch$0 = 1}
                    if(switch$0)var res=[0,arm,0];
                    if(pad)
                     {var
                       _k4_=function(param){return padding_code},
                       _k5_=n - caml_call1(Stdlib_list[1],res) | 0,
                       padding=caml_call2(Stdlib_list[10],_k5_,_k4_);
                      return caml_call2(Stdlib[37],res,padding)}
                    return res}
                  if(typeof optimize === "number")
                   return optimize?optimize_with_card(arm,5,0):[0,arm,0];
                  var card=optimize[1];
                  return optimize_with_card(arm,card,1)},
               tweak_arm=
                function(lst)
                 {var _kK_=caml_call2(Stdlib_list[19],tweak_command,lst);
                  return caml_call1(Stdlib_list[14],_kK_)},
               do_not_tweak_arm=
                function(lst)
                 {function _kJ_(param)
                   {var optimize=param[2],arm=param[1];
                    if(0 === optimize)return arm;
                    throw CannotOptimize}
                  return caml_call2(Stdlib_list[19],_kJ_,lst)},
               Optimizer=
                [0,CannotOptimize,synthesis_test,tweak_arm,do_not_tweak_arm];
              caml_register_global(494,Optimizer,"Optimizer");
              var
               CommandError=
                [248,cst_Parser_ast_CommandError,caml_fresh_oo_id(0)],
               StructError=
                [248,cst_Parser_ast_StructError,caml_fresh_oo_id(0)],
               preprocess=
                function(env,ui)
                 {if(0 === ui[0]){var i=ui[1];return i}
                  var e=ui[1];
                  return eval_meta_expr(env,e)},
               combine_opt=
                function(o1,o2)
                 {if(o1)
                   {var _kI_=o1[1];if(o2)throw StructError;var s=_kI_}
                  else
                   {if(! o2)return 0;var s=o2[1]}
                  return [0,s]},
               combine_bool=
                function(b1,b2)
                 {if(b1){if(b2)throw StructError}else if(! b2)return 0;
                  return 1},
               recognize_modifiers=
                function(str$3,i)
                 {var n$2=caml_ml_string_length(str$3),mods$1=mods,i$0=i;
                  for(;;)
                   {if(n$2 <= i$0)return mods$1;
                    var
                     n=caml_ml_string_length(str$3),
                     _ky_=caml_call2(Stdlib[16],2,n - i$0 | 0),
                     str=caml_call3(Stdlib_string[9],str$3,i$0,_ky_),
                     switch$0=caml_string_compare(str,cst_LE),
                     switch$1=0;
                    if(0 <= switch$0)
                     if(0 < switch$0)
                      if(caml_string_notequal(str,cst_LO))
                       if(caml_string_notequal(str,cst_LS))
                        if(caml_string_notequal(str,cst_LT))
                         if(caml_string_notequal(str,cst_MI))
                          if(caml_string_notequal(str,cst_NE))
                           if(caml_string_notequal(str,cst_PL))
                            if(caml_string_notequal(str,cst_VC))
                             if(caml_string_notequal(str,cst_VS))
                              switch$1 = 1;
                             else
                              var _kC_=[0,_a3_,i$0 + 2 | 0];
                            else
                             var _kC_=[0,_a4_,i$0 + 2 | 0];
                           else
                            var _kC_=[0,_a5_,i$0 + 2 | 0];
                          else
                           var _kC_=[0,_a6_,i$0 + 2 | 0];
                         else
                          var _kC_=[0,_a7_,i$0 + 2 | 0];
                        else
                         var _kC_=[0,_a8_,i$0 + 2 | 0];
                       else
                        var _kC_=[0,_a9_,i$0 + 2 | 0];
                      else
                       var _kC_=[0,_a__,i$0 + 2 | 0];
                     else
                      var _kC_=[0,_a$_,i$0 + 2 | 0];
                    else
                     if(caml_string_notequal(str,cst_AL))
                      if(caml_string_notequal(str,cst_CC))
                       if(caml_string_notequal(str,cst_CS))
                        if(caml_string_notequal(str,cst_EQ))
                         if(caml_string_notequal(str,cst_GE))
                          if(caml_string_notequal(str,cst_GT))
                           if(caml_string_notequal(str,cst_HI))
                            if(caml_string_notequal(str,cst_HS))
                             switch$1 = 1;
                            else
                             var _kC_=[0,_ba_,i$0 + 2 | 0];
                           else
                            var _kC_=[0,_bb_,i$0 + 2 | 0];
                          else
                           var _kC_=[0,_bc_,i$0 + 2 | 0];
                         else
                          var _kC_=[0,_bd_,i$0 + 2 | 0];
                        else
                         var _kC_=[0,_be_,i$0 + 2 | 0];
                       else
                        var _kC_=[0,_bf_,i$0 + 2 | 0];
                      else
                       var _kC_=[0,_bg_,i$0 + 2 | 0];
                     else
                      var _kC_=[0,_bh_,i$0 + 2 | 0];
                    if(switch$1)var _kC_=[0,0,i$0];
                    var _kD_=_kC_[1];
                    if(_kD_)
                     var i$1=_kC_[2],c=_kD_[1],i$2=i$1,nmods=[0,[0,c],0,0,0,0];
                    else
                     {var
                       i$3=_kC_[2],
                       n$0=caml_ml_string_length(str$3),
                       _kz_=caml_call2(Stdlib[16],2,n$0 - i$3 | 0),
                       str$0=caml_call3(Stdlib_string[9],str$3,i$3,_kz_);
                      if(caml_string_notequal(str$0,cst_BT))
                       if(caml_string_notequal(str$0,cst_SB))
                        if(caml_string_notequal(str$0,cst_SH))
                         var
                          _kA_=caml_call2(Stdlib[16],1,n$0 - i$3 | 0),
                          str$1=caml_call3(Stdlib_string[9],str$0,0,_kA_),
                          _kE_=
                           caml_string_notequal(str$1,cst_B)
                            ?caml_string_notequal(str$1,cst_H)
                              ?caml_string_notequal(str$1,cst_T)
                                ?caml_string_notequal(str$1,cst_W)
                                  ?[0,0,i$3]
                                  :[0,_bi_,i$3 + 1 | 0]
                                :[0,_bj_,i$3 + 1 | 0]
                              :[0,_bk_,i$3 + 1 | 0]
                            :[0,_bl_,i$3 + 1 | 0];
                        else
                         var _kE_=[0,_bm_,i$3 + 2 | 0];
                       else
                        var _kE_=[0,_bn_,i$3 + 2 | 0];
                      else
                       var _kE_=[0,_bo_,i$3 + 2 | 0];
                      var _kF_=_kE_[1];
                      if(_kF_)
                       var
                        i$4=_kE_[2],
                        lst$2=_kF_[1],
                        i$2=i$4,
                        nmods=[0,0,[0,lst$2],0,0,0];
                      else
                       {var
                         i$5=_kE_[2],
                         n$1=caml_ml_string_length(str$3),
                         _kB_=caml_call2(Stdlib[16],1,n$1 - i$5 | 0),
                         str$2=caml_call3(Stdlib_string[9],str$3,i$5,_kB_),
                         match=
                          caml_string_notequal(str$2,cst_L)
                           ?caml_string_notequal(str$2,cst_S)
                             ?caml_string_notequal(str$2,cst_X)
                               ?[0,0,i$5]
                               :[0,_bp_,i$5 + 1 | 0]
                             :[0,_bq_,i$5 + 1 | 0]
                           :[0,_br_,i$5 + 1 | 0],
                         _kG_=match[1],
                         switch$2=0;
                        if(_kG_)
                         {var _kH_=_kG_[1];
                          if(caml_string_notequal(_kH_,cst_L$0))
                           if(caml_string_notequal(_kH_,cst_S$0))
                            if(caml_string_notequal(_kH_,cst_X$0))
                             switch$2 = 1;
                            else
                             var i$6=match[2],i$2=i$6,nmods=_bs_;
                           else
                            var i$7=match[2],i$2=i$7,nmods=_bt_;
                          else
                           var i$8=match[2],i$2=i$8,nmods=_bu_}
                        else
                         switch$2 = 1;
                        if(switch$2)throw StructError}}
                    var
                     x=nmods[5],
                     l=nmods[4],
                     s=nmods[3],
                     lst=nmods[2],
                     cond=nmods[1],
                     x$0=mods$1[5],
                     l$0=mods$1[4],
                     s$0=mods$1[3],
                     lst$0=mods$1[2],
                     cond$0=mods$1[1],
                     cond$1=combine_opt(cond$0,cond),
                     lst$1=combine_opt(lst$0,lst),
                     s$1=combine_bool(s$0,s),
                     l$1=combine_bool(l$0,l),
                     x$1=combine_bool(x$0,x),
                     mods$0=[0,cond$1,lst$1,s$1,l$1,x$1],
                     mods$1=mods$0,
                     i$0=i$2;
                    continue}},
               register_of_str=
                function(str)
                 {var
                   str$0=caml_call1(Stdlib_string[16],str),
                   switch$0=caml_string_compare(str$0,cst_r15);
                  if(0 <= switch$0)
                   {if(! (0 < switch$0))return 15;
                    var switch$1=caml_string_compare(str$0,cst_r7);
                    if(0 <= switch$1)
                     {if(! (0 < switch$1))return 7;
                      if(! caml_string_notequal(str$0,cst_r8))return 8;
                      if(! caml_string_notequal(str$0,cst_r9))return 9;
                      if(! caml_string_notequal(str$0,cst_sb))return sb;
                      if(! caml_string_notequal(str$0,cst_sl))return sl;
                      if(! caml_string_notequal(str$0,cst_sp))return sp}
                    else
                     {if(! caml_string_notequal(str$0,cst_r2))return 2;
                      if(! caml_string_notequal(str$0,cst_r3))return 3;
                      if(! caml_string_notequal(str$0,cst_r4))return 4;
                      if(! caml_string_notequal(str$0,cst_r5))return 5;
                      if(! caml_string_notequal(str$0,cst_r6))return 6}}
                  else
                   {var switch$2=caml_string_compare(str$0,cst_r1);
                    if(0 <= switch$2)
                     {if(! (0 < switch$2))return 1;
                      if(! caml_string_notequal(str$0,cst_r10))return 10;
                      if(! caml_string_notequal(str$0,cst_r11))return 11;
                      if(! caml_string_notequal(str$0,cst_r12))return 12;
                      if(! caml_string_notequal(str$0,cst_r13))return 13;
                      if(! caml_string_notequal(str$0,cst_r14))return 14}
                    else
                     {if(! caml_string_notequal(str$0,cst_fp))return fp;
                      if(! caml_string_notequal(str$0,cst_ip))return ip;
                      if(! caml_string_notequal(str$0,cst_lr))return lr;
                      if(! caml_string_notequal(str$0,cst_pc))return pc;
                      if(! caml_string_notequal(str$0,cst_r0))return 0}}
                  throw StructError},
               get_register=
                function(arg)
                 {if(0 === arg[0]){var str=arg[1];return register_of_str(str)}
                  throw StructError},
               get_rd=
                function(args)
                 {return get_register(caml_call1(Stdlib_list[5],args))},
               get_rn=
                function(args)
                 {var n=caml_call1(Stdlib_list[1],args);
                  return get_register
                          (caml_call2(Stdlib_list[7],args,n - 2 | 0))},
               get_op2=
                function(env,args)
                 {var
                   n=caml_call1(Stdlib_list[1],args),
                   arg=caml_call2(Stdlib_list[7],args,n - 1 | 0);
                  switch(arg[0])
                   {case 0:var str=arg[1];return [1,register_of_str(str)];
                    case 1:var i=arg[1];return [0,preprocess(env,i)];
                    default:throw StructError}},
               get_ro=
                function(env,args)
                 {var
                   n=caml_call1(Stdlib_list[1],args),
                   match=caml_call2(Stdlib_list[7],args,n - 1 | 0);
                  if(2 === match[0])
                   {var
                     addr_typ=match[3],
                     offset=match[2],
                     str=match[1],
                     r=register_of_str(str);
                    if(0 === offset[0])
                     var
                      i=offset[2],
                      sign=offset[1],
                      ro=[0,r,sign,preprocess(env,i)];
                    else
                     var
                      str$0=offset[2],
                      sign$0=offset[1],
                      ro=[1,r,sign$0,register_of_str(str$0)];
                    return [0,ro,addr_typ]}
                  throw StructError},
               get_target=
                function(env,args)
                 {var arg=caml_call1(Stdlib_list[5],args);
                  if(1 === arg[0]){var i=arg[1];return preprocess(env,i)}
                  throw StructError},
               cmd_to_arm=
                function(env,cmd$1)
                 {if(0 === cmd$1[0])
                   {var
                     optimize=cmd$1[4],
                     args=cmd$1[3],
                     cmd$2=cmd$1[2],
                     pos=cmd$1[1];
                    try
                     {try
                       {if(caml_ml_string_length(cmd$2) < 3)throw StructError;
                        var
                         cmd=caml_call1(Stdlib_string[15],cmd$2),
                         match=recognize_modifiers(cmd,3),
                         s=match[3],
                         typ=match[2],
                         cond=match[1];
                        if(cond)var c=cond[1],cond$0=c;else var cond$0=16;
                        if(typ)var typ$0=typ[1],typ$1=typ$0;else var typ$1=4;
                        try
                         {var
                           match$0=caml_call3(Stdlib_string[9],cmd,0,3),
                           switch$0=caml_string_compare(match$0,cst_MOV),
                           switch$1=0;
                          if(0 <= switch$0)
                           if(0 < switch$0)
                            if(caml_string_notequal(match$0,cst_MVN))
                             if(caml_string_notequal(match$0,cst_ORR))
                              if(caml_string_notequal(match$0,cst_SBC))
                               if(caml_string_notequal(match$0,cst_STR))
                                if(caml_string_notequal(match$0,cst_SUB))
                                 switch$1 = 1;
                                else
                                 var
                                  _j8_=get_op2(env,args),
                                  _j9_=get_rn(args),
                                  _j__=[3,5,s,cond$0,get_rd(args),_j9_,_j8_];
                               else
                                var
                                 _j$_=get_ro(env,args),
                                 _j__=[1,1,typ$1,cond$0,get_rd(args),_j$_];
                              else
                               var
                                _ka_=get_op2(env,args),
                                _kb_=get_rn(args),
                                _j__=[3,1,s,cond$0,get_rd(args),_kb_,_ka_];
                             else
                              var
                               _kc_=get_op2(env,args),
                               _kd_=get_rn(args),
                               _j__=[3,6,s,cond$0,get_rd(args),_kd_,_kc_];
                            else
                             var
                              _ke_=get_op2(env,args),
                              _j__=[2,1,s,cond$0,get_rd(args),_ke_];
                           else
                            var
                             _kf_=get_op2(env,args),
                             _j__=[2,0,s,cond$0,get_rd(args),_kf_];
                          else
                           if(caml_string_notequal(match$0,cst_ADC))
                            if(caml_string_notequal(match$0,cst_ADD))
                             if(caml_string_notequal(match$0,cst_AND))
                              if(caml_string_notequal(match$0,cst_BIC))
                               if(caml_string_notequal(match$0,cst_EOR))
                                if(caml_string_notequal(match$0,cst_LDR))
                                 switch$1 = 1;
                                else
                                 var
                                  _kg_=get_ro(env,args),
                                  _j__=[1,0,typ$1,cond$0,get_rd(args),_kg_];
                               else
                                var
                                 _kh_=get_op2(env,args),
                                 _ki_=get_rn(args),
                                 _j__=[3,7,s,cond$0,get_rd(args),_ki_,_kh_];
                              else
                               var
                                _kj_=get_op2(env,args),
                                _kk_=get_rn(args),
                                _j__=[3,2,s,cond$0,get_rd(args),_kk_,_kj_];
                             else
                              var
                               _kl_=get_op2(env,args),
                               _km_=get_rn(args),
                               _j__=[3,3,s,cond$0,get_rd(args),_km_,_kl_];
                            else
                             var
                              _kn_=get_op2(env,args),
                              _ko_=get_rn(args),
                              _j__=[3,4,s,cond$0,get_rd(args),_ko_,_kn_];
                           else
                            var
                             _kp_=get_op2(env,args),
                             _kq_=get_rn(args),
                             _j__=[3,0,s,cond$0,get_rd(args),_kq_,_kp_];
                          if(switch$1)throw StructError}
                        catch(_kx_)
                         {_kx_ = caml_wrap_exception(_kx_);
                          if(_kx_[1] !== Stdlib[7] && _kx_[1] !== Stdlib[6])
                           throw _kx_;
                          throw StructError}
                        var _ks_=_j__}
                      catch(_kv_)
                       {_kv_ = caml_wrap_exception(_kv_);
                        if(_kv_ !== StructError)throw _kv_;
                        if(caml_ml_string_length(cmd$2) < 1)throw StructError;
                        var
                         cmd$0=caml_call1(Stdlib_string[15],cmd$2),
                         match$1=recognize_modifiers(cmd$0,1),
                         x=match$1[5],
                         l=match$1[4],
                         cond$1=match$1[1];
                        if(cond$1)var c$0=cond$1[1],cond$2=c$0;else var cond$2=16;
                        try
                         {var match$2=caml_call3(Stdlib_string[9],cmd$0,0,1);
                          if(caml_string_notequal(match$2,cst_B$0))throw StructError;
                          var
                           _kr_=
                            x
                             ?[5,l,cond$2,get_rd(args)]
                             :[4,l,cond$2,get_target(env,args)]}
                        catch(_kw_)
                         {_kw_ = caml_wrap_exception(_kw_);
                          if(_kw_[1] !== Stdlib[7] && _kw_[1] !== Stdlib[6])
                           throw _kw_;
                          throw StructError}
                        var _ks_=_kr_}
                      var _kt_=[0,_ks_,optimize];
                      return _kt_}
                    catch(_ku_)
                     {_ku_ = caml_wrap_exception(_ku_);
                      if(_ku_ === StructError)throw [0,CommandError,pos];
                      throw _ku_}}
                  var i=cmd$1[2];
                  return [0,[0,preprocess(env,i)],0]},
               to_arm=
                function(env,ast)
                 {function _j6_(_j7_){return cmd_to_arm(env,_j7_)}
                  return caml_call2(Stdlib_list[19],_j6_,ast)},
               Parser_ast=[0,CommandError,to_arm];
              caml_register_global(495,Parser_ast,"Parser_ast");
              var
               eRR=[248,cst_Parser_MenhirBasics_Error,caml_fresh_oo_id(0)],
               menhir_discard=
                function(menhir_env)
                 {var
                   lexer=menhir_env[1],
                   lexbuf=menhir_env[2],
                   tok=caml_call1(lexer,lexbuf);
                  return [0,lexer,lexbuf,tok,0]},
               menhir_errorcase=
                function(menhir_env,menhir_stack,menhir_s)
                 {var menhir_stack$0=menhir_stack,menhir_s$0=menhir_s;
                  for(;;)
                   switch(menhir_s$0)
                    {case 0:
                      var
                       match=menhir_stack$0[1],
                       menhir_s$1=match[2],
                       menhir_stack$1=match[1],
                       menhir_stack$0=menhir_stack$1,
                       menhir_s$0=menhir_s$1;
                      continue;
                     case 1:throw eRR;
                     case 2:throw eRR;
                     case 3:throw eRR;
                     case 4:
                      var
                       menhir_s$2=menhir_stack$0[2],
                       menhir_stack$2=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$2,
                       menhir_s$0=menhir_s$2;
                      continue;
                     case 5:
                      var
                       menhir_s$3=menhir_stack$0[2],
                       menhir_stack$3=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$3,
                       menhir_s$0=menhir_s$3;
                      continue;
                     case 6:
                      var
                       menhir_s$4=menhir_stack$0[2],
                       menhir_stack$4=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$4,
                       menhir_s$0=menhir_s$4;
                      continue;
                     case 7:
                      var
                       match$0=menhir_stack$0[1],
                       menhir_s$5=match$0[2],
                       menhir_stack$5=match$0[1],
                       menhir_stack$0=menhir_stack$5,
                       menhir_s$0=menhir_s$5;
                      continue;
                     case 8:
                      var
                       menhir_s$6=menhir_stack$0[2],
                       menhir_stack$6=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$6,
                       menhir_s$0=menhir_s$6;
                      continue;
                     case 9:
                      var
                       menhir_s$7=menhir_stack$0[2],
                       menhir_stack$7=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$7,
                       menhir_s$0=menhir_s$7;
                      continue;
                     case 10:
                      var
                       menhir_s$8=menhir_stack$0[2],
                       menhir_stack$8=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$8,
                       menhir_s$0=menhir_s$8;
                      continue;
                     case 11:
                      var
                       menhir_s$9=menhir_stack$0[2],
                       menhir_stack$9=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$9,
                       menhir_s$0=menhir_s$9;
                      continue;
                     case 12:
                      var
                       menhir_s$10=menhir_stack$0[2],
                       menhir_stack$10=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$10,
                       menhir_s$0=menhir_s$10;
                      continue;
                     case 13:
                      var
                       match$1=menhir_stack$0[1],
                       menhir_s$11=match$1[2],
                       menhir_stack$11=match$1[1],
                       menhir_stack$0=menhir_stack$11,
                       menhir_s$0=menhir_s$11;
                      continue;
                     case 14:
                      var
                       menhir_s$12=menhir_stack$0[2],
                       menhir_stack$12=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$12,
                       menhir_s$0=menhir_s$12;
                      continue;
                     case 15:
                      var
                       menhir_s$13=menhir_stack$0[2],
                       menhir_stack$13=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$13,
                       menhir_s$0=menhir_s$13;
                      continue;
                     case 16:
                      var
                       menhir_s$14=menhir_stack$0[2],
                       menhir_stack$14=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$14,
                       menhir_s$0=menhir_s$14;
                      continue;
                     case 17:
                      var
                       menhir_s$15=menhir_stack$0[2],
                       menhir_stack$15=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$15,
                       menhir_s$0=menhir_s$15;
                      continue;
                     case 18:
                      var
                       menhir_s$16=menhir_stack$0[2],
                       menhir_stack$16=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$16,
                       menhir_s$0=menhir_s$16;
                      continue;
                     case 19:
                      var
                       menhir_s$17=menhir_stack$0[2],
                       menhir_stack$17=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$17,
                       menhir_s$0=menhir_s$17;
                      continue;
                     case 20:
                      var
                       menhir_s$18=menhir_stack$0[2],
                       menhir_stack$18=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$18,
                       menhir_s$0=menhir_s$18;
                      continue;
                     case 21:
                      var
                       menhir_s$19=menhir_stack$0[2],
                       menhir_stack$19=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$19,
                       menhir_s$0=menhir_s$19;
                      continue;
                     case 22:
                      var
                       menhir_s$20=menhir_stack$0[2],
                       menhir_stack$20=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$20,
                       menhir_s$0=menhir_s$20;
                      continue;
                     case 23:
                      var
                       menhir_s$21=menhir_stack$0[2],
                       menhir_stack$21=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$21,
                       menhir_s$0=menhir_s$21;
                      continue;
                     case 24:
                      var
                       menhir_s$22=menhir_stack$0[2],
                       menhir_stack$22=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$22,
                       menhir_s$0=menhir_s$22;
                      continue;
                     case 25:
                      var
                       menhir_s$23=menhir_stack$0[2],
                       menhir_stack$23=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$23,
                       menhir_s$0=menhir_s$23;
                      continue;
                     case 26:
                      var
                       menhir_s$24=menhir_stack$0[2],
                       menhir_stack$24=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$24,
                       menhir_s$0=menhir_s$24;
                      continue;
                     case 27:
                      var
                       menhir_s$25=menhir_stack$0[2],
                       menhir_stack$25=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$25,
                       menhir_s$0=menhir_s$25;
                      continue;
                     case 28:
                      var
                       menhir_s$26=menhir_stack$0[2],
                       menhir_stack$26=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$26,
                       menhir_s$0=menhir_s$26;
                      continue;
                     case 29:
                      var
                       menhir_s$27=menhir_stack$0[2],
                       menhir_stack$27=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$27,
                       menhir_s$0=menhir_s$27;
                      continue;
                     case 30:
                      var
                       menhir_s$28=menhir_stack$0[2],
                       menhir_stack$28=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$28,
                       menhir_s$0=menhir_s$28;
                      continue;
                     case 31:
                      var
                       menhir_s$29=menhir_stack$0[2],
                       menhir_stack$29=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$29,
                       menhir_s$0=menhir_s$29;
                      continue;
                     case 32:
                      var
                       menhir_s$30=menhir_stack$0[2],
                       menhir_stack$30=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$30,
                       menhir_s$0=menhir_s$30;
                      continue;
                     case 33:
                      var
                       menhir_s$31=menhir_stack$0[2],
                       menhir_stack$31=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$31,
                       menhir_s$0=menhir_s$31;
                      continue;
                     case 34:
                      var
                       menhir_s$32=menhir_stack$0[2],
                       menhir_stack$32=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$32,
                       menhir_s$0=menhir_s$32;
                      continue;
                     case 35:
                      var
                       menhir_s$33=menhir_stack$0[2],
                       menhir_stack$33=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$33,
                       menhir_s$0=menhir_s$33;
                      continue;
                     case 36:
                      var
                       menhir_s$34=menhir_stack$0[2],
                       menhir_stack$34=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$34,
                       menhir_s$0=menhir_s$34;
                      continue;
                     case 37:
                      var
                       menhir_s$35=menhir_stack$0[2],
                       menhir_stack$35=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$35,
                       menhir_s$0=menhir_s$35;
                      continue;
                     case 38:
                      var
                       menhir_s$36=menhir_stack$0[2],
                       menhir_stack$36=menhir_stack$0[1],
                       menhir_stack$0=menhir_stack$36,
                       menhir_s$0=menhir_s$36;
                      continue;
                     default:throw eRR}},
               menhir_fail=
                function(param)
                 {caml_call2(Stdlib_printf[1],Stdlib[40],_cv_);
                  throw [0,Assert_failure,_cw_]},
               menhir_goto_ast=
                function(menhir_env,menhir_stack,menhir_s,v)
                 {var menhir_stack$0=menhir_stack,menhir_s$0=menhir_s,v$0=v;
                  for(;;)
                   {if(4 === menhir_s$0)
                     {var
                       cmd=menhir_stack$0[3],
                       match=menhir_stack$0[1],
                       menhir_s$1=match[2],
                       menhir_stack$1=match[1],
                       v$1=[0,cmd,v$0],
                       menhir_stack$0=menhir_stack$1,
                       menhir_s$0=menhir_s$1,
                       v$0=v$1;
                      continue}
                    return 39 <= menhir_s$0?v$0:menhir_fail(0)}},
               menhir_goto_headers=
                function(menhir_env,menhir_stack,menhir_s,v)
                 {var menhir_stack$0=menhir_stack,menhir_s$0=menhir_s,v$0=v;
                  for(;;)
                   {if(3 === menhir_s$0)return v$0;
                    if(menhir_s$0)return menhir_fail(0);
                    var
                     d=menhir_stack$0[2],
                     match=menhir_stack$0[1],
                     menhir_s$1=match[2],
                     menhir_stack$1=match[1],
                     v$1=[0,d,v$0],
                     menhir_stack$0=menhir_stack$1,
                     menhir_s$0=menhir_s$1,
                     v$0=v$1;
                    continue}},
               menhir_run15=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _jX_=30;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_jX_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_jX_]);
                     case 9:
                      var _jY_=30;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jY_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_jY_]);
                     case 12:
                      var _jZ_=30;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jZ_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_jZ_]);
                     case 14:
                      var _j0_=30;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_j0_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_j0_]);
                     case 20:
                      var _j1_=30;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_j1_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_j1_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_j2_=menhir_env$0[2][11],_j3_=30;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_j3_,v,_j2_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_j3_,v,_j2_]);
                     case 2:
                      var v$0=tok[1],_j4_=menhir_env$0[2][11],_j5_=30;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_j5_,v$0,_j4_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_j5_,v$0,_j4_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bv_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,30)},
               menhir_run17=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _jO_=29;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_jO_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_jO_]);
                     case 9:
                      var _jP_=29;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jP_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_jP_]);
                     case 12:
                      var _jQ_=29;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jQ_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_jQ_]);
                     case 14:
                      var _jR_=29;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_jR_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_jR_]);
                     case 20:
                      var _jS_=29;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_jS_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_jS_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_jT_=menhir_env$0[2][11],_jU_=29;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_jU_,v,_jT_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_jU_,v,_jT_]);
                     case 2:
                      var v$0=tok[1],_jV_=menhir_env$0[2][11],_jW_=29;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_jW_,v$0,_jV_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_jW_,v$0,_jV_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bw_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,29)},
               menhir_run19=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _jF_=28;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_jF_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_jF_]);
                     case 9:
                      var _jG_=28;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jG_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_jG_]);
                     case 12:
                      var _jH_=28;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jH_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_jH_]);
                     case 14:
                      var _jI_=28;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_jI_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_jI_]);
                     case 20:
                      var _jJ_=28;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_jJ_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_jJ_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_jK_=menhir_env$0[2][11],_jL_=28;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_jL_,v,_jK_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_jL_,v,_jK_]);
                     case 2:
                      var v$0=tok[1],_jM_=menhir_env$0[2][11],_jN_=28;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_jN_,v$0,_jM_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_jN_,v$0,_jM_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bx_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,28)},
               menhir_run21=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _jw_=27;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_jw_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_jw_]);
                     case 9:
                      var _jx_=27;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jx_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_jx_]);
                     case 12:
                      var _jy_=27;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jy_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_jy_]);
                     case 14:
                      var _jz_=27;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_jz_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_jz_]);
                     case 20:
                      var _jA_=27;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_jA_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_jA_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_jB_=menhir_env$0[2][11],_jC_=27;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_jC_,v,_jB_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_jC_,v,_jB_]);
                     case 2:
                      var v$0=tok[1],_jD_=menhir_env$0[2][11],_jE_=27;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_jE_,v$0,_jD_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_jE_,v$0,_jD_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_by_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,27)},
               menhir_run38=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _jn_=19;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_jn_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_jn_]);
                     case 9:
                      var _jo_=19;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jo_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_jo_]);
                     case 12:
                      var _jp_=19;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jp_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_jp_]);
                     case 14:
                      var _jq_=19;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_jq_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_jq_]);
                     case 20:
                      var _jr_=19;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_jr_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_jr_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_js_=menhir_env$0[2][11],_jt_=19;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_jt_,v,_js_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_jt_,v,_js_]);
                     case 2:
                      var v$0=tok[1],_ju_=menhir_env$0[2][11],_jv_=19;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_jv_,v$0,_ju_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_jv_,v$0,_ju_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bz_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,19)},
               menhir_run29=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _je_=23;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_je_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_je_]);
                     case 9:
                      var _jf_=23;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_jf_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_jf_]);
                     case 12:
                      var _jg_=23;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_jg_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_jg_]);
                     case 14:
                      var _jh_=23;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_jh_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_jh_]);
                     case 20:
                      var _ji_=23;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_ji_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_ji_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_jj_=menhir_env$0[2][11],_jk_=23;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_jk_,v,_jj_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_jk_,v,_jj_]);
                     case 2:
                      var v$0=tok[1],_jl_=menhir_env$0[2][11],_jm_=23;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_jm_,v$0,_jl_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_jm_,v$0,_jl_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bA_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,23)},
               menhir_run23=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _i7_=26;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_i7_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_i7_]);
                     case 9:
                      var _i8_=26;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_i8_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_i8_]);
                     case 12:
                      var _i9_=26;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_i9_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_i9_]);
                     case 14:
                      var _i__=26;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_i__)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_i__]);
                     case 20:
                      var _i$_=26;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_i$_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_i$_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_ja_=menhir_env$0[2][11],_jb_=26;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_jb_,v,_ja_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_jb_,v,_ja_]);
                     case 2:
                      var v$0=tok[1],_jc_=menhir_env$0[2][11],_jd_=26;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_jd_,v$0,_jc_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_jd_,v$0,_jc_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bB_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,26)},
               menhir_run27=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _iY_=24;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_iY_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_iY_]);
                     case 9:
                      var _iZ_=24;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_iZ_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_iZ_]);
                     case 12:
                      var _i0_=24;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_i0_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_i0_]);
                     case 14:
                      var _i1_=24;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_i1_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_i1_]);
                     case 20:
                      var _i2_=24;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_i2_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_i2_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_i3_=menhir_env$0[2][11],_i4_=24;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_i4_,v,_i3_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_i4_,v,_i3_]);
                     case 2:
                      var v$0=tok[1],_i5_=menhir_env$0[2][11],_i6_=24;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_i6_,v$0,_i5_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_i6_,v$0,_i5_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bC_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,24)},
               menhir_run31=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _iP_=22;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_iP_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_iP_]);
                     case 9:
                      var _iQ_=22;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_iQ_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_iQ_]);
                     case 12:
                      var _iR_=22;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_iR_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_iR_]);
                     case 14:
                      var _iS_=22;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_iS_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_iS_]);
                     case 20:
                      var _iT_=22;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_iT_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_iT_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_iU_=menhir_env$0[2][11],_iV_=22;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_iV_,v,_iU_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_iV_,v,_iU_]);
                     case 2:
                      var v$0=tok[1],_iW_=menhir_env$0[2][11],_iX_=22;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_iX_,v$0,_iW_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_iX_,v$0,_iW_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bD_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,22)},
               menhir_run40=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _iG_=18;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_iG_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_iG_]);
                     case 9:
                      var _iH_=18;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_iH_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_iH_]);
                     case 12:
                      var _iI_=18;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_iI_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_iI_]);
                     case 14:
                      var _iJ_=18;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_iJ_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_iJ_]);
                     case 20:
                      var _iK_=18;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_iK_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_iK_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_iL_=menhir_env$0[2][11],_iM_=18;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_iM_,v,_iL_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_iM_,v,_iL_]);
                     case 2:
                      var v$0=tok[1],_iN_=menhir_env$0[2][11],_iO_=18;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_iO_,v$0,_iN_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_iO_,v$0,_iN_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bE_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,18)},
               menhir_run33=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _ix_=21;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_ix_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_ix_]);
                     case 9:
                      var _iy_=21;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_iy_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_iy_]);
                     case 12:
                      var _iz_=21;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_iz_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_iz_]);
                     case 14:
                      var _iA_=21;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_iA_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_iA_]);
                     case 20:
                      var _iB_=21;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_iB_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_iB_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_iC_=menhir_env$0[2][11],_iD_=21;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_iD_,v,_iC_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_iD_,v,_iC_]);
                     case 2:
                      var v$0=tok[1],_iE_=menhir_env$0[2][11],_iF_=21;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_iF_,v$0,_iE_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_iF_,v$0,_iE_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bF_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,21)},
               menhir_run25=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _io_=25;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_io_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_io_]);
                     case 9:
                      var _ip_=25;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_ip_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_ip_]);
                     case 12:
                      var _iq_=25;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_iq_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_iq_]);
                     case 14:
                      var _ir_=25;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_ir_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_ir_]);
                     case 20:
                      var _is_=25;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_is_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_is_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_it_=menhir_env$0[2][11],_iu_=25;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_iu_,v,_it_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_iu_,v,_it_]);
                     case 2:
                      var v$0=tok[1],_iv_=menhir_env$0[2][11],_iw_=25;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_iw_,v$0,_iv_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_iw_,v$0,_iv_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bG_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,25)},
               menhir_run44=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _if_=16;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_if_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_if_]);
                     case 9:
                      var _ig_=16;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_ig_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_ig_]);
                     case 12:
                      var _ih_=16;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_ih_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_ih_]);
                     case 14:
                      var _ii_=16;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_ii_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_ii_]);
                     case 20:
                      var _ij_=16;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_ij_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_ij_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_ik_=menhir_env$0[2][11],_il_=16;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_il_,v,_ik_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_il_,v,_ik_]);
                     case 2:
                      var v$0=tok[1],_im_=menhir_env$0[2][11],_in_=16;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_in_,v$0,_im_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_in_,v$0,_im_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bH_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,16)},
               menhir_run46=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _h8_=15;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_h8_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_h8_]);
                     case 9:
                      var _h9_=15;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_h9_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_h9_]);
                     case 12:
                      var _h__=15;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_h__)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_h__]);
                     case 14:
                      var _h$_=15;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_h$_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_h$_]);
                     case 20:
                      var _ia_=15;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_ia_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_ia_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_ib_=menhir_env$0[2][11],_ic_=15;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_ic_,v,_ib_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_ic_,v,_ib_]);
                     case 2:
                      var v$0=tok[1],_id_=menhir_env$0[2][11],_ie_=15;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_ie_,v$0,_id_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_ie_,v$0,_id_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bI_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,15)},
               menhir_run35=
                function(counter,menhir_env,menhir_stack)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _hZ_=20;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6(counter$6,menhir_env$0,menhir_stack,_hZ_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack,_hZ_]);
                     case 9:
                      var _h0_=20;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8(counter$4,menhir_env$0,menhir_stack,_h0_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack,_h0_]);
                     case 12:
                      var _h1_=20;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9(counter$3,menhir_env$0,menhir_stack,_h1_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack,_h1_]);
                     case 14:
                      var _h2_=20;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack,_h2_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack,_h2_]);
                     case 20:
                      var _h3_=20;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack,_h3_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack,_h3_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_h4_=menhir_env$0[2][11],_h5_=20;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack,_h5_,v,_h4_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack,_h5_,v,_h4_]);
                     case 2:
                      var v$0=tok[1],_h6_=menhir_env$0[2][11],_h7_=20;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack,_h7_,v$0,_h6_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack,_h7_,v$0,_h6_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_bJ_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,20)},
               menhir_goto_offset=
                function(counter,menhir_env,menhir_stack,menhir_s,o)
                 {if(7 === menhir_s)
                   {if(menhir_env[4])throw [0,Assert_failure,_bK_];
                    var tok=menhir_env[3];
                    if(typeof tok === "number" && 4 === tok)
                     {var
                       menhir_env$0=menhir_discard(menhir_env),
                       tok$0=menhir_env$0[3];
                      if(typeof tok$0 === "number" && 17 <= tok$0)
                       {var switcher=tok$0 - 17 | 0;
                        switch(switcher)
                         {case 3:
                           var
                            menhir_env$1=menhir_discard(menhir_env$0),
                            id$0=menhir_stack[2],
                            match$0=menhir_stack[1],
                            menhir_s$1=match$0[2],
                            menhir_stack$1=match$0[1],
                            v$0=[2,id$0,o,1];
                           if(counter < 50)
                            {var counter$1=counter + 1 | 0;
                             return menhir_goto_arg
                                     (counter$1,menhir_env$1,menhir_stack$1,menhir_s$1,v$0)}
                           return caml_trampoline_return
                                   (menhir_goto_arg,
                                    [0,menhir_env$1,menhir_stack$1,menhir_s$1,v$0]);
                          case 0:
                          case 6:
                          case 7:
                          case 9:
                           var
                            id=menhir_stack[2],
                            match=menhir_stack[1],
                            menhir_s$0=match[2],
                            menhir_stack$0=match[1],
                            v=[2,id,o,0];
                           if(counter < 50)
                            {var counter$2=counter + 1 | 0;
                             return menhir_goto_arg
                                     (counter$2,menhir_env$0,menhir_stack$0,menhir_s$0,v)}
                           return caml_trampoline_return
                                   (menhir_goto_arg,
                                    [0,menhir_env$0,menhir_stack$0,menhir_s$0,v])
                          }}
                      if(menhir_env$0[4])throw [0,Assert_failure,_bL_];
                      menhir_env$0[4] = 1;
                      return menhir_errorcase(menhir_env$0,menhir_stack,menhir_s)}
                    if(menhir_env[4])throw [0,Assert_failure,_bM_];
                    menhir_env[4] = 1;
                    return menhir_errorcase(menhir_env,menhir_stack,menhir_s)}
                  if(13 === menhir_s)
                   {var
                     id$1=menhir_stack[2],
                     match$1=menhir_stack[1],
                     menhir_s$2=match$1[2],
                     menhir_stack$2=match$1[1],
                     v$1=[2,id$1,o,2];
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return menhir_goto_arg
                              (counter$0,menhir_env,menhir_stack$2,menhir_s$2,v$1)}
                    return caml_trampoline_return
                            (menhir_goto_arg,
                             [0,menhir_env,menhir_stack$2,menhir_s$2,v$1])}
                  return menhir_fail(0)},
               menhir_goto_meta_expr=
                function(counter,menhir_env,menhir_stack,menhir_s,v)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s,
                   v$0=v;
                  for(;;)
                   {var menhir_stack$1=[0,menhir_stack$0,menhir_s$0,v$0];
                    switch(menhir_s$0)
                     {case 1:
                       if(menhir_env$0[4])throw [0,Assert_failure,_bN_];
                       var tok=menhir_env$0[3];
                       if(typeof tok === "number")
                        switch(tok)
                         {case 0:
                           if(counter < 50)
                            {var counter$176=counter + 1 | 0;
                             return menhir_run15(counter$176,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$159=counter + 1 | 0;
                             return menhir_run17(counter$159,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$146=counter + 1 | 0;
                             return menhir_run19(counter$146,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$131=counter + 1 | 0;
                             return menhir_run21(counter$131,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$123=counter + 1 | 0;
                             return menhir_run38(counter$123,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$112=counter + 1 | 0;
                             return menhir_run29(counter$112,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$95=counter + 1 | 0;
                             return menhir_run23(counter$95,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$80=counter + 1 | 0;
                             return menhir_run27(counter$80,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$67=counter + 1 | 0;
                             return menhir_run31(counter$67,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 17:
                           if(counter < 50)
                            {var counter$61=counter + 1 | 0;
                             return menhir_run40(counter$61,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$50=counter + 1 | 0;
                             return menhir_run33(counter$50,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 23:
                           var
                            e=menhir_stack$1[3],
                            match=menhir_stack$1[1],
                            id=match[2],
                            menhir_stack$3=match[1],
                            v$1=[1,id,0,e];
                           if(counter < 50)
                            {var counter$0=counter + 1 | 0;
                             return menhir_goto_definition
                                     (counter$0,menhir_env$0,menhir_stack$3,v$1)}
                           return caml_trampoline_return
                                   (menhir_goto_definition,[0,menhir_env$0,menhir_stack$3,v$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$33=counter + 1 | 0;
                             return menhir_run25(counter$33,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 28:
                           if(counter < 50)
                            {var counter$27=counter + 1 | 0;
                             return menhir_run44(counter$27,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$20=counter + 1 | 0;
                             return menhir_run46(counter$20,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$10=counter + 1 | 0;
                             return menhir_run35(counter$10,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_bO_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$1=menhir_stack$1[2],
                        menhir_stack$2=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$2,menhir_s$1);
                      case 2:
                       if(menhir_env$0[4])throw [0,Assert_failure,_bP_];
                       var tok$0=menhir_env$0[3];
                       if(typeof tok$0 === "number")
                        switch(tok$0)
                         {case 0:
                           if(counter < 50)
                            {var counter$177=counter + 1 | 0;
                             return menhir_run15(counter$177,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$160=counter + 1 | 0;
                             return menhir_run17(counter$160,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$147=counter + 1 | 0;
                             return menhir_run19(counter$147,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$132=counter + 1 | 0;
                             return menhir_run21(counter$132,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$124=counter + 1 | 0;
                             return menhir_run38(counter$124,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$113=counter + 1 | 0;
                             return menhir_run29(counter$113,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$96=counter + 1 | 0;
                             return menhir_run23(counter$96,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$81=counter + 1 | 0;
                             return menhir_run27(counter$81,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$68=counter + 1 | 0;
                             return menhir_run31(counter$68,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 17:
                           if(counter < 50)
                            {var counter$62=counter + 1 | 0;
                             return menhir_run40(counter$62,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$51=counter + 1 | 0;
                             return menhir_run33(counter$51,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 23:
                           var
                            e$0=menhir_stack$1[3],
                            match$0=menhir_stack$1[1],
                            id$0=match$0[2],
                            menhir_stack$5=match$0[1],
                            v$2=[1,id$0,1,e$0];
                           if(counter < 50)
                            {var counter$1=counter + 1 | 0;
                             return menhir_goto_definition
                                     (counter$1,menhir_env$0,menhir_stack$5,v$2)}
                           return caml_trampoline_return
                                   (menhir_goto_definition,[0,menhir_env$0,menhir_stack$5,v$2]);
                          case 25:
                           if(counter < 50)
                            {var counter$34=counter + 1 | 0;
                             return menhir_run25(counter$34,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 28:
                           if(counter < 50)
                            {var counter$28=counter + 1 | 0;
                             return menhir_run44(counter$28,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$21=counter + 1 | 0;
                             return menhir_run46(counter$21,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$11=counter + 1 | 0;
                             return menhir_run35(counter$11,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_bQ_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$2=menhir_stack$1[2],
                        menhir_stack$4=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$4,menhir_s$2);
                      case 15:
                       if(menhir_env$0[4])throw [0,Assert_failure,_bR_];
                       var tok$1=menhir_env$0[3];
                       if(typeof tok$1 === "number")
                        switch(tok$1)
                         {case 0:
                           if(counter < 50)
                            {var counter$178=counter + 1 | 0;
                             return menhir_run15(counter$178,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$161=counter + 1 | 0;
                             return menhir_run17(counter$161,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$148=counter + 1 | 0;
                             return menhir_run19(counter$148,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$133=counter + 1 | 0;
                             return menhir_run21(counter$133,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$125=counter + 1 | 0;
                             return menhir_run38(counter$125,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$114=counter + 1 | 0;
                             return menhir_run29(counter$114,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$97=counter + 1 | 0;
                             return menhir_run23(counter$97,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$82=counter + 1 | 0;
                             return menhir_run27(counter$82,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$69=counter + 1 | 0;
                             return menhir_run31(counter$69,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$52=counter + 1 | 0;
                             return menhir_run33(counter$52,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$35=counter + 1 | 0;
                             return menhir_run25(counter$35,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$12=counter + 1 | 0;
                             return menhir_run35(counter$12,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                          case 3:
                          case 5:
                          case 17:
                          case 23:
                          case 27:
                          case 28:
                          case 29:
                           var
                            e2=menhir_stack$1[3],
                            match$1=menhir_stack$1[1],
                            e1=match$1[3],
                            menhir_s$3=match$1[2],
                            menhir_stack$6=match$1[1],
                            v$3=[1,13,e1,e2],
                            menhir_stack$0=menhir_stack$6,
                            menhir_s$0=menhir_s$3,
                            v$0=v$3;
                           continue
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_bS_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$4=menhir_stack$1[2],
                        menhir_stack$7=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$7,menhir_s$4);
                      case 16:
                       if(menhir_env$0[4])throw [0,Assert_failure,_bT_];
                       var tok$2=menhir_env$0[3];
                       if(typeof tok$2 === "number")
                        switch(tok$2)
                         {case 0:
                           if(counter < 50)
                            {var counter$179=counter + 1 | 0;
                             return menhir_run15(counter$179,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$162=counter + 1 | 0;
                             return menhir_run17(counter$162,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$149=counter + 1 | 0;
                             return menhir_run19(counter$149,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$134=counter + 1 | 0;
                             return menhir_run21(counter$134,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$126=counter + 1 | 0;
                             return menhir_run38(counter$126,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$115=counter + 1 | 0;
                             return menhir_run29(counter$115,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$98=counter + 1 | 0;
                             return menhir_run23(counter$98,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$83=counter + 1 | 0;
                             return menhir_run27(counter$83,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$70=counter + 1 | 0;
                             return menhir_run31(counter$70,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$53=counter + 1 | 0;
                             return menhir_run33(counter$53,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$36=counter + 1 | 0;
                             return menhir_run25(counter$36,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$22=counter + 1 | 0;
                             return menhir_run46(counter$22,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$13=counter + 1 | 0;
                             return menhir_run35(counter$13,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                          case 3:
                          case 5:
                          case 17:
                          case 23:
                          case 27:
                          case 28:
                           var
                            e2$0=menhir_stack$1[3],
                            match$2=menhir_stack$1[1],
                            e1$0=match$2[3],
                            menhir_s$5=match$2[2],
                            menhir_stack$8=match$2[1],
                            v$4=[1,12,e1$0,e2$0],
                            menhir_stack$0=menhir_stack$8,
                            menhir_s$0=menhir_s$5,
                            v$0=v$4;
                           continue
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_bU_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$6=menhir_stack$1[2],
                        menhir_stack$9=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$9,menhir_s$6);
                      case 17:
                       if(menhir_env$0[4])throw [0,Assert_failure,_bV_];
                       var tok$3=menhir_env$0[3];
                       if(typeof tok$3 === "number")
                        switch(tok$3)
                         {case 0:
                           if(counter < 50)
                            {var counter$180=counter + 1 | 0;
                             return menhir_run15(counter$180,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$163=counter + 1 | 0;
                             return menhir_run17(counter$163,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$150=counter + 1 | 0;
                             return menhir_run19(counter$150,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$135=counter + 1 | 0;
                             return menhir_run21(counter$135,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$127=counter + 1 | 0;
                             return menhir_run38(counter$127,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$116=counter + 1 | 0;
                             return menhir_run29(counter$116,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$99=counter + 1 | 0;
                             return menhir_run23(counter$99,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$84=counter + 1 | 0;
                             return menhir_run27(counter$84,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$71=counter + 1 | 0;
                             return menhir_run31(counter$71,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 17:
                           if(counter < 50)
                            {var counter$63=counter + 1 | 0;
                             return menhir_run40(counter$63,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$54=counter + 1 | 0;
                             return menhir_run33(counter$54,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$37=counter + 1 | 0;
                             return menhir_run25(counter$37,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 28:
                           if(counter < 50)
                            {var counter$29=counter + 1 | 0;
                             return menhir_run44(counter$29,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$23=counter + 1 | 0;
                             return menhir_run46(counter$23,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$14=counter + 1 | 0;
                             return menhir_run35(counter$14,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                          case 3:
                          case 5:
                          case 23:
                          case 27:
                           var
                            e2$1=menhir_stack$1[3],
                            _hP_=menhir_stack$1[1],
                            e1$1=_hP_[3],
                            match$3=_hP_[1],
                            e0=match$3[3],
                            menhir_s$7=match$3[2],
                            menhir_stack$10=match$3[1],
                            v$5=[4,e0,e1$1,e2$1],
                            menhir_stack$0=menhir_stack$10,
                            menhir_s$0=menhir_s$7,
                            v$0=v$5;
                           continue
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_bW_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$8=menhir_stack$1[2],
                        menhir_stack$11=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$11,menhir_s$8);
                      case 18:
                       if(menhir_env$0[4])throw [0,Assert_failure,_bX_];
                       var tok$4=menhir_env$0[3];
                       if(typeof tok$4 === "number")
                        switch(tok$4)
                         {case 0:
                           if(counter < 50)
                            {var counter$181=counter + 1 | 0;
                             return menhir_run15(counter$181,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$164=counter + 1 | 0;
                             return menhir_run17(counter$164,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$151=counter + 1 | 0;
                             return menhir_run19(counter$151,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$136=counter + 1 | 0;
                             return menhir_run21(counter$136,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$128=counter + 1 | 0;
                             return menhir_run38(counter$128,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$117=counter + 1 | 0;
                             return menhir_run29(counter$117,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$100=counter + 1 | 0;
                             return menhir_run23(counter$100,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$85=counter + 1 | 0;
                             return menhir_run27(counter$85,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$72=counter + 1 | 0;
                             return menhir_run31(counter$72,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 17:
                           if(counter < 50)
                            {var counter$64=counter + 1 | 0;
                             return menhir_run40(counter$64,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$55=counter + 1 | 0;
                             return menhir_run33(counter$55,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$38=counter + 1 | 0;
                             return menhir_run25(counter$38,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 27:
                           var
                            menhir_env$1=menhir_discard(menhir_env$0),
                            tok$5=menhir_env$1[3];
                           if(typeof tok$5 === "number")
                            switch(tok$5)
                             {case 6:
                               var _hQ_=17;
                               if(counter < 50)
                                {var counter$8=counter + 1 | 0;
                                 return menhir_run6
                                         (counter$8,menhir_env$1,menhir_stack$1,_hQ_)}
                               return caml_trampoline_return
                                       (menhir_run6,[0,menhir_env$1,menhir_stack$1,_hQ_]);
                              case 9:
                               var _hR_=17;
                               if(counter < 50)
                                {var counter$6=counter + 1 | 0;
                                 return menhir_run8
                                         (counter$6,menhir_env$1,menhir_stack$1,_hR_)}
                               return caml_trampoline_return
                                       (menhir_run8,[0,menhir_env$1,menhir_stack$1,_hR_]);
                              case 12:
                               var _hS_=17;
                               if(counter < 50)
                                {var counter$5=counter + 1 | 0;
                                 return menhir_run9
                                         (counter$5,menhir_env$1,menhir_stack$1,_hS_)}
                               return caml_trampoline_return
                                       (menhir_run9,[0,menhir_env$1,menhir_stack$1,_hS_]);
                              case 14:
                               var _hT_=17;
                               if(counter < 50)
                                {var counter$4=counter + 1 | 0;
                                 return menhir_run10
                                         (counter$4,menhir_env$1,menhir_stack$1,_hT_)}
                               return caml_trampoline_return
                                       (menhir_run10,[0,menhir_env$1,menhir_stack$1,_hT_]);
                              case 20:
                               var _hU_=17;
                               if(counter < 50)
                                {var counter$2=counter + 1 | 0;
                                 return menhir_run12
                                         (counter$2,menhir_env$1,menhir_stack$1,_hU_)}
                               return caml_trampoline_return
                                       (menhir_run12,[0,menhir_env$1,menhir_stack$1,_hU_])
                              }
                           else
                            switch(tok$5[0])
                             {case 1:
                               var v$6=tok$5[1],_hV_=menhir_env$1[2][11],_hW_=17;
                               if(counter < 50)
                                {var counter$7=counter + 1 | 0;
                                 return menhir_run7
                                         (counter$7,menhir_env$1,menhir_stack$1,_hW_,v$6,_hV_)}
                               return caml_trampoline_return
                                       (menhir_run7,[0,menhir_env$1,menhir_stack$1,_hW_,v$6,_hV_]);
                              case 2:
                               var v$7=tok$5[1],_hX_=menhir_env$1[2][11],_hY_=17;
                               if(counter < 50)
                                {var counter$3=counter + 1 | 0;
                                 return menhir_run11
                                         (counter$3,menhir_env$1,menhir_stack$1,_hY_,v$7,_hX_)}
                               return caml_trampoline_return
                                       (menhir_run11,[0,menhir_env$1,menhir_stack$1,_hY_,v$7,_hX_])
                              }
                           if(menhir_env$1[4])throw [0,Assert_failure,_bZ_];
                           menhir_env$1[4] = 1;
                           return menhir_errorcase(menhir_env$1,menhir_stack$1,17);
                          case 28:
                           if(counter < 50)
                            {var counter$30=counter + 1 | 0;
                             return menhir_run44(counter$30,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$24=counter + 1 | 0;
                             return menhir_run46(counter$24,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$15=counter + 1 | 0;
                             return menhir_run35(counter$15,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_bY_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$9=menhir_stack$1[2],
                        menhir_stack$12=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$12,menhir_s$9);
                      case 19:
                       if(menhir_env$0[4])throw [0,Assert_failure,_b0_];
                       var tok$6=menhir_env$0[3];
                       if(typeof tok$6 === "number")
                        switch(tok$6)
                         {case 0:
                           if(counter < 50)
                            {var counter$182=counter + 1 | 0;
                             return menhir_run15(counter$182,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$165=counter + 1 | 0;
                             return menhir_run17(counter$165,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$152=counter + 1 | 0;
                             return menhir_run19(counter$152,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$137=counter + 1 | 0;
                             return menhir_run21(counter$137,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$118=counter + 1 | 0;
                             return menhir_run29(counter$118,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$101=counter + 1 | 0;
                             return menhir_run23(counter$101,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$86=counter + 1 | 0;
                             return menhir_run27(counter$86,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$73=counter + 1 | 0;
                             return menhir_run31(counter$73,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$56=counter + 1 | 0;
                             return menhir_run33(counter$56,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$39=counter + 1 | 0;
                             return menhir_run25(counter$39,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$16=counter + 1 | 0;
                             return menhir_run35(counter$16,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                          case 3:
                          case 5:
                          case 7:
                          case 17:
                          case 23:
                          case 27:
                          case 28:
                          case 29:
                           var
                            e2$2=menhir_stack$1[3],
                            match$4=menhir_stack$1[1],
                            e1$2=match$4[3],
                            menhir_s$10=match$4[2],
                            menhir_stack$13=match$4[1],
                            v$8=[1,7,e1$2,e2$2],
                            menhir_stack$0=menhir_stack$13,
                            menhir_s$0=menhir_s$10,
                            v$0=v$8;
                           continue
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_b1_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$11=menhir_stack$1[2],
                        menhir_stack$14=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$14,menhir_s$11);
                      case 20:
                       if(menhir_env$0[4])throw [0,Assert_failure,_b2_];
                       var tok$7=menhir_env$0[3];
                       if(typeof tok$7 === "number")
                        switch(tok$7)
                         {case 1:
                           if(counter < 50)
                            {var counter$166=counter + 1 | 0;
                             return menhir_run17(counter$166,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$153=counter + 1 | 0;
                             return menhir_run19(counter$153,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$138=counter + 1 | 0;
                             return menhir_run21(counter$138,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$119=counter + 1 | 0;
                             return menhir_run29(counter$119,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$102=counter + 1 | 0;
                             return menhir_run23(counter$102,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$87=counter + 1 | 0;
                             return menhir_run27(counter$87,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$74=counter + 1 | 0;
                             return menhir_run31(counter$74,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$57=counter + 1 | 0;
                             return menhir_run33(counter$57,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$40=counter + 1 | 0;
                             return menhir_run25(counter$40,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 0:
                          case 3:
                          case 5:
                          case 7:
                          case 17:
                          case 23:
                          case 27:
                          case 28:
                          case 29:
                          case 30:
                           var
                            e2$3=menhir_stack$1[3],
                            match$5=menhir_stack$1[1],
                            e1$3=match$5[3],
                            menhir_s$12=match$5[2],
                            menhir_stack$15=match$5[1],
                            v$9=[1,5,e1$3,e2$3],
                            menhir_stack$0=menhir_stack$15,
                            menhir_s$0=menhir_s$12,
                            v$0=v$9;
                           continue
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_b3_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$13=menhir_stack$1[2],
                        menhir_stack$16=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$16,menhir_s$13);
                      case 21:
                       if(menhir_env$0[4])throw [0,Assert_failure,_b4_];
                       var tok$8=menhir_env$0[3];
                       if(typeof tok$8 === "number")
                        switch(tok$8)
                         {case 1:
                           if(counter < 50)
                            {var counter$167=counter + 1 | 0;
                             return menhir_run17(counter$167,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$154=counter + 1 | 0;
                             return menhir_run19(counter$154,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$139=counter + 1 | 0;
                             return menhir_run21(counter$139,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$103=counter + 1 | 0;
                             return menhir_run23(counter$103,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$88=counter + 1 | 0;
                             return menhir_run27(counter$88,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$75=counter + 1 | 0;
                             return menhir_run31(counter$75,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$41=counter + 1 | 0;
                             return menhir_run25(counter$41,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 4:
                          case 8:
                          case 9:
                          case 14:
                          case 15:
                          case 16:
                          case 18:
                          case 19:
                          case 20:
                          case 21:
                          case 24:
                          case 26:break;
                          default:
                           var
                            e2$4=menhir_stack$1[3],
                            match$6=menhir_stack$1[1],
                            e1$4=match$6[3],
                            menhir_s$14=match$6[2],
                            menhir_stack$17=match$6[1],
                            v$10=[1,10,e1$4,e2$4],
                            menhir_stack$0=menhir_stack$17,
                            menhir_s$0=menhir_s$14,
                            v$0=v$10;
                           continue}
                       if(menhir_env$0[4])throw [0,Assert_failure,_b5_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$15=menhir_stack$1[2],
                        menhir_stack$18=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$18,menhir_s$15);
                      case 22:
                       if(menhir_env$0[4])throw [0,Assert_failure,_b6_];
                       var tok$9=menhir_env$0[3];
                       if(typeof tok$9 === "number")
                        switch(tok$9)
                         {case 1:
                           if(counter < 50)
                            {var counter$168=counter + 1 | 0;
                             return menhir_run17(counter$168,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$140=counter + 1 | 0;
                             return menhir_run21(counter$140,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$104=counter + 1 | 0;
                             return menhir_run23(counter$104,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$89=counter + 1 | 0;
                             return menhir_run27(counter$89,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$42=counter + 1 | 0;
                             return menhir_run25(counter$42,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 4:
                          case 8:
                          case 9:
                          case 14:
                          case 15:
                          case 16:
                          case 18:
                          case 19:
                          case 20:
                          case 21:
                          case 24:
                          case 26:break;
                          default:
                           var
                            e2$5=menhir_stack$1[3],
                            match$7=menhir_stack$1[1],
                            e1$5=match$7[3],
                            menhir_s$16=match$7[2],
                            menhir_stack$19=match$7[1],
                            v$11=[1,8,e1$5,e2$5],
                            menhir_stack$0=menhir_stack$19,
                            menhir_s$0=menhir_s$16,
                            v$0=v$11;
                           continue}
                       if(menhir_env$0[4])throw [0,Assert_failure,_b7_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$17=menhir_stack$1[2],
                        menhir_stack$20=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$20,menhir_s$17);
                      case 23:
                       if(menhir_env$0[4])throw [0,Assert_failure,_b8_];
                       var tok$10=menhir_env$0[3];
                       if(typeof tok$10 === "number")
                        switch(tok$10)
                         {case 1:
                           if(counter < 50)
                            {var counter$169=counter + 1 | 0;
                             return menhir_run17(counter$169,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$155=counter + 1 | 0;
                             return menhir_run19(counter$155,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$141=counter + 1 | 0;
                             return menhir_run21(counter$141,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$105=counter + 1 | 0;
                             return menhir_run23(counter$105,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$90=counter + 1 | 0;
                             return menhir_run27(counter$90,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$76=counter + 1 | 0;
                             return menhir_run31(counter$76,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$43=counter + 1 | 0;
                             return menhir_run25(counter$43,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 4:
                          case 8:
                          case 9:
                          case 14:
                          case 15:
                          case 16:
                          case 18:
                          case 19:
                          case 20:
                          case 21:
                          case 24:
                          case 26:break;
                          default:
                           var
                            e2$6=menhir_stack$1[3],
                            match$8=menhir_stack$1[1],
                            e1$6=match$8[3],
                            menhir_s$18=match$8[2],
                            menhir_stack$21=match$8[1],
                            v$12=[1,11,e1$6,e2$6],
                            menhir_stack$0=menhir_stack$21,
                            menhir_s$0=menhir_s$18,
                            v$0=v$12;
                           continue}
                       if(menhir_env$0[4])throw [0,Assert_failure,_b9_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$19=menhir_stack$1[2],
                        menhir_stack$22=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$22,menhir_s$19);
                      case 24:
                       if(menhir_env$0[4])throw [0,Assert_failure,_b__];
                       var tok$11=menhir_env$0[3];
                       if(typeof tok$11 === "number")
                        switch(tok$11)
                         {case 1:
                           if(counter < 50)
                            {var counter$170=counter + 1 | 0;
                             return menhir_run17(counter$170,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$106=counter + 1 | 0;
                             return menhir_run23(counter$106,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$44=counter + 1 | 0;
                             return menhir_run25(counter$44,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 4:
                          case 8:
                          case 9:
                          case 14:
                          case 15:
                          case 16:
                          case 18:
                          case 19:
                          case 20:
                          case 21:
                          case 24:
                          case 26:break;
                          default:
                           var
                            e2$7=menhir_stack$1[3],
                            match$9=menhir_stack$1[1],
                            e1$7=match$9[3],
                            menhir_s$20=match$9[2],
                            menhir_stack$23=match$9[1],
                            v$13=[1,1,e1$7,e2$7],
                            menhir_stack$0=menhir_stack$23,
                            menhir_s$0=menhir_s$20,
                            v$0=v$13;
                           continue}
                       if(menhir_env$0[4])throw [0,Assert_failure,_b$_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$21=menhir_stack$1[2],
                        menhir_stack$24=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$24,menhir_s$21);
                      case 25:
                       var
                        e2$8=menhir_stack$1[3],
                        match$10=menhir_stack$1[1],
                        e1$8=match$10[3],
                        menhir_s$22=match$10[2],
                        menhir_stack$25=match$10[1],
                        v$14=[1,3,e1$8,e2$8],
                        menhir_stack$0=menhir_stack$25,
                        menhir_s$0=menhir_s$22,
                        v$0=v$14;
                       continue;
                      case 26:
                       var
                        e2$9=menhir_stack$1[3],
                        match$11=menhir_stack$1[1],
                        e1$9=match$11[3],
                        menhir_s$23=match$11[2],
                        menhir_stack$26=match$11[1],
                        v$15=[1,4,e1$9,e2$9],
                        menhir_stack$0=menhir_stack$26,
                        menhir_s$0=menhir_s$23,
                        v$0=v$15;
                       continue;
                      case 27:
                       if(menhir_env$0[4])throw [0,Assert_failure,_ca_];
                       var tok$12=menhir_env$0[3];
                       if(typeof tok$12 === "number")
                        switch(tok$12)
                         {case 1:
                           if(counter < 50)
                            {var counter$171=counter + 1 | 0;
                             return menhir_run17(counter$171,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$107=counter + 1 | 0;
                             return menhir_run23(counter$107,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$45=counter + 1 | 0;
                             return menhir_run25(counter$45,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 4:
                          case 8:
                          case 9:
                          case 14:
                          case 15:
                          case 16:
                          case 18:
                          case 19:
                          case 20:
                          case 21:
                          case 24:
                          case 26:break;
                          default:
                           var
                            e2$10=menhir_stack$1[3],
                            match$12=menhir_stack$1[1],
                            e1$10=match$12[3],
                            menhir_s$24=match$12[2],
                            menhir_stack$27=match$12[1],
                            v$16=[1,0,e1$10,e2$10],
                            menhir_stack$0=menhir_stack$27,
                            menhir_s$0=menhir_s$24,
                            v$0=v$16;
                           continue}
                       if(menhir_env$0[4])throw [0,Assert_failure,_cb_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$25=menhir_stack$1[2],
                        menhir_stack$28=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$28,menhir_s$25);
                      case 28:
                       if(menhir_env$0[4])throw [0,Assert_failure,_cc_];
                       var tok$13=menhir_env$0[3];
                       if(typeof tok$13 === "number")
                        switch(tok$13)
                         {case 1:
                           if(counter < 50)
                            {var counter$172=counter + 1 | 0;
                             return menhir_run17(counter$172,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$142=counter + 1 | 0;
                             return menhir_run21(counter$142,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$108=counter + 1 | 0;
                             return menhir_run23(counter$108,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$91=counter + 1 | 0;
                             return menhir_run27(counter$91,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$46=counter + 1 | 0;
                             return menhir_run25(counter$46,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 4:
                          case 8:
                          case 9:
                          case 14:
                          case 15:
                          case 16:
                          case 18:
                          case 19:
                          case 20:
                          case 21:
                          case 24:
                          case 26:break;
                          default:
                           var
                            e2$11=menhir_stack$1[3],
                            match$13=menhir_stack$1[1],
                            e1$11=match$13[3],
                            menhir_s$26=match$13[2],
                            menhir_stack$29=match$13[1],
                            v$17=[1,9,e1$11,e2$11],
                            menhir_stack$0=menhir_stack$29,
                            menhir_s$0=menhir_s$26,
                            v$0=v$17;
                           continue}
                       if(menhir_env$0[4])throw [0,Assert_failure,_cd_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$27=menhir_stack$1[2],
                        menhir_stack$30=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$30,menhir_s$27);
                      case 29:
                       var
                        e2$12=menhir_stack$1[3],
                        match$14=menhir_stack$1[1],
                        e1$12=match$14[3],
                        menhir_s$28=match$14[2],
                        menhir_stack$31=match$14[1],
                        v$18=[1,2,e1$12,e2$12],
                        menhir_stack$0=menhir_stack$31,
                        menhir_s$0=menhir_s$28,
                        v$0=v$18;
                       continue;
                      case 30:
                       if(menhir_env$0[4])throw [0,Assert_failure,_ce_];
                       var tok$14=menhir_env$0[3];
                       if(typeof tok$14 === "number")
                        switch(tok$14)
                         {case 1:
                           if(counter < 50)
                            {var counter$173=counter + 1 | 0;
                             return menhir_run17(counter$173,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$156=counter + 1 | 0;
                             return menhir_run19(counter$156,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 6:
                           if(counter < 50)
                            {var counter$143=counter + 1 | 0;
                             return menhir_run21(counter$143,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$120=counter + 1 | 0;
                             return menhir_run29(counter$120,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$109=counter + 1 | 0;
                             return menhir_run23(counter$109,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$92=counter + 1 | 0;
                             return menhir_run27(counter$92,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$77=counter + 1 | 0;
                             return menhir_run31(counter$77,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$58=counter + 1 | 0;
                             return menhir_run33(counter$58,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$47=counter + 1 | 0;
                             return menhir_run25(counter$47,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$17=counter + 1 | 0;
                             return menhir_run35(counter$17,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1]);
                          case 0:
                          case 3:
                          case 5:
                          case 7:
                          case 17:
                          case 23:
                          case 27:
                          case 28:
                          case 29:
                           var
                            e2$13=menhir_stack$1[3],
                            match$15=menhir_stack$1[1],
                            e1$13=match$15[3],
                            menhir_s$29=match$15[2],
                            menhir_stack$32=match$15[1],
                            v$19=[1,6,e1$13,e2$13],
                            menhir_stack$0=menhir_stack$32,
                            menhir_s$0=menhir_s$29,
                            v$0=v$19;
                           continue
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_cf_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$30=menhir_stack$1[2],
                        menhir_stack$33=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$33,menhir_s$30);
                      case 31:
                       var
                        e$1=menhir_stack$1[3],
                        match$16=menhir_stack$1[1],
                        menhir_s$31=match$16[2],
                        menhir_stack$34=match$16[1],
                        v$20=[2,3,e$1],
                        menhir_stack$0=menhir_stack$34,
                        menhir_s$0=menhir_s$31,
                        v$0=v$20;
                       continue;
                      case 32:
                       if(menhir_env$0[4])throw [0,Assert_failure,_cg_];
                       var tok$15=menhir_env$0[3];
                       if(typeof tok$15 === "number")
                        switch(tok$15)
                         {case 0:
                           if(counter < 50)
                            {var counter$183=counter + 1 | 0;
                             return menhir_run15(counter$183,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$174=counter + 1 | 0;
                             return menhir_run17(counter$174,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$157=counter + 1 | 0;
                             return menhir_run19(counter$157,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 3:
                           var
                            menhir_env$2=menhir_discard(menhir_env$0),
                            v$21=menhir_stack$1[3],
                            match$17=menhir_stack$1[1],
                            menhir_s$32=match$17[2],
                            menhir_stack$35=match$17[1],
                            menhir_env$0=menhir_env$2,
                            menhir_stack$0=menhir_stack$35,
                            menhir_s$0=menhir_s$32,
                            v$0=v$21;
                           continue;
                          case 6:
                           if(counter < 50)
                            {var counter$144=counter + 1 | 0;
                             return menhir_run21(counter$144,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$129=counter + 1 | 0;
                             return menhir_run38(counter$129,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$121=counter + 1 | 0;
                             return menhir_run29(counter$121,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$110=counter + 1 | 0;
                             return menhir_run23(counter$110,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$93=counter + 1 | 0;
                             return menhir_run27(counter$93,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$78=counter + 1 | 0;
                             return menhir_run31(counter$78,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 17:
                           if(counter < 50)
                            {var counter$65=counter + 1 | 0;
                             return menhir_run40(counter$65,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$59=counter + 1 | 0;
                             return menhir_run33(counter$59,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$48=counter + 1 | 0;
                             return menhir_run25(counter$48,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 28:
                           if(counter < 50)
                            {var counter$31=counter + 1 | 0;
                             return menhir_run44(counter$31,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$25=counter + 1 | 0;
                             return menhir_run46(counter$25,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$18=counter + 1 | 0;
                             return menhir_run35(counter$18,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_ch_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$33=menhir_stack$1[2],
                        menhir_stack$36=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$36,menhir_s$33);
                      case 33:
                       var
                        e$2=menhir_stack$1[3],
                        match$18=menhir_stack$1[1],
                        menhir_s$34=match$18[2],
                        menhir_stack$37=match$18[1],
                        v$22=[2,1,e$2],
                        menhir_stack$0=menhir_stack$37,
                        menhir_s$0=menhir_s$34,
                        v$0=v$22;
                       continue;
                      case 34:
                       var
                        e$3=menhir_stack$1[3],
                        match$19=menhir_stack$1[1],
                        menhir_s$35=match$19[2],
                        menhir_stack$38=match$19[1],
                        v$23=[2,2,e$3],
                        menhir_stack$0=menhir_stack$38,
                        menhir_s$0=menhir_s$35,
                        v$0=v$23;
                       continue;
                      case 35:
                       var
                        e$4=menhir_stack$1[3],
                        match$20=menhir_stack$1[1],
                        menhir_s$36=match$20[2],
                        menhir_stack$39=match$20[1],
                        v$24=[2,0,e$4],
                        menhir_stack$0=menhir_stack$39,
                        menhir_s$0=menhir_s$36,
                        v$0=v$24;
                       continue;
                      case 36:
                       if(menhir_env$0[4])throw [0,Assert_failure,_ci_];
                       var tok$16=menhir_env$0[3];
                       if(typeof tok$16 === "number")
                        switch(tok$16)
                         {case 0:
                           if(counter < 50)
                            {var counter$184=counter + 1 | 0;
                             return menhir_run15(counter$184,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run15,[0,menhir_env$0,menhir_stack$1]);
                          case 1:
                           if(counter < 50)
                            {var counter$175=counter + 1 | 0;
                             return menhir_run17(counter$175,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run17,[0,menhir_env$0,menhir_stack$1]);
                          case 2:
                           if(counter < 50)
                            {var counter$158=counter + 1 | 0;
                             return menhir_run19(counter$158,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run19,[0,menhir_env$0,menhir_stack$1]);
                          case 5:
                           var
                            menhir_env$3=menhir_discard(menhir_env$0),
                            e$5=menhir_stack$1[3],
                            match$21=menhir_stack$1[1],
                            startpos_1=match$21[3],
                            menhir_s$38=match$21[2],
                            menhir_stack$41=match$21[1],
                            v$25=[1,e$5];
                           if(counter < 50)
                            {var counter$9=counter + 1 | 0;
                             return menhir_goto_number
                                     (counter$9,
                                      menhir_env$3,
                                      menhir_stack$41,
                                      menhir_s$38,
                                      v$25,
                                      startpos_1)}
                           return caml_trampoline_return
                                   (menhir_goto_number,
                                    [0,menhir_env$3,menhir_stack$41,menhir_s$38,v$25,startpos_1]);
                          case 6:
                           if(counter < 50)
                            {var counter$145=counter + 1 | 0;
                             return menhir_run21(counter$145,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run21,[0,menhir_env$0,menhir_stack$1]);
                          case 7:
                           if(counter < 50)
                            {var counter$130=counter + 1 | 0;
                             return menhir_run38(counter$130,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run38,[0,menhir_env$0,menhir_stack$1]);
                          case 10:
                           if(counter < 50)
                            {var counter$122=counter + 1 | 0;
                             return menhir_run29(counter$122,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run29,[0,menhir_env$0,menhir_stack$1]);
                          case 11:
                           if(counter < 50)
                            {var counter$111=counter + 1 | 0;
                             return menhir_run23(counter$111,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run23,[0,menhir_env$0,menhir_stack$1]);
                          case 12:
                           if(counter < 50)
                            {var counter$94=counter + 1 | 0;
                             return menhir_run27(counter$94,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run27,[0,menhir_env$0,menhir_stack$1]);
                          case 13:
                           if(counter < 50)
                            {var counter$79=counter + 1 | 0;
                             return menhir_run31(counter$79,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run31,[0,menhir_env$0,menhir_stack$1]);
                          case 17:
                           if(counter < 50)
                            {var counter$66=counter + 1 | 0;
                             return menhir_run40(counter$66,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run40,[0,menhir_env$0,menhir_stack$1]);
                          case 22:
                           if(counter < 50)
                            {var counter$60=counter + 1 | 0;
                             return menhir_run33(counter$60,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run33,[0,menhir_env$0,menhir_stack$1]);
                          case 25:
                           if(counter < 50)
                            {var counter$49=counter + 1 | 0;
                             return menhir_run25(counter$49,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run25,[0,menhir_env$0,menhir_stack$1]);
                          case 28:
                           if(counter < 50)
                            {var counter$32=counter + 1 | 0;
                             return menhir_run44(counter$32,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run44,[0,menhir_env$0,menhir_stack$1]);
                          case 29:
                           if(counter < 50)
                            {var counter$26=counter + 1 | 0;
                             return menhir_run46(counter$26,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run46,[0,menhir_env$0,menhir_stack$1]);
                          case 30:
                           if(counter < 50)
                            {var counter$19=counter + 1 | 0;
                             return menhir_run35(counter$19,menhir_env$0,menhir_stack$1)}
                           return caml_trampoline_return
                                   (menhir_run35,[0,menhir_env$0,menhir_stack$1])
                          }
                       if(menhir_env$0[4])throw [0,Assert_failure,_cj_];
                       menhir_env$0[4] = 1;
                       var
                        menhir_s$37=menhir_stack$1[2],
                        menhir_stack$40=menhir_stack$1[1];
                       return menhir_errorcase
                               (menhir_env$0,menhir_stack$40,menhir_s$37);
                      default:return menhir_fail(0)}}},
               menhir_goto_command=
                function(counter,menhir_env,menhir_stack,menhir_s,v)
                 {var menhir_stack$0=[0,menhir_stack,menhir_s,v];
                  if(menhir_env[4])throw [0,Assert_failure,_ck_];
                  var tok=menhir_env[3];
                  if(typeof tok === "number")
                   {if(23 === tok)
                     {var
                       menhir_env$0=menhir_discard(menhir_env),
                       tok$0=menhir_env$0[3],
                       switch$0=0;
                      if(typeof tok$0 === "number")
                       switch(tok$0)
                        {case 23:
                          var _hO_=4;
                          if(counter < 50)
                           {var counter$0=counter + 1 | 0;
                            return menhir_run1$0
                                    (counter$0,menhir_env$0,menhir_stack$0,_hO_)}
                          return caml_trampoline_return
                                  (menhir_run1$0,[0,menhir_env$0,menhir_stack$0,_hO_]);
                         case 16:
                         case 24:switch$0 = 1;break
                         }
                      else
                       switch(tok$0[0]){case 0:case 3:break;default:switch$0 = 1}
                      if(switch$0)
                       {var _hN_=4;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_reduce26$0
                                  (counter$1,menhir_env$0,menhir_stack$0,_hN_)}
                        return caml_trampoline_return
                                (menhir_reduce26$0,[0,menhir_env$0,menhir_stack$0,_hN_])}
                      if(menhir_env$0[4])throw [0,Assert_failure,_cl_];
                      menhir_env$0[4] = 1;
                      return menhir_errorcase(menhir_env$0,menhir_stack$0,4)}
                    if(24 === tok)
                     {var
                       cmd=menhir_stack$0[3],
                       match=menhir_stack$0[1],
                       menhir_s$0=match[2],
                       menhir_stack$1=match[1],
                       v$0=[0,cmd,0];
                      return menhir_goto_ast
                              (menhir_env,menhir_stack$1,menhir_s$0,v$0)}}
                  if(menhir_env[4])throw [0,Assert_failure,_cm_];
                  menhir_env[4] = 1;
                  var
                   menhir_s$1=menhir_stack$0[2],
                   menhir_stack$2=menhir_stack$0[1];
                  return menhir_errorcase
                          (menhir_env,menhir_stack$2,menhir_s$1)},
               menhir_goto_number=
                function(counter,menhir_env,menhir_stack,menhir_s,nb,startpos)
                 {switch(menhir_s)
                   {case 6:
                     var
                      menhir_s$0=menhir_stack[2],
                      menhir_stack$0=menhir_stack[1],
                      v$0=[1,nb];
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return menhir_goto_arg
                               (counter$0,menhir_env,menhir_stack$0,menhir_s$0,v$0)}
                     return caml_trampoline_return
                             (menhir_goto_arg,
                              [0,menhir_env,menhir_stack$0,menhir_s$0,v$0]);
                    case 8:
                     var
                      match=menhir_stack[1],
                      menhir_s$1=match[2],
                      menhir_stack$1=match[1],
                      v$2=[0,sign_minus,nb];
                     if(counter < 50)
                      {var counter$3=counter + 1 | 0;
                       return menhir_goto_offset
                               (counter$3,menhir_env,menhir_stack$1,menhir_s$1,v$2)}
                     return caml_trampoline_return
                             (menhir_goto_offset,
                              [0,menhir_env,menhir_stack$1,menhir_s$1,v$2]);
                    case 9:
                     var
                      match$0=menhir_stack[1],
                      menhir_s$2=match$0[2],
                      menhir_stack$2=match$0[1],
                      v$3=[0,sign_plus,nb];
                     if(counter < 50)
                      {var counter$4=counter + 1 | 0;
                       return menhir_goto_offset
                               (counter$4,menhir_env,menhir_stack$2,menhir_s$2,v$3)}
                     return caml_trampoline_return
                             (menhir_goto_offset,
                              [0,menhir_env,menhir_stack$2,menhir_s$2,v$3]);
                    case 10:
                     var
                      menhir_s$3=menhir_stack[2],
                      menhir_stack$3=menhir_stack[1],
                      v$4=[0,sign_plus,nb];
                     if(counter < 50)
                      {var counter$5=counter + 1 | 0;
                       return menhir_goto_offset
                               (counter$5,menhir_env,menhir_stack$3,menhir_s$3,v$4)}
                     return caml_trampoline_return
                             (menhir_goto_offset,
                              [0,menhir_env,menhir_stack$3,menhir_s$3,v$4]);
                    case 11:
                     var
                      menhir_s$4=menhir_stack[2],
                      menhir_stack$4=menhir_stack[1],
                      v$5=[0,sign_minus,nb];
                     if(counter < 50)
                      {var counter$6=counter + 1 | 0;
                       return menhir_goto_offset
                               (counter$6,menhir_env,menhir_stack$4,menhir_s$4,v$5)}
                     return caml_trampoline_return
                             (menhir_goto_offset,
                              [0,menhir_env,menhir_stack$4,menhir_s$4,v$5]);
                    case 12:
                     var
                      menhir_s$5=menhir_stack[2],
                      menhir_stack$5=menhir_stack[1],
                      v$6=[0,sign_plus,nb];
                     if(counter < 50)
                      {var counter$7=counter + 1 | 0;
                       return menhir_goto_offset
                               (counter$7,menhir_env,menhir_stack$5,menhir_s$5,v$6)}
                     return caml_trampoline_return
                             (menhir_goto_offset,
                              [0,menhir_env,menhir_stack$5,menhir_s$5,v$6]);
                    case 37:
                     var v$7=[1,startpos,nb];
                     if(counter < 50)
                      {var counter$2=counter + 1 | 0;
                       return menhir_goto_command
                               (counter$2,menhir_env,menhir_stack,menhir_s,v$7)}
                     return caml_trampoline_return
                             (menhir_goto_command,
                              [0,menhir_env,menhir_stack,menhir_s,v$7]);
                    case 7:
                    case 13:
                     var v$1=[0,sign_plus,nb];
                     if(counter < 50)
                      {var counter$8=counter + 1 | 0;
                       return menhir_goto_offset
                               (counter$8,menhir_env,menhir_stack,menhir_s,v$1)}
                     return caml_trampoline_return
                             (menhir_goto_offset,
                              [0,menhir_env,menhir_stack,menhir_s,v$1]);
                    case 5:
                    case 14:
                     var v=[1,nb];
                     if(counter < 50)
                      {var counter$1=counter + 1 | 0;
                       return menhir_goto_arg
                               (counter$1,menhir_env,menhir_stack,menhir_s,v)}
                     return caml_trampoline_return
                             (menhir_goto_arg,[0,menhir_env,menhir_stack,menhir_s,v]);
                    default:return menhir_fail(0)}},
               menhir_run59=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_stack$0=[0,menhir_stack,menhir_s],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   {if(16 === tok)
                     {var _hJ_=menhir_env$0[2][11],_hK_=12;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run5
                                (counter$0,menhir_env$0,menhir_stack$0,_hK_,_hJ_)}
                      return caml_trampoline_return
                              (menhir_run5,[0,menhir_env$0,menhir_stack$0,_hK_,_hJ_])}}
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_hL_=menhir_env$0[2][11],_hM_=12;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run4
                                (counter$1,menhir_env$0,menhir_stack$0,_hM_,v,_hL_)}
                      return caml_trampoline_return
                              (menhir_run4,[0,menhir_env$0,menhir_stack$0,_hM_,v,_hL_]);
                     case 2:
                      var
                       v$0=tok[1],
                       menhir_env$1=menhir_discard(menhir_env$0),
                       menhir_s$0=menhir_stack$0[2],
                       menhir_stack$1=menhir_stack$0[1],
                       v$1=[1,sign_plus,v$0];
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_goto_offset
                                (counter$2,menhir_env$1,menhir_stack$1,menhir_s$0,v$1)}
                      return caml_trampoline_return
                              (menhir_goto_offset,
                               [0,menhir_env$1,menhir_stack$1,menhir_s$0,v$1])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_cn_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack$0,12)},
               menhir_run62=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_stack$0=[0,menhir_stack,menhir_s],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   {if(16 === tok)
                     {var _hF_=menhir_env$0[2][11],_hG_=11;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run5
                                (counter$0,menhir_env$0,menhir_stack$0,_hG_,_hF_)}
                      return caml_trampoline_return
                              (menhir_run5,[0,menhir_env$0,menhir_stack$0,_hG_,_hF_])}}
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_hH_=menhir_env$0[2][11],_hI_=11;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run4
                                (counter$1,menhir_env$0,menhir_stack$0,_hI_,v,_hH_)}
                      return caml_trampoline_return
                              (menhir_run4,[0,menhir_env$0,menhir_stack$0,_hI_,v,_hH_]);
                     case 2:
                      var
                       v$0=tok[1],
                       menhir_env$1=menhir_discard(menhir_env$0),
                       menhir_s$0=menhir_stack$0[2],
                       menhir_stack$1=menhir_stack$0[1],
                       v$1=[1,sign_minus,v$0];
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_goto_offset
                                (counter$2,menhir_env$1,menhir_stack$1,menhir_s$0,v$1)}
                      return caml_trampoline_return
                              (menhir_goto_offset,
                               [0,menhir_env$1,menhir_stack$1,menhir_s$0,v$1])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_co_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack$0,11)},
               menhir_run65=
                function(counter,menhir_env,menhir_stack,menhir_s,id,startpos)
                 {var
                   menhir_env$0=menhir_discard(menhir_env),
                   v=[1,sign_plus,id];
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_goto_offset
                            (counter$0,menhir_env$0,menhir_stack,menhir_s,v)}
                  return caml_trampoline_return
                          (menhir_goto_offset,
                           [0,menhir_env$0,menhir_stack,menhir_s,v])},
               menhir_run66=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_stack$0=[0,menhir_stack,menhir_s],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var
                       menhir_stack$1=[0,menhir_stack$0,10],
                       menhir_env$1=menhir_discard(menhir_env$0),
                       tok$0=menhir_env$1[3];
                      if(typeof tok$0 === "number")
                       {if(16 === tok$0)
                         {var _ht_=menhir_env$1[2][11],_hu_=9;
                          if(counter < 50)
                           {var counter$0=counter + 1 | 0;
                            return menhir_run5
                                    (counter$0,menhir_env$1,menhir_stack$1,_hu_,_ht_)}
                          return caml_trampoline_return
                                  (menhir_run5,[0,menhir_env$1,menhir_stack$1,_hu_,_ht_])}}
                      else
                       if(1 === tok$0[0])
                        {var v=tok$0[1],_hv_=menhir_env$1[2][11],_hw_=9;
                         if(counter < 50)
                          {var counter$3=counter + 1 | 0;
                           return menhir_run4
                                   (counter$3,menhir_env$1,menhir_stack$1,_hw_,v,_hv_)}
                         return caml_trampoline_return
                                 (menhir_run4,[0,menhir_env$1,menhir_stack$1,_hw_,v,_hv_])}
                      if(menhir_env$1[4])throw [0,Assert_failure,_cq_];
                      menhir_env$1[4] = 1;
                      return menhir_errorcase(menhir_env$1,menhir_stack$1,9);
                     case 12:
                      var
                       menhir_stack$2=[0,menhir_stack$0,10],
                       menhir_env$2=menhir_discard(menhir_env$0),
                       tok$1=menhir_env$2[3];
                      if(typeof tok$1 === "number")
                       {if(16 === tok$1)
                         {var _hx_=menhir_env$2[2][11],_hy_=8;
                          if(counter < 50)
                           {var counter$1=counter + 1 | 0;
                            return menhir_run5
                                    (counter$1,menhir_env$2,menhir_stack$2,_hy_,_hx_)}
                          return caml_trampoline_return
                                  (menhir_run5,[0,menhir_env$2,menhir_stack$2,_hy_,_hx_])}}
                      else
                       if(1 === tok$1[0])
                        {var v$0=tok$1[1],_hz_=menhir_env$2[2][11],_hA_=8;
                         if(counter < 50)
                          {var counter$4=counter + 1 | 0;
                           return menhir_run4
                                   (counter$4,menhir_env$2,menhir_stack$2,_hA_,v$0,_hz_)}
                         return caml_trampoline_return
                                 (menhir_run4,[0,menhir_env$2,menhir_stack$2,_hA_,v$0,_hz_])}
                      if(menhir_env$2[4])throw [0,Assert_failure,_cr_];
                      menhir_env$2[4] = 1;
                      return menhir_errorcase(menhir_env$2,menhir_stack$2,8);
                     case 16:
                      var _hB_=menhir_env$0[2][11],_hC_=10;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run5
                                (counter$2,menhir_env$0,menhir_stack$0,_hC_,_hB_)}
                      return caml_trampoline_return
                              (menhir_run5,[0,menhir_env$0,menhir_stack$0,_hC_,_hB_])
                     }
                  else
                   if(1 === tok[0])
                    {var v$1=tok[1],_hD_=menhir_env$0[2][11],_hE_=10;
                     if(counter < 50)
                      {var counter$5=counter + 1 | 0;
                       return menhir_run4
                               (counter$5,menhir_env$0,menhir_stack$0,_hE_,v$1,_hD_)}
                     return caml_trampoline_return
                             (menhir_run4,[0,menhir_env$0,menhir_stack$0,_hE_,v$1,_hD_])}
                  if(menhir_env$0[4])throw [0,Assert_failure,_cp_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack$0,10)},
               menhir_goto_arg=
                function(counter,menhir_env,menhir_stack$1,menhir_s$1,v$1)
                 {var menhir_stack$2=[0,menhir_stack$1,menhir_s$1,v$1];
                  if(menhir_env[4])throw [0,Assert_failure,_cs_];
                  var tok=menhir_env[3];
                  if(typeof tok === "number")
                   {var switcher=tok - 17 | 0;
                    if(! (9 < switcher >>> 0))
                     switch(switcher)
                      {case 9:
                        var
                         menhir_env$0=menhir_discard(menhir_env),
                         tok$0=menhir_env$0[3];
                        if(typeof tok$0 === "number")
                         switch(tok$0)
                          {case 15:
                            var _hl_=5;
                            if(counter < 50)
                             {var counter$3=counter + 1 | 0;
                              return menhir_run54
                                      (counter$3,menhir_env$0,menhir_stack$2,_hl_)}
                            return caml_trampoline_return
                                    (menhir_run54,[0,menhir_env$0,menhir_stack$2,_hl_]);
                           case 16:
                            var _hm_=menhir_env$0[2][11],_hn_=5;
                            if(counter < 50)
                             {var counter$2=counter + 1 | 0;
                              return menhir_run5
                                      (counter$2,menhir_env$0,menhir_stack$2,_hn_,_hm_)}
                            return caml_trampoline_return
                                    (menhir_run5,[0,menhir_env$0,menhir_stack$2,_hn_,_hm_]);
                           case 19:
                            var _ho_=5;
                            if(counter < 50)
                             {var counter$0=counter + 1 | 0;
                              return menhir_run79
                                      (counter$0,menhir_env$0,menhir_stack$2,_ho_)}
                            return caml_trampoline_return
                                    (menhir_run79,[0,menhir_env$0,menhir_stack$2,_ho_])
                           }
                        else
                         switch(tok$0[0])
                          {case 1:
                            var v$3=tok$0[1],_hp_=menhir_env$0[2][11],_hq_=5;
                            if(counter < 50)
                             {var counter$4=counter + 1 | 0;
                              return menhir_run4
                                      (counter$4,menhir_env$0,menhir_stack$2,_hq_,v$3,_hp_)}
                            return caml_trampoline_return
                                    (menhir_run4,[0,menhir_env$0,menhir_stack$2,_hq_,v$3,_hp_]);
                           case 2:
                            var v$4=tok$0[1],_hr_=menhir_env$0[2][11],_hs_=5;
                            if(counter < 50)
                             {var counter$1=counter + 1 | 0;
                              return menhir_run78
                                      (counter$1,menhir_env$0,menhir_stack$2,_hs_,v$4,_hr_)}
                            return caml_trampoline_return
                                    (menhir_run78,[0,menhir_env$0,menhir_stack$2,_hs_,v$4,_hr_])
                           }
                        if(menhir_env$0[4])throw [0,Assert_failure,_cu_];
                        menhir_env$0[4] = 1;
                        return menhir_errorcase(menhir_env$0,menhir_stack$2,5);
                       case 0:
                       case 6:
                       case 7:
                        var
                         x$0=menhir_stack$2[3],
                         menhir_s$3=menhir_stack$2[2],
                         menhir_stack$4=menhir_stack$2[1],
                         v$2=[0,x$0,0],
                         menhir_stack=menhir_stack$4,
                         menhir_s=menhir_s$3,
                         v=v$2;
                        for(;;)
                         {if(5 === menhir_s)
                           {var
                             x=menhir_stack[3],
                             menhir_s$0=menhir_stack[2],
                             menhir_stack$0=menhir_stack[1],
                             v$0=[0,x,v],
                             menhir_stack=menhir_stack$0,
                             menhir_s=menhir_s$0,
                             v=v$0;
                            continue}
                          if(14 === menhir_s)
                           {if(counter < 50)
                             {var counter$5=counter + 1 | 0;
                              return menhir_goto_loption_separated_
                                      (counter$5,menhir_env,menhir_stack,menhir_s,v)}
                            return caml_trampoline_return
                                    (menhir_goto_loption_separated_,
                                     [0,menhir_env,menhir_stack,menhir_s,v])}
                          return menhir_fail(0)}
                       }}
                  if(menhir_env[4])throw [0,Assert_failure,_ct_];
                  menhir_env[4] = 1;
                  var
                   menhir_s$2=menhir_stack$2[2],
                   menhir_stack$3=menhir_stack$2[1];
                  return menhir_errorcase
                          (menhir_env,menhir_stack$3,menhir_s$2)},
               menhir_run6=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s;
                  for(;;)
                   {var
                     menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok=menhir_env$1[3];
                    if(typeof tok === "number")
                     switch(tok)
                      {case 6:
                        var
                         menhir_env$0=menhir_env$1,
                         menhir_stack$0=menhir_stack$1,
                         menhir_s$0=35;
                        continue;
                       case 9:
                        var _hd_=35;
                        if(counter < 50)
                         {var counter$4=counter + 1 | 0;
                          return menhir_run8
                                  (counter$4,menhir_env$1,menhir_stack$1,_hd_)}
                        return caml_trampoline_return
                                (menhir_run8,[0,menhir_env$1,menhir_stack$1,_hd_]);
                       case 12:
                        var _he_=35;
                        if(counter < 50)
                         {var counter$3=counter + 1 | 0;
                          return menhir_run9
                                  (counter$3,menhir_env$1,menhir_stack$1,_he_)}
                        return caml_trampoline_return
                                (menhir_run9,[0,menhir_env$1,menhir_stack$1,_he_]);
                       case 14:
                        var _hf_=35;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run10
                                  (counter$2,menhir_env$1,menhir_stack$1,_hf_)}
                        return caml_trampoline_return
                                (menhir_run10,[0,menhir_env$1,menhir_stack$1,_hf_]);
                       case 20:
                        var _hg_=35;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run12
                                  (counter$0,menhir_env$1,menhir_stack$1,_hg_)}
                        return caml_trampoline_return
                                (menhir_run12,[0,menhir_env$1,menhir_stack$1,_hg_])
                       }
                    else
                     switch(tok[0])
                      {case 1:
                        var v=tok[1],_hh_=menhir_env$1[2][11],_hi_=35;
                        if(counter < 50)
                         {var counter$5=counter + 1 | 0;
                          return menhir_run7
                                  (counter$5,menhir_env$1,menhir_stack$1,_hi_,v,_hh_)}
                        return caml_trampoline_return
                                (menhir_run7,[0,menhir_env$1,menhir_stack$1,_hi_,v,_hh_]);
                       case 2:
                        var v$0=tok[1],_hj_=menhir_env$1[2][11],_hk_=35;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_run11
                                  (counter$1,menhir_env$1,menhir_stack$1,_hk_,v$0,_hj_)}
                        return caml_trampoline_return
                                (menhir_run11,[0,menhir_env$1,menhir_stack$1,_hk_,v$0,_hj_])
                       }
                    if(menhir_env$1[4])throw [0,Assert_failure,_cx_];
                    menhir_env$1[4] = 1;
                    return menhir_errorcase(menhir_env$1,menhir_stack$1,35)}},
               menhir_run7=
                function(counter,menhir_env,menhir_stack,menhir_s,i,startpos)
                 {var menhir_env$0=menhir_discard(menhir_env),v=[0,i];
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_goto_meta_expr
                            (counter$0,menhir_env$0,menhir_stack,menhir_s,v)}
                  return caml_trampoline_return
                          (menhir_goto_meta_expr,
                           [0,menhir_env$0,menhir_stack,menhir_s,v])},
               menhir_run8=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s;
                  for(;;)
                   {var
                     menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok=menhir_env$1[3];
                    if(typeof tok === "number")
                     switch(tok)
                      {case 6:
                        var _g7_=34;
                        if(counter < 50)
                         {var counter$5=counter + 1 | 0;
                          return menhir_run6
                                  (counter$5,menhir_env$1,menhir_stack$1,_g7_)}
                        return caml_trampoline_return
                                (menhir_run6,[0,menhir_env$1,menhir_stack$1,_g7_]);
                       case 9:
                        var
                         menhir_env$0=menhir_env$1,
                         menhir_stack$0=menhir_stack$1,
                         menhir_s$0=34;
                        continue;
                       case 12:
                        var _g8_=34;
                        if(counter < 50)
                         {var counter$3=counter + 1 | 0;
                          return menhir_run9
                                  (counter$3,menhir_env$1,menhir_stack$1,_g8_)}
                        return caml_trampoline_return
                                (menhir_run9,[0,menhir_env$1,menhir_stack$1,_g8_]);
                       case 14:
                        var _g9_=34;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run10
                                  (counter$2,menhir_env$1,menhir_stack$1,_g9_)}
                        return caml_trampoline_return
                                (menhir_run10,[0,menhir_env$1,menhir_stack$1,_g9_]);
                       case 20:
                        var _g__=34;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run12
                                  (counter$0,menhir_env$1,menhir_stack$1,_g__)}
                        return caml_trampoline_return
                                (menhir_run12,[0,menhir_env$1,menhir_stack$1,_g__])
                       }
                    else
                     switch(tok[0])
                      {case 1:
                        var v=tok[1],_g$_=menhir_env$1[2][11],_ha_=34;
                        if(counter < 50)
                         {var counter$4=counter + 1 | 0;
                          return menhir_run7
                                  (counter$4,menhir_env$1,menhir_stack$1,_ha_,v,_g$_)}
                        return caml_trampoline_return
                                (menhir_run7,[0,menhir_env$1,menhir_stack$1,_ha_,v,_g$_]);
                       case 2:
                        var v$0=tok[1],_hb_=menhir_env$1[2][11],_hc_=34;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_run11
                                  (counter$1,menhir_env$1,menhir_stack$1,_hc_,v$0,_hb_)}
                        return caml_trampoline_return
                                (menhir_run11,[0,menhir_env$1,menhir_stack$1,_hc_,v$0,_hb_])
                       }
                    if(menhir_env$1[4])throw [0,Assert_failure,_cy_];
                    menhir_env$1[4] = 1;
                    return menhir_errorcase(menhir_env$1,menhir_stack$1,34)}},
               menhir_run9=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s;
                  for(;;)
                   {var
                     menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok=menhir_env$1[3];
                    if(typeof tok === "number")
                     switch(tok)
                      {case 6:
                        var _gZ_=33;
                        if(counter < 50)
                         {var counter$5=counter + 1 | 0;
                          return menhir_run6
                                  (counter$5,menhir_env$1,menhir_stack$1,_gZ_)}
                        return caml_trampoline_return
                                (menhir_run6,[0,menhir_env$1,menhir_stack$1,_gZ_]);
                       case 9:
                        var _g0_=33;
                        if(counter < 50)
                         {var counter$3=counter + 1 | 0;
                          return menhir_run8
                                  (counter$3,menhir_env$1,menhir_stack$1,_g0_)}
                        return caml_trampoline_return
                                (menhir_run8,[0,menhir_env$1,menhir_stack$1,_g0_]);
                       case 12:
                        var
                         menhir_env$0=menhir_env$1,
                         menhir_stack$0=menhir_stack$1,
                         menhir_s$0=33;
                        continue;
                       case 14:
                        var _g1_=33;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run10
                                  (counter$2,menhir_env$1,menhir_stack$1,_g1_)}
                        return caml_trampoline_return
                                (menhir_run10,[0,menhir_env$1,menhir_stack$1,_g1_]);
                       case 20:
                        var _g2_=33;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run12
                                  (counter$0,menhir_env$1,menhir_stack$1,_g2_)}
                        return caml_trampoline_return
                                (menhir_run12,[0,menhir_env$1,menhir_stack$1,_g2_])
                       }
                    else
                     switch(tok[0])
                      {case 1:
                        var v=tok[1],_g3_=menhir_env$1[2][11],_g4_=33;
                        if(counter < 50)
                         {var counter$4=counter + 1 | 0;
                          return menhir_run7
                                  (counter$4,menhir_env$1,menhir_stack$1,_g4_,v,_g3_)}
                        return caml_trampoline_return
                                (menhir_run7,[0,menhir_env$1,menhir_stack$1,_g4_,v,_g3_]);
                       case 2:
                        var v$0=tok[1],_g5_=menhir_env$1[2][11],_g6_=33;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_run11
                                  (counter$1,menhir_env$1,menhir_stack$1,_g6_,v$0,_g5_)}
                        return caml_trampoline_return
                                (menhir_run11,[0,menhir_env$1,menhir_stack$1,_g6_,v$0,_g5_])
                       }
                    if(menhir_env$1[4])throw [0,Assert_failure,_cz_];
                    menhir_env$1[4] = 1;
                    return menhir_errorcase(menhir_env$1,menhir_stack$1,33)}},
               menhir_run10=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s;
                  for(;;)
                   {var
                     menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok=menhir_env$1[3];
                    if(typeof tok === "number")
                     switch(tok)
                      {case 6:
                        var _gR_=32;
                        if(counter < 50)
                         {var counter$5=counter + 1 | 0;
                          return menhir_run6
                                  (counter$5,menhir_env$1,menhir_stack$1,_gR_)}
                        return caml_trampoline_return
                                (menhir_run6,[0,menhir_env$1,menhir_stack$1,_gR_]);
                       case 9:
                        var _gS_=32;
                        if(counter < 50)
                         {var counter$3=counter + 1 | 0;
                          return menhir_run8
                                  (counter$3,menhir_env$1,menhir_stack$1,_gS_)}
                        return caml_trampoline_return
                                (menhir_run8,[0,menhir_env$1,menhir_stack$1,_gS_]);
                       case 12:
                        var _gT_=32;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run9
                                  (counter$2,menhir_env$1,menhir_stack$1,_gT_)}
                        return caml_trampoline_return
                                (menhir_run9,[0,menhir_env$1,menhir_stack$1,_gT_]);
                       case 14:
                        var
                         menhir_env$0=menhir_env$1,
                         menhir_stack$0=menhir_stack$1,
                         menhir_s$0=32;
                        continue;
                       case 20:
                        var _gU_=32;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run12
                                  (counter$0,menhir_env$1,menhir_stack$1,_gU_)}
                        return caml_trampoline_return
                                (menhir_run12,[0,menhir_env$1,menhir_stack$1,_gU_])
                       }
                    else
                     switch(tok[0])
                      {case 1:
                        var v=tok[1],_gV_=menhir_env$1[2][11],_gW_=32;
                        if(counter < 50)
                         {var counter$4=counter + 1 | 0;
                          return menhir_run7
                                  (counter$4,menhir_env$1,menhir_stack$1,_gW_,v,_gV_)}
                        return caml_trampoline_return
                                (menhir_run7,[0,menhir_env$1,menhir_stack$1,_gW_,v,_gV_]);
                       case 2:
                        var v$0=tok[1],_gX_=menhir_env$1[2][11],_gY_=32;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_run11
                                  (counter$1,menhir_env$1,menhir_stack$1,_gY_,v$0,_gX_)}
                        return caml_trampoline_return
                                (menhir_run11,[0,menhir_env$1,menhir_stack$1,_gY_,v$0,_gX_])
                       }
                    if(menhir_env$1[4])throw [0,Assert_failure,_cA_];
                    menhir_env$1[4] = 1;
                    return menhir_errorcase(menhir_env$1,menhir_stack$1,32)}},
               menhir_run11=
                function(counter,menhir_env,menhir_stack,menhir_s,v,startpos)
                 {var menhir_env$0=menhir_discard(menhir_env),v$0=[3,v];
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_goto_meta_expr
                            (counter$0,menhir_env$0,menhir_stack,menhir_s,v$0)}
                  return caml_trampoline_return
                          (menhir_goto_meta_expr,
                           [0,menhir_env$0,menhir_stack,menhir_s,v$0])},
               menhir_run12=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s;
                  for(;;)
                   {var
                     menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok=menhir_env$1[3];
                    if(typeof tok === "number")
                     switch(tok)
                      {case 6:
                        var _gJ_=31;
                        if(counter < 50)
                         {var counter$5=counter + 1 | 0;
                          return menhir_run6
                                  (counter$5,menhir_env$1,menhir_stack$1,_gJ_)}
                        return caml_trampoline_return
                                (menhir_run6,[0,menhir_env$1,menhir_stack$1,_gJ_]);
                       case 9:
                        var _gK_=31;
                        if(counter < 50)
                         {var counter$3=counter + 1 | 0;
                          return menhir_run8
                                  (counter$3,menhir_env$1,menhir_stack$1,_gK_)}
                        return caml_trampoline_return
                                (menhir_run8,[0,menhir_env$1,menhir_stack$1,_gK_]);
                       case 12:
                        var _gL_=31;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run9
                                  (counter$2,menhir_env$1,menhir_stack$1,_gL_)}
                        return caml_trampoline_return
                                (menhir_run9,[0,menhir_env$1,menhir_stack$1,_gL_]);
                       case 14:
                        var _gM_=31;
                        if(counter < 50)
                         {var counter$1=counter + 1 | 0;
                          return menhir_run10
                                  (counter$1,menhir_env$1,menhir_stack$1,_gM_)}
                        return caml_trampoline_return
                                (menhir_run10,[0,menhir_env$1,menhir_stack$1,_gM_]);
                       case 20:
                        var
                         menhir_env$0=menhir_env$1,
                         menhir_stack$0=menhir_stack$1,
                         menhir_s$0=31;
                        continue
                       }
                    else
                     switch(tok[0])
                      {case 1:
                        var v=tok[1],_gN_=menhir_env$1[2][11],_gO_=31;
                        if(counter < 50)
                         {var counter$4=counter + 1 | 0;
                          return menhir_run7
                                  (counter$4,menhir_env$1,menhir_stack$1,_gO_,v,_gN_)}
                        return caml_trampoline_return
                                (menhir_run7,[0,menhir_env$1,menhir_stack$1,_gO_,v,_gN_]);
                       case 2:
                        var v$0=tok[1],_gP_=menhir_env$1[2][11],_gQ_=31;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run11
                                  (counter$0,menhir_env$1,menhir_stack$1,_gQ_,v$0,_gP_)}
                        return caml_trampoline_return
                                (menhir_run11,[0,menhir_env$1,menhir_stack$1,_gQ_,v$0,_gP_])
                       }
                    if(menhir_env$1[4])throw [0,Assert_failure,_cB_];
                    menhir_env$1[4] = 1;
                    return menhir_errorcase(menhir_env$1,menhir_stack$1,31)}},
               menhir_goto_definition=
                function(counter,menhir_env,menhir_stack,v)
                 {var menhir_stack$0=[0,menhir_stack,v];
                  if(menhir_env[4])throw [0,Assert_failure,_cC_];
                  var tok=menhir_env[3];
                  if(typeof tok === "number" && 23 === tok)
                   {var
                     menhir_env$0=menhir_discard(menhir_env),
                     tok$0=menhir_env$0[3],
                     switch$0=0;
                    if(typeof tok$0 === "number")
                     switch(tok$0)
                      {case 23:
                        var _gI_=0;
                        if(counter < 50)
                         {var counter$0=counter + 1 | 0;
                          return menhir_run1$0
                                  (counter$0,menhir_env$0,menhir_stack$0,_gI_)}
                        return caml_trampoline_return
                                (menhir_run1$0,[0,menhir_env$0,menhir_stack$0,_gI_]);
                       case 18:switch$0 = 1;break
                       }
                    else
                     if(2 === tok$0[0])switch$0 = 1;
                    if(switch$0)
                     {var _gH_=0;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_reduce26$0
                                (counter$1,menhir_env$0,menhir_stack$0,_gH_)}
                      return caml_trampoline_return
                              (menhir_reduce26$0,[0,menhir_env$0,menhir_stack$0,_gH_])}
                    if(menhir_env$0[4])throw [0,Assert_failure,_cD_];
                    menhir_env$0[4] = 1;
                    return menhir_errorcase(menhir_env$0,menhir_stack$0,0)}
                  if(menhir_env[4])throw [0,Assert_failure,_cE_];
                  menhir_env[4] = 1;
                  var
                   match=menhir_stack$0[1],
                   menhir_s=match[2],
                   menhir_stack$1=match[1];
                  return menhir_errorcase(menhir_env,menhir_stack$1,menhir_s)},
               menhir_goto_loption_separated_=
                function(counter,menhir_env,match,menhir_s,args)
                 {if(menhir_env[4])throw [0,Assert_failure,_cF_];
                  var tok=menhir_env[3];
                  if(typeof tok === "number")
                   if(23 <= tok)
                    {if(! (25 <= tok))
                      {var
                        startpos_id=match[4],
                        id=match[3],
                        menhir_s$0=match[2],
                        menhir_stack=match[1],
                        v=[0,startpos_id,id,args,0];
                       if(counter < 50)
                        {var counter$0=counter + 1 | 0;
                         return menhir_goto_command
                                 (counter$0,menhir_env,menhir_stack,menhir_s$0,v)}
                       return caml_trampoline_return
                               (menhir_goto_command,
                                [0,menhir_env,menhir_stack,menhir_s$0,v])}}
                   else
                    if(17 === tok)
                     {var
                       menhir_env$0=menhir_discard(menhir_env),
                       tok$0=menhir_env$0[3];
                      if(typeof tok$0 === "number")
                       switch(tok$0)
                        {case 23:
                         case 24:
                          var
                           startpos_id$0=match[4],
                           id$0=match[3],
                           menhir_s$1=match[2],
                           menhir_stack$0=match[1],
                           v$0=[0,startpos_id$0,id$0,args,1];
                          if(counter < 50)
                           {var counter$2=counter + 1 | 0;
                            return menhir_goto_command
                                    (counter$2,menhir_env$0,menhir_stack$0,menhir_s$1,v$0)}
                          return caml_trampoline_return
                                  (menhir_goto_command,
                                   [0,menhir_env$0,menhir_stack$0,menhir_s$1,v$0])
                         }
                      else
                       if(1 === tok$0[0])
                        {var
                          v$1=tok$0[1],
                          menhir_env$1=menhir_discard(menhir_env$0),
                          startpos_id$1=match[4],
                          id$1=match[3],
                          menhir_s$2=match[2],
                          menhir_stack$1=match[1],
                          v$2=[0,startpos_id$1,id$1,args,[0,uint32_to_int(v$1)]];
                         if(counter < 50)
                          {var counter$1=counter + 1 | 0;
                           return menhir_goto_command
                                   (counter$1,menhir_env$1,menhir_stack$1,menhir_s$2,v$2)}
                         return caml_trampoline_return
                                 (menhir_goto_command,
                                  [0,menhir_env$1,menhir_stack$1,menhir_s$2,v$2])}
                      if(menhir_env$0[4])throw [0,Assert_failure,_cH_];
                      menhir_env$0[4] = 1;
                      return menhir_errorcase(menhir_env$0,match,menhir_s)}
                  if(menhir_env[4])throw [0,Assert_failure,_cG_];
                  menhir_env[4] = 1;
                  return menhir_errorcase(menhir_env,match,menhir_s)},
               menhir_run4=
                function
                 (counter,menhir_env,menhir_stack,menhir_s,i,startpos_i)
                 {var menhir_env$0=menhir_discard(menhir_env),v=[0,i];
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_goto_number
                            (counter$0,menhir_env$0,menhir_stack,menhir_s,v,startpos_i)}
                  return caml_trampoline_return
                          (menhir_goto_number,
                           [0,menhir_env$0,menhir_stack,menhir_s,v,startpos_i])},
               menhir_run54=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_stack$0=[0,menhir_stack,menhir_s],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok !== "number" && 2 === tok[0])
                   {var
                     v=tok[1],
                     startpos=menhir_env$0[2][11],
                     menhir_stack$2=[0,menhir_stack$0,v,startpos],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok$0=menhir_env$1[3];
                    if(typeof tok$0 === "number")
                     {if(4 === tok$0)
                       {var
                         menhir_env$2=menhir_discard(menhir_env$1),
                         tok$1=menhir_env$2[3];
                        if(typeof tok$1 === "number" && 17 <= tok$1)
                         {var switcher=tok$1 - 17 | 0;
                          switch(switcher)
                           {case 3:
                             var
                              menhir_env$3=menhir_discard(menhir_env$2),
                              id$0=menhir_stack$2[2],
                              match$1=menhir_stack$2[1],
                              menhir_s$3=match$1[2],
                              menhir_stack$5=match$1[1],
                              v$1=[2,id$0,[0,sign_plus,[0,Stdlib_int32[1]]],1];
                             if(counter < 50)
                              {var counter$4=counter + 1 | 0;
                               return menhir_goto_arg
                                       (counter$4,menhir_env$3,menhir_stack$5,menhir_s$3,v$1)}
                             return caml_trampoline_return
                                     (menhir_goto_arg,
                                      [0,menhir_env$3,menhir_stack$5,menhir_s$3,v$1]);
                            case 9:
                             var
                              menhir_env$4=menhir_discard(menhir_env$2),
                              tok$2=menhir_env$4[3];
                             if(typeof tok$2 === "number")
                              switch(tok$2)
                               {case 6:
                                 var _gp_=13;
                                 if(counter < 50)
                                  {var counter$13=counter + 1 | 0;
                                   return menhir_run59
                                           (counter$13,menhir_env$4,menhir_stack$2,_gp_)}
                                 return caml_trampoline_return
                                         (menhir_run59,[0,menhir_env$4,menhir_stack$2,_gp_]);
                                case 12:
                                 var _gq_=13;
                                 if(counter < 50)
                                  {var counter$11=counter + 1 | 0;
                                   return menhir_run62
                                           (counter$11,menhir_env$4,menhir_stack$2,_gq_)}
                                 return caml_trampoline_return
                                         (menhir_run62,[0,menhir_env$4,menhir_stack$2,_gq_]);
                                case 16:
                                 var _gr_=menhir_env$4[2][11],_gs_=13;
                                 if(counter < 50)
                                  {var counter$1=counter + 1 | 0;
                                   return menhir_run5
                                           (counter$1,menhir_env$4,menhir_stack$2,_gs_,_gr_)}
                                 return caml_trampoline_return
                                         (menhir_run5,[0,menhir_env$4,menhir_stack$2,_gs_,_gr_]);
                                case 19:
                                 var _gt_=13;
                                 if(counter < 50)
                                  {var counter$7=counter + 1 | 0;
                                   return menhir_run66
                                           (counter$7,menhir_env$4,menhir_stack$2,_gt_)}
                                 return caml_trampoline_return
                                         (menhir_run66,[0,menhir_env$4,menhir_stack$2,_gt_])
                                }
                             else
                              switch(tok$2[0])
                               {case 1:
                                 var v$2=tok$2[1],_gu_=menhir_env$4[2][11],_gv_=13;
                                 if(counter < 50)
                                  {var counter$3=counter + 1 | 0;
                                   return menhir_run4
                                           (counter$3,menhir_env$4,menhir_stack$2,_gv_,v$2,_gu_)}
                                 return caml_trampoline_return
                                         (menhir_run4,[0,menhir_env$4,menhir_stack$2,_gv_,v$2,_gu_]);
                                case 2:
                                 var v$3=tok$2[1],_gw_=menhir_env$4[2][11],_gx_=13;
                                 if(counter < 50)
                                  {var counter$9=counter + 1 | 0;
                                   return menhir_run65
                                           (counter$9,menhir_env$4,menhir_stack$2,_gx_,v$3,_gw_)}
                                 return caml_trampoline_return
                                         (menhir_run65,[0,menhir_env$4,menhir_stack$2,_gx_,v$3,_gw_])
                                }
                             if(menhir_env$4[4])throw [0,Assert_failure,_cK_];
                             menhir_env$4[4] = 1;
                             return menhir_errorcase(menhir_env$4,menhir_stack$2,13);
                            case 0:
                            case 6:
                            case 7:
                             var
                              id=menhir_stack$2[2],
                              match=menhir_stack$2[1],
                              menhir_s$1=match[2],
                              menhir_stack$3=match[1],
                              v$0=[2,id,[0,sign_plus,[0,Stdlib_int32[1]]],0];
                             if(counter < 50)
                              {var counter$5=counter + 1 | 0;
                               return menhir_goto_arg
                                       (counter$5,menhir_env$2,menhir_stack$3,menhir_s$1,v$0)}
                             return caml_trampoline_return
                                     (menhir_goto_arg,
                                      [0,menhir_env$2,menhir_stack$3,menhir_s$1,v$0])
                            }}
                        if(menhir_env$2[4])throw [0,Assert_failure,_cJ_];
                        menhir_env$2[4] = 1;
                        var
                         match$0=menhir_stack$2[1],
                         menhir_s$2=match$0[2],
                         menhir_stack$4=match$0[1];
                        return menhir_errorcase
                                (menhir_env$2,menhir_stack$4,menhir_s$2)}
                      if(26 === tok$0)
                       {var
                         menhir_env$5=menhir_discard(menhir_env$1),
                         tok$3=menhir_env$5[3];
                        if(typeof tok$3 === "number")
                         switch(tok$3)
                          {case 6:
                            var _gy_=7;
                            if(counter < 50)
                             {var counter$12=counter + 1 | 0;
                              return menhir_run59
                                      (counter$12,menhir_env$5,menhir_stack$2,_gy_)}
                            return caml_trampoline_return
                                    (menhir_run59,[0,menhir_env$5,menhir_stack$2,_gy_]);
                           case 12:
                            var _gz_=7;
                            if(counter < 50)
                             {var counter$10=counter + 1 | 0;
                              return menhir_run62
                                      (counter$10,menhir_env$5,menhir_stack$2,_gz_)}
                            return caml_trampoline_return
                                    (menhir_run62,[0,menhir_env$5,menhir_stack$2,_gz_]);
                           case 16:
                            var _gA_=menhir_env$5[2][11],_gB_=7;
                            if(counter < 50)
                             {var counter$0=counter + 1 | 0;
                              return menhir_run5
                                      (counter$0,menhir_env$5,menhir_stack$2,_gB_,_gA_)}
                            return caml_trampoline_return
                                    (menhir_run5,[0,menhir_env$5,menhir_stack$2,_gB_,_gA_]);
                           case 19:
                            var _gC_=7;
                            if(counter < 50)
                             {var counter$6=counter + 1 | 0;
                              return menhir_run66
                                      (counter$6,menhir_env$5,menhir_stack$2,_gC_)}
                            return caml_trampoline_return
                                    (menhir_run66,[0,menhir_env$5,menhir_stack$2,_gC_])
                           }
                        else
                         switch(tok$3[0])
                          {case 1:
                            var v$4=tok$3[1],_gD_=menhir_env$5[2][11],_gE_=7;
                            if(counter < 50)
                             {var counter$2=counter + 1 | 0;
                              return menhir_run4
                                      (counter$2,menhir_env$5,menhir_stack$2,_gE_,v$4,_gD_)}
                            return caml_trampoline_return
                                    (menhir_run4,[0,menhir_env$5,menhir_stack$2,_gE_,v$4,_gD_]);
                           case 2:
                            var v$5=tok$3[1],_gF_=menhir_env$5[2][11],_gG_=7;
                            if(counter < 50)
                             {var counter$8=counter + 1 | 0;
                              return menhir_run65
                                      (counter$8,menhir_env$5,menhir_stack$2,_gG_,v$5,_gF_)}
                            return caml_trampoline_return
                                    (menhir_run65,[0,menhir_env$5,menhir_stack$2,_gG_,v$5,_gF_])
                           }
                        if(menhir_env$5[4])throw [0,Assert_failure,_cL_];
                        menhir_env$5[4] = 1;
                        return menhir_errorcase(menhir_env$5,menhir_stack$2,7)}}
                    if(menhir_env$1[4])throw [0,Assert_failure,_cM_];
                    menhir_env$1[4] = 1;
                    var
                     match$2=menhir_stack$2[1],
                     menhir_s$4=match$2[2],
                     menhir_stack$6=match$2[1];
                    return menhir_errorcase
                            (menhir_env$1,menhir_stack$6,menhir_s$4)}
                  if(menhir_env$0[4])throw [0,Assert_failure,_cI_];
                  menhir_env$0[4] = 1;
                  var
                   menhir_s$0=menhir_stack$0[2],
                   menhir_stack$1=menhir_stack$0[1];
                  return menhir_errorcase
                          (menhir_env$0,menhir_stack$1,menhir_s$0)},
               menhir_run5=
                function(counter,menhir_env,menhir_stack,menhir_s,startpos)
                 {var
                   menhir_stack$0=[0,menhir_stack,menhir_s,startpos],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   switch(tok)
                    {case 6:
                      var _gg_=36;
                      if(counter < 50)
                       {var counter$6=counter + 1 | 0;
                        return menhir_run6
                                (counter$6,menhir_env$0,menhir_stack$0,_gg_)}
                      return caml_trampoline_return
                              (menhir_run6,[0,menhir_env$0,menhir_stack$0,_gg_]);
                     case 9:
                      var _gh_=36;
                      if(counter < 50)
                       {var counter$4=counter + 1 | 0;
                        return menhir_run8
                                (counter$4,menhir_env$0,menhir_stack$0,_gh_)}
                      return caml_trampoline_return
                              (menhir_run8,[0,menhir_env$0,menhir_stack$0,_gh_]);
                     case 12:
                      var _gi_=36;
                      if(counter < 50)
                       {var counter$3=counter + 1 | 0;
                        return menhir_run9
                                (counter$3,menhir_env$0,menhir_stack$0,_gi_)}
                      return caml_trampoline_return
                              (menhir_run9,[0,menhir_env$0,menhir_stack$0,_gi_]);
                     case 14:
                      var _gj_=36;
                      if(counter < 50)
                       {var counter$2=counter + 1 | 0;
                        return menhir_run10
                                (counter$2,menhir_env$0,menhir_stack$0,_gj_)}
                      return caml_trampoline_return
                              (menhir_run10,[0,menhir_env$0,menhir_stack$0,_gj_]);
                     case 20:
                      var _gk_=36;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run12
                                (counter$0,menhir_env$0,menhir_stack$0,_gk_)}
                      return caml_trampoline_return
                              (menhir_run12,[0,menhir_env$0,menhir_stack$0,_gk_])
                     }
                  else
                   switch(tok[0])
                    {case 1:
                      var v=tok[1],_gl_=menhir_env$0[2][11],_gm_=36;
                      if(counter < 50)
                       {var counter$5=counter + 1 | 0;
                        return menhir_run7
                                (counter$5,menhir_env$0,menhir_stack$0,_gm_,v,_gl_)}
                      return caml_trampoline_return
                              (menhir_run7,[0,menhir_env$0,menhir_stack$0,_gm_,v,_gl_]);
                     case 2:
                      var v$0=tok[1],_gn_=menhir_env$0[2][11],_go_=36;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return menhir_run11
                                (counter$1,menhir_env$0,menhir_stack$0,_go_,v$0,_gn_)}
                      return caml_trampoline_return
                              (menhir_run11,[0,menhir_env$0,menhir_stack$0,_go_,v$0,_gn_])
                     }
                  if(menhir_env$0[4])throw [0,Assert_failure,_cN_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack$0,36)},
               menhir_run78=
                function(counter,menhir_env,menhir_stack,menhir_s,id,startpos)
                 {var menhir_env$0=menhir_discard(menhir_env),v=[0,id];
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return menhir_goto_arg
                            (counter$0,menhir_env$0,menhir_stack,menhir_s,v)}
                  return caml_trampoline_return
                          (menhir_goto_arg,[0,menhir_env$0,menhir_stack,menhir_s,v])},
               menhir_run79=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_stack$0=[0,menhir_stack,menhir_s],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3];
                  if(typeof tok === "number")
                   {if(16 === tok)
                     {var _gc_=menhir_env$0[2][11],_gd_=6;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_run5
                                (counter$0,menhir_env$0,menhir_stack$0,_gd_,_gc_)}
                      return caml_trampoline_return
                              (menhir_run5,[0,menhir_env$0,menhir_stack$0,_gd_,_gc_])}}
                  else
                   if(1 === tok[0])
                    {var v=tok[1],_ge_=menhir_env$0[2][11],_gf_=6;
                     if(counter < 50)
                      {var counter$1=counter + 1 | 0;
                       return menhir_run4
                               (counter$1,menhir_env$0,menhir_stack$0,_gf_,v,_ge_)}
                     return caml_trampoline_return
                             (menhir_run4,[0,menhir_env$0,menhir_stack$0,_gf_,v,_ge_])}
                  if(menhir_env$0[4])throw [0,Assert_failure,_cO_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack$0,6)},
               menhir_reduce26$0=
                function(counter,menhir_env$11,menhir_stack$9,menhir_s$7)
                 {var menhir_stack=menhir_stack$9,menhir_s=menhir_s$7,v=0;
                  for(;;)
                   {var menhir_stack$0=[0,menhir_stack,menhir_s,v];
                    if(38 <= menhir_s)
                     {if(! (39 <= menhir_s))
                       {var
                         xs=menhir_stack$0[3],
                         match=menhir_stack$0[1],
                         menhir_s$2=match[2],
                         menhir_stack$3=match[1],
                         v$5=[0,0,xs],
                         menhir_stack=menhir_stack$3,
                         menhir_s=menhir_s$2,
                         v=v$5;
                        continue}}
                    else
                     {var switch$0=0;
                      if(! (5 <= menhir_s))
                       switch(menhir_s)
                        {case 4:switch$0 = 1;break;
                         case 1:
                         case 2:break;
                         default:
                          if(menhir_env$11[4])throw [0,Assert_failure,_cS_];
                          var tok$1=menhir_env$11[3];
                          if(typeof tok$1 === "number")
                           {if(18 === tok$1)
                             {var
                               menhir_env$0=menhir_discard(menhir_env$11),
                               tok$2=menhir_env$0[3];
                              if(typeof tok$2 === "number")
                               switch(tok$2)
                                {case 23:
                                  var
                                   menhir_s$5=menhir_stack$0[2],
                                   menhir_stack$6=menhir_stack$0[1];
                                  return menhir_goto_headers
                                          (menhir_env$0,menhir_stack$6,menhir_s$5,0);
                                 case 24:
                                  var
                                   menhir_s$6=menhir_stack$0[2],
                                   menhir_stack$7=menhir_stack$0[1];
                                  return menhir_goto_headers
                                          (menhir_env$0,menhir_stack$7,menhir_s$6,0)
                                 }
                              else
                               if(2 === tok$2[0])
                                {var
                                  id=tok$2[1],
                                  menhir_env$1=menhir_discard(menhir_env$0),
                                  tok$3=menhir_env$1[3];
                                 if(typeof tok$3 === "number" && 21 === tok$3)
                                  {var
                                    menhir_env$2=menhir_discard(menhir_env$1),
                                    tok$4=menhir_env$2[3];
                                   if(typeof tok$4 === "number")
                                    {if(8 === tok$4)
                                      {var menhir_env$3=menhir_discard(menhir_env$2),v$6=[0,id,0];
                                       if(counter < 50)
                                        {var counter$8=counter + 1 | 0;
                                         return menhir_goto_definition
                                                 (counter$8,menhir_env$3,menhir_stack$0,v$6)}
                                       return caml_trampoline_return
                                               (menhir_goto_definition,[0,menhir_env$3,menhir_stack$0,v$6])}}
                                   else
                                    switch(tok$4[0])
                                     {case 0:
                                       var
                                        v$7=tok$4[1],
                                        menhir_env$4=menhir_discard(menhir_env$2),
                                        v$8=[0,id,[0,v$7]];
                                       if(counter < 50)
                                        {var counter$9=counter + 1 | 0;
                                         return menhir_goto_definition
                                                 (counter$9,menhir_env$4,menhir_stack$0,v$8)}
                                       return caml_trampoline_return
                                               (menhir_goto_definition,[0,menhir_env$4,menhir_stack$0,v$8]);
                                      case 1:
                                       var
                                        v$9=tok$4[1],
                                        menhir_env$5=menhir_discard(menhir_env$2),
                                        v$10=[0,id,[1,v$9]];
                                       if(counter < 50)
                                        {var counter$10=counter + 1 | 0;
                                         return menhir_goto_definition
                                                 (counter$10,menhir_env$5,menhir_stack$0,v$10)}
                                       return caml_trampoline_return
                                               (menhir_goto_definition,
                                                [0,menhir_env$5,menhir_stack$0,v$10]);
                                      case 3:
                                       var
                                        v$11=tok$4[1],
                                        menhir_env$6=menhir_discard(menhir_env$2),
                                        v$12=[0,id,[2,v$11]];
                                       if(counter < 50)
                                        {var counter$11=counter + 1 | 0;
                                         return menhir_goto_definition
                                                 (counter$11,menhir_env$6,menhir_stack$0,v$12)}
                                       return caml_trampoline_return
                                               (menhir_goto_definition,
                                                [0,menhir_env$6,menhir_stack$0,v$12])
                                      }
                                   if(menhir_env$2[4])throw [0,Assert_failure,_cV_];
                                   menhir_env$2[4] = 1;
                                   throw eRR}
                                 if(menhir_env$1[4])throw [0,Assert_failure,_cW_];
                                 menhir_env$1[4] = 1;
                                 throw eRR}
                              if(menhir_env$0[4])throw [0,Assert_failure,_cU_];
                              menhir_env$0[4] = 1;
                              var
                               menhir_s$4=menhir_stack$0[2],
                               menhir_stack$5=menhir_stack$0[1];
                              return menhir_errorcase
                                      (menhir_env$0,menhir_stack$5,menhir_s$4)}}
                          else
                           if(2 === tok$1[0])
                            {var
                              v$13=tok$1[1],
                              startpos$0=menhir_env$11[2][11],
                              menhir_stack$8=[0,menhir_stack$0,v$13,startpos$0],
                              menhir_env$7=menhir_discard(menhir_env$11),
                              tok$5=menhir_env$7[3];
                             if(typeof tok$5 === "number")
                              {if(17 === tok$5)
                                {var
                                  menhir_env$8=menhir_discard(menhir_env$7),
                                  tok$6=menhir_env$8[3];
                                 if(typeof tok$6 === "number" && 21 === tok$6)
                                  {var
                                    menhir_env$9=menhir_discard(menhir_env$8),
                                    tok$7=menhir_env$9[3];
                                   if(typeof tok$7 === "number")
                                    switch(tok$7)
                                     {case 6:
                                       var _fW_=2;
                                       if(counter < 50)
                                        {var counter$25=counter + 1 | 0;
                                         return menhir_run6
                                                 (counter$25,menhir_env$9,menhir_stack$8,_fW_)}
                                       return caml_trampoline_return
                                               (menhir_run6,[0,menhir_env$9,menhir_stack$8,_fW_]);
                                      case 9:
                                       var _fX_=2;
                                       if(counter < 50)
                                        {var counter$21=counter + 1 | 0;
                                         return menhir_run8
                                                 (counter$21,menhir_env$9,menhir_stack$8,_fX_)}
                                       return caml_trampoline_return
                                               (menhir_run8,[0,menhir_env$9,menhir_stack$8,_fX_]);
                                      case 12:
                                       var _fY_=2;
                                       if(counter < 50)
                                        {var counter$19=counter + 1 | 0;
                                         return menhir_run9
                                                 (counter$19,menhir_env$9,menhir_stack$8,_fY_)}
                                       return caml_trampoline_return
                                               (menhir_run9,[0,menhir_env$9,menhir_stack$8,_fY_]);
                                      case 14:
                                       var _fZ_=2;
                                       if(counter < 50)
                                        {var counter$17=counter + 1 | 0;
                                         return menhir_run10
                                                 (counter$17,menhir_env$9,menhir_stack$8,_fZ_)}
                                       return caml_trampoline_return
                                               (menhir_run10,[0,menhir_env$9,menhir_stack$8,_fZ_]);
                                      case 20:
                                       var _f0_=2;
                                       if(counter < 50)
                                        {var counter$13=counter + 1 | 0;
                                         return menhir_run12
                                                 (counter$13,menhir_env$9,menhir_stack$8,_f0_)}
                                       return caml_trampoline_return
                                               (menhir_run12,[0,menhir_env$9,menhir_stack$8,_f0_])
                                      }
                                   else
                                    switch(tok$7[0])
                                     {case 1:
                                       var v$14=tok$7[1],_f1_=menhir_env$9[2][11],_f2_=2;
                                       if(counter < 50)
                                        {var counter$23=counter + 1 | 0;
                                         return menhir_run7
                                                 (counter$23,menhir_env$9,menhir_stack$8,_f2_,v$14,_f1_)}
                                       return caml_trampoline_return
                                               (menhir_run7,[0,menhir_env$9,menhir_stack$8,_f2_,v$14,_f1_]);
                                      case 2:
                                       var v$15=tok$7[1],_f3_=menhir_env$9[2][11],_f4_=2;
                                       if(counter < 50)
                                        {var counter$15=counter + 1 | 0;
                                         return menhir_run11
                                                 (counter$15,menhir_env$9,menhir_stack$8,_f4_,v$15,_f3_)}
                                       return caml_trampoline_return
                                               (menhir_run11,
                                                [0,menhir_env$9,menhir_stack$8,_f4_,v$15,_f3_])
                                      }
                                   if(menhir_env$9[4])throw [0,Assert_failure,_cX_];
                                   menhir_env$9[4] = 1;
                                   return menhir_errorcase(menhir_env$9,menhir_stack$8,2)}
                                 if(menhir_env$8[4])throw [0,Assert_failure,_cY_];
                                 menhir_env$8[4] = 1;
                                 throw eRR}
                               if(21 === tok$5)
                                {var
                                  menhir_env$10=menhir_discard(menhir_env$7),
                                  tok$8=menhir_env$10[3];
                                 if(typeof tok$8 === "number")
                                  switch(tok$8)
                                   {case 6:
                                     var _f5_=1;
                                     if(counter < 50)
                                      {var counter$24=counter + 1 | 0;
                                       return menhir_run6
                                               (counter$24,menhir_env$10,menhir_stack$8,_f5_)}
                                     return caml_trampoline_return
                                             (menhir_run6,[0,menhir_env$10,menhir_stack$8,_f5_]);
                                    case 9:
                                     var _f6_=1;
                                     if(counter < 50)
                                      {var counter$20=counter + 1 | 0;
                                       return menhir_run8
                                               (counter$20,menhir_env$10,menhir_stack$8,_f6_)}
                                     return caml_trampoline_return
                                             (menhir_run8,[0,menhir_env$10,menhir_stack$8,_f6_]);
                                    case 12:
                                     var _f7_=1;
                                     if(counter < 50)
                                      {var counter$18=counter + 1 | 0;
                                       return menhir_run9
                                               (counter$18,menhir_env$10,menhir_stack$8,_f7_)}
                                     return caml_trampoline_return
                                             (menhir_run9,[0,menhir_env$10,menhir_stack$8,_f7_]);
                                    case 14:
                                     var _f8_=1;
                                     if(counter < 50)
                                      {var counter$16=counter + 1 | 0;
                                       return menhir_run10
                                               (counter$16,menhir_env$10,menhir_stack$8,_f8_)}
                                     return caml_trampoline_return
                                             (menhir_run10,[0,menhir_env$10,menhir_stack$8,_f8_]);
                                    case 20:
                                     var _f9_=1;
                                     if(counter < 50)
                                      {var counter$12=counter + 1 | 0;
                                       return menhir_run12
                                               (counter$12,menhir_env$10,menhir_stack$8,_f9_)}
                                     return caml_trampoline_return
                                             (menhir_run12,[0,menhir_env$10,menhir_stack$8,_f9_])
                                    }
                                 else
                                  switch(tok$8[0])
                                   {case 1:
                                     var v$16=tok$8[1],_f__=menhir_env$10[2][11],_f$_=1;
                                     if(counter < 50)
                                      {var counter$22=counter + 1 | 0;
                                       return menhir_run7
                                               (counter$22,menhir_env$10,menhir_stack$8,_f$_,v$16,_f__)}
                                     return caml_trampoline_return
                                             (menhir_run7,
                                              [0,menhir_env$10,menhir_stack$8,_f$_,v$16,_f__]);
                                    case 2:
                                     var v$17=tok$8[1],_ga_=menhir_env$10[2][11],_gb_=1;
                                     if(counter < 50)
                                      {var counter$14=counter + 1 | 0;
                                       return menhir_run11
                                               (counter$14,menhir_env$10,menhir_stack$8,_gb_,v$17,_ga_)}
                                     return caml_trampoline_return
                                             (menhir_run11,
                                              [0,menhir_env$10,menhir_stack$8,_gb_,v$17,_ga_])
                                    }
                                 if(menhir_env$10[4])throw [0,Assert_failure,_cZ_];
                                 menhir_env$10[4] = 1;
                                 return menhir_errorcase(menhir_env$10,menhir_stack$8,1)}}
                             if(menhir_env$7[4])throw [0,Assert_failure,_c0_];
                             menhir_env$7[4] = 1;
                             throw eRR}
                          if(menhir_env$11[4])throw [0,Assert_failure,_cT_];
                          menhir_env$11[4] = 1;
                          var
                           menhir_s$3=menhir_stack$0[2],
                           menhir_stack$4=menhir_stack$0[1];
                          return menhir_errorcase
                                  (menhir_env$11,menhir_stack$4,menhir_s$3)}
                      if(! switch$0)return menhir_fail(0)}
                    if(menhir_env$11[4])throw [0,Assert_failure,_cP_];
                    var tok=menhir_env$11[3];
                    if(typeof tok === "number")
                     switch(tok)
                      {case 16:
                        var _fK_=menhir_env$11[2][11],_fL_=37;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return menhir_run5
                                  (counter$2,menhir_env$11,menhir_stack$0,_fL_,_fK_)}
                        return caml_trampoline_return
                                (menhir_run5,[0,menhir_env$11,menhir_stack$0,_fL_,_fK_]);
                       case 24:
                        var
                         menhir_s$0=menhir_stack$0[2],
                         menhir_stack$1=menhir_stack$0[1];
                        return menhir_goto_ast
                                (menhir_env$11,menhir_stack$1,menhir_s$0,0)
                       }
                    else
                     switch(tok[0])
                      {case 1:
                        var v$0=tok[1],_fM_=menhir_env$11[2][11],_fN_=37;
                        if(counter < 50)
                         {var counter$5=counter + 1 | 0;
                          return menhir_run4
                                  (counter$5,menhir_env$11,menhir_stack$0,_fN_,v$0,_fM_)}
                        return caml_trampoline_return
                                (menhir_run4,[0,menhir_env$11,menhir_stack$0,_fN_,v$0,_fM_]);
                       case 2:
                        var
                         v$1=tok[1],
                         startpos=menhir_env$11[2][11],
                         menhir_stack$2=[0,menhir_stack$0,37,v$1,startpos],
                         menhir_env=menhir_discard(menhir_env$11),
                         tok$0=menhir_env[3];
                        if(typeof tok$0 === "number")
                         switch(tok$0)
                          {case 15:
                            var _fO_=14;
                            if(counter < 50)
                             {var counter$4=counter + 1 | 0;
                              return menhir_run54
                                      (counter$4,menhir_env,menhir_stack$2,_fO_)}
                            return caml_trampoline_return
                                    (menhir_run54,[0,menhir_env,menhir_stack$2,_fO_]);
                           case 16:
                            var _fP_=menhir_env[2][11],_fQ_=14;
                            if(counter < 50)
                             {var counter$3=counter + 1 | 0;
                              return menhir_run5
                                      (counter$3,menhir_env,menhir_stack$2,_fQ_,_fP_)}
                            return caml_trampoline_return
                                    (menhir_run5,[0,menhir_env,menhir_stack$2,_fQ_,_fP_]);
                           case 19:
                            var _fR_=14;
                            if(counter < 50)
                             {var counter$0=counter + 1 | 0;
                              return menhir_run79
                                      (counter$0,menhir_env,menhir_stack$2,_fR_)}
                            return caml_trampoline_return
                                    (menhir_run79,[0,menhir_env,menhir_stack$2,_fR_]);
                           case 17:
                           case 23:
                           case 24:
                            var menhir_s$1=14,v$2=0;
                            if(counter < 50)
                             {var counter$7=counter + 1 | 0;
                              return menhir_goto_loption_separated_
                                      (counter$7,menhir_env,menhir_stack$2,menhir_s$1,v$2)}
                            return caml_trampoline_return
                                    (menhir_goto_loption_separated_,
                                     [0,menhir_env,menhir_stack$2,menhir_s$1,v$2])
                           }
                        else
                         switch(tok$0[0])
                          {case 1:
                            var v$3=tok$0[1],_fS_=menhir_env[2][11],_fT_=14;
                            if(counter < 50)
                             {var counter$6=counter + 1 | 0;
                              return menhir_run4
                                      (counter$6,menhir_env,menhir_stack$2,_fT_,v$3,_fS_)}
                            return caml_trampoline_return
                                    (menhir_run4,[0,menhir_env,menhir_stack$2,_fT_,v$3,_fS_]);
                           case 2:
                            var v$4=tok$0[1],_fU_=menhir_env[2][11],_fV_=14;
                            if(counter < 50)
                             {var counter$1=counter + 1 | 0;
                              return menhir_run78
                                      (counter$1,menhir_env,menhir_stack$2,_fV_,v$4,_fU_)}
                            return caml_trampoline_return
                                    (menhir_run78,[0,menhir_env,menhir_stack$2,_fV_,v$4,_fU_])
                           }
                        if(menhir_env[4])throw [0,Assert_failure,_cR_];
                        menhir_env[4] = 1;
                        return menhir_errorcase(menhir_env,menhir_stack$2,14)
                       }
                    if(menhir_env$11[4])throw [0,Assert_failure,_cQ_];
                    menhir_env$11[4] = 1;
                    return menhir_errorcase(menhir_env$11,menhir_stack$0,37)}},
               menhir_run1$0=
                function(counter,menhir_env,menhir_stack,menhir_s)
                 {var
                   menhir_env$0=menhir_env,
                   menhir_stack$0=menhir_stack,
                   menhir_s$0=menhir_s;
                  for(;;)
                   {var
                     menhir_stack$1=[0,menhir_stack$0,menhir_s$0],
                     menhir_env$1=menhir_discard(menhir_env$0),
                     tok=menhir_env$1[3],
                     switch$0=0;
                    if(typeof tok === "number")
                     switch(tok)
                      {case 23:
                        var
                         menhir_env$0=menhir_env$1,
                         menhir_stack$0=menhir_stack$1,
                         menhir_s$0=38;
                        continue;
                       case 16:
                       case 18:
                       case 24:switch$0 = 1;break
                       }
                    else
                     switch(tok[0]){case 0:case 3:break;default:switch$0 = 1}
                    if(switch$0)
                     {var _fJ_=38;
                      if(counter < 50)
                       {var counter$0=counter + 1 | 0;
                        return menhir_reduce26$0
                                (counter$0,menhir_env$1,menhir_stack$1,_fJ_)}
                      return caml_trampoline_return
                              (menhir_reduce26$0,[0,menhir_env$1,menhir_stack$1,_fJ_])}
                    if(menhir_env$1[4])throw [0,Assert_failure,_c1_];
                    menhir_env$1[4] = 1;
                    return menhir_errorcase(menhir_env$1,menhir_stack$1,38)}},
               menhir_reduce26=
                function(menhir_env,menhir_stack,menhir_s)
                 {return caml_trampoline
                          (menhir_reduce26$0(0,menhir_env,menhir_stack,menhir_s))},
               menhir_run1=
                function(menhir_env,menhir_stack,menhir_s)
                 {return caml_trampoline
                          (menhir_run1$0(0,menhir_env,menhir_stack,menhir_s))},
               ast=
                function(lexer,lexbuf)
                 {var
                   menhir_env=[0,lexer,lexbuf,0,0],
                   menhir_stack=[0,0,menhir_env[2][12]],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3],
                   switch$0=0;
                  if(typeof tok === "number")
                   switch(tok)
                    {case 23:return menhir_run1(menhir_env$0,menhir_stack,39);
                     case 16:
                     case 24:switch$0 = 1;break
                     }
                  else
                   switch(tok[0]){case 0:case 3:break;default:switch$0 = 1}
                  if(switch$0)
                   return menhir_reduce26(menhir_env$0,menhir_stack,39);
                  if(menhir_env$0[4])throw [0,Assert_failure,_c2_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,39)},
               headers=
                function(lexer,lexbuf)
                 {var
                   menhir_env=[0,lexer,lexbuf,0,0],
                   menhir_stack=[0,0,menhir_env[2][12]],
                   menhir_env$0=menhir_discard(menhir_env),
                   tok=menhir_env$0[3],
                   switch$0=0;
                  if(typeof tok === "number")
                   switch(tok)
                    {case 23:return menhir_run1(menhir_env$0,menhir_stack,3);
                     case 18:switch$0 = 1;break
                     }
                  else
                   if(2 === tok[0])switch$0 = 1;
                  if(switch$0)
                   return menhir_reduce26(menhir_env$0,menhir_stack,3);
                  if(menhir_env$0[4])throw [0,Assert_failure,_c3_];
                  menhir_env$0[4] = 1;
                  return menhir_errorcase(menhir_env$0,menhir_stack,3)},
               Parser=[0,eRR,headers,ast];
              caml_register_global(497,Parser,"Parser");
              var
               SyntaxError=[248,cst_Lexer_SyntaxError,caml_fresh_oo_id(0)],
               next_line=
                function(lexbuf)
                 {var pos=lexbuf[12];
                  lexbuf[12] = [0,pos[1],pos[2] + 1 | 0,lexbuf[6],pos[4]];
                  return 0},
               eof_reached=function(lexbuf){lexbuf[9] = 1;return 0},
               read_comment$0=
                function(counter,lexbuf)
                 {var _fI_=82;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return ocaml_lex_read_comment_rec$0(counter$0,lexbuf,_fI_)}
                  return caml_trampoline_return
                          (ocaml_lex_read_comment_rec$0,[0,lexbuf,_fI_])},
               ocaml_lex_read_comment_rec$0=
                function(counter,lexbuf,ocaml_lex_state)
                 {var ocaml_lex_state$0=ocaml_lex_state;
                  for(;;)
                   {var
                     ocaml_lex_state$1=
                      caml_call3
                       (Stdlib_lexing[20],
                        ocaml_lex_tables,
                        ocaml_lex_state$0,
                        lexbuf);
                    if(2 < ocaml_lex_state$1 >>> 0)
                     {caml_call1(lexbuf[1],lexbuf);
                      var ocaml_lex_state$0=ocaml_lex_state$1;
                      continue}
                    switch(ocaml_lex_state$1)
                     {case 0:next_line(lexbuf);return 23;
                      case 1:eof_reached(lexbuf);return 24;
                      default:
                       if(counter < 50)
                        {var counter$0=counter + 1 | 0;
                         return read_comment$0(counter$0,lexbuf)}
                       return caml_trampoline_return(read_comment$0,[0,lexbuf])}}},
               read_comment=
                function(lexbuf)
                 {return caml_trampoline(read_comment$0(0,lexbuf))},
               ocaml_lex_read_comment_rec=
                function(lexbuf,ocaml_lex_state)
                 {return caml_trampoline
                          (ocaml_lex_read_comment_rec$0(0,lexbuf,ocaml_lex_state))},
               read_string$0=
                function(counter,buf,lexbuf)
                 {var _fH_=68;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return ocaml_lex_read_string_rec$0
                            (counter$0,buf,lexbuf,_fH_)}
                  return caml_trampoline_return
                          (ocaml_lex_read_string_rec$0,[0,buf,lexbuf,_fH_])},
               ocaml_lex_read_string_rec$0=
                function(counter,buf,lexbuf,ocaml_lex_state)
                 {var ocaml_lex_state$0=ocaml_lex_state;
                  for(;;)
                   {var
                     ocaml_lex_state$1=
                      caml_call3
                       (Stdlib_lexing[20],
                        ocaml_lex_tables,
                        ocaml_lex_state$0,
                        lexbuf);
                    if(11 < ocaml_lex_state$1 >>> 0)
                     {caml_call1(lexbuf[1],lexbuf);
                      var ocaml_lex_state$0=ocaml_lex_state$1;
                      continue}
                    switch(ocaml_lex_state$1)
                     {case 0:return [0,caml_call1(Stdlib_buffer[2],buf)];
                      case 1:
                       caml_call2(Stdlib_buffer[10],buf,47);
                       if(counter < 50)
                        {var counter$0=counter + 1 | 0;
                         return read_string$0(counter$0,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 2:
                       caml_call2(Stdlib_buffer[10],buf,92);
                       if(counter < 50)
                        {var counter$1=counter + 1 | 0;
                         return read_string$0(counter$1,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 3:
                       caml_call2(Stdlib_buffer[10],buf,8);
                       if(counter < 50)
                        {var counter$2=counter + 1 | 0;
                         return read_string$0(counter$2,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 4:
                       caml_call2(Stdlib_buffer[10],buf,12);
                       if(counter < 50)
                        {var counter$3=counter + 1 | 0;
                         return read_string$0(counter$3,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 5:
                       caml_call2(Stdlib_buffer[10],buf,10);
                       if(counter < 50)
                        {var counter$4=counter + 1 | 0;
                         return read_string$0(counter$4,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 6:
                       caml_call2(Stdlib_buffer[10],buf,13);
                       if(counter < 50)
                        {var counter$5=counter + 1 | 0;
                         return read_string$0(counter$5,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 7:
                       caml_call2(Stdlib_buffer[10],buf,9);
                       if(counter < 50)
                        {var counter$6=counter + 1 | 0;
                         return read_string$0(counter$6,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 8:
                       var _fF_=caml_call1(Stdlib_lexing[8],lexbuf);
                       caml_call2(Stdlib_buffer[14],buf,_fF_);
                       if(counter < 50)
                        {var counter$7=counter + 1 | 0;
                         return read_string$0(counter$7,buf,lexbuf)}
                       return caml_trampoline_return(read_string$0,[0,buf,lexbuf]);
                      case 9:throw [0,SyntaxError,cst_String_cannot_be_multiline];
                      case 10:throw [0,SyntaxError,cst_String_is_not_terminated];
                      default:
                       var _fG_=caml_call1(Stdlib_lexing[8],lexbuf);
                       throw [0,
                              SyntaxError,
                              caml_call2(Stdlib[28],cst_Illegal_string_character,_fG_)]}}},
               read_string=
                function(buf,lexbuf)
                 {return caml_trampoline(read_string$0(0,buf,lexbuf))},
               ocaml_lex_read_string_rec=
                function(buf,lexbuf,ocaml_lex_state)
                 {return caml_trampoline
                          (ocaml_lex_read_string_rec$0(0,buf,lexbuf,ocaml_lex_state))},
               read$0=
                function(counter,lexbuf)
                 {var _fE_=0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return ocaml_lex_read_rec$0(counter$0,lexbuf,_fE_)}
                  return caml_trampoline_return
                          (ocaml_lex_read_rec$0,[0,lexbuf,_fE_])},
               ocaml_lex_read_rec$0=
                function(counter,lexbuf,ocaml_lex_state)
                 {var ocaml_lex_state$0=ocaml_lex_state;
                  for(;;)
                   {var
                     ocaml_lex_state$1=
                      caml_call3
                       (Stdlib_lexing[20],
                        ocaml_lex_tables,
                        ocaml_lex_state$0,
                        lexbuf);
                    if(40 < ocaml_lex_state$1 >>> 0)
                     {caml_call1(lexbuf[1],lexbuf);
                      var ocaml_lex_state$0=ocaml_lex_state$1;
                      continue}
                    switch(ocaml_lex_state$1)
                     {case 0:return 24;
                      case 1:return 18;
                      case 2:return 8;
                      case 3:return _c4_;
                      case 4:return _c5_;
                      case 5:return 13;
                      case 6:return 2;
                      case 7:return 22;
                      case 8:return 10;
                      case 9:return 28;
                      case 10:return 29;
                      case 11:return read_comment(lexbuf);
                      case 12:
                       if(counter < 50)
                        {var counter$0=counter + 1 | 0;
                         return read$0(counter$0,lexbuf)}
                       return caml_trampoline_return(read$0,[0,lexbuf]);
                      case 13:
                       next_line(lexbuf);
                       if(counter < 50)
                        {var counter$1=counter + 1 | 0;
                         return read$0(counter$1,lexbuf)}
                       return caml_trampoline_return(read$0,[0,lexbuf]);
                      case 14:next_line(lexbuf);return 23;
                      case 15:
                       return [1,
                               uint32_of_str(caml_call1(Stdlib_lexing[8],lexbuf))];
                      case 16:return [2,caml_call1(Stdlib_lexing[8],lexbuf)];
                      case 17:
                       return read_string(caml_call1(Stdlib_buffer[1],17),lexbuf);
                      case 18:return 21;
                      case 19:return 19;
                      case 20:return 15;
                      case 21:return 4;
                      case 22:return 16;
                      case 23:return 5;
                      case 24:return 26;
                      case 25:return 20;
                      case 26:return 17;
                      case 27:return 27;
                      case 28:return 14;
                      case 29:return 3;
                      case 30:return 6;
                      case 31:return 12;
                      case 32:return 1;
                      case 33:return 25;
                      case 34:return 11;
                      case 35:return 30;
                      case 36:return 7;
                      case 37:return 0;
                      case 38:return 9;
                      case 39:eof_reached(lexbuf);return 24;
                      default:
                       var _fD_=caml_call1(Stdlib_lexing[8],lexbuf);
                       throw [0,
                              SyntaxError,
                              caml_call2(Stdlib[28],cst_Unexpected_char,_fD_)]}}},
               read=function(lexbuf){return caml_trampoline(read$0(0,lexbuf))},
               ocaml_lex_read_rec=
                function(lexbuf,ocaml_lex_state)
                 {return caml_trampoline
                          (ocaml_lex_read_rec$0(0,lexbuf,ocaml_lex_state))},
               Lexer=
                [0,
                 SyntaxError,
                 next_line,
                 eof_reached,
                 ocaml_lex_tables,
                 read,
                 ocaml_lex_read_rec,
                 read_string,
                 ocaml_lex_read_string_rec,
                 read_comment,
                 ocaml_lex_read_comment_rec];
              caml_register_global(500,Lexer,"Lexer");
              var
               InvalidContent=
                [248,cst_Parse_InvalidContent,caml_fresh_oo_id(0)],
               print_position=
                function(fmt,pos)
                 {return caml_call5
                          (Stdlib_format[126],
                           fmt,
                           _c6_,
                           pos[1],
                           pos[2],
                           (pos[4] - pos[3] | 0) + 1 | 0)},
               print_lexbuf_pos=
                function(fmt,lexbuf){return print_position(fmt,lexbuf[12])},
               parse_with_error=
                function(f,lexbuf)
                 {try
                   {var _fC_=caml_call1(f,lexbuf);return _fC_}
                  catch(exn)
                   {exn = caml_wrap_exception(exn);
                    if(exn[1] === SyntaxError)
                     {var msg=exn[2];
                      throw [0,
                             InvalidContent,
                             caml_call4
                              (Stdlib_format[130],_c7_,print_lexbuf_pos,lexbuf,msg)]}
                    if(exn === eRR)
                     throw [0,
                            InvalidContent,
                            caml_call3(Stdlib_format[130],_c8_,print_lexbuf_pos,lexbuf)];
                    throw exn}},
               from_lexbuf=
                function(headers$0,lexbuf)
                 {var
                   headers$1=
                    headers$0
                     ?parse_with_error
                       (function(_fB_){return headers(read,_fB_)},lexbuf)
                     :0,
                   ast$0=
                    parse_with_error
                     (function(_fA_){return ast(read,_fA_)},lexbuf);
                  return [0,headers$1,ast$0]},
               from_filename=
                function(headers,filename)
                 {var
                   channel=caml_call1(Stdlib[79],filename),
                   lexbuf=caml_call2(Stdlib_lexing[2],0,channel),
                   _fz_=lexbuf[12];
                  lexbuf[12] = [0,filename,_fz_[2],_fz_[3],_fz_[4]];
                  var res=from_lexbuf(headers,lexbuf);
                  caml_call1(Stdlib[93],channel);
                  return res},
               from_str=
                function(headers,str)
                 {return from_lexbuf
                          (headers,caml_call2(Stdlib_lexing[3],0,str))},
               parsed_ast_to_arm=
                function(optimize,env,lst)
                 {try
                   {var
                     _fw_=to_arm(env,lst),
                     _fx_=optimize?tweak_arm:do_not_tweak_arm,
                     _fy_=_fx_(_fw_);
                    return _fy_}
                  catch(exn)
                   {exn = caml_wrap_exception(exn);
                    if(exn[1] === CommandError)
                     {var pos=exn[2];
                      throw [0,
                             InvalidContent,
                             caml_call3(Stdlib_format[130],_c9_,print_position,pos)]}
                    throw exn}},
               parsed_content_to_arm=
                function(fmt,optimize,env,param)
                 {var
                   lst=param[2],
                   headers=param[1],
                   env$0=concat_env(env,env_from_headers(fmt,headers));
                  return parsed_ast_to_arm(optimize,env$0,lst)},
               Parse=
                [0,
                 InvalidContent,
                 from_lexbuf,
                 from_str,
                 from_filename,
                 parsed_ast_to_arm,
                 parsed_content_to_arm];
              caml_register_global(501,Parse,"Parse");
              var
               StrMap$0=caml_call1(Stdlib_map[1],[0,Stdlib_string[5]]),
               parse=
                function(lexbuf)
                 {lexbuf[9] = 0;
                  var main_file=from_lexbuf(1,lexbuf),acc=StrMap$0[1];
                  for(;;)
                   {if(lexbuf[9])return [0,main_file,acc];
                    var
                     match=from_lexbuf(1,lexbuf),
                     arm=match[2],
                     headers=match[1],
                     match$0=get_param(headers,cst_filename);
                    if(typeof match$0 === "number")
                     var fn=caml_call1(Stdlib[2],cst_Please_specify_the_filenam);
                    else
                     if(0 === match$0[0])
                      var fn$0=match$0[1],fn=fn$0;
                     else
                      var fn=caml_call1(Stdlib[2],cst_Invalid_headers);
                    var
                     acc$0=caml_call3(StrMap$0[4],fn,[0,headers,arm],acc),
                     acc=acc$0;
                    continue}},
               from_filename$0=
                function(filename)
                 {var
                   channel=caml_call1(Stdlib[79],filename),
                   lexbuf=caml_call2(Stdlib_lexing[2],0,channel),
                   _fv_=lexbuf[12];
                  lexbuf[12] = [0,filename,_fv_[2],_fv_[3],_fv_[4]];
                  var res=parse(lexbuf);
                  caml_call1(Stdlib[93],channel);
                  return res},
               from_str$0=
                function(str)
                 {return parse(caml_call2(Stdlib_lexing[3],0,str))},
               main_file=function(param){var mf=param[1];return mf},
               get_file=
                function(name,param)
                 {var files=param[2];
                  return caml_call2(StrMap$0[28],name,files)},
               Fs=[0,from_str$0,from_filename$0,main_file,get_file];
              caml_register_global(502,Fs,"Fs");
              var
               load_from_dir=
                function(env,dirname)
                 {try
                   {var
                     _fk_=enumerate_files(dirname,cst_txt),
                     _fl_=
                      function(x)
                       {var
                         path=caml_call2(Stdlib_filename[4],dirname,x),
                         _fs_=caml_call1(Stdlib_filename[13],x),
                         str=caml_call1(Stdlib_filename[11],_fs_),
                         i=runtime.caml_int_of_string(str),
                         arm=
                          parsed_content_to_arm(dummy_fmt,0,env,from_filename(0,path));
                        function _ft_(arm)
                         {var _fu_=arm_to_binary(arm);
                          return preferred_code
                                  (caml_call2(Stdlib_list[19],codes_for_command,_fu_))}
                        var codes=caml_call2(Stdlib_list[19],_ft_,arm);
                        return [0,i,codes]},
                     _fm_=caml_call2(Stdlib_list[19],_fl_,_fk_),
                     _fn_=
                      function(param,_fr_)
                       {var j=_fr_[1],i=param[1];
                        return runtime.caml_int_compare(i,j)},
                     _fo_=caml_call2(Stdlib_list[56],_fn_,_fm_),
                     _fp_=function(x){return [0,x,0]}(_fo_);
                    return _fp_}
                  catch(_fq_)
                   {_fq_ = caml_wrap_exception(_fq_);
                    if(_fq_ === CannotOptimize)
                     return caml_call1(Stdlib[2],cst_Exit_codes_cannot_be_tweak);
                    throw _fq_}},
               load_from_parsed_file=
                function(fmt,env,param)
                 {var
                   arm=param[2],
                   h=param[1],
                   _fh_=parsed_content_to_arm(fmt,1,env,[0,h,arm]);
                  function _fi_(arm)
                   {var _fj_=arm_to_binary(arm);
                    return preferred_code
                            (caml_call2(Stdlib_list[19],codes_for_command,_fj_))}
                  var
                   codes=caml_call2(Stdlib_list[19],_fi_,_fh_),
                   match=get_param(h,cst_start);
                  if(typeof match === "number")
                   return [0,0,[0,codes]];
                  else
                   {if(1 === match[0])
                     {var i=match[1];
                      return [0,[0,[0,uint32_to_int(i),codes],0],0]}
                    return caml_call1(Stdlib[2],cst_Exit_code_has_invalid_head)}},
               load_from_file=
                function(fmt,env,filename)
                 {var
                   match=from_filename(1,filename),
                   ast=match[2],
                   headers=match[1];
                  return [0,
                          headers,
                          load_from_parsed_file(fmt,env,[0,headers,ast])]},
               NoExitCode=[248,cst_Exit_NoExitCode,caml_fresh_oo_id(0)],
               get_preferred=
                function(param,i)
                 {var default$0=param[2],lst=param[1];
                  try
                   {var
                     aux=
                      function(lst)
                       {var lst$0=lst;
                        for(;;)
                         {if(lst$0)
                           {var match=lst$0[1],c=match[2],j=match[1];
                            if(runtime.caml_lessequal(i,j))return [0,j,c];
                            var lst$1=lst$0[2],lst$0=lst$1;
                            continue}
                          throw NoExitCode}},
                     _ff_=aux(lst);
                    return _ff_}
                  catch(_fg_)
                   {_fg_ = caml_wrap_exception(_fg_);
                    if(_fg_ === NoExitCode)
                     {if(default$0){var c=default$0[1];return [0,i,c]}
                      throw NoExitCode}
                    throw _fg_}},
               Exit=
                [0,
                 load_from_dir,
                 load_from_file,
                 load_from_parsed_file,
                 NoExitCode,
                 get_preferred];
              caml_register_global(503,Exit,"Exit");
              var
               string_of_uchar=
                function(uchar)
                 {var buffer=caml_call1(Stdlib_buffer[1],4);
                  caml_call2(Uutf[23][1],buffer,uchar);
                  return caml_call1(Stdlib_buffer[2],buffer)},
               decompose_into_uchars=
                function(str)
                 {var _fc_=0;
                  function _fd_(acc,param,uc)
                   {if(852405675 <= uc[1]){var uc$0=uc[2];return [0,uc$0,acc]}
                    throw Stdlib[8]}
                  var _fe_=caml_call5(Uutf[22][2],0,0,_fd_,_fc_,str);
                  return caml_call1(Stdlib_list[9],_fe_)},
               main$1=
                function(fmt)
                 {caml_call2(Stdlib_format[126],fmt,_c__);
                  var _fb_=caml_call2(Stdlib_format[126],fmt,_c$_);
                  caml_call2(Stdlib_list[17],_fb_,acc);
                  caml_call2(Stdlib_format[126],fmt,_da_);
                  return [0,main_1$1]},
               main_1$1=
                function(fmt,str)
                 {function aux2(lst)
                   {var lst$0=lst;
                    for(;;)
                     {if(lst$0)
                       {var _fa_=lst$0[2];
                        if(_fa_)
                         {var lst$1=_fa_[2],b=_fa_[1],a=lst$0[1];
                          caml_call4(Stdlib_format[126],fmt,_db_,b,a);
                          var lst$0=lst$1;
                          continue}
                        throw [0,Assert_failure,_dc_]}
                      return 0}}
                  function aux4(lst)
                   {var lst$0=lst;
                    for(;;)
                     {if(lst$0)
                       {var _e9_=lst$0[2];
                        if(_e9_)
                         {var _e__=_e9_[2];
                          if(_e__)
                           {var _e$_=_e__[2];
                            if(_e$_)
                             {var lst$1=_e$_[2],d=_e$_[1],c=_e__[1],b=_e9_[1],a=lst$0[1];
                              caml_call6(Stdlib_format[126],fmt,_dd_,d,c,b,a);
                              var lst$0=lst$1;
                              continue}}}
                        throw [0,Assert_failure,_de_]}
                      return 0}}
                  try
                   {var
                     _e5_=decompose_into_uchars(str),
                     _e6_=caml_call2(Stdlib_list[19],string_of_uchar,_e5_),
                     encoding=
                      caml_call2(Stdlib_list[19],encode_writable_char,_e6_),
                     encoding$0=caml_call2(Stdlib[37],encoding,[0,eof,0]);
                    caml_call2(Stdlib_format[126],fmt,_dg_);
                    var _e7_=caml_call2(Stdlib_format[126],fmt,_dh_);
                    caml_call2(Stdlib_list[17],_e7_,encoding$0);
                    var
                     n=caml_call1(Stdlib_list[1],encoding$0),
                     encoding$1=
                      0 === (n % 2 | 0)
                       ?encoding$0
                       :caml_call2(Stdlib[37],encoding$0,_dm_);
                    caml_call2(Stdlib_format[126],fmt,_di_);
                    aux2(encoding$1);
                    var
                     n$0=caml_call1(Stdlib_list[1],encoding$1),
                     encoding$2=
                      0 === (n$0 % 4 | 0)
                       ?encoding$1
                       :caml_call2(Stdlib[37],encoding$1,_dl_);
                    caml_call2(Stdlib_format[126],fmt,_dj_);
                    aux4(encoding$2);
                    caml_call2(Stdlib_format[126],fmt,_dk_)}
                  catch(_e8_)
                   {_e8_ = caml_wrap_exception(_e8_);
                    if(_e8_ !== Stdlib[8])throw _e8_;
                    caml_call2(Stdlib_format[126],fmt,_df_)}
                  return 0},
               Encoder_common=
                [0,string_of_uchar,decompose_into_uchars,main$1,main_1$1];
              caml_register_global(505,Encoder_common,"Encoder_common");
              var Constants=[0,33703148,100];
              caml_register_global(506,Constants,"Constants");
              var
               BoxFittingError=
                [248,cst_Boxes_BoxFittingError,caml_fresh_oo_id(0)],
               default_fillers=[0,_ds_,_dr_,[0,_dq_,_dp_,_do_,_dn_]],
               nb_boxes=14,
               no_eof=
                function(codes)
                 {function _e4_(c){return c !== 255?1:0}
                  return caml_call2(Stdlib_list[32],_e4_,codes)},
               pad_nb=
                function(fillers,pos$0,nb)
                 {if(0 <= nb)
                   {if(0 === nb)return 0;
                    var
                     pos=pos$0 % 9 | 0,
                     n=caml_call1(Stdlib_list[1],fillers[1]);
                    if((pos + n | 0) <= 8)
                     var code=fillers[1];
                    else
                     var
                      _e2_=8 - pos | 0,
                      code=caml_check_bound(fillers[3],_e2_)[1 + _e2_];
                    var
                     m=caml_call1(Stdlib_list[1],code),
                     _e3_=pad_nb(fillers,pos$0 + m | 0,nb - m | 0);
                    return caml_call2(Stdlib[37],code,_e3_)}
                  throw [0,BoxFittingError,cst_Cannot_pad_the_required_am]},
               fit_code_at_pos=
                function(opt,fillers,pos,codes$9)
                 {if(opt)var sth=opt[1],next=sth;else var next=_du_;
                  var
                   pos$0=pos % 9 | 0,
                   n$0=caml_call1(Stdlib_list[1],codes$9);
                  if(no_eof(codes$9))
                   var is_ok_here=(pos$0 + n$0 | 0) <= 8?1:0;
                  else
                   {var codes=codes$9;
                    for(;;)
                     {if(codes)
                       {var c=codes[1],codes$0=codes[2];
                        if(c !== 255){var codes=codes$0;continue}
                        if(codes$0)
                         {var codes$1=codes$0[2],c$0=codes$0[1];
                          if(c$0 === 255)
                           {var codes$2=[0,c$0,codes$1],codes=codes$2;continue}}
                        var codes$3=codes[2],_eT_=no_eof(codes$3)}
                      else
                       var _eT_=1;
                      if(! _eT_)
                       throw [0,BoxFittingError,cst_Some_codes_cannot_be_posit];
                      var
                       n=caml_call1(Stdlib_list[1],codes$9),
                       codes$4=caml_call1(Stdlib_list[9],codes$9),
                       acc=0,
                       codes$5=codes$4;
                      for(;;)
                       {if(! codes$5)throw [0,Assert_failure,_dt_];
                        var c$1=codes$5[1];
                        if(c$1 !== 255)
                         {var
                           codes$6=codes$5[2],
                           acc$0=acc + 1 | 0,
                           acc=acc$0,
                           codes$5=codes$6;
                          continue}
                        var i=(n - 1 | 0) - acc | 0;
                        if(next)
                         {var next$0=next[1],acc$1=0,codes$7=next$0;
                          for(;;)
                           {if(codes$7)
                             {var codes$8=codes$7[2],c$2=codes$7[1];
                              if(c$2 === 255)
                               {var acc$2=acc$1 + 1 | 0,acc$1=acc$2,codes$7=codes$8;
                                continue}}
                            var j=acc$1;
                            break}}
                        else
                         var j=0;
                        var _eU_=(pos$0 + i | 0) === 8?1:0;
                        if(_eU_)
                         var _eV_=_eU_;
                        else
                         {var
                           _eW_=i === (n$0 - 1 | 0)?1:0,
                           _eX_=_eW_?((pos$0 + i | 0) + 1 | 0) === 8?1:0:_eW_;
                          if(_eX_)
                           var _eV_=_eX_;
                          else
                           {var
                             _eY_=i === (n$0 - 1 | 0)?1:0,
                             _eZ_=_eY_?((pos$0 + i | 0) + j | 0) === 8?1:0:_eY_;
                            if(_eZ_)
                             var _eV_=_eZ_;
                            else
                             {var _e0_=0 === next?1:0;
                              if(_e0_)
                               var
                                _e1_=i === (n$0 - 1 | 0)?1:0,
                                _eV_=_e1_?(pos$0 + i | 0) <= 8?1:0:_e1_;
                              else
                               var _eV_=_e0_}}}
                        var is_ok_here=_eV_;
                        break}
                      break}}
                  if(is_ok_here)return codes$9;
                  var m=caml_call1(Stdlib_list[1],fillers[1]);
                  if((pos$0 + m | 0) <= 8)
                   var nop_code=fillers[1];
                  else
                   var
                    _eS_=8 - pos$0 | 0,
                    nop_code=caml_check_bound(fillers[3],_eS_)[1 + _eS_];
                  var
                   m$0=caml_call1(Stdlib_list[1],nop_code),
                   _eR_=
                    fit_code_at_pos([0,next],fillers,pos$0 + m$0 | 0,codes$9);
                  return caml_call2(Stdlib[37],nop_code,_eR_)},
               add_codes_after=
                function(opt,fillers,res,codes)
                 {if(opt)var sth=opt[1],final$0=sth;else var final$0=0;
                  var acc=res,codes$0=codes;
                  for(;;)
                   {if(codes$0)
                     {var _eO_=codes$0[2],_eP_=codes$0[1];
                      if(_eO_)
                       {var
                         codes$1=_eO_[2],
                         c2=_eO_[1],
                         nc=
                          fit_code_at_pos
                           ([0,[0,c2]],fillers,caml_call1(Stdlib_list[1],acc),_eP_),
                         codes$2=[0,c2,codes$1],
                         acc$0=caml_call2(Stdlib[37],acc,nc),
                         acc=acc$0,
                         codes$0=codes$2;
                        continue}
                      var
                       next=final$0?0:_dv_,
                       _eQ_=
                        fit_code_at_pos
                         ([0,next],fillers,caml_call1(Stdlib_list[1],acc),_eP_);
                      return caml_call2(Stdlib[37],acc,_eQ_)}
                    return acc}},
               split_raw_into_boxes=
                function(opt,raw)
                 {if(opt)var sth=opt[1],fill_last=sth;else var fill_last=0;
                  var finished=0,current=0,codes=raw,i=0;
                  for(;;)
                   {if(codes)
                     {var c=codes[1],codes$0=codes[2];
                      if(i === 8)
                       {if(c !== 255)
                         throw [0,BoxFittingError,cst_Result_is_inconsistent_Ple];
                        var
                         finished$0=[0,current,finished],
                         finished=finished$0,
                         current=0,
                         codes=codes$0,
                         i=0;
                        continue}
                      if(c === 255)
                       {var i$0=i + 1 | 0,codes=codes$0,i=i$0;continue}
                      var codes$1=codes[2];
                      if(caml_call1(Stdlib_list[1],current) !== i)
                       throw [0,BoxFittingError,cst_Result_is_inconsistent_Ple$0];
                      var
                       i$1=i + 1 | 0,
                       current$0=[0,c,current],
                       current=current$0,
                       codes=codes$1,
                       i=i$1;
                      continue}
                    if(0 === i)
                     var _eM_=finished;
                    else
                     {var n=caml_call1(Stdlib_list[1],current),switch$0=0;
                      if(fill_last && n === i)
                       {var
                         _eK_=function(param){return space},
                         _eL_=caml_call2(Stdlib_list[10],8 - n | 0,_eK_),
                         current$1=caml_call2(Stdlib[37],_eL_,current);
                        switch$0 = 1}
                      if(! switch$0)var current$1=current;
                      var _eM_=[0,current$1,finished]}
                    var _eN_=caml_call2(Stdlib_list[19],Stdlib_list[9],_eM_);
                    return caml_call1(Stdlib_list[9],_eN_)}},
               fit_codes_into_boxes=
                function(opt,_eG_,_eF_,_eE_,codes)
                 {if(opt)var sth=opt[1],fill_last=sth;else var fill_last=1;
                  if(_eG_)
                   var sth$0=_eG_[1],fillers=sth$0;
                  else
                   var fillers=default_fillers;
                  if(_eF_)var sth$1=_eF_[1],start=sth$1;else var start=0;
                  if(_eE_)var sth$2=_eE_[1],exit=sth$2;else var exit=0;
                  var
                   padding=pad_nb(fillers,0,start),
                   res=
                    add_codes_after([0,0 === exit?1:0],fillers,padding,codes);
                  if(exit)
                   var
                    exit$0=exit[1],
                    i=caml_call1(Stdlib_list[1],res),
                    match=get_preferred(exit$0,i),
                    ecode=match[2],
                    j=match[1],
                    padding$0=pad_nb(fillers,i,j - i | 0),
                    res$0=caml_call2(Stdlib[37],res,padding$0),
                    res$1=add_codes_after(_dw_,fillers,res$0,ecode);
                  else
                   var res$1=res;
                  var res$2=split_raw_into_boxes([0,fill_last],res$1);
                  function _eH_(i,lst)
                   {if(is_full_of_spaces(lst))
                     {var
                       y=caml_call1(Stdlib_list[1],fillers[2]),
                       x=(- i | 0) * 9 | 0,
                       result=caml_mod(x,y),
                       pos=0 <= result?result:result + y | 0,
                       _eI_=function(param){return space},
                       prefix=caml_call2(Stdlib_list[10],pos,_eI_),
                       suffix_len=
                        (caml_call1(Stdlib_list[1],lst) - pos | 0)
                        -
                        y
                        |
                        0;
                      if(0 <= suffix_len)
                       {var
                         _eJ_=function(param){return space},
                         suffix=caml_call2(Stdlib_list[10],suffix_len,_eJ_);
                        return caml_call1
                                (Stdlib_list[13],[0,prefix,[0,fillers[2],[0,suffix,0]]])}
                      return lst}
                    return lst}
                  return caml_call2(Stdlib_list[20],_eH_,res$2)},
               fit_codes_into_hex_boxes=
                function(opt,codes)
                 {if(opt)var sth=opt[1],exit=sth;else var exit=0;
                  if(exit)
                   var
                    exit$0=exit[1],
                    match=get_preferred(exit$0,0),
                    ecode=match[2],
                    codes$0=caml_call2(Stdlib[37],codes,ecode);
                  else
                   var codes$0=codes;
                  function _eA_(code)
                   {function _eB_(i)
                     {var
                       hex1=caml_call2(Stdlib_format[129],_dx_,i % 16 | 0),
                       hex2=caml_call2(Stdlib_format[129],_dy_,i / 16 | 0),
                       _eD_=[0,encode_writable_char(hex1),0];
                      return [0,encode_writable_char(hex2),_eD_]}
                    var _eC_=caml_call2(Stdlib_list[19],_eB_,code);
                    return caml_call1(Stdlib_list[14],_eC_)}
                  return caml_call2(Stdlib_list[19],_eA_,codes$0)},
               pp_boxes_names=
                function(fmt,lst)
                 {function pp_box(i,codes)
                   {var chars=codes_to_chars(codes);
                    return caml_call7
                            (Stdlib_format[126],
                             fmt,
                             _dz_,
                             i + 1 | 0,
                             pp_chars,
                             chars,
                             pp_chars_raw,
                             chars)}
                  return caml_call2(Stdlib_list[18],pp_box,lst)},
               pp_box_raw=
                function(fmt,lst)
                 {function _ew_(param){return eof}
                  var
                   _ex_=9 - caml_call1(Stdlib_list[1],lst) | 0,
                   pad=caml_call2(Stdlib_list[10],_ex_,_ew_),
                   _ey_=caml_call2(Stdlib[37],lst,pad),
                   _ez_=caml_call2(Stdlib_format[126],fmt,_dA_);
                  return caml_call2(Stdlib_list[17],_ez_,_ey_)},
               Boxes=
                [0,
                 BoxFittingError,
                 default_fillers,
                 fit_codes_into_boxes,
                 fit_codes_into_hex_boxes,
                 split_raw_into_boxes,
                 pp_boxes_names,
                 pp_box_raw,
                 nb_boxes];
              caml_register_global(507,Boxes,"Boxes");
              var
               pp_hex=
                function(fmt,i)
                 {return caml_call3(Stdlib_format[126],fmt,_dB_,i)},
               cond_to_str=
                function(c)
                 {switch(c)
                   {case 0:return cst_EQ$0;
                    case 1:return cst_NE$0;
                    case 2:return cst_CS$0;
                    case 3:return cst_HS$0;
                    case 4:return cst_CC$0;
                    case 5:return cst_LO$0;
                    case 6:return cst_MI$0;
                    case 7:return cst_PL$0;
                    case 8:return cst_VS$0;
                    case 9:return cst_VC$0;
                    case 10:return cst_HI$0;
                    case 11:return cst_LS$0;
                    case 12:return cst_GE$0;
                    case 13:return cst_LT$0;
                    case 14:return cst_GT$0;
                    case 15:return cst_LE$0;
                    default:return cst$2}},
               sign_to_str=function(sign){return sign === 0?cst$4:cst$5},
               s_to_str=function(s){return s?cst_S$1:cst$6},
               l_to_str=function(l){return l?cst_L$1:cst$7},
               print_register=
                function(fmt,r)
                 {return caml_call3(Stdlib_format[126],fmt,_dC_,r)},
               print_immediate=
                function(fmt,i)
                 {return caml_call3(Stdlib_format[126],fmt,_dD_,i)},
               print_operand=
                function(fmt,op)
                 {switch(op[0])
                   {case 0:var i=op[1];return print_immediate(fmt,i);
                    case 1:
                     var r=op[1];
                     return caml_call4
                             (Stdlib_format[126],fmt,_dE_,print_register,r);
                    default:return caml_call1(Stdlib[2],cst_Not_implemented$3)}},
               print_immediate_offset=
                function(fmt,param)
                 {var i=param[2],s=param[1],_ev_=sign_to_str(s);
                  return caml_call4(Stdlib_format[126],fmt,_dF_,_ev_,i)},
               print_register_offset=
                function(fmt,param)
                 {var
                   addr_typ=param[2],
                   ro=param[1],
                   str=1 === addr_typ?cst$8:cst$9;
                  switch(ro[0])
                   {case 0:
                     var _er_=ro[1];
                     if(2 <= addr_typ)
                      {var i=ro[3],s=ro[2];
                       return caml_call6
                               (Stdlib_format[126],
                                fmt,
                                _dG_,
                                print_register,
                                _er_,
                                print_immediate_offset,
                                [0,s,i])}
                     var i$0=ro[3],s$0=ro[2];
                     return caml_call7
                             (Stdlib_format[126],
                              fmt,
                              _dH_,
                              print_register,
                              _er_,
                              print_immediate_offset,
                              [0,s$0,i$0],
                              str);
                    case 1:
                     var _es_=ro[1];
                     if(2 <= addr_typ)
                      {var ro$0=ro[3],s$1=ro[2],_et_=sign_to_str(s$1);
                       return caml_call7
                               (Stdlib_format[126],
                                fmt,
                                _dI_,
                                print_register,
                                _es_,
                                _et_,
                                print_register,
                                ro$0)}
                     var ro$1=ro[3],s$2=ro[2],_eu_=sign_to_str(s$2);
                     return caml_call8
                             (Stdlib_format[126],
                              fmt,
                              _dJ_,
                              print_register,
                              _es_,
                              _eu_,
                              print_register,
                              ro$1,
                              str);
                    default:return caml_call1(Stdlib[2],cst_Not_implemented$4)}},
               pp_arm=
                function(fmt,arm)
                 {switch(arm[0])
                   {case 0:var i=arm[1];return pp_hex(fmt,i);
                    case 1:
                     var ro=arm[5],rd=arm[4],cond=arm[3],typ=arm[2],instr=arm[1];
                     switch(typ)
                      {case 0:var _ee_=cst_B$1;break;
                       case 1:var _ee_=cst_SB$0;break;
                       case 2:var _ee_=cst_H$0;break;
                       case 3:var _ee_=cst_SH$0;break;
                       case 4:var _ee_=cst$3;break;
                       case 5:var _ee_=cst_T$0;break;
                       default:var _ee_=cst_BT$0}
                     var _ef_=cond_to_str(cond),_eg_=instr?cst_STR$0:cst_LDR$0;
                     return caml_call9
                             (Stdlib_format[126],
                              fmt,
                              _dK_,
                              _eg_,
                              _ef_,
                              _ee_,
                              print_register,
                              rd,
                              print_register_offset,
                              ro);
                    case 2:
                     var
                      rs=arm[5],
                      rd$0=arm[4],
                      cond$0=arm[3],
                      s=arm[2],
                      instr$0=arm[1],
                      _eh_=s_to_str(s),
                      _ei_=cond_to_str(cond$0),
                      _ej_=instr$0?cst_MVN$0:cst_MOV$0;
                     return caml_call9
                             (Stdlib_format[126],
                              fmt,
                              _dL_,
                              _ej_,
                              _ei_,
                              _eh_,
                              print_register,
                              rd$0,
                              print_operand,
                              rs);
                    case 3:
                     var
                      op2=arm[6],
                      rn=arm[5],
                      rd$1=arm[4],
                      cond$1=arm[3],
                      s$0=arm[2],
                      instr$1=arm[1],
                      _ek_=s_to_str(s$0),
                      _el_=cond_to_str(cond$1);
                     switch(instr$1)
                      {case 0:var _em_=cst_ADC$0;break;
                       case 1:var _em_=cst_SBC$0;break;
                       case 2:var _em_=cst_BIC$0;break;
                       case 3:var _em_=cst_AND$0;break;
                       case 4:var _em_=cst_ADD$0;break;
                       case 5:var _em_=cst_SUB$0;break;
                       case 6:var _em_=cst_ORR$0;break;
                       default:var _em_=cst_EOR$0}
                     return caml_call11
                             (Stdlib_format[126],
                              fmt,
                              _dM_,
                              _em_,
                              _el_,
                              _ek_,
                              print_register,
                              rd$1,
                              print_register,
                              rn,
                              print_operand,
                              op2);
                    case 4:
                     var
                      target=arm[3],
                      cond$2=arm[2],
                      l=arm[1],
                      _en_=cond_to_str(cond$2),
                      _eo_=l_to_str(l);
                     return caml_call6
                             (Stdlib_format[126],
                              fmt,
                              _dN_,
                              _eo_,
                              _en_,
                              print_immediate,
                              target);
                    default:
                     var
                      rm=arm[3],
                      cond$3=arm[2],
                      l$0=arm[1],
                      _ep_=cond_to_str(cond$3),
                      _eq_=l_to_str(l$0);
                     return caml_call6
                             (Stdlib_format[126],fmt,_dO_,_eq_,_ep_,print_register,rm)}},
               Arm_printer=[0,pp_arm,pp_hex];
              caml_register_global(508,Arm_printer,"Arm_printer");
              var
               treat_command=
                function(fmt,arm)
                 {var
                   hexs=arm_to_binary(arm),
                   codes=caml_call2(Stdlib_list[19],codes_for_command,hexs),
                   code=preferred_code(codes),
                   hex=command_for_codes(code),
                   chars=codes_to_chars(code);
                  caml_call8
                   (Stdlib_format[126],
                    fmt,
                    _dP_,
                    pp_chars,
                    chars,
                    pp_hex,
                    hex,
                    pp_arm,
                    arm);
                  return code},
               main$2=
                function(fmt,env,param,parsed,exit)
                 {var
                   headers2=param[2],
                   headers=param[1],
                   match=get_param(headers,cst_onlyraw);
                  if(typeof match === "number")
                   var onlyraw=0;
                  else
                   if(2 === match[0])
                    var b$0=match[1],onlyraw=b$0;
                   else
                    var onlyraw=caml_call1(Stdlib[2],cst_Invalid_headers$5);
                  var _d3_=onlyraw?0 !== exit?1:0:onlyraw;
                  if(_d3_)
                   caml_call1(Stdlib[2],cst_Only_raw_mode_does_not_sup);
                  var match$0=get_param(headers,cst_start$0);
                  if(typeof match$0 === "number")
                   var start=0;
                  else
                   if(1 === match$0[0])
                    var i$1=match$0[1],start=uint32_to_int(i$1);
                   else
                    var start=caml_call1(Stdlib[2],cst_Invalid_headers$4);
                  function _d4_(n)
                   {var
                     header_name=caml_call2(Stdlib_format[129],_dQ_,n + 1 | 0),
                     match=get_param(headers,header_name);
                    if(typeof match === "number")
                     return caml_check_bound(default_fillers[3],n)[1 + n];
                    else
                     {if(1 === match[0])
                       {var i=match[1],codes=codes_for_command(i);
                        if(caml_call2(Stdlib_list[7],codes,n) !== 255)
                         caml_call1(Stdlib[2],cst_Invalid_filler);
                        return codes}
                      return caml_call1(Stdlib[2],cst_Invalid_headers$0)}}
                  var
                   fillers=caml_call2(Stdlib_array[2],4,_d4_),
                   match$1=get_param(headers,cst_filler0);
                  if(typeof match$1 === "number")
                   var nop_code=default_fillers[1];
                  else
                   if(1 === match$1[0])
                    var i$0=match$1[1],nop_code=codes_for_command(i$0);
                   else
                    var nop_code=caml_call1(Stdlib[2],cst_Invalid_headers$3);
                  var match$2=get_param(headers,cst_filler0_alt);
                  if(typeof match$2 === "number")
                   var nop_code_alt=default_fillers[2];
                  else
                   if(1 === match$2[0])
                    var i=match$2[1],nop_code_alt=codes_for_command(i);
                   else
                    var
                     nop_code_alt=
                      caml_call1(Stdlib[2],cst_Invalid_headers$2);
                  var
                   match$3=get_param(headers,cst_fill),
                   match$4=get_param(headers2,cst_fill$0),
                   switch$0=0;
                  if(typeof match$3 === "number")
                   if(typeof match$4 === "number")
                    var fill_last=1;
                   else
                    if(2 === match$4[0])
                     {var b=match$4[1];switch$0 = 2}
                    else
                     switch$0 = 1;
                  else
                   if(2 === match$3[0])
                    {var _eb_=match$3[1];
                     if(typeof match$4 === "number")
                      {var b=_eb_;switch$0 = 2}
                     else
                      if(2 === match$4[0])
                       var
                        b2=match$4[1],
                        b1=
                         _eb_ === b2
                          ?_eb_
                          :caml_call1(Stdlib[2],cst_The_fill_header_has_a_diff),
                        fill_last=b1;
                      else
                       switch$0 = 1}
                   else
                    switch$0 = 1;
                  switch(switch$0)
                   {case 1:
                     var fill_last=caml_call1(Stdlib[2],cst_Invalid_headers$1);
                     break;
                    case 2:var fill_last=b;break
                    }
                  var _d5_=parsed_ast_to_arm(1,env,parsed);
                  function _d6_(_ed_){return treat_command(fmt,_ed_)}
                  var res=caml_call2(Stdlib_list[19],_d6_,_d5_);
                  if(onlyraw)
                   {var
                     _d7_=function(param){return 0},
                     start$0=caml_call2(Stdlib_list[10],start,_d7_),
                     res$0=caml_call1(Stdlib_list[13],[0,start$0,res]);
                    caml_call2(Stdlib_format[126],fmt,_dR_);
                    var _d8_=caml_call2(Stdlib_format[126],fmt,_dS_);
                    caml_call2(Stdlib_list[17],_d8_,res$0);
                    caml_call2(Stdlib_format[126],fmt,_dT_);
                    return 0}
                  try
                   {var
                     fillers$0=[0,nop_code,nop_code_alt,fillers],
                     boxes_codes=
                      hex_box_mode[1]
                       ?fit_codes_into_hex_boxes([0,exit],res)
                       :fit_codes_into_boxes
                         ([0,fill_last],[0,fillers$0],[0,start],[0,exit],res);
                    caml_call4
                     (Stdlib_format[126],fmt,_dU_,pp_boxes_names,boxes_codes);
                    var size=caml_call1(Stdlib_list[1],boxes_codes);
                    if(14 < size)
                     caml_call4(Stdlib_format[126],fmt,_dV_,size,nb_boxes);
                    var _d9_=function(c){return 1 - is_code_writable(c)};
                    if(caml_call2(Stdlib_list[33],_d9_,boxes_codes))
                     caml_call2(Stdlib_format[126],fmt,_dW_);
                    else
                     if
                      (caml_call2(Stdlib_list[33],is_full_of_spaces,boxes_codes))
                      caml_call2(Stdlib_format[126],fmt,_d0_);
                    caml_call2(Stdlib_format[126],fmt,_dX_);
                    var _d__=caml_call3(Stdlib_format[126],fmt,_dY_,pp_box_raw);
                    caml_call2(Stdlib_list[17],_d__,boxes_codes);
                    caml_call2(Stdlib_format[126],fmt,_dZ_);
                    var
                     _d$_=function(c){return concat_strings(codes_to_chars(c))},
                     _ea_=[0,caml_call2(Stdlib_list[19],_d$_,boxes_codes)];
                    return _ea_}
                  catch(_ec_)
                   {_ec_ = caml_wrap_exception(_ec_);
                    if(_ec_ === NoExitCode)
                     return caml_call1(Stdlib[2],cst_The_exit_code_overlaps_thi);
                    throw _ec_}},
               Ace_common=[0,treat_command,main$2];
              caml_register_global(509,Ace_common,"Ace_common");
              return}
            var
             i$3=caml_call1(Stdlib_int32[6],i$2),
             acc$2=[0,i$2,acc$1],
             acc$1=acc$2,
             i$2=i$3;
            continue}}}
      throw [0,Assert_failure,_d1_]}}
  (function(){return this}()));


//# 1 ".js/js_of_ocaml/js_of_ocaml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_exn_with_js_backtrace=runtime.caml_exn_with_js_backtrace,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_js_from_array=runtime.caml_js_from_array,
     caml_js_get=runtime.caml_js_get,
     caml_js_html_escape=runtime.caml_js_html_escape,
     caml_js_set=runtime.caml_js_set,
     caml_js_wrap_callback=runtime.caml_js_wrap_callback,
     caml_js_wrap_meth_callback=runtime.caml_js_wrap_meth_callback,
     caml_jsbytes_of_string=runtime.caml_jsbytes_of_string,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_array=runtime.caml_string_of_array,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseFloat=caml_string_of_jsbytes("parseFloat"),
     cst_parseInt=caml_string_of_jsbytes("parseInt"),
     cst_Js_of_ocaml_Js_Error=caml_string_of_jsbytes("Js_of_ocaml__Js.Error"),
     cst_jsError=caml_string_of_jsbytes("jsError"),
     cst_can_t_retrieve_file_name_n=
      caml_string_of_jsbytes("can't retrieve file name: not implemented"),
     cst_endings=caml_string_of_jsbytes("endings"),
     cst_type=caml_string_of_jsbytes("type"),
     cst_loadstart=caml_string_of_jsbytes("loadstart"),
     cst_progress=caml_string_of_jsbytes("progress"),
     cst_abort=caml_string_of_jsbytes("abort"),
     cst_error=caml_string_of_jsbytes("error"),
     cst_load=caml_string_of_jsbytes("load"),
     cst_loadend=caml_string_of_jsbytes("loadend"),
     cst_a$1=caml_string_of_jsbytes("a"),
     cst_area$1=caml_string_of_jsbytes("area"),
     cst_audio$1=caml_string_of_jsbytes("audio"),
     cst_base$1=caml_string_of_jsbytes("base"),
     cst_blockquote$1=caml_string_of_jsbytes("blockquote"),
     cst_body$1=caml_string_of_jsbytes("body"),
     cst_br$1=caml_string_of_jsbytes("br"),
     cst_button$1=caml_string_of_jsbytes("button"),
     cst_canvas$1=caml_string_of_jsbytes("canvas"),
     cst_caption$1=caml_string_of_jsbytes("caption"),
     cst_col$1=caml_string_of_jsbytes("col"),
     cst_colgroup$1=caml_string_of_jsbytes("colgroup"),
     cst_del$1=caml_string_of_jsbytes("del"),
     cst_div$1=caml_string_of_jsbytes("div"),
     cst_dl$1=caml_string_of_jsbytes("dl"),
     cst_embed$1=caml_string_of_jsbytes("embed"),
     cst_fieldset$1=caml_string_of_jsbytes("fieldset"),
     cst_form$1=caml_string_of_jsbytes("form"),
     cst_frame$1=caml_string_of_jsbytes("frame"),
     cst_frameset$1=caml_string_of_jsbytes("frameset"),
     cst_h1$1=caml_string_of_jsbytes("h1"),
     cst_h2$1=caml_string_of_jsbytes("h2"),
     cst_h3$1=caml_string_of_jsbytes("h3"),
     cst_h4$1=caml_string_of_jsbytes("h4"),
     cst_h5$1=caml_string_of_jsbytes("h5"),
     cst_h6$1=caml_string_of_jsbytes("h6"),
     cst_head$1=caml_string_of_jsbytes("head"),
     cst_hr$1=caml_string_of_jsbytes("hr"),
     cst_html$1=caml_string_of_jsbytes("html"),
     cst_iframe$1=caml_string_of_jsbytes("iframe"),
     cst_img$1=caml_string_of_jsbytes("img"),
     cst_input$2=caml_string_of_jsbytes("input"),
     cst_ins$1=caml_string_of_jsbytes("ins"),
     cst_label$1=caml_string_of_jsbytes("label"),
     cst_legend$1=caml_string_of_jsbytes("legend"),
     cst_li$1=caml_string_of_jsbytes("li"),
     cst_link$1=caml_string_of_jsbytes("link"),
     cst_map$1=caml_string_of_jsbytes("map"),
     cst_meta$1=caml_string_of_jsbytes("meta"),
     cst_object$1=caml_string_of_jsbytes("object"),
     cst_ol$1=caml_string_of_jsbytes("ol"),
     cst_optgroup$1=caml_string_of_jsbytes("optgroup"),
     cst_option$1=caml_string_of_jsbytes("option"),
     cst_p$1=caml_string_of_jsbytes("p"),
     cst_param$1=caml_string_of_jsbytes("param"),
     cst_pre$1=caml_string_of_jsbytes("pre"),
     cst_q$1=caml_string_of_jsbytes("q"),
     cst_script$1=caml_string_of_jsbytes("script"),
     cst_select$2=caml_string_of_jsbytes("select"),
     cst_style$1=caml_string_of_jsbytes("style"),
     cst_table$1=caml_string_of_jsbytes("table"),
     cst_tbody$1=caml_string_of_jsbytes("tbody"),
     cst_td$1=caml_string_of_jsbytes("td"),
     cst_textarea$1=caml_string_of_jsbytes("textarea"),
     cst_tfoot$1=caml_string_of_jsbytes("tfoot"),
     cst_th$1=caml_string_of_jsbytes("th"),
     cst_thead$1=caml_string_of_jsbytes("thead"),
     cst_title$1=caml_string_of_jsbytes("title"),
     cst_tr$1=caml_string_of_jsbytes("tr"),
     cst_ul$1=caml_string_of_jsbytes("ul"),
     cst_video$1=caml_string_of_jsbytes("video"),
     cst_KeyH=caml_string_of_jsbytes("KeyH"),
     cst_Digit6=caml_string_of_jsbytes("Digit6"),
     cst_BrowserRefresh=caml_string_of_jsbytes("BrowserRefresh"),
     cst_Backslash=caml_string_of_jsbytes("Backslash"),
     cst_AltLeft=caml_string_of_jsbytes("AltLeft"),
     cst_AltRight=caml_string_of_jsbytes("AltRight"),
     cst_ArrowDown=caml_string_of_jsbytes("ArrowDown"),
     cst_ArrowLeft=caml_string_of_jsbytes("ArrowLeft"),
     cst_ArrowRight=caml_string_of_jsbytes("ArrowRight"),
     cst_ArrowUp=caml_string_of_jsbytes("ArrowUp"),
     cst_Backquote=caml_string_of_jsbytes("Backquote"),
     cst_Backspace=caml_string_of_jsbytes("Backspace"),
     cst_BracketLeft=caml_string_of_jsbytes("BracketLeft"),
     cst_BracketRight=caml_string_of_jsbytes("BracketRight"),
     cst_BrowserBack=caml_string_of_jsbytes("BrowserBack"),
     cst_BrowserFavorites=caml_string_of_jsbytes("BrowserFavorites"),
     cst_BrowserForward=caml_string_of_jsbytes("BrowserForward"),
     cst_BrowserHome=caml_string_of_jsbytes("BrowserHome"),
     cst_Delete=caml_string_of_jsbytes("Delete"),
     cst_BrowserSearch=caml_string_of_jsbytes("BrowserSearch"),
     cst_BrowserStop=caml_string_of_jsbytes("BrowserStop"),
     cst_CapsLock=caml_string_of_jsbytes("CapsLock"),
     cst_Comma=caml_string_of_jsbytes("Comma"),
     cst_ContextMenu=caml_string_of_jsbytes("ContextMenu"),
     cst_ControlLeft=caml_string_of_jsbytes("ControlLeft"),
     cst_ControlRight=caml_string_of_jsbytes("ControlRight"),
     cst_Digit0=caml_string_of_jsbytes("Digit0"),
     cst_Digit1=caml_string_of_jsbytes("Digit1"),
     cst_Digit2=caml_string_of_jsbytes("Digit2"),
     cst_Digit3=caml_string_of_jsbytes("Digit3"),
     cst_Digit4=caml_string_of_jsbytes("Digit4"),
     cst_Digit5=caml_string_of_jsbytes("Digit5"),
     cst_F6=caml_string_of_jsbytes("F6"),
     cst_F1=caml_string_of_jsbytes("F1"),
     cst_Digit7=caml_string_of_jsbytes("Digit7"),
     cst_Digit8=caml_string_of_jsbytes("Digit8"),
     cst_Digit9=caml_string_of_jsbytes("Digit9"),
     cst_End=caml_string_of_jsbytes("End"),
     cst_Enter=caml_string_of_jsbytes("Enter"),
     cst_Equal=caml_string_of_jsbytes("Equal"),
     cst_Escape=caml_string_of_jsbytes("Escape"),
     cst_F10=caml_string_of_jsbytes("F10"),
     cst_F11=caml_string_of_jsbytes("F11"),
     cst_F12=caml_string_of_jsbytes("F12"),
     cst_F2=caml_string_of_jsbytes("F2"),
     cst_F3=caml_string_of_jsbytes("F3"),
     cst_F4=caml_string_of_jsbytes("F4"),
     cst_F5=caml_string_of_jsbytes("F5"),
     cst_KeyA=caml_string_of_jsbytes("KeyA"),
     cst_F7=caml_string_of_jsbytes("F7"),
     cst_F8=caml_string_of_jsbytes("F8"),
     cst_F9=caml_string_of_jsbytes("F9"),
     cst_Home=caml_string_of_jsbytes("Home"),
     cst_Insert=caml_string_of_jsbytes("Insert"),
     cst_IntlBackslash=caml_string_of_jsbytes("IntlBackslash"),
     cst_IntlYen=caml_string_of_jsbytes("IntlYen"),
     cst_KeyB=caml_string_of_jsbytes("KeyB"),
     cst_KeyC=caml_string_of_jsbytes("KeyC"),
     cst_KeyD=caml_string_of_jsbytes("KeyD"),
     cst_KeyE=caml_string_of_jsbytes("KeyE"),
     cst_KeyF=caml_string_of_jsbytes("KeyF"),
     cst_KeyG=caml_string_of_jsbytes("KeyG"),
     cst_Numpad4=caml_string_of_jsbytes("Numpad4"),
     cst_KeyX=caml_string_of_jsbytes("KeyX"),
     cst_KeyP=caml_string_of_jsbytes("KeyP"),
     cst_KeyI=caml_string_of_jsbytes("KeyI"),
     cst_KeyJ=caml_string_of_jsbytes("KeyJ"),
     cst_KeyK=caml_string_of_jsbytes("KeyK"),
     cst_KeyL=caml_string_of_jsbytes("KeyL"),
     cst_KeyM=caml_string_of_jsbytes("KeyM"),
     cst_KeyN=caml_string_of_jsbytes("KeyN"),
     cst_KeyO=caml_string_of_jsbytes("KeyO"),
     cst_KeyQ=caml_string_of_jsbytes("KeyQ"),
     cst_KeyR=caml_string_of_jsbytes("KeyR"),
     cst_KeyS=caml_string_of_jsbytes("KeyS"),
     cst_KeyT=caml_string_of_jsbytes("KeyT"),
     cst_KeyU=caml_string_of_jsbytes("KeyU"),
     cst_KeyV=caml_string_of_jsbytes("KeyV"),
     cst_KeyW=caml_string_of_jsbytes("KeyW"),
     cst_MetaRight=caml_string_of_jsbytes("MetaRight"),
     cst_KeyY=caml_string_of_jsbytes("KeyY"),
     cst_KeyZ=caml_string_of_jsbytes("KeyZ"),
     cst_MediaPlayPause=caml_string_of_jsbytes("MediaPlayPause"),
     cst_MediaStop=caml_string_of_jsbytes("MediaStop"),
     cst_MediaTrackNext=caml_string_of_jsbytes("MediaTrackNext"),
     cst_MediaTrackPrevious=caml_string_of_jsbytes("MediaTrackPrevious"),
     cst_MetaLeft=caml_string_of_jsbytes("MetaLeft"),
     cst_Minus=caml_string_of_jsbytes("Minus"),
     cst_NumLock=caml_string_of_jsbytes("NumLock"),
     cst_Numpad0=caml_string_of_jsbytes("Numpad0"),
     cst_Numpad1=caml_string_of_jsbytes("Numpad1"),
     cst_Numpad2=caml_string_of_jsbytes("Numpad2"),
     cst_Numpad3=caml_string_of_jsbytes("Numpad3"),
     cst_PageUp=caml_string_of_jsbytes("PageUp"),
     cst_NumpadDivide=caml_string_of_jsbytes("NumpadDivide"),
     cst_Numpad5=caml_string_of_jsbytes("Numpad5"),
     cst_Numpad6=caml_string_of_jsbytes("Numpad6"),
     cst_Numpad7=caml_string_of_jsbytes("Numpad7"),
     cst_Numpad8=caml_string_of_jsbytes("Numpad8"),
     cst_Numpad9=caml_string_of_jsbytes("Numpad9"),
     cst_NumpadAdd=caml_string_of_jsbytes("NumpadAdd"),
     cst_NumpadDecimal=caml_string_of_jsbytes("NumpadDecimal"),
     cst_NumpadEnter=caml_string_of_jsbytes("NumpadEnter"),
     cst_NumpadEqual=caml_string_of_jsbytes("NumpadEqual"),
     cst_NumpadMultiply=caml_string_of_jsbytes("NumpadMultiply"),
     cst_NumpadSubtract=caml_string_of_jsbytes("NumpadSubtract"),
     cst_OSLeft=caml_string_of_jsbytes("OSLeft"),
     cst_OSRight=caml_string_of_jsbytes("OSRight"),
     cst_PageDown=caml_string_of_jsbytes("PageDown"),
     cst_ShiftRight=caml_string_of_jsbytes("ShiftRight"),
     cst_Pause=caml_string_of_jsbytes("Pause"),
     cst_Period=caml_string_of_jsbytes("Period"),
     cst_PrintScreen=caml_string_of_jsbytes("PrintScreen"),
     cst_Quote=caml_string_of_jsbytes("Quote"),
     cst_ScrollLock=caml_string_of_jsbytes("ScrollLock"),
     cst_Semicolon=caml_string_of_jsbytes("Semicolon"),
     cst_ShiftLeft=caml_string_of_jsbytes("ShiftLeft"),
     cst_Slash=caml_string_of_jsbytes("Slash"),
     cst_Space=caml_string_of_jsbytes("Space"),
     cst_Tab=caml_string_of_jsbytes("Tab"),
     cst_VolumeDown=caml_string_of_jsbytes("VolumeDown"),
     cst_VolumeMute=caml_string_of_jsbytes("VolumeMute"),
     cst_VolumeUp=caml_string_of_jsbytes("VolumeUp"),
     cst_mouseout$0=caml_string_of_jsbytes("mouseout"),
     cst_mouseover$0=caml_string_of_jsbytes("mouseover"),
     cst_video$0=caml_string_of_jsbytes("video"),
     cst_audio$0=caml_string_of_jsbytes("audio"),
     cst_ul$0=caml_string_of_jsbytes("ul"),
     cst_tr$0=caml_string_of_jsbytes("tr"),
     cst_title$0=caml_string_of_jsbytes("title"),
     cst_thead$0=caml_string_of_jsbytes("thead"),
     cst_th$0=caml_string_of_jsbytes("th"),
     cst_tfoot$0=caml_string_of_jsbytes("tfoot"),
     cst_textarea$0=caml_string_of_jsbytes("textarea"),
     cst_td$0=caml_string_of_jsbytes("td"),
     cst_tbody$0=caml_string_of_jsbytes("tbody"),
     cst_table$0=caml_string_of_jsbytes("table"),
     cst_style$0=caml_string_of_jsbytes("style"),
     cst_select$1=caml_string_of_jsbytes("select"),
     cst_script$0=caml_string_of_jsbytes("script"),
     cst_q$0=caml_string_of_jsbytes("q"),
     cst_pre$0=caml_string_of_jsbytes("pre"),
     cst_param$0=caml_string_of_jsbytes("param"),
     cst_p$0=caml_string_of_jsbytes("p"),
     cst_option$0=caml_string_of_jsbytes("option"),
     cst_optgroup$0=caml_string_of_jsbytes("optgroup"),
     cst_ol$0=caml_string_of_jsbytes("ol"),
     cst_object$0=caml_string_of_jsbytes("object"),
     cst_meta$0=caml_string_of_jsbytes("meta"),
     cst_map$0=caml_string_of_jsbytes("map"),
     cst_link$0=caml_string_of_jsbytes("link"),
     cst_li$0=caml_string_of_jsbytes("li"),
     cst_legend$0=caml_string_of_jsbytes("legend"),
     cst_label$0=caml_string_of_jsbytes("label"),
     cst_ins$0=caml_string_of_jsbytes("ins"),
     cst_input$1=caml_string_of_jsbytes("input"),
     cst_img$0=caml_string_of_jsbytes("img"),
     cst_iframe$0=caml_string_of_jsbytes("iframe"),
     cst_html$0=caml_string_of_jsbytes("html"),
     cst_hr$0=caml_string_of_jsbytes("hr"),
     cst_head$0=caml_string_of_jsbytes("head"),
     cst_h6$0=caml_string_of_jsbytes("h6"),
     cst_h5$0=caml_string_of_jsbytes("h5"),
     cst_h4$0=caml_string_of_jsbytes("h4"),
     cst_h3$0=caml_string_of_jsbytes("h3"),
     cst_h2$0=caml_string_of_jsbytes("h2"),
     cst_h1$0=caml_string_of_jsbytes("h1"),
     cst_frame$0=caml_string_of_jsbytes("frame"),
     cst_frameset$0=caml_string_of_jsbytes("frameset"),
     cst_form$0=caml_string_of_jsbytes("form"),
     cst_embed$0=caml_string_of_jsbytes("embed"),
     cst_fieldset$0=caml_string_of_jsbytes("fieldset"),
     cst_dl$0=caml_string_of_jsbytes("dl"),
     cst_div$0=caml_string_of_jsbytes("div"),
     cst_del$0=caml_string_of_jsbytes("del"),
     cst_colgroup$0=caml_string_of_jsbytes("colgroup"),
     cst_col$0=caml_string_of_jsbytes("col"),
     cst_caption$0=caml_string_of_jsbytes("caption"),
     cst_canvas$0=caml_string_of_jsbytes("canvas"),
     cst_button$0=caml_string_of_jsbytes("button"),
     cst_br$0=caml_string_of_jsbytes("br"),
     cst_body$0=caml_string_of_jsbytes("body"),
     cst_blockquote$0=caml_string_of_jsbytes("blockquote"),
     cst_base$0=caml_string_of_jsbytes("base"),
     cst_area$0=caml_string_of_jsbytes("area"),
     cst_a$0=caml_string_of_jsbytes("a"),
     cst_canvas=caml_string_of_jsbytes("canvas"),
     cst_video=caml_string_of_jsbytes("video"),
     cst_audio=caml_string_of_jsbytes("audio"),
     cst_iframe=caml_string_of_jsbytes("iframe"),
     cst_frame=caml_string_of_jsbytes("frame"),
     cst_frameset=caml_string_of_jsbytes("frameset"),
     cst_address=caml_string_of_jsbytes("address"),
     cst_noscript=caml_string_of_jsbytes("noscript"),
     cst_dt=caml_string_of_jsbytes("dt"),
     cst_dd=caml_string_of_jsbytes("dd"),
     cst_abbr=caml_string_of_jsbytes("abbr"),
     cst_var=caml_string_of_jsbytes("var"),
     cst_kbd=caml_string_of_jsbytes("kbd"),
     cst_samp=caml_string_of_jsbytes("samp"),
     cst_code=caml_string_of_jsbytes("code"),
     cst_dfn=caml_string_of_jsbytes("dfn"),
     cst_cite=caml_string_of_jsbytes("cite"),
     cst_strong=caml_string_of_jsbytes("strong"),
     cst_em=caml_string_of_jsbytes("em"),
     cst_small=caml_string_of_jsbytes("small"),
     cst_big=caml_string_of_jsbytes("big"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_i=caml_string_of_jsbytes("i"),
     cst_tt=caml_string_of_jsbytes("tt"),
     cst_span=caml_string_of_jsbytes("span"),
     cst_sup=caml_string_of_jsbytes("sup"),
     cst_sub=caml_string_of_jsbytes("sub"),
     cst_td=caml_string_of_jsbytes("td"),
     cst_th=caml_string_of_jsbytes("th"),
     cst_tr=caml_string_of_jsbytes("tr"),
     cst_tbody=caml_string_of_jsbytes("tbody"),
     cst_tfoot=caml_string_of_jsbytes("tfoot"),
     cst_thead=caml_string_of_jsbytes("thead"),
     cst_colgroup=caml_string_of_jsbytes("colgroup"),
     cst_col=caml_string_of_jsbytes("col"),
     cst_caption=caml_string_of_jsbytes("caption"),
     cst_table=caml_string_of_jsbytes("table"),
     cst_script=caml_string_of_jsbytes("script"),
     cst_area=caml_string_of_jsbytes("area"),
     cst_map=caml_string_of_jsbytes("map"),
     cst_param=caml_string_of_jsbytes("param"),
     cst_object=caml_string_of_jsbytes("object"),
     cst_img=caml_string_of_jsbytes("img"),
     cst_a=caml_string_of_jsbytes("a"),
     cst_del=caml_string_of_jsbytes("del"),
     cst_ins=caml_string_of_jsbytes("ins"),
     cst_hr=caml_string_of_jsbytes("hr"),
     cst_br=caml_string_of_jsbytes("br"),
     cst_pre=caml_string_of_jsbytes("pre"),
     cst_blockquote=caml_string_of_jsbytes("blockquote"),
     cst_q=caml_string_of_jsbytes("q"),
     cst_h6=caml_string_of_jsbytes("h6"),
     cst_h5=caml_string_of_jsbytes("h5"),
     cst_h4=caml_string_of_jsbytes("h4"),
     cst_h3=caml_string_of_jsbytes("h3"),
     cst_h2=caml_string_of_jsbytes("h2"),
     cst_h1=caml_string_of_jsbytes("h1"),
     cst_p=caml_string_of_jsbytes("p"),
     cst_embed=caml_string_of_jsbytes("embed"),
     cst_div=caml_string_of_jsbytes("div"),
     cst_li=caml_string_of_jsbytes("li"),
     cst_dl=caml_string_of_jsbytes("dl"),
     cst_ol=caml_string_of_jsbytes("ol"),
     cst_ul=caml_string_of_jsbytes("ul"),
     cst_legend=caml_string_of_jsbytes("legend"),
     cst_fieldset=caml_string_of_jsbytes("fieldset"),
     cst_label=caml_string_of_jsbytes("label"),
     cst_button=caml_string_of_jsbytes("button"),
     cst_textarea=caml_string_of_jsbytes("textarea"),
     cst_input$0=caml_string_of_jsbytes("input"),
     cst_select$0=caml_string_of_jsbytes("select"),
     cst_option=caml_string_of_jsbytes("option"),
     cst_optgroup=caml_string_of_jsbytes("optgroup"),
     cst_form=caml_string_of_jsbytes("form"),
     cst_body=caml_string_of_jsbytes("body"),
     cst_style=caml_string_of_jsbytes("style"),
     cst_base=caml_string_of_jsbytes("base"),
     cst_meta=caml_string_of_jsbytes("meta"),
     cst_title=caml_string_of_jsbytes("title"),
     cst_link=caml_string_of_jsbytes("link"),
     cst_head=caml_string_of_jsbytes("head"),
     cst_html=caml_string_of_jsbytes("html"),
     cst_click=caml_string_of_jsbytes("click"),
     cst_copy=caml_string_of_jsbytes("copy"),
     cst_cut=caml_string_of_jsbytes("cut"),
     cst_paste=caml_string_of_jsbytes("paste"),
     cst_dblclick=caml_string_of_jsbytes("dblclick"),
     cst_mousedown=caml_string_of_jsbytes("mousedown"),
     cst_mouseup=caml_string_of_jsbytes("mouseup"),
     cst_mouseover=caml_string_of_jsbytes("mouseover"),
     cst_mousemove=caml_string_of_jsbytes("mousemove"),
     cst_mouseout=caml_string_of_jsbytes("mouseout"),
     cst_keypress=caml_string_of_jsbytes("keypress"),
     cst_keydown=caml_string_of_jsbytes("keydown"),
     cst_keyup=caml_string_of_jsbytes("keyup"),
     cst_mousewheel=caml_string_of_jsbytes("mousewheel"),
     cst_DOMMouseScroll=caml_string_of_jsbytes("DOMMouseScroll"),
     cst_touchstart=caml_string_of_jsbytes("touchstart"),
     cst_touchmove=caml_string_of_jsbytes("touchmove"),
     cst_touchend=caml_string_of_jsbytes("touchend"),
     cst_touchcancel=caml_string_of_jsbytes("touchcancel"),
     cst_dragstart=caml_string_of_jsbytes("dragstart"),
     cst_dragend=caml_string_of_jsbytes("dragend"),
     cst_dragenter=caml_string_of_jsbytes("dragenter"),
     cst_dragover=caml_string_of_jsbytes("dragover"),
     cst_dragleave=caml_string_of_jsbytes("dragleave"),
     cst_drag=caml_string_of_jsbytes("drag"),
     cst_drop=caml_string_of_jsbytes("drop"),
     cst_hashchange=caml_string_of_jsbytes("hashchange"),
     cst_change=caml_string_of_jsbytes("change"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_timeupdate=caml_string_of_jsbytes("timeupdate"),
     cst_submit=caml_string_of_jsbytes("submit"),
     cst_scroll=caml_string_of_jsbytes("scroll"),
     cst_focus=caml_string_of_jsbytes("focus"),
     cst_blur=caml_string_of_jsbytes("blur"),
     cst_load$0=caml_string_of_jsbytes("load"),
     cst_unload=caml_string_of_jsbytes("unload"),
     cst_beforeunload=caml_string_of_jsbytes("beforeunload"),
     cst_resize=caml_string_of_jsbytes("resize"),
     cst_orientationchange=caml_string_of_jsbytes("orientationchange"),
     cst_popstate=caml_string_of_jsbytes("popstate"),
     cst_error$0=caml_string_of_jsbytes("error"),
     cst_abort$0=caml_string_of_jsbytes("abort"),
     cst_select=caml_string_of_jsbytes("select"),
     cst_online=caml_string_of_jsbytes("online"),
     cst_offline=caml_string_of_jsbytes("offline"),
     cst_checking=caml_string_of_jsbytes("checking"),
     cst_noupdate=caml_string_of_jsbytes("noupdate"),
     cst_downloading=caml_string_of_jsbytes("downloading"),
     cst_progress$0=caml_string_of_jsbytes("progress"),
     cst_updateready=caml_string_of_jsbytes("updateready"),
     cst_cached=caml_string_of_jsbytes("cached"),
     cst_obsolete=caml_string_of_jsbytes("obsolete"),
     cst_DOMContentLoaded=caml_string_of_jsbytes("DOMContentLoaded"),
     cst_animationstart=caml_string_of_jsbytes("animationstart"),
     cst_animationend=caml_string_of_jsbytes("animationend"),
     cst_animationiteration=caml_string_of_jsbytes("animationiteration"),
     cst_animationcancel=caml_string_of_jsbytes("animationcancel"),
     cst_canplay=caml_string_of_jsbytes("canplay"),
     cst_canplaythrough=caml_string_of_jsbytes("canplaythrough"),
     cst_durationchange=caml_string_of_jsbytes("durationchange"),
     cst_emptied=caml_string_of_jsbytes("emptied"),
     cst_ended=caml_string_of_jsbytes("ended"),
     cst_gotpointercapture=caml_string_of_jsbytes("gotpointercapture"),
     cst_loadeddata=caml_string_of_jsbytes("loadeddata"),
     cst_loadedmetadata=caml_string_of_jsbytes("loadedmetadata"),
     cst_loadstart$0=caml_string_of_jsbytes("loadstart"),
     cst_lostpointercapture=caml_string_of_jsbytes("lostpointercapture"),
     cst_pause=caml_string_of_jsbytes("pause"),
     cst_play=caml_string_of_jsbytes("play"),
     cst_playing=caml_string_of_jsbytes("playing"),
     cst_pointerenter=caml_string_of_jsbytes("pointerenter"),
     cst_pointercancel=caml_string_of_jsbytes("pointercancel"),
     cst_pointerdown=caml_string_of_jsbytes("pointerdown"),
     cst_pointerleave=caml_string_of_jsbytes("pointerleave"),
     cst_pointermove=caml_string_of_jsbytes("pointermove"),
     cst_pointerout=caml_string_of_jsbytes("pointerout"),
     cst_pointerover=caml_string_of_jsbytes("pointerover"),
     cst_pointerup=caml_string_of_jsbytes("pointerup"),
     cst_ratechange=caml_string_of_jsbytes("ratechange"),
     cst_seeked=caml_string_of_jsbytes("seeked"),
     cst_seeking=caml_string_of_jsbytes("seeking"),
     cst_stalled=caml_string_of_jsbytes("stalled"),
     cst_suspend=caml_string_of_jsbytes("suspend"),
     cst_volumechange=caml_string_of_jsbytes("volumechange"),
     cst_waiting=caml_string_of_jsbytes("waiting"),
     cst_Js_of_ocaml_Dom_html_Canva=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_html.Canvas_not_available"),
     cst_checkbox=caml_string_of_jsbytes("checkbox"),
     cst_file=caml_string_of_jsbytes("file"),
     cst_password=caml_string_of_jsbytes("password"),
     cst_radio=caml_string_of_jsbytes("radio"),
     cst_reset=caml_string_of_jsbytes("reset"),
     cst_submit$0=caml_string_of_jsbytes("submit"),
     cst_text=caml_string_of_jsbytes("text"),
     cst_readystatechange=caml_string_of_jsbytes("readystatechange"),
     cst_loadstart$1=caml_string_of_jsbytes("loadstart"),
     cst_progress$1=caml_string_of_jsbytes("progress"),
     cst_abort$1=caml_string_of_jsbytes("abort"),
     cst_error$1=caml_string_of_jsbytes("error"),
     cst_load$1=caml_string_of_jsbytes("load"),
     cst_timeout=caml_string_of_jsbytes("timeout"),
     cst_loadend$0=caml_string_of_jsbytes("loadend"),
     cst_Worker_onmessage_is_undefi$0=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_onmessage_is_undefi=
      caml_string_of_jsbytes("Worker.onmessage is undefined"),
     cst_Worker_import_scripts_is_u=
      caml_string_of_jsbytes("Worker.import_scripts is undefined"),
     cst_webglcontextlost=caml_string_of_jsbytes("webglcontextlost"),
     cst_webglcontextrestored=caml_string_of_jsbytes("webglcontextrestored"),
     cst_webglcontextcreationerror=
      caml_string_of_jsbytes("webglcontextcreationerror"),
     cst_g=caml_string_of_jsbytes("g"),
     cst=caml_string_of_jsbytes("[\\][()\\\\|+*.?{}^$]"),
     cst$37=caml_string_of_jsbytes(""),
     cst$13=caml_string_of_jsbytes(""),
     cst$21=caml_string_of_jsbytes(""),
     cst$14=caml_string_of_jsbytes("#"),
     cst$15=caml_string_of_jsbytes("?"),
     cst$20=caml_string_of_jsbytes(""),
     cst$16=caml_string_of_jsbytes("/"),
     cst$17=caml_string_of_jsbytes("/"),
     cst$19=caml_string_of_jsbytes(":"),
     cst$18=caml_string_of_jsbytes(""),
     cst_http$1=caml_string_of_jsbytes("http://"),
     cst$22=caml_string_of_jsbytes(""),
     cst$30=caml_string_of_jsbytes(""),
     cst$23=caml_string_of_jsbytes("#"),
     cst$24=caml_string_of_jsbytes("?"),
     cst$29=caml_string_of_jsbytes(""),
     cst$25=caml_string_of_jsbytes("/"),
     cst$26=caml_string_of_jsbytes("/"),
     cst$28=caml_string_of_jsbytes(":"),
     cst$27=caml_string_of_jsbytes(""),
     cst_https$1=caml_string_of_jsbytes("https://"),
     cst$31=caml_string_of_jsbytes(""),
     cst$36=caml_string_of_jsbytes(""),
     cst$32=caml_string_of_jsbytes("#"),
     cst$33=caml_string_of_jsbytes("?"),
     cst$35=caml_string_of_jsbytes(""),
     cst$34=caml_string_of_jsbytes("/"),
     cst_file$2=caml_string_of_jsbytes("file://"),
     cst$12=caml_string_of_jsbytes(""),
     cst$11=caml_string_of_jsbytes(""),
     cst$10=caml_string_of_jsbytes(""),
     cst$9=caml_string_of_jsbytes(""),
     cst$8=caml_string_of_jsbytes(""),
     cst$7=caml_string_of_jsbytes(""),
     cst$6=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes("="),
     cst$5=caml_string_of_jsbytes("&"),
     cst$2=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_file$0=caml_string_of_jsbytes("file"),
     cst_file$1=caml_string_of_jsbytes("file:"),
     cst_http=caml_string_of_jsbytes("http"),
     cst_http$0=caml_string_of_jsbytes("http:"),
     cst_https=caml_string_of_jsbytes("https"),
     cst_https$0=caml_string_of_jsbytes("https:"),
     cst$1=caml_string_of_jsbytes(" "),
     cst_2B=caml_string_of_jsbytes("%2B"),
     cst_Js_of_ocaml_Url_Local_exn=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Local_exn"),
     cst$0=caml_string_of_jsbytes("+"),
     cst_Js_of_ocaml_Url_Not_an_htt=
      caml_string_of_jsbytes("Js_of_ocaml__Url.Not_an_http_protocol"),
     cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0=
      caml_string_of_jsbytes
       ("^([Hh][Tt][Tt][Pp][Ss]?)://([0-9a-zA-Z.-]+|\\[[0-9a-zA-Z.-]+\\]|\\[[0-9A-Fa-f:.]+\\])?(:([0-9]+))?(/([^\\?#]*)(\\?([^#]*))?(#(.*))?)?$"),
     cst_Ff_Ii_Ll_Ee=
      caml_string_of_jsbytes
       ("^([Ff][Ii][Ll][Ee])://([^\\?#]*)(\\?([^#]*))?(#(.*))?$"),
     s=caml_string_of_jsbytes("3.9.0"),
     git_version=caml_string_of_jsbytes(""),
     cst$38=caml_string_of_jsbytes(""),
     cst$41=caml_string_of_jsbytes("+"),
     cst_Jstable_keys=caml_string_of_jsbytes("Jstable.keys"),
     dummy_string=caml_string_of_jsbytes(""),
     dummy_int64=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     cst_is_not_a_valid_length$0=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_d_d_deg_grad_rad_turns=
      caml_string_of_jsbytes("^(\\d*(?:\\.\\d*))(deg|grad|rad|turns)$"),
     cst_length_conversion_error$0=
      caml_string_of_jsbytes("length conversion error: "),
     cst_deg$0=caml_string_of_jsbytes("deg"),
     cst_grad$0=caml_string_of_jsbytes("grad"),
     cst_rad$0=caml_string_of_jsbytes("rad"),
     cst_turns$0=caml_string_of_jsbytes("turns"),
     cst_deg=caml_string_of_jsbytes("deg"),
     cst_grad=caml_string_of_jsbytes("grad"),
     cst_rad=caml_string_of_jsbytes("rad"),
     cst_turns=caml_string_of_jsbytes("turns"),
     cst_is_not_a_valid_length=
      caml_string_of_jsbytes(" is not a valid length"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_d_d_s_S=caml_string_of_jsbytes("^(\\d*(?:\\.\\d*)?)\\s*(\\S*)$"),
     cst_length_conversion_error=
      caml_string_of_jsbytes("length conversion error: "),
     cst_pc$0=caml_string_of_jsbytes("pc"),
     cst_ch$0=caml_string_of_jsbytes("ch"),
     cst_cm$0=caml_string_of_jsbytes("cm"),
     cst_em$1=caml_string_of_jsbytes("em"),
     cst_ex$0=caml_string_of_jsbytes("ex"),
     cst_gd$0=caml_string_of_jsbytes("gd"),
     cst_in$0=caml_string_of_jsbytes("in"),
     cst_mm$0=caml_string_of_jsbytes("mm"),
     cst_pt$0=caml_string_of_jsbytes("pt"),
     cst_px$0=caml_string_of_jsbytes("px"),
     cst_rem$0=caml_string_of_jsbytes("rem"),
     cst_vh$0=caml_string_of_jsbytes("vh"),
     cst_vm$0=caml_string_of_jsbytes("vm"),
     cst_vw$0=caml_string_of_jsbytes("vw"),
     cst_0=caml_string_of_jsbytes("0"),
     cst_em$0=caml_string_of_jsbytes("em"),
     cst_ex=caml_string_of_jsbytes("ex"),
     cst_px=caml_string_of_jsbytes("px"),
     cst_gd=caml_string_of_jsbytes("gd"),
     cst_rem=caml_string_of_jsbytes("rem"),
     cst_vw=caml_string_of_jsbytes("vw"),
     cst_vh=caml_string_of_jsbytes("vh"),
     cst_vm=caml_string_of_jsbytes("vm"),
     cst_ch=caml_string_of_jsbytes("ch"),
     cst_mm=caml_string_of_jsbytes("mm"),
     cst_cm=caml_string_of_jsbytes("cm"),
     cst_in=caml_string_of_jsbytes("in"),
     cst_pt=caml_string_of_jsbytes("pt"),
     cst_pc=caml_string_of_jsbytes("pc"),
     cst$40=caml_string_of_jsbytes("): "),
     cst_color_conversion_error$0=
      caml_string_of_jsbytes("color conversion error ("),
     cst$39=caml_string_of_jsbytes("): "),
     cst_color_conversion_error=
      caml_string_of_jsbytes("color conversion error ("),
     cst_is_not_a_valid_color$0=
      caml_string_of_jsbytes(" is not a valid color"),
     cst_rgba_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*),(\\d*),(\\d*)(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgba_d_d_d_d_d$0=
      caml_string_of_jsbytes
       ("(rgba?)\\((?:(\\d*)%,(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_hsla_d_d_d_d_d=
      caml_string_of_jsbytes
       ("(hsla?)\\((?:(\\d*),(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgb=caml_string_of_jsbytes("rgb"),
     cst_rgba=caml_string_of_jsbytes("rgba"),
     cst_rgb$0=caml_string_of_jsbytes("rgb"),
     cst_rgba$0=caml_string_of_jsbytes("rgba"),
     cst_hsl=caml_string_of_jsbytes("hsl"),
     cst_hsla=caml_string_of_jsbytes("hsla"),
     cst_rgb_s_d_s_d_s_d=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*,\\s*\\d*,\\s*\\d*\\)$"),
     cst_rgb_s_d_s_d_s_d$0=
      caml_string_of_jsbytes("^rgb\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*,\\s*\\d*,\\s*\\d*,\\d*\\.?\\d*\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d$0=
      caml_string_of_jsbytes
       ("^rgba\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_hsl_s_d_s_d_s_d=
      caml_string_of_jsbytes("^hsl\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_hsla_s_d_s_d_s_d_d_d=
      caml_string_of_jsbytes
       ("^hsla\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_is_not_a_valid_color=caml_string_of_jsbytes(" is not a valid color"),
     cst_is_out_of_valid_range=
      caml_string_of_jsbytes(" is out of valid range"),
     partial=[8,[0,0,0],0,0,[12,41,0]],
     partial$0=[12,41,0],
     partial$1=[0,0,0],
     cst_lightgrey$0=caml_string_of_jsbytes("lightgrey"),
     cst_darkslategray$0=caml_string_of_jsbytes("darkslategray"),
     cst_cornsilk$0=caml_string_of_jsbytes("cornsilk"),
     cst_blue$0=caml_string_of_jsbytes("blue"),
     cst_aliceblue$0=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite$0=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua$0=caml_string_of_jsbytes("aqua"),
     cst_aquamarine$0=caml_string_of_jsbytes("aquamarine"),
     cst_azure$0=caml_string_of_jsbytes("azure"),
     cst_beige$0=caml_string_of_jsbytes("beige"),
     cst_bisque$0=caml_string_of_jsbytes("bisque"),
     cst_black$0=caml_string_of_jsbytes("black"),
     cst_blanchedalmond$0=caml_string_of_jsbytes("blanchedalmond"),
     cst_blueviolet$0=caml_string_of_jsbytes("blueviolet"),
     cst_brown$0=caml_string_of_jsbytes("brown"),
     cst_burlywood$0=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue$0=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse$0=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate$0=caml_string_of_jsbytes("chocolate"),
     cst_coral$0=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue$0=caml_string_of_jsbytes("cornflowerblue"),
     cst_darkkhaki$0=caml_string_of_jsbytes("darkkhaki"),
     cst_crimson$0=caml_string_of_jsbytes("crimson"),
     cst_cyan$0=caml_string_of_jsbytes("cyan"),
     cst_darkblue$0=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan$0=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod$0=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray$0=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen$0=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey$0=caml_string_of_jsbytes("darkgrey"),
     cst_darkmagenta$0=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen$0=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange$0=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid$0=caml_string_of_jsbytes("darkorchid"),
     cst_darkred$0=caml_string_of_jsbytes("darkred"),
     cst_darksalmon$0=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen$0=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue$0=caml_string_of_jsbytes("darkslateblue"),
     cst_greenyellow$0=caml_string_of_jsbytes("greenyellow"),
     cst_floralwhite$0=caml_string_of_jsbytes("floralwhite"),
     cst_darkslategrey$0=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise$0=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet$0=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink$0=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue$0=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray$0=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey$0=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue$0=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick$0=caml_string_of_jsbytes("firebrick"),
     cst_forestgreen$0=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia$0=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro$0=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite$0=caml_string_of_jsbytes("ghostwhite"),
     cst_gold$0=caml_string_of_jsbytes("gold"),
     cst_goldenrod$0=caml_string_of_jsbytes("goldenrod"),
     cst_gray$0=caml_string_of_jsbytes("gray"),
     cst_green$0=caml_string_of_jsbytes("green"),
     cst_lavenderblush$0=caml_string_of_jsbytes("lavenderblush"),
     cst_grey$0=caml_string_of_jsbytes("grey"),
     cst_honeydew$0=caml_string_of_jsbytes("honeydew"),
     cst_hotpink$0=caml_string_of_jsbytes("hotpink"),
     cst_indianred$0=caml_string_of_jsbytes("indianred"),
     cst_indigo$0=caml_string_of_jsbytes("indigo"),
     cst_ivory$0=caml_string_of_jsbytes("ivory"),
     cst_khaki$0=caml_string_of_jsbytes("khaki"),
     cst_lavender$0=caml_string_of_jsbytes("lavender"),
     cst_lawngreen$0=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon$0=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue$0=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral$0=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan$0=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow$0=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray$0=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen$0=caml_string_of_jsbytes("lightgreen"),
     cst_paleturquoise$0=caml_string_of_jsbytes("paleturquoise"),
     cst_mediumslateblue$0=caml_string_of_jsbytes("mediumslateblue"),
     cst_limegreen$0=caml_string_of_jsbytes("limegreen"),
     cst_lightpink$0=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon$0=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen$0=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue$0=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray$0=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey$0=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue$0=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow$0=caml_string_of_jsbytes("lightyellow"),
     cst_lime$0=caml_string_of_jsbytes("lime"),
     cst_linen$0=caml_string_of_jsbytes("linen"),
     cst_magenta$0=caml_string_of_jsbytes("magenta"),
     cst_maroon$0=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine$0=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue$0=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid$0=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple$0=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen$0=caml_string_of_jsbytes("mediumseagreen"),
     cst_navy$0=caml_string_of_jsbytes("navy"),
     cst_mediumspringgreen$0=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise$0=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred$0=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue$0=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream$0=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose$0=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin$0=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite$0=caml_string_of_jsbytes("navajowhite"),
     cst_oldlace$0=caml_string_of_jsbytes("oldlace"),
     cst_olive$0=caml_string_of_jsbytes("olive"),
     cst_olivedrab$0=caml_string_of_jsbytes("olivedrab"),
     cst_orange$0=caml_string_of_jsbytes("orange"),
     cst_orangered$0=caml_string_of_jsbytes("orangered"),
     cst_orchid$0=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod$0=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen$0=caml_string_of_jsbytes("palegreen"),
     cst_skyblue$0=caml_string_of_jsbytes("skyblue"),
     cst_rosybrown$0=caml_string_of_jsbytes("rosybrown"),
     cst_palevioletred$0=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip$0=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff$0=caml_string_of_jsbytes("peachpuff"),
     cst_peru$0=caml_string_of_jsbytes("peru"),
     cst_pink$0=caml_string_of_jsbytes("pink"),
     cst_plum$0=caml_string_of_jsbytes("plum"),
     cst_powderblue$0=caml_string_of_jsbytes("powderblue"),
     cst_purple$0=caml_string_of_jsbytes("purple"),
     cst_red$0=caml_string_of_jsbytes("red"),
     cst_royalblue$0=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown$0=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon$0=caml_string_of_jsbytes("salmon"),
     cst_sandybrown$0=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen$0=caml_string_of_jsbytes("seagreen"),
     cst_seashell$0=caml_string_of_jsbytes("seashell"),
     cst_sienna$0=caml_string_of_jsbytes("sienna"),
     cst_silver$0=caml_string_of_jsbytes("silver"),
     cst_thistle$0=caml_string_of_jsbytes("thistle"),
     cst_slateblue$0=caml_string_of_jsbytes("slateblue"),
     cst_slategray$0=caml_string_of_jsbytes("slategray"),
     cst_slategrey$0=caml_string_of_jsbytes("slategrey"),
     cst_snow$0=caml_string_of_jsbytes("snow"),
     cst_springgreen$0=caml_string_of_jsbytes("springgreen"),
     cst_steelblue$0=caml_string_of_jsbytes("steelblue"),
     cst_tan$0=caml_string_of_jsbytes("tan"),
     cst_teal$0=caml_string_of_jsbytes("teal"),
     cst_tomato$0=caml_string_of_jsbytes("tomato"),
     cst_turquoise$0=caml_string_of_jsbytes("turquoise"),
     cst_violet$0=caml_string_of_jsbytes("violet"),
     cst_wheat$0=caml_string_of_jsbytes("wheat"),
     cst_white$0=caml_string_of_jsbytes("white"),
     cst_whitesmoke$0=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow$0=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen$0=caml_string_of_jsbytes("yellowgreen"),
     cst_is_not_a_valid_color_name=
      caml_string_of_jsbytes(" is not a valid color name"),
     cst_aliceblue=caml_string_of_jsbytes("aliceblue"),
     cst_antiquewhite=caml_string_of_jsbytes("antiquewhite"),
     cst_aqua=caml_string_of_jsbytes("aqua"),
     cst_aquamarine=caml_string_of_jsbytes("aquamarine"),
     cst_azure=caml_string_of_jsbytes("azure"),
     cst_beige=caml_string_of_jsbytes("beige"),
     cst_bisque=caml_string_of_jsbytes("bisque"),
     cst_black=caml_string_of_jsbytes("black"),
     cst_blanchedalmond=caml_string_of_jsbytes("blanchedalmond"),
     cst_blue=caml_string_of_jsbytes("blue"),
     cst_blueviolet=caml_string_of_jsbytes("blueviolet"),
     cst_brown=caml_string_of_jsbytes("brown"),
     cst_burlywood=caml_string_of_jsbytes("burlywood"),
     cst_cadetblue=caml_string_of_jsbytes("cadetblue"),
     cst_chartreuse=caml_string_of_jsbytes("chartreuse"),
     cst_chocolate=caml_string_of_jsbytes("chocolate"),
     cst_coral=caml_string_of_jsbytes("coral"),
     cst_cornflowerblue=caml_string_of_jsbytes("cornflowerblue"),
     cst_cornsilk=caml_string_of_jsbytes("cornsilk"),
     cst_crimson=caml_string_of_jsbytes("crimson"),
     cst_cyan=caml_string_of_jsbytes("cyan"),
     cst_darkblue=caml_string_of_jsbytes("darkblue"),
     cst_darkcyan=caml_string_of_jsbytes("darkcyan"),
     cst_darkgoldenrod=caml_string_of_jsbytes("darkgoldenrod"),
     cst_darkgray=caml_string_of_jsbytes("darkgray"),
     cst_darkgreen=caml_string_of_jsbytes("darkgreen"),
     cst_darkgrey=caml_string_of_jsbytes("darkgrey"),
     cst_darkkhaki=caml_string_of_jsbytes("darkkhaki"),
     cst_darkmagenta=caml_string_of_jsbytes("darkmagenta"),
     cst_darkolivegreen=caml_string_of_jsbytes("darkolivegreen"),
     cst_darkorange=caml_string_of_jsbytes("darkorange"),
     cst_darkorchid=caml_string_of_jsbytes("darkorchid"),
     cst_darkred=caml_string_of_jsbytes("darkred"),
     cst_darksalmon=caml_string_of_jsbytes("darksalmon"),
     cst_darkseagreen=caml_string_of_jsbytes("darkseagreen"),
     cst_darkslateblue=caml_string_of_jsbytes("darkslateblue"),
     cst_darkslategray=caml_string_of_jsbytes("darkslategray"),
     cst_darkslategrey=caml_string_of_jsbytes("darkslategrey"),
     cst_darkturquoise=caml_string_of_jsbytes("darkturquoise"),
     cst_darkviolet=caml_string_of_jsbytes("darkviolet"),
     cst_deeppink=caml_string_of_jsbytes("deeppink"),
     cst_deepskyblue=caml_string_of_jsbytes("deepskyblue"),
     cst_dimgray=caml_string_of_jsbytes("dimgray"),
     cst_dimgrey=caml_string_of_jsbytes("dimgrey"),
     cst_dodgerblue=caml_string_of_jsbytes("dodgerblue"),
     cst_firebrick=caml_string_of_jsbytes("firebrick"),
     cst_floralwhite=caml_string_of_jsbytes("floralwhite"),
     cst_forestgreen=caml_string_of_jsbytes("forestgreen"),
     cst_fuchsia=caml_string_of_jsbytes("fuchsia"),
     cst_gainsboro=caml_string_of_jsbytes("gainsboro"),
     cst_ghostwhite=caml_string_of_jsbytes("ghostwhite"),
     cst_gold=caml_string_of_jsbytes("gold"),
     cst_goldenrod=caml_string_of_jsbytes("goldenrod"),
     cst_gray=caml_string_of_jsbytes("gray"),
     cst_grey=caml_string_of_jsbytes("grey"),
     cst_green=caml_string_of_jsbytes("green"),
     cst_greenyellow=caml_string_of_jsbytes("greenyellow"),
     cst_honeydew=caml_string_of_jsbytes("honeydew"),
     cst_hotpink=caml_string_of_jsbytes("hotpink"),
     cst_indianred=caml_string_of_jsbytes("indianred"),
     cst_indigo=caml_string_of_jsbytes("indigo"),
     cst_ivory=caml_string_of_jsbytes("ivory"),
     cst_khaki=caml_string_of_jsbytes("khaki"),
     cst_lavender=caml_string_of_jsbytes("lavender"),
     cst_lavenderblush=caml_string_of_jsbytes("lavenderblush"),
     cst_lawngreen=caml_string_of_jsbytes("lawngreen"),
     cst_lemonchiffon=caml_string_of_jsbytes("lemonchiffon"),
     cst_lightblue=caml_string_of_jsbytes("lightblue"),
     cst_lightcoral=caml_string_of_jsbytes("lightcoral"),
     cst_lightcyan=caml_string_of_jsbytes("lightcyan"),
     cst_lightgoldenrodyellow=caml_string_of_jsbytes("lightgoldenrodyellow"),
     cst_lightgray=caml_string_of_jsbytes("lightgray"),
     cst_lightgreen=caml_string_of_jsbytes("lightgreen"),
     cst_lightgrey=caml_string_of_jsbytes("lightgrey"),
     cst_lightpink=caml_string_of_jsbytes("lightpink"),
     cst_lightsalmon=caml_string_of_jsbytes("lightsalmon"),
     cst_lightseagreen=caml_string_of_jsbytes("lightseagreen"),
     cst_lightskyblue=caml_string_of_jsbytes("lightskyblue"),
     cst_lightslategray=caml_string_of_jsbytes("lightslategray"),
     cst_lightslategrey=caml_string_of_jsbytes("lightslategrey"),
     cst_lightsteelblue=caml_string_of_jsbytes("lightsteelblue"),
     cst_lightyellow=caml_string_of_jsbytes("lightyellow"),
     cst_lime=caml_string_of_jsbytes("lime"),
     cst_limegreen=caml_string_of_jsbytes("limegreen"),
     cst_linen=caml_string_of_jsbytes("linen"),
     cst_magenta=caml_string_of_jsbytes("magenta"),
     cst_maroon=caml_string_of_jsbytes("maroon"),
     cst_mediumaquamarine=caml_string_of_jsbytes("mediumaquamarine"),
     cst_mediumblue=caml_string_of_jsbytes("mediumblue"),
     cst_mediumorchid=caml_string_of_jsbytes("mediumorchid"),
     cst_mediumpurple=caml_string_of_jsbytes("mediumpurple"),
     cst_mediumseagreen=caml_string_of_jsbytes("mediumseagreen"),
     cst_mediumslateblue=caml_string_of_jsbytes("mediumslateblue"),
     cst_mediumspringgreen=caml_string_of_jsbytes("mediumspringgreen"),
     cst_mediumturquoise=caml_string_of_jsbytes("mediumturquoise"),
     cst_mediumvioletred=caml_string_of_jsbytes("mediumvioletred"),
     cst_midnightblue=caml_string_of_jsbytes("midnightblue"),
     cst_mintcream=caml_string_of_jsbytes("mintcream"),
     cst_mistyrose=caml_string_of_jsbytes("mistyrose"),
     cst_moccasin=caml_string_of_jsbytes("moccasin"),
     cst_navajowhite=caml_string_of_jsbytes("navajowhite"),
     cst_navy=caml_string_of_jsbytes("navy"),
     cst_oldlace=caml_string_of_jsbytes("oldlace"),
     cst_olive=caml_string_of_jsbytes("olive"),
     cst_olivedrab=caml_string_of_jsbytes("olivedrab"),
     cst_orange=caml_string_of_jsbytes("orange"),
     cst_orangered=caml_string_of_jsbytes("orangered"),
     cst_orchid=caml_string_of_jsbytes("orchid"),
     cst_palegoldenrod=caml_string_of_jsbytes("palegoldenrod"),
     cst_palegreen=caml_string_of_jsbytes("palegreen"),
     cst_paleturquoise=caml_string_of_jsbytes("paleturquoise"),
     cst_palevioletred=caml_string_of_jsbytes("palevioletred"),
     cst_papayawhip=caml_string_of_jsbytes("papayawhip"),
     cst_peachpuff=caml_string_of_jsbytes("peachpuff"),
     cst_peru=caml_string_of_jsbytes("peru"),
     cst_pink=caml_string_of_jsbytes("pink"),
     cst_plum=caml_string_of_jsbytes("plum"),
     cst_powderblue=caml_string_of_jsbytes("powderblue"),
     cst_purple=caml_string_of_jsbytes("purple"),
     cst_red=caml_string_of_jsbytes("red"),
     cst_rosybrown=caml_string_of_jsbytes("rosybrown"),
     cst_royalblue=caml_string_of_jsbytes("royalblue"),
     cst_saddlebrown=caml_string_of_jsbytes("saddlebrown"),
     cst_salmon=caml_string_of_jsbytes("salmon"),
     cst_sandybrown=caml_string_of_jsbytes("sandybrown"),
     cst_seagreen=caml_string_of_jsbytes("seagreen"),
     cst_seashell=caml_string_of_jsbytes("seashell"),
     cst_sienna=caml_string_of_jsbytes("sienna"),
     cst_silver=caml_string_of_jsbytes("silver"),
     cst_skyblue=caml_string_of_jsbytes("skyblue"),
     cst_slateblue=caml_string_of_jsbytes("slateblue"),
     cst_slategray=caml_string_of_jsbytes("slategray"),
     cst_slategrey=caml_string_of_jsbytes("slategrey"),
     cst_snow=caml_string_of_jsbytes("snow"),
     cst_springgreen=caml_string_of_jsbytes("springgreen"),
     cst_steelblue=caml_string_of_jsbytes("steelblue"),
     cst_tan=caml_string_of_jsbytes("tan"),
     cst_teal=caml_string_of_jsbytes("teal"),
     cst_thistle=caml_string_of_jsbytes("thistle"),
     cst_tomato=caml_string_of_jsbytes("tomato"),
     cst_turquoise=caml_string_of_jsbytes("turquoise"),
     cst_violet=caml_string_of_jsbytes("violet"),
     cst_wheat=caml_string_of_jsbytes("wheat"),
     cst_white=caml_string_of_jsbytes("white"),
     cst_whitesmoke=caml_string_of_jsbytes("whitesmoke"),
     cst_yellow=caml_string_of_jsbytes("yellow"),
     cst_yellowgreen=caml_string_of_jsbytes("yellowgreen"),
     cst_vkern$0=caml_string_of_jsbytes("vkern"),
     cst_view$0=caml_string_of_jsbytes("view"),
     cst_use$0=caml_string_of_jsbytes("use"),
     cst_tspan$0=caml_string_of_jsbytes("tspan"),
     cst_tref$0=caml_string_of_jsbytes("tref"),
     cst_title$3=caml_string_of_jsbytes("title"),
     cst_textpath$0=caml_string_of_jsbytes("textpath"),
     cst_text$1=caml_string_of_jsbytes("text"),
     cst_symbol$0=caml_string_of_jsbytes("symbol"),
     cst_switch$0=caml_string_of_jsbytes("switch"),
     cst_svg$0=caml_string_of_jsbytes("svg"),
     cst_style$3=caml_string_of_jsbytes("style"),
     cst_stop$0=caml_string_of_jsbytes("stop"),
     cst_set$0=caml_string_of_jsbytes("set"),
     cst_script$3=caml_string_of_jsbytes("script"),
     cst_rect$0=caml_string_of_jsbytes("rect"),
     cst_radialgradient$0=caml_string_of_jsbytes("radialgradient"),
     cst_polyline$0=caml_string_of_jsbytes("polyline"),
     cst_polygon$0=caml_string_of_jsbytes("polygon"),
     cst_pattern$0=caml_string_of_jsbytes("pattern"),
     cst_path$0=caml_string_of_jsbytes("path"),
     cst_mpath$0=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph$0=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata$0=caml_string_of_jsbytes("metadata"),
     cst_mask$0=caml_string_of_jsbytes("mask"),
     cst_lineargradient$0=caml_string_of_jsbytes("lineargradient"),
     cst_line$0=caml_string_of_jsbytes("line"),
     cst_image$0=caml_string_of_jsbytes("image"),
     cst_hkern$0=caml_string_of_jsbytes("hkern"),
     cst_glyphref$0=caml_string_of_jsbytes("glyphref"),
     cst_glyph$0=caml_string_of_jsbytes("glyph"),
     cst_g$1=caml_string_of_jsbytes("g"),
     cst_foreignobject=caml_string_of_jsbytes("foreignobject"),
     cst_font_face_uri$0=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src$0=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name$0=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format$0=caml_string_of_jsbytes("font-face-format"),
     cst_font_face$0=caml_string_of_jsbytes("font-face"),
     cst_font$0=caml_string_of_jsbytes("font"),
     cst_filter$0=caml_string_of_jsbytes("filter"),
     cst_ellipse$0=caml_string_of_jsbytes("ellipse"),
     cst_desc$0=caml_string_of_jsbytes("desc"),
     cst_defs$0=caml_string_of_jsbytes("defs"),
     cst_cursor$0=caml_string_of_jsbytes("cursor"),
     cst_clippath$0=caml_string_of_jsbytes("clippath"),
     cst_circle$0=caml_string_of_jsbytes("circle"),
     cst_animatetransform$0=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion$0=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor$0=caml_string_of_jsbytes("animatecolor"),
     cst_animate$0=caml_string_of_jsbytes("animate"),
     cst_altglyphitem$0=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef$0=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph$0=caml_string_of_jsbytes("altglyph"),
     cst_a$3=caml_string_of_jsbytes("a"),
     cst_vkern=caml_string_of_jsbytes("vkern"),
     cst_view=caml_string_of_jsbytes("view"),
     cst_use=caml_string_of_jsbytes("use"),
     cst_tspan=caml_string_of_jsbytes("tspan"),
     cst_tref=caml_string_of_jsbytes("tref"),
     cst_title$2=caml_string_of_jsbytes("title"),
     cst_textpath=caml_string_of_jsbytes("textpath"),
     cst_text$0=caml_string_of_jsbytes("text"),
     cst_symbol=caml_string_of_jsbytes("symbol"),
     cst_switch=caml_string_of_jsbytes("switch"),
     cst_svg=caml_string_of_jsbytes("svg"),
     cst_style$2=caml_string_of_jsbytes("style"),
     cst_stop=caml_string_of_jsbytes("stop"),
     cst_set=caml_string_of_jsbytes("set"),
     cst_script$2=caml_string_of_jsbytes("script"),
     cst_rect=caml_string_of_jsbytes("rect"),
     cst_radialgradient=caml_string_of_jsbytes("radialgradient"),
     cst_polyline=caml_string_of_jsbytes("polyline"),
     cst_polygon=caml_string_of_jsbytes("polygon"),
     cst_pattern=caml_string_of_jsbytes("pattern"),
     cst_path=caml_string_of_jsbytes("path"),
     cst_mpath=caml_string_of_jsbytes("mpath"),
     cst_missing_glyph=caml_string_of_jsbytes("missing-glyph"),
     cst_metadata=caml_string_of_jsbytes("metadata"),
     cst_mask=caml_string_of_jsbytes("mask"),
     cst_lineargradient=caml_string_of_jsbytes("lineargradient"),
     cst_line=caml_string_of_jsbytes("line"),
     cst_image=caml_string_of_jsbytes("image"),
     cst_hkern=caml_string_of_jsbytes("hkern"),
     cst_glyphref=caml_string_of_jsbytes("glyphref"),
     cst_glyph=caml_string_of_jsbytes("glyph"),
     cst_g$0=caml_string_of_jsbytes("g"),
     cst_foreignObject=caml_string_of_jsbytes("foreignObject"),
     cst_font_face_uri=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_src=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_name=caml_string_of_jsbytes("font-face-name"),
     cst_font_face_format=caml_string_of_jsbytes("font-face-format"),
     cst_font_face=caml_string_of_jsbytes("font-face"),
     cst_font=caml_string_of_jsbytes("font"),
     cst_filter=caml_string_of_jsbytes("filter"),
     cst_ellipse=caml_string_of_jsbytes("ellipse"),
     cst_desc=caml_string_of_jsbytes("desc"),
     cst_defs=caml_string_of_jsbytes("defs"),
     cst_cursor=caml_string_of_jsbytes("cursor"),
     cst_clippath=caml_string_of_jsbytes("clippath"),
     cst_circle=caml_string_of_jsbytes("circle"),
     cst_animatetransform=caml_string_of_jsbytes("animatetransform"),
     cst_animatemotion=caml_string_of_jsbytes("animatemotion"),
     cst_animatecolor=caml_string_of_jsbytes("animatecolor"),
     cst_animate=caml_string_of_jsbytes("animate"),
     cst_altglyphitem=caml_string_of_jsbytes("altglyphitem"),
     cst_altglyphdef=caml_string_of_jsbytes("altglyphdef"),
     cst_altglyph=caml_string_of_jsbytes("altglyph"),
     cst_a$2=caml_string_of_jsbytes("a"),
     cst_Js_of_ocaml_Dom_svg_SVGErr=
      caml_string_of_jsbytes("Js_of_ocaml__Dom_svg.SVGError"),
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_char=global_data.Stdlib__char,
     Stdlib=global_data.Stdlib,
     Stdlib_callback=global_data.Stdlib__callback,
     Stdlib_printexc=global_data.Stdlib__printexc,
     Assert_failure=global_data.Assert_failure,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_printf=global_data.Stdlib__printf,
     Js_of_ocaml=[0];
    caml_register_global(1632,Js_of_ocaml,"Js_of_ocaml__");
    var
     Poly=[0],
     _f_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom.ml"),351,67],
     _g_=[0,caml_string_of_jsbytes("transparent")],
     _h_=[0,caml_string_of_jsbytes("native")],
     _l_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2816,58],
     _k_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/dom_html.ml"),2815,61],
     _j_=
      [0,
       [11,
        caml_string_of_jsbytes("getElementById_exn: "),
        [3,0,[11,caml_string_of_jsbytes(" not found"),0]]],
       caml_string_of_jsbytes("getElementById_exn: %S not found")],
     _n_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/form.ml"),177,13],
     _m_=[0,1],
     _o_=[0,caml_string_of_jsbytes("lib/js_of_ocaml/regexp.ml"),34,64],
     _p_=[0,caml_string_of_jsbytes(""),0],
     _cj_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ck_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cl_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cm_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b7_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b8_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b9_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b__=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b$_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ca_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cb_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cc_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cd_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ce_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cf_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _cg_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ch_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _ci_=[0,[8,[0,0,0],0,0,[2,0,0]],caml_string_of_jsbytes("%f%s")],
     _b6_=
      caml_list_of_js_array
       ([caml_string_of_jsbytes("aliceblue"),
         caml_string_of_jsbytes("antiquewhite"),
         caml_string_of_jsbytes("aqua"),
         caml_string_of_jsbytes("aquamarine"),
         caml_string_of_jsbytes("azure"),
         caml_string_of_jsbytes("beige"),
         caml_string_of_jsbytes("bisque"),
         caml_string_of_jsbytes("black"),
         caml_string_of_jsbytes("blanchedalmond"),
         caml_string_of_jsbytes("blue"),
         caml_string_of_jsbytes("blueviolet"),
         caml_string_of_jsbytes("brown"),
         caml_string_of_jsbytes("burlywood"),
         caml_string_of_jsbytes("cadetblue"),
         caml_string_of_jsbytes("chartreuse"),
         caml_string_of_jsbytes("chocolate"),
         caml_string_of_jsbytes("coral"),
         caml_string_of_jsbytes("cornflowerblue"),
         caml_string_of_jsbytes("cornsilk"),
         caml_string_of_jsbytes("crimson"),
         caml_string_of_jsbytes("cyan"),
         caml_string_of_jsbytes("darkblue"),
         caml_string_of_jsbytes("darkcyan"),
         caml_string_of_jsbytes("darkgoldenrod"),
         caml_string_of_jsbytes("darkgray"),
         caml_string_of_jsbytes("darkgreen"),
         caml_string_of_jsbytes("darkgrey"),
         caml_string_of_jsbytes("darkkhaki"),
         caml_string_of_jsbytes("darkmagenta"),
         caml_string_of_jsbytes("darkolivegreen"),
         caml_string_of_jsbytes("darkorange"),
         caml_string_of_jsbytes("darkorchid"),
         caml_string_of_jsbytes("darkred"),
         caml_string_of_jsbytes("darksalmon"),
         caml_string_of_jsbytes("darkseagreen"),
         caml_string_of_jsbytes("darkslateblue"),
         caml_string_of_jsbytes("darkslategray"),
         caml_string_of_jsbytes("darkslategrey"),
         caml_string_of_jsbytes("darkturquoise"),
         caml_string_of_jsbytes("darkviolet"),
         caml_string_of_jsbytes("deeppink"),
         caml_string_of_jsbytes("deepskyblue"),
         caml_string_of_jsbytes("dimgray"),
         caml_string_of_jsbytes("dimgrey"),
         caml_string_of_jsbytes("dodgerblue"),
         caml_string_of_jsbytes("firebrick"),
         caml_string_of_jsbytes("floralwhite"),
         caml_string_of_jsbytes("forestgreen"),
         caml_string_of_jsbytes("fuchsia"),
         caml_string_of_jsbytes("gainsboro"),
         caml_string_of_jsbytes("ghostwhite"),
         caml_string_of_jsbytes("gold"),
         caml_string_of_jsbytes("goldenrod"),
         caml_string_of_jsbytes("gray"),
         caml_string_of_jsbytes("green"),
         caml_string_of_jsbytes("greenyellow"),
         caml_string_of_jsbytes("grey"),
         caml_string_of_jsbytes("honeydew"),
         caml_string_of_jsbytes("hotpink"),
         caml_string_of_jsbytes("indianred"),
         caml_string_of_jsbytes("indigo"),
         caml_string_of_jsbytes("ivory"),
         caml_string_of_jsbytes("khaki"),
         caml_string_of_jsbytes("lavender"),
         caml_string_of_jsbytes("lavenderblush"),
         caml_string_of_jsbytes("lawngreen"),
         caml_string_of_jsbytes("lemonchiffon"),
         caml_string_of_jsbytes("lightblue"),
         caml_string_of_jsbytes("lightcoral"),
         caml_string_of_jsbytes("lightcyan"),
         caml_string_of_jsbytes("lightgoldenrodyellow"),
         caml_string_of_jsbytes("lightgray"),
         caml_string_of_jsbytes("lightgreen"),
         caml_string_of_jsbytes("lightgrey"),
         caml_string_of_jsbytes("lightpink"),
         caml_string_of_jsbytes("lightsalmon"),
         caml_string_of_jsbytes("lightseagreen"),
         caml_string_of_jsbytes("lightskyblue"),
         caml_string_of_jsbytes("lightslategray"),
         caml_string_of_jsbytes("lightslategrey"),
         caml_string_of_jsbytes("lightsteelblue"),
         caml_string_of_jsbytes("lightyellow"),
         caml_string_of_jsbytes("lime"),
         caml_string_of_jsbytes("limegreen"),
         caml_string_of_jsbytes("linen"),
         caml_string_of_jsbytes("magenta"),
         caml_string_of_jsbytes("maroon"),
         caml_string_of_jsbytes("mediumaquamarine"),
         caml_string_of_jsbytes("mediumblue"),
         caml_string_of_jsbytes("mediumorchid"),
         caml_string_of_jsbytes("mediumpurple"),
         caml_string_of_jsbytes("mediumseagreen"),
         caml_string_of_jsbytes("mediumslateblue"),
         caml_string_of_jsbytes("mediumspringgreen"),
         caml_string_of_jsbytes("mediumturquoise"),
         caml_string_of_jsbytes("mediumvioletred"),
         caml_string_of_jsbytes("midnightblue"),
         caml_string_of_jsbytes("mintcream"),
         caml_string_of_jsbytes("mistyrose"),
         caml_string_of_jsbytes("moccasin"),
         caml_string_of_jsbytes("navajowhite"),
         caml_string_of_jsbytes("navy"),
         caml_string_of_jsbytes("oldlace"),
         caml_string_of_jsbytes("olive"),
         caml_string_of_jsbytes("olivedrab"),
         caml_string_of_jsbytes("orange"),
         caml_string_of_jsbytes("orangered"),
         caml_string_of_jsbytes("orchid"),
         caml_string_of_jsbytes("palegoldenrod"),
         caml_string_of_jsbytes("palegreen"),
         caml_string_of_jsbytes("paleturquoise"),
         caml_string_of_jsbytes("palevioletred"),
         caml_string_of_jsbytes("papayawhip"),
         caml_string_of_jsbytes("peachpuff"),
         caml_string_of_jsbytes("peru"),
         caml_string_of_jsbytes("pink"),
         caml_string_of_jsbytes("plum"),
         caml_string_of_jsbytes("powderblue"),
         caml_string_of_jsbytes("purple"),
         caml_string_of_jsbytes("red"),
         caml_string_of_jsbytes("rosybrown"),
         caml_string_of_jsbytes("royalblue"),
         caml_string_of_jsbytes("saddlebrown"),
         caml_string_of_jsbytes("salmon"),
         caml_string_of_jsbytes("sandybrown"),
         caml_string_of_jsbytes("seagreen"),
         caml_string_of_jsbytes("seashell"),
         caml_string_of_jsbytes("sienna"),
         caml_string_of_jsbytes("silver"),
         caml_string_of_jsbytes("skyblue"),
         caml_string_of_jsbytes("slateblue"),
         caml_string_of_jsbytes("slategray"),
         caml_string_of_jsbytes("slategrey"),
         caml_string_of_jsbytes("snow"),
         caml_string_of_jsbytes("springgreen"),
         caml_string_of_jsbytes("steelblue"),
         caml_string_of_jsbytes("tan"),
         caml_string_of_jsbytes("teal"),
         caml_string_of_jsbytes("thistle"),
         caml_string_of_jsbytes("tomato"),
         caml_string_of_jsbytes("turquoise"),
         caml_string_of_jsbytes("violet"),
         caml_string_of_jsbytes("wheat"),
         caml_string_of_jsbytes("white"),
         caml_string_of_jsbytes("whitesmoke"),
         caml_string_of_jsbytes("yellow"),
         caml_string_of_jsbytes("yellowgreen")]),
     _b5_=
      [0,
       [12,35,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,0]]]],
       caml_string_of_jsbytes("#%02X%02X%02X")],
     _bZ_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,0,0,0,[12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,41,0]]]]]]],
       caml_string_of_jsbytes("rgb(%d,%d,%d)")],
     _b0_=
      [0,
       [11,
        caml_string_of_jsbytes("rgb("),
        [4,
         0,
         0,
         0,
         [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]]],
       caml_string_of_jsbytes("rgb(%d%%,%d%%,%d%%)")],
     _b1_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,44,[8,[0,0,0],0,0,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d,%d,%d,%f)")],
     _b2_=
      [0,
       [11,
        caml_string_of_jsbytes("rgba("),
        [4,
         0,
         0,
         0,
         [12,
          37,
          [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,44,partial]]]]]]]]]],
       caml_string_of_jsbytes("rgba(%d%%,%d%%,%d%%,%f)")],
     _b3_=
      [0,
       [11,
        caml_string_of_jsbytes("hsl("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]],
       caml_string_of_jsbytes("hsl(%d,%d%%,%d%%)")],
     _b4_=
      [0,
       [11,
        caml_string_of_jsbytes("hsla("),
        [4,
         0,
         0,
         0,
         [12,
          44,
          [4,
           0,
           0,
           0,
           [12,
            37,
            [12,44,[4,0,0,0,[12,37,[12,44,[8,partial$1,0,0,partial$0]]]]]]]]]],
       caml_string_of_jsbytes("hsla(%d,%d%%,%d%%,%f)")],
     _w_=[0,240,248,255],
     _x_=[0,250,235,215],
     _y_=[0,0,255,255],
     _z_=[0,127,255,212],
     _A_=[0,240,255,255],
     _B_=[0,245,245,220],
     _C_=[0,255,228,196],
     _D_=[0,0,0,0],
     _E_=[0,255,235,205],
     _F_=[0,0,0,255],
     _G_=[0,138,43,226],
     _H_=[0,165,42,42],
     _I_=[0,222,184,135],
     _J_=[0,95,158,160],
     _K_=[0,127,255,0],
     _L_=[0,210,105,30],
     _M_=[0,255,127,80],
     _N_=[0,100,149,237],
     _O_=[0,255,248,220],
     _P_=[0,220,20,60],
     _Q_=[0,0,255,255],
     _R_=[0,0,0,139],
     _S_=[0,0,139,139],
     _T_=[0,184,134,11],
     _U_=[0,169,169,169],
     _V_=[0,0,100,0],
     _W_=[0,169,169,169],
     _X_=[0,189,183,107],
     _Y_=[0,139,0,139],
     _Z_=[0,85,107,47],
     ___=[0,255,140,0],
     _$_=[0,153,50,204],
     _aa_=[0,139,0,0],
     _ab_=[0,233,150,122],
     _ac_=[0,143,188,143],
     _ad_=[0,72,61,139],
     _ae_=[0,47,79,79],
     _af_=[0,47,79,79],
     _ag_=[0,0,206,209],
     _ah_=[0,148,0,211],
     _ai_=[0,255,20,147],
     _aj_=[0,0,191,255],
     _ak_=[0,105,105,105],
     _al_=[0,105,105,105],
     _am_=[0,30,144,255],
     _an_=[0,178,34,34],
     _ao_=[0,255,250,240],
     _ap_=[0,34,139,34],
     _aq_=[0,255,0,255],
     _ar_=[0,220,220,220],
     _as_=[0,248,248,255],
     _at_=[0,255,215,0],
     _au_=[0,218,165,32],
     _av_=[0,128,128,128],
     _aw_=[0,128,128,128],
     _ax_=[0,0,128,0],
     _ay_=[0,173,255,47],
     _az_=[0,240,255,240],
     _aA_=[0,255,105,180],
     _aB_=[0,205,92,92],
     _aC_=[0,75,0,130],
     _aD_=[0,255,255,240],
     _aE_=[0,240,230,140],
     _aF_=[0,230,230,250],
     _aG_=[0,255,240,245],
     _aH_=[0,124,252,0],
     _aI_=[0,255,250,205],
     _aJ_=[0,173,216,230],
     _aK_=[0,240,128,128],
     _aL_=[0,224,255,255],
     _aM_=[0,250,250,210],
     _aN_=[0,211,211,211],
     _aO_=[0,144,238,144],
     _aP_=[0,211,211,211],
     _aQ_=[0,255,182,193],
     _aR_=[0,255,160,122],
     _aS_=[0,32,178,170],
     _aT_=[0,135,206,250],
     _aU_=[0,119,136,153],
     _aV_=[0,119,136,153],
     _aW_=[0,176,196,222],
     _aX_=[0,255,255,224],
     _aY_=[0,0,255,0],
     _aZ_=[0,50,205,50],
     _a0_=[0,250,240,230],
     _a1_=[0,255,0,255],
     _a2_=[0,128,0,0],
     _a3_=[0,102,205,170],
     _a4_=[0,0,0,205],
     _a5_=[0,186,85,211],
     _a6_=[0,147,112,219],
     _a7_=[0,60,179,113],
     _a8_=[0,123,104,238],
     _a9_=[0,0,250,154],
     _a__=[0,72,209,204],
     _a$_=[0,199,21,133],
     _ba_=[0,25,25,112],
     _bb_=[0,245,255,250],
     _bc_=[0,255,228,225],
     _bd_=[0,255,228,181],
     _be_=[0,255,222,173],
     _bf_=[0,0,0,128],
     _bg_=[0,253,245,230],
     _bh_=[0,128,128,0],
     _bi_=[0,107,142,35],
     _bj_=[0,255,165,0],
     _bk_=[0,255,69,0],
     _bl_=[0,218,112,214],
     _bm_=[0,238,232,170],
     _bn_=[0,152,251,152],
     _bo_=[0,175,238,238],
     _bp_=[0,219,112,147],
     _bq_=[0,255,239,213],
     _br_=[0,255,218,185],
     _bs_=[0,205,133,63],
     _bt_=[0,255,192,203],
     _bu_=[0,221,160,221],
     _bv_=[0,176,224,230],
     _bw_=[0,128,0,128],
     _bx_=[0,255,0,0],
     _by_=[0,188,143,143],
     _bz_=[0,65,105,225],
     _bA_=[0,139,69,19],
     _bB_=[0,250,128,114],
     _bC_=[0,244,164,96],
     _bD_=[0,46,139,87],
     _bE_=[0,255,245,238],
     _bF_=[0,160,82,45],
     _bG_=[0,192,192,192],
     _bH_=[0,135,206,235],
     _bI_=[0,106,90,205],
     _bJ_=[0,112,128,144],
     _bK_=[0,112,128,144],
     _bL_=[0,255,250,250],
     _bM_=[0,0,255,127],
     _bN_=[0,70,130,180],
     _bO_=[0,210,180,140],
     _bP_=[0,0,128,128],
     _bQ_=[0,216,191,216],
     _bR_=[0,255,99,71],
     _bS_=[0,64,224,208],
     _bT_=[0,238,130,238],
     _bU_=[0,245,222,179],
     _bV_=[0,255,255,255],
     _bW_=[0,245,245,245],
     _bX_=[0,255,255,0],
     _bY_=[0,154,205,50];
    function symbol(x,y){return x < y?1:0}
    function symbol$0(x,y){return x <= y?1:0}
    function symbol$1(x,y){return x !== y?1:0}
    function symbol$2(x,y){return x === y?1:0}
    function symbol$3(x,y){return y < x?1:0}
    function symbol$4(x,y){return y <= x?1:0}
    var compare=runtime.caml_int_compare;
    function equal(x,y){return x === y?1:0}
    function max(x,y){return y <= x?x:y}
    function min(x,y){return x <= y?x:y}
    var
     Int_replace_polymorphic_compar=
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       compare,
       equal,
       max,
       min],
     make=Stdlib_string[1],
     init=Stdlib_string[2],
     concat=Stdlib_string[3],
     compare$0=Stdlib_string[5],
     contains_from=Stdlib_string[6],
     rcontains_from=Stdlib_string[7],
     contains=Stdlib_string[8],
     sub=Stdlib_string[9],
     split_on_char=Stdlib_string[10],
     map=Stdlib_string[11],
     mapi=Stdlib_string[12],
     trim=Stdlib_string[13],
     escaped=Stdlib_string[14],
     uppercase_ascii=Stdlib_string[15],
     lowercase_ascii=Stdlib_string[16],
     capitalize_ascii=Stdlib_string[17],
     uncapitalize_ascii=Stdlib_string[18],
     iter=Stdlib_string[19],
     iteri=Stdlib_string[20],
     index_from=Stdlib_string[21],
     index_from_opt=Stdlib_string[22],
     rindex_from=Stdlib_string[23],
     rindex_from_opt=Stdlib_string[24],
     index=Stdlib_string[25],
     index_opt=Stdlib_string[26],
     rindex=Stdlib_string[27],
     rindex_opt=Stdlib_string[28],
     to_seq=Stdlib_string[29],
     to_seqi=Stdlib_string[30],
     of_seq=Stdlib_string[31],
     blit=Stdlib_string[32],
     copy=Stdlib_string[33],
     fill=Stdlib_string[34],
     uppercase=Stdlib_string[35],
     lowercase=Stdlib_string[36],
     capitalize=Stdlib_string[37],
     uncapitalize=Stdlib_string[38];
    function equal$0(x,y){return runtime.caml_string_equal(x,y)}
    var
     String=
      [0,
       make,
       init,
       concat,
       compare$0,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map,
       mapi,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter,
       iteri,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq,
       to_seqi,
       of_seq,
       blit,
       copy,
       fill,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       equal$0],
     chr=Stdlib_char[1],
     escaped$0=Stdlib_char[2],
     lowercase$0=Stdlib_char[3],
     uppercase$0=Stdlib_char[4],
     lowercase_ascii$0=Stdlib_char[5],
     uppercase_ascii$0=Stdlib_char[6],
     compare$1=Stdlib_char[7];
    function equal$1(x,y){return x === y?1:0}
    var
     Char=
      [0,
       chr,
       escaped$0,
       lowercase$0,
       uppercase$0,
       lowercase_ascii$0,
       uppercase_ascii$0,
       compare$1,
       equal$1],
     symbol$5=Int_replace_polymorphic_compar[1],
     symbol$6=Int_replace_polymorphic_compar[2],
     symbol$7=Int_replace_polymorphic_compar[3],
     symbol$8=Int_replace_polymorphic_compar[4],
     symbol$9=Int_replace_polymorphic_compar[5],
     symbol$10=Int_replace_polymorphic_compar[6],
     compare$2=Int_replace_polymorphic_compar[7],
     equal$2=Int_replace_polymorphic_compar[8],
     max$0=Int_replace_polymorphic_compar[9],
     min$0=Int_replace_polymorphic_compar[10],
     Js_of_ocaml_Import=
      [0,
       Poly,
       Int_replace_polymorphic_compar,
       String,
       Char,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       compare$2,
       equal$2,
       max$0,
       min$0];
    caml_register_global(1635,Js_of_ocaml_Import,"Js_of_ocaml__Import");
    var
     global=joo_global_object,
     Unsafe=[0,global],
     no_handler=null,
     t39=undefined;
    function return$0(_gH_){return _gH_}
    function map$0(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function bind(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function test(x){return 1 - (x == no_handler?1:0)}
    function iter$0(x,f)
     {var _gG_=1 - (x == no_handler?1:0);return _gG_?caml_call1(f,x):_gG_}
    function case$0(x,f,g)
     {return x == no_handler?caml_call1(f,0):caml_call1(g,x)}
    function get(x,f){return x == no_handler?caml_call1(f,0):x}
    function option(x){if(x){var x$0=x[1];return x$0}return no_handler}
    function to_option(x)
     {function _gF_(x){return [0,x]}
      return case$0(x,function(param){return 0},_gF_)}
    var
     Opt=
      [0,
       no_handler,
       return$0,
       map$0,
       bind,
       test,
       iter$0,
       case$0,
       get,
       option,
       to_option];
    function return$1(_gE_){return _gE_}
    function map$1(x,f){return x === t39?t39:caml_call1(f,x)}
    function bind$0(x,f){return x === t39?t39:caml_call1(f,x)}
    function test$0(x){return x !== t39?1:0}
    function iter$1(x,f)
     {var _gD_=x !== t39?1:0;return _gD_?caml_call1(f,x):_gD_}
    function case$1(x,f,g){return x === t39?caml_call1(f,0):caml_call1(g,x)}
    function get$0(x,f){return x === t39?caml_call1(f,0):x}
    function option$0(x){if(x){var x$0=x[1];return x$0}return t39}
    function to_option$0(x)
     {function _gC_(x){return [0,x]}
      return case$1(x,function(param){return 0},_gC_)}
    var
     Optdef=
      [0,
       t39,
       return$1,
       map$1,
       bind$0,
       test$0,
       iter$1,
       case$1,
       get$0,
       option$0,
       to_option$0];
    function coerce(x,f,g)
     {function _gA_(param){return caml_call1(g,x)}
      var _gB_=caml_call1(f,x);
      return caml_call2(Opt[8],_gB_,_gA_)}
    function coerce_opt(x,f,g)
     {function _gy_(param){return caml_call1(g,x)}
      var _gz_=caml_call2(Opt[4],x,f);
      return caml_call2(Opt[8],_gz_,_gy_)}
    var
     t25=true,
     t4=false,
     string_constr=Unsafe[1].String,
     t11=Unsafe[1].RegExp,
     t4$0=Unsafe[1].Object;
    function object_keys(t3){return t4$0.keys(t3)}
    var
     array_length=Unsafe[1].Array,
     array_get=caml_js_get,
     array_set=caml_js_set;
    function array_map(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call1(f,x)}))}
    function array_mapi(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call2(f,idx,x)}))}
    function str_array(_gx_){return _gx_}
    function match_result(_gw_){return _gw_}
    var
     t121=Unsafe[1].Date,
     math=Unsafe[1].Math,
     Error=[248,cst_Js_of_ocaml_Js_Error,caml_fresh_oo_id(0)],
     error_constr=Unsafe[1].Error;
    caml_call2(Stdlib_callback[2],cst_jsError,[0,Error,{}]);
    function raise_js_error(exn){throw exn}
    var JSON=Unsafe[1].JSON;
    function decodeURI(s){return Unsafe[1].decodeURI(s)}
    function decodeURIComponent(s){return Unsafe[1].decodeURIComponent(s)}
    function encodeURI(s){return Unsafe[1].encodeURI(s)}
    function encodeURIComponent(s){return Unsafe[1].encodeURIComponent(s)}
    function escape(s){return Unsafe[1].escape(s)}
    function unescape(s){return Unsafe[1].unescape(s)}
    function isNaN(i){return Unsafe[1].isNaN(i) | 0}
    function parseInt(s)
     {var s$0=Unsafe[1].parseInt(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseInt):s$0}
    function parseFloat(s)
     {var s$0=Unsafe[1].parseFloat(s);
      return isNaN(s$0)?caml_call1(Stdlib[2],cst_parseFloat):s$0}
    function _a_(param)
     {if(param[1] === Error)
       {var e=param[2];return [0,caml_string_of_jsstring(e.toString())]}
      return 0}
    caml_call1(Stdlib_printexc[9],_a_);
    function _b_(e)
     {return e instanceof array_length
              ?0
              :[0,caml_string_of_jsstring(e.toString())]}
    caml_call1(Stdlib_printexc[9],_b_);
    function string_of_error(e){return caml_string_of_jsstring(e.toString())}
    function export_js(field,x)
     {return runtime.caml_js_export_var(0)[field] = x}
    function export$0(field,x)
     {return export_js(caml_jsstring_of_string(field),x)}
    function export_all(obj)
     {var
       t25=object_keys(obj),
       t24=
        caml_js_wrap_callback
         (function(key,param,_gv_){return export_js(key,obj[key])});
      return t25.forEach(t24)}
    var _c_=runtime.caml_js_error_of_exception,_d_=caml_exn_with_js_backtrace;
    function _e_(_gu_){return _gu_}
    var
     Js_of_ocaml_Js=
      [0,
       no_handler,
       function(_gt_){return _gt_},
       t39,
       _e_,
       Opt,
       Optdef,
       t25,
       t4,
       string_constr,
       t11,
       t11,
       t11,
       object_keys,
       array_length,
       array_length,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       t121,
       math,
       error_constr,
       string_of_error,
       raise_js_error,
       _d_,
       _c_,
       Error,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe];
    caml_register_global(1639,Js_of_ocaml_Js,"Js_of_ocaml__Js");
    function list_of_nodeList(nodeList)
     {var length=nodeList.length,acc=0,i=0;
      for(;;)
       {if(caml_call2(symbol$5,i,length))
         {var _gs_=nodeList.item(i),match=caml_call1(Opt[10],_gs_);
          if(match)
           {var e=match[1],i$0=i + 1 | 0,acc$0=[0,e,acc],acc=acc$0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}
        return caml_call1(Stdlib_list[9],acc)}}
    var
     disconnected=1,
     preceding=2,
     following=4,
     contains$0=8,
     contained_by=16,
     implementation_specific=32;
    function has(t,mask){return caml_call2(symbol$8,t & mask,mask)}
    function add(x,y){return x | y}
    var
     DocumentPosition=
      [0,
       disconnected,
       preceding,
       following,
       contains$0,
       contained_by,
       implementation_specific,
       has,
       add,
       add];
    function appendChild(p,n){p.appendChild(n);return 0}
    function removeChild(p,n){p.removeChild(n);return 0}
    function replaceChild(p,n,o){p.replaceChild(n,o);return 0}
    function insertBefore(p,n,o){p.insertBefore(n,o);return 0}
    function nodeType(e)
     {var match=e.nodeType;
      if(match)
       {var switcher=match - 1 | 0;
        switch(switcher)
         {case 0:return [0,e];case 1:return [1,e];case 2:case 3:return [2,e]}}
      return [3,e]}
    function cast(e,t){return e.nodeType === t?e:no_handler}
    function element(e){return cast(e,1)}
    function text(e)
     {if(3 !== e.nodeType && 4 !== e.nodeType)return no_handler;return e}
    function attr(e){return cast(e,2)}
    function handler(f)
     {return function(e)
       {if(caml_call1(Opt[5],e))
         {var res=caml_call1(f,e);
          if(1 - (res | 0))e.preventDefault();
          return res}
        var e$0=event,res$0=caml_call1(f,e$0);
        if(1 - (res$0 | 0))e$0.returnValue = res$0;
        return res$0}}
    function full_handler(f)
     {return runtime.caml_js_wrap_meth_callback_unsafe
              (function(this$0,e)
                {if(caml_call1(Opt[5],e))
                  {var res=caml_call2(f,this$0,e);
                   if(1 - (res | 0))e.preventDefault();
                   return res}
                 var e$0=event,res$0=caml_call2(f,this$0,e$0);
                 if(1 - (res$0 | 0))e$0.returnValue = res$0;
                 return res$0})}
    function invoke_handler(f,this$0,event){return f.call(this$0,event)}
    function eventTarget(e)
     {function _gp_(param)
       {function _gr_(param){throw Stdlib[8]}
        return caml_call2(Opt[8],e.srcElement,_gr_)}
      var target=caml_call2(Opt[8],e.target,_gp_);
      if(target instanceof Unsafe[1].Node)
       {if(3 === target.nodeType)
         {var _gq_=function(param){throw [0,Assert_failure,_f_]};
          return caml_call2(Opt[8],target.parentNode,_gq_)}
        return target}
      return target}
    function make$0(s){return caml_jsstring_of_string(s)}
    var Event=[0,make$0];
    function addEventListenerWithOptions(t50,t47,capture,once,passive,t48)
     {if(t50.addEventListener === t39)
       {var
         t34="on".concat(t47),
         t35=
          function(e)
           {var _gm_=[0,t48,e,[0]];
            return function(_gn_,_go_)
             {return runtime.caml_js_call(_gm_,_gn_,_go_)}};
        t50.attachEvent(t34,t35);
        return function(param){return t50.detachEvent(t34,t35)}}
      var t49={};
      function iter(t,f){if(t){var b=t[1];return caml_call1(f,b)}return 0}
      iter(capture,function(b){return t49.capture = b});
      iter(once,function(b){return t49.once = b});
      iter(passive,function(b){return t49.passive = b});
      t50.addEventListener(t47,t48,t49);
      return function(param){return t50.removeEventListener(t47,t48,t49)}}
    function addEventListener(e,typ,h,capt)
     {return addEventListenerWithOptions(e,typ,[0,capt],0,0,h)}
    function removeEventListener(id){return caml_call1(id,0)}
    function preventDefault(ev)
     {return caml_call1(Optdef[5],ev.preventDefault)
              ?ev.preventDefault()
              :ev.returnValue = ! ! 0}
    function createCustomEvent(bubbles,cancelable,detail,t62)
     {function opt_iter(f,param)
       {if(param){var x=param[1];return caml_call1(f,x)}return 0}
      var t63={};
      opt_iter(function(x){return t63.bubbles = ! ! x},bubbles);
      opt_iter(function(x){return t63.cancelable = ! ! x},cancelable);
      opt_iter(function(x){return t63.detail = x},detail);
      var t64=Unsafe[1].CustomEvent;
      return new t64(t62,t63)}
    var
     Js_of_ocaml_Dom=
      [0,
       DocumentPosition,
       insertBefore,
       replaceChild,
       removeChild,
       appendChild,
       list_of_nodeList,
       nodeType,
       [0,element,text,attr],
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       Event,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       preventDefault,
       createCustomEvent];
    caml_register_global(1642,Js_of_ocaml_Dom,"Js_of_ocaml__Dom");
    var
     arrayBuffer=Unsafe[1].ArrayBuffer,
     int8Array_inBuffer=Unsafe[1].Int8Array,
     t11$0=Unsafe[1].Uint8Array,
     int16Array_inBuffer=Unsafe[1].Int16Array,
     uint16Array_inBuffer=Unsafe[1].Uint16Array,
     int32Array_inBuffer=Unsafe[1].Int32Array,
     uint32Array_inBuffer=Unsafe[1].Uint32Array,
     float32Array_inBuffer=Unsafe[1].Float32Array,
     float64Array_inBuffer=Unsafe[1].Float64Array,
     set=caml_js_set;
    function get$1(a,i){return a[i]}
    function unsafe_get(a,i){return a[i]}
    var dataView=Unsafe[1].DataView;
    function of_arrayBuffer(ab)
     {var uint8=new t11$0(ab);return caml_string_of_array(uint8)}
    var
     Js_of_ocaml_Typed_array=
      [0,
       arrayBuffer,
       runtime.caml_ba_kind_of_typed_array,
       runtime.caml_ba_to_typed_array,
       runtime.caml_ba_from_typed_array,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       t11$0,
       t11$0,
       t11$0,
       t11$0,
       t11$0,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       set,
       get$1,
       unsafe_get,
       dataView,
       dataView,
       [0,
        runtime.bigstring_to_array_buffer,
        runtime.bigstring_to_typed_array,
        runtime.bigstring_of_array_buffer,
        runtime.bigstring_of_typed_array],
       [0,of_arrayBuffer,caml_string_of_array]];
    caml_register_global
     (1643,Js_of_ocaml_Typed_array,"Js_of_ocaml__Typed_array");
    var t3=Unsafe[1].Blob;
    function filter_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function blob_raw(contentType,endings,a)
     {var _gi_=0;
      if(endings)
       var _gj_=116179762 <= endings[1]?_g_:_h_,_gk_=_gj_;
      else
       var _gk_=0;
      var
       _gl_=[0,[0,cst_type,contentType],[0,[0,cst_endings,_gk_],_gi_]],
       options=
        filter_map
         (function(param)
           {var v=param[2],name=param[1];
            if(v)
             {var v$0=v[1];return [0,[0,name,caml_jsstring_of_string(v$0)]]}
            return 0},
          _gl_),
       options$0=
        options
         ?runtime.caml_js_object(caml_call1(Stdlib_array[12],options))
         :t39,
       t1=caml_js_from_array(a);
      return new t3(t1,options$0)}
    function blob_from_string(contentType,endings,s)
     {return blob_raw(contentType,endings,[0,caml_jsstring_of_string(s)])}
    function blob_from_any(contentType,endings,l)
     {function _gg_(param)
       {var _gh_=param[1];
        if(155580615 === _gh_){var s=param[2];return s}
        if(486041214 <= _gh_)
         {if(1037850489 <= _gh_){var a=param[2];return a}
          var a$0=param[2];
          return a$0}
        if(288368849 <= _gh_)
         {var s$0=param[2];return caml_jsstring_of_string(s$0)}
        var b=param[2];
        return b}
      var l$0=caml_call2(Stdlib_list[19],_gg_,l);
      return blob_raw(contentType,endings,caml_call1(Stdlib_array[12],l$0))}
    function filename(file)
     {var match=caml_call1(Optdef[10],file.name);
      if(match){var name=match[1];return name}
      var match$0=caml_call1(Optdef[10],file.fileName);
      if(match$0){var name$0=match$0[1];return name$0}
      return caml_call1(Stdlib[2],cst_can_t_retrieve_file_name_n)}
    var doc_constr=Unsafe[1].Document;
    function document(e){return e instanceof doc_constr?e:no_handler}
    function blob(e){return e instanceof t3?e:no_handler}
    function string(e){return typeof e === "string"?e:no_handler}
    function arrayBuffer$0(e){return e instanceof arrayBuffer?e:no_handler}
    var
     loadstart=caml_call1(Event[1],cst_loadstart),
     progress=caml_call1(Event[1],cst_progress),
     abort=caml_call1(Event[1],cst_abort),
     error=caml_call1(Event[1],cst_error),
     load=caml_call1(Event[1],cst_load),
     loadend=caml_call1(Event[1],cst_loadend),
     ReaderEvent=[0,loadstart,progress,abort,error,load,loadend],
     fileReader=Unsafe[1].FileReader,
     Js_of_ocaml_File=
      [0,
       blob_from_string,
       blob_from_any,
       [0,document,blob,function(_gf_){return _gf_},string,arrayBuffer$0],
       ReaderEvent,
       filename,
       fileReader,
       addEventListener];
    caml_register_global(1645,Js_of_ocaml_File,"Js_of_ocaml__File");
    var
     onIE=runtime.caml_js_on_ie(0) | 0,
     click=caml_call1(Event[1],cst_click),
     copy$0=caml_call1(Event[1],cst_copy),
     cut=caml_call1(Event[1],cst_cut),
     paste=caml_call1(Event[1],cst_paste),
     dblclick=caml_call1(Event[1],cst_dblclick),
     mousedown=caml_call1(Event[1],cst_mousedown),
     mouseup=caml_call1(Event[1],cst_mouseup),
     mouseover=caml_call1(Event[1],cst_mouseover),
     mousemove=caml_call1(Event[1],cst_mousemove),
     mouseout=caml_call1(Event[1],cst_mouseout),
     keypress=caml_call1(Event[1],cst_keypress),
     keydown=caml_call1(Event[1],cst_keydown),
     keyup=caml_call1(Event[1],cst_keyup),
     mousewheel=caml_call1(Event[1],cst_mousewheel),
     DOMMouseScroll=caml_call1(Event[1],cst_DOMMouseScroll),
     touchstart=caml_call1(Event[1],cst_touchstart),
     touchmove=caml_call1(Event[1],cst_touchmove),
     touchend=caml_call1(Event[1],cst_touchend),
     touchcancel=caml_call1(Event[1],cst_touchcancel),
     dragstart=caml_call1(Event[1],cst_dragstart),
     dragend=caml_call1(Event[1],cst_dragend),
     dragenter=caml_call1(Event[1],cst_dragenter),
     dragover=caml_call1(Event[1],cst_dragover),
     dragleave=caml_call1(Event[1],cst_dragleave),
     drag=caml_call1(Event[1],cst_drag),
     drop=caml_call1(Event[1],cst_drop),
     hashchange=caml_call1(Event[1],cst_hashchange),
     change=caml_call1(Event[1],cst_change),
     input=caml_call1(Event[1],cst_input),
     timeupdate=caml_call1(Event[1],cst_timeupdate),
     submit=caml_call1(Event[1],cst_submit),
     scroll=caml_call1(Event[1],cst_scroll),
     focus=caml_call1(Event[1],cst_focus),
     blur=caml_call1(Event[1],cst_blur),
     load$0=caml_call1(Event[1],cst_load$0),
     unload=caml_call1(Event[1],cst_unload),
     beforeunload=caml_call1(Event[1],cst_beforeunload),
     resize=caml_call1(Event[1],cst_resize),
     orientationchange=caml_call1(Event[1],cst_orientationchange),
     popstate=caml_call1(Event[1],cst_popstate),
     error$0=caml_call1(Event[1],cst_error$0),
     abort$0=caml_call1(Event[1],cst_abort$0),
     select=caml_call1(Event[1],cst_select),
     online=caml_call1(Event[1],cst_online),
     offline=caml_call1(Event[1],cst_offline),
     checking=caml_call1(Event[1],cst_checking),
     noupdate=caml_call1(Event[1],cst_noupdate),
     downloading=caml_call1(Event[1],cst_downloading),
     progress$0=caml_call1(Event[1],cst_progress$0),
     updateready=caml_call1(Event[1],cst_updateready),
     cached=caml_call1(Event[1],cst_cached),
     obsolete=caml_call1(Event[1],cst_obsolete),
     domContentLoaded=caml_call1(Event[1],cst_DOMContentLoaded),
     animationstart=caml_call1(Event[1],cst_animationstart),
     animationend=caml_call1(Event[1],cst_animationend),
     animationiteration=caml_call1(Event[1],cst_animationiteration),
     animationcancel=caml_call1(Event[1],cst_animationcancel),
     canplay=caml_call1(Event[1],cst_canplay),
     canplaythrough=caml_call1(Event[1],cst_canplaythrough),
     durationchange=caml_call1(Event[1],cst_durationchange),
     emptied=caml_call1(Event[1],cst_emptied),
     ended=caml_call1(Event[1],cst_ended),
     gotpointercapture=caml_call1(Event[1],cst_gotpointercapture),
     loadeddata=caml_call1(Event[1],cst_loadeddata),
     loadedmetadata=caml_call1(Event[1],cst_loadedmetadata),
     loadstart$0=caml_call1(Event[1],cst_loadstart$0),
     lostpointercapture=caml_call1(Event[1],cst_lostpointercapture),
     pause=caml_call1(Event[1],cst_pause),
     play=caml_call1(Event[1],cst_play),
     playing=caml_call1(Event[1],cst_playing),
     pointerenter=caml_call1(Event[1],cst_pointerenter),
     pointercancel=caml_call1(Event[1],cst_pointercancel),
     pointerdown=caml_call1(Event[1],cst_pointerdown),
     pointerleave=caml_call1(Event[1],cst_pointerleave),
     pointermove=caml_call1(Event[1],cst_pointermove),
     pointerout=caml_call1(Event[1],cst_pointerout),
     pointerover=caml_call1(Event[1],cst_pointerover),
     pointerup=caml_call1(Event[1],cst_pointerup),
     ratechange=caml_call1(Event[1],cst_ratechange),
     seeked=caml_call1(Event[1],cst_seeked),
     seeking=caml_call1(Event[1],cst_seeking),
     stalled=caml_call1(Event[1],cst_stalled),
     suspend=caml_call1(Event[1],cst_suspend),
     volumechange=caml_call1(Event[1],cst_volumechange),
     waiting=caml_call1(Event[1],cst_waiting),
     make$1=Event[1],
     Event$0=
      [0,
       click,
       copy$0,
       cut,
       paste,
       dblclick,
       mousedown,
       mouseup,
       mouseover,
       mousemove,
       mouseout,
       keypress,
       keydown,
       keyup,
       mousewheel,
       DOMMouseScroll,
       touchstart,
       touchmove,
       touchend,
       touchcancel,
       dragstart,
       dragend,
       dragenter,
       dragover,
       dragleave,
       drag,
       drop,
       hashchange,
       change,
       input,
       timeupdate,
       submit,
       scroll,
       focus,
       blur,
       load$0,
       unload,
       beforeunload,
       resize,
       orientationchange,
       popstate,
       error$0,
       abort$0,
       select,
       online,
       offline,
       checking,
       noupdate,
       downloading,
       progress$0,
       updateready,
       cached,
       obsolete,
       domContentLoaded,
       animationstart,
       animationend,
       animationiteration,
       animationcancel,
       canplay,
       canplaythrough,
       durationchange,
       emptied,
       ended,
       gotpointercapture,
       loadeddata,
       loadedmetadata,
       loadstart$0,
       lostpointercapture,
       pause,
       play,
       playing,
       pointerenter,
       pointercancel,
       pointerdown,
       pointerleave,
       pointermove,
       pointerout,
       pointerover,
       pointerup,
       ratechange,
       seeked,
       seeking,
       stalled,
       suspend,
       volumechange,
       waiting,
       make$1],
     d="2d";
    function location_origin(loc)
     {function _gd_(o){return o}
      function _ge_(param)
       {var t8=loc.protocol,t7=loc.hostname,port=loc.port;
        if
         (caml_call2(symbol$8,t8.length,0)
          &&
          caml_call2(symbol$8,t7.length,0))
         return "";
        var t13=t8.concat("//",t7);
        if(caml_call2(symbol$9,port.length,0))
         {var t12=loc.port;return t13.concat(":",t12)}
        return t13}
      return caml_call3(Optdef[7],loc.origin,_ge_,_gd_)}
    var _i_=Unsafe[1],t22=_i_.document;
    function getElementById(id)
     {function _ga_(pnode){return pnode}
      function _gb_(param){throw Stdlib[8]}
      var t15=caml_jsstring_of_string(id),_gc_=t22.getElementById(t15);
      return caml_call3(Opt[7],_gc_,_gb_,_ga_)}
    function getElementById_exn(id)
     {function _f8_(pnode){return pnode}
      function _f9_(param)
       {var _f$_=caml_call2(Stdlib_printf[4],_j_,id);
        return caml_call1(Stdlib[2],_f$_)}
      var t17=caml_jsstring_of_string(id),_f__=t22.getElementById(t17);
      return caml_call3(Opt[7],_f__,_f9_,_f8_)}
    function getElementById_opt(id)
     {var t19=caml_jsstring_of_string(id),_f7_=t22.getElementById(t19);
      return caml_call1(Opt[10],_f7_)}
    function getElementById_coerce(id,coerce)
     {function _f3_(e)
       {var _f6_=caml_call1(coerce,e);return caml_call1(Opt[10],_f6_)}
      function _f4_(param){return 0}
      var t21=caml_jsstring_of_string(id),_f5_=t22.getElementById(t21);
      return caml_call3(Opt[7],_f5_,_f4_,_f3_)}
    function opt_iter(x,f){if(x){var v=x[1];return caml_call1(f,v)}return 0}
    function createElement(t24,name)
     {var t23=caml_jsstring_of_string(name);return t24.createElement(t23)}
    function unsafeCreateElement(doc,name){return createElement(doc,name)}
    var createElementSyntax=[0,785140586];
    function unsafeCreateElementEx(type,name,doc,elt)
     {for(;;)
       {if(0 === type && 0 === name)return createElement(doc,elt);
        var _fX_=createElementSyntax[1];
        if(785140586 === _fX_)
         {try
           {var
             el=t22.createElement('<input name="x">'),
             _f0_=el.tagName.toLowerCase() === "input"?1:0,
             _f1_=_f0_?el.name === "x"?1:0:_f0_,
             _fY_=_f1_}
          catch(_f2_){var _fY_=0}
          var _fZ_=_fY_?982028505:-1003883683;
          createElementSyntax[1] = _fZ_;
          continue}
        if(982028505 <= _fX_)
         {var t40=new array_length();
          t40.push("<",caml_jsstring_of_string(elt));
          opt_iter
           (type,
            function(t)
             {var t34=caml_js_html_escape(t);
              t40.push(' type="',t34,'"');
              return 0});
          opt_iter
           (name,
            function(n)
             {var t38=caml_js_html_escape(n);
              t40.push(' name="',t38,'"');
              return 0});
          t40.push(">");
          return doc.createElement(t40.join(""))}
        var res=createElement(doc,elt);
        opt_iter(type,function(t){return res.type = t});
        opt_iter(name,function(n){return res.name = n});
        return res}}
    function createHtml(doc){return unsafeCreateElement(doc,cst_html)}
    function createHead(doc){return unsafeCreateElement(doc,cst_head)}
    function createLink(doc){return unsafeCreateElement(doc,cst_link)}
    function createTitle(doc){return unsafeCreateElement(doc,cst_title)}
    function createMeta(doc){return unsafeCreateElement(doc,cst_meta)}
    function createBase(doc){return unsafeCreateElement(doc,cst_base)}
    function createStyle(doc){return unsafeCreateElement(doc,cst_style)}
    function createBody(doc){return unsafeCreateElement(doc,cst_body)}
    function createForm(doc){return unsafeCreateElement(doc,cst_form)}
    function createOptgroup(doc){return unsafeCreateElement(doc,cst_optgroup)}
    function createOption(doc){return unsafeCreateElement(doc,cst_option)}
    function createSelect(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_select$0)}
    function createInput(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_input$0)}
    function createTextarea(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_textarea)}
    function createButton(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_button)}
    function createLabel(doc){return unsafeCreateElement(doc,cst_label)}
    function createFieldset(doc){return unsafeCreateElement(doc,cst_fieldset)}
    function createLegend(doc){return unsafeCreateElement(doc,cst_legend)}
    function createUl(doc){return unsafeCreateElement(doc,cst_ul)}
    function createOl(doc){return unsafeCreateElement(doc,cst_ol)}
    function createDl(doc){return unsafeCreateElement(doc,cst_dl)}
    function createLi(doc){return unsafeCreateElement(doc,cst_li)}
    function createDiv(doc){return unsafeCreateElement(doc,cst_div)}
    function createEmbed(doc){return unsafeCreateElement(doc,cst_embed)}
    function createP(doc){return unsafeCreateElement(doc,cst_p)}
    function createH1(doc){return unsafeCreateElement(doc,cst_h1)}
    function createH2(doc){return unsafeCreateElement(doc,cst_h2)}
    function createH3(doc){return unsafeCreateElement(doc,cst_h3)}
    function createH4(doc){return unsafeCreateElement(doc,cst_h4)}
    function createH5(doc){return unsafeCreateElement(doc,cst_h5)}
    function createH6(doc){return unsafeCreateElement(doc,cst_h6)}
    function createQ(doc){return unsafeCreateElement(doc,cst_q)}
    function createBlockquote(doc)
     {return unsafeCreateElement(doc,cst_blockquote)}
    function createPre(doc){return unsafeCreateElement(doc,cst_pre)}
    function createBr(doc){return unsafeCreateElement(doc,cst_br)}
    function createHr(doc){return unsafeCreateElement(doc,cst_hr)}
    function createIns(doc){return unsafeCreateElement(doc,cst_ins)}
    function createDel(doc){return unsafeCreateElement(doc,cst_del)}
    function createA(doc){return unsafeCreateElement(doc,cst_a)}
    function createImg(doc){return unsafeCreateElement(doc,cst_img)}
    function createObject(doc){return unsafeCreateElement(doc,cst_object)}
    function createParam(doc){return unsafeCreateElement(doc,cst_param)}
    function createMap(doc){return unsafeCreateElement(doc,cst_map)}
    function createArea(doc){return unsafeCreateElement(doc,cst_area)}
    function createScript(doc){return unsafeCreateElement(doc,cst_script)}
    function createTable(doc){return unsafeCreateElement(doc,cst_table)}
    function createCaption(doc){return unsafeCreateElement(doc,cst_caption)}
    function createCol(doc){return unsafeCreateElement(doc,cst_col)}
    function createColgroup(doc){return unsafeCreateElement(doc,cst_colgroup)}
    function createThead(doc){return unsafeCreateElement(doc,cst_thead)}
    function createTfoot(doc){return unsafeCreateElement(doc,cst_tfoot)}
    function createTbody(doc){return unsafeCreateElement(doc,cst_tbody)}
    function createTr(doc){return unsafeCreateElement(doc,cst_tr)}
    function createTh(doc){return unsafeCreateElement(doc,cst_th)}
    function createTd(doc){return unsafeCreateElement(doc,cst_td)}
    function createSub(doc){return createElement(doc,cst_sub)}
    function createSup(doc){return createElement(doc,cst_sup)}
    function createSpan(doc){return createElement(doc,cst_span)}
    function createTt(doc){return createElement(doc,cst_tt)}
    function createI(doc){return createElement(doc,cst_i)}
    function createB(doc){return createElement(doc,cst_b)}
    function createBig(doc){return createElement(doc,cst_big)}
    function createSmall(doc){return createElement(doc,cst_small)}
    function createEm(doc){return createElement(doc,cst_em)}
    function createStrong(doc){return createElement(doc,cst_strong)}
    function createCite(doc){return createElement(doc,cst_cite)}
    function createDfn(doc){return createElement(doc,cst_dfn)}
    function createCode(doc){return createElement(doc,cst_code)}
    function createSamp(doc){return createElement(doc,cst_samp)}
    function createKbd(doc){return createElement(doc,cst_kbd)}
    function createVar(doc){return createElement(doc,cst_var)}
    function createAbbr(doc){return createElement(doc,cst_abbr)}
    function createDd(doc){return createElement(doc,cst_dd)}
    function createDt(doc){return createElement(doc,cst_dt)}
    function createNoscript(doc){return createElement(doc,cst_noscript)}
    function createAddress(doc){return createElement(doc,cst_address)}
    function createFrameset(doc){return unsafeCreateElement(doc,cst_frameset)}
    function createFrame(doc){return unsafeCreateElement(doc,cst_frame)}
    function createIframe(doc){return unsafeCreateElement(doc,cst_iframe)}
    function createAudio(doc){return unsafeCreateElement(doc,cst_audio)}
    function createVideo(doc){return unsafeCreateElement(doc,cst_video)}
    var
     Canvas_not_available=
      [248,cst_Js_of_ocaml_Dom_html_Canva,caml_fresh_oo_id(0)];
    function createCanvas(doc)
     {var c=unsafeCreateElement(doc,cst_canvas);
      if(1 - caml_call1(Opt[5],c.getContext))throw Canvas_not_available;
      return c}
    var
     html_element=Unsafe[1].HTMLElement,
     element$0=
      html_element === t39
       ?function(e){return e.innerHTML === t39?no_handler:e}
       :function(e){return e instanceof html_element?e:no_handler};
    function unsafeCoerce(tag,e)
     {var t56=e.tagName,_fW_=caml_jsstring_of_string(tag);
      return t56.toLowerCase() === _fW_?e:no_handler}
    function a(e){return unsafeCoerce(cst_a$0,e)}
    function area(e){return unsafeCoerce(cst_area$0,e)}
    function base(e){return unsafeCoerce(cst_base$0,e)}
    function blockquote(e){return unsafeCoerce(cst_blockquote$0,e)}
    function body(e){return unsafeCoerce(cst_body$0,e)}
    function br(e){return unsafeCoerce(cst_br$0,e)}
    function button(e){return unsafeCoerce(cst_button$0,e)}
    function canvas(e){return unsafeCoerce(cst_canvas$0,e)}
    function caption(e){return unsafeCoerce(cst_caption$0,e)}
    function col(e){return unsafeCoerce(cst_col$0,e)}
    function colgroup(e){return unsafeCoerce(cst_colgroup$0,e)}
    function del(e){return unsafeCoerce(cst_del$0,e)}
    function div(e){return unsafeCoerce(cst_div$0,e)}
    function dl(e){return unsafeCoerce(cst_dl$0,e)}
    function fieldset(e){return unsafeCoerce(cst_fieldset$0,e)}
    function embed(e){return unsafeCoerce(cst_embed$0,e)}
    function form(e){return unsafeCoerce(cst_form$0,e)}
    function frameset(e){return unsafeCoerce(cst_frameset$0,e)}
    function frame(e){return unsafeCoerce(cst_frame$0,e)}
    function h1(e){return unsafeCoerce(cst_h1$0,e)}
    function h2(e){return unsafeCoerce(cst_h2$0,e)}
    function h3(e){return unsafeCoerce(cst_h3$0,e)}
    function h4(e){return unsafeCoerce(cst_h4$0,e)}
    function h5(e){return unsafeCoerce(cst_h5$0,e)}
    function h6(e){return unsafeCoerce(cst_h6$0,e)}
    function head(e){return unsafeCoerce(cst_head$0,e)}
    function hr(e){return unsafeCoerce(cst_hr$0,e)}
    function html(e){return unsafeCoerce(cst_html$0,e)}
    function iframe(e){return unsafeCoerce(cst_iframe$0,e)}
    function img(e){return unsafeCoerce(cst_img$0,e)}
    function input$0(e){return unsafeCoerce(cst_input$1,e)}
    function ins(e){return unsafeCoerce(cst_ins$0,e)}
    function label(e){return unsafeCoerce(cst_label$0,e)}
    function legend(e){return unsafeCoerce(cst_legend$0,e)}
    function li(e){return unsafeCoerce(cst_li$0,e)}
    function link(e){return unsafeCoerce(cst_link$0,e)}
    function map$2(e){return unsafeCoerce(cst_map$0,e)}
    function meta(e){return unsafeCoerce(cst_meta$0,e)}
    function object(e){return unsafeCoerce(cst_object$0,e)}
    function ol(e){return unsafeCoerce(cst_ol$0,e)}
    function optgroup(e){return unsafeCoerce(cst_optgroup$0,e)}
    function option$1(e){return unsafeCoerce(cst_option$0,e)}
    function p(e){return unsafeCoerce(cst_p$0,e)}
    function param(e){return unsafeCoerce(cst_param$0,e)}
    function pre(e){return unsafeCoerce(cst_pre$0,e)}
    function q(e){return unsafeCoerce(cst_q$0,e)}
    function script(e){return unsafeCoerce(cst_script$0,e)}
    function select$0(e){return unsafeCoerce(cst_select$1,e)}
    function style(e){return unsafeCoerce(cst_style$0,e)}
    function table(e){return unsafeCoerce(cst_table$0,e)}
    function tbody(e){return unsafeCoerce(cst_tbody$0,e)}
    function td(e){return unsafeCoerce(cst_td$0,e)}
    function textarea(e){return unsafeCoerce(cst_textarea$0,e)}
    function tfoot(e){return unsafeCoerce(cst_tfoot$0,e)}
    function th(e){return unsafeCoerce(cst_th$0,e)}
    function thead(e){return unsafeCoerce(cst_thead$0,e)}
    function title(e){return unsafeCoerce(cst_title$0,e)}
    function tr(e){return unsafeCoerce(cst_tr$0,e)}
    function ul(e){return unsafeCoerce(cst_ul$0,e)}
    function audio(e){return unsafeCoerce(cst_audio$0,e)}
    function video(e){return unsafeCoerce(cst_video$0,e)}
    function unsafeCoerceEvent(constr,ev)
     {if(constr !== t39 && ev instanceof constr)return ev;return no_handler}
    function mouseEvent(ev){return unsafeCoerceEvent(Unsafe[1].MouseEvent,ev)}
    function keyboardEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].KeyboardEvent,ev)}
    function wheelEvent(ev){return unsafeCoerceEvent(Unsafe[1].WheelEvent,ev)}
    function mouseScrollEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].MouseScrollEvent,ev)}
    function popStateEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].PopStateEvent,ev)}
    function eventRelatedTarget(e)
     {function _fT_(param)
       {var match=caml_string_of_jsstring(e.type);
        if(caml_string_notequal(match,cst_mouseout$0))
         {if(caml_string_notequal(match,cst_mouseover$0))return no_handler;
          var _fU_=function(param){throw [0,Assert_failure,_k_]};
          return caml_call2(Optdef[8],e.fromElement,_fU_)}
        function _fV_(param){throw [0,Assert_failure,_l_]}
        return caml_call2(Optdef[8],e.toElement,_fV_)}
      return caml_call2(Optdef[8],e.relatedTarget,_fT_)}
    function eventAbsolutePosition(e)
     {var body=t22.body,html=t22.documentElement;
      return [0,
              (e.clientX + body.scrollLeft | 0) + html.scrollLeft | 0,
              (e.clientY + body.scrollTop | 0) + html.scrollTop | 0]}
    function eventAbsolutePosition$0(e)
     {function _fP_(x)
       {function _fR_(y){return [0,x,y]}
        function _fS_(param){return eventAbsolutePosition(e)}
        return caml_call3(Optdef[7],e.pageY,_fS_,_fR_)}
      function _fQ_(param){return eventAbsolutePosition(e)}
      return caml_call3(Optdef[7],e.pageX,_fQ_,_fP_)}
    function elementClientPosition(e)
     {var r=e.getBoundingClientRect(),body=t22.body,html=t22.documentElement;
      return [0,
              ((r.left | 0) - body.clientLeft | 0) - html.clientLeft | 0,
              ((r.top | 0) - body.clientTop | 0) - html.clientTop | 0]}
    function getDocumentScroll(param)
     {var body=t22.body,html=t22.documentElement;
      return [0,
              body.scrollLeft + html.scrollLeft | 0,
              body.scrollTop + html.scrollTop | 0]}
    function buttonPressed(ev)
     {function _fN_(x){return x}
      function _fO_(param)
       {var match=ev.button,switcher=match - 1 | 0;
        if(! (3 < switcher >>> 0))
         switch(switcher)
          {case 0:return 1;case 1:return 3;case 2:break;default:return 2}
        return 0}
      return caml_call3(Optdef[7],ev.which,_fO_,_fN_)}
    function addMousewheelEventListenerWith(e,capture,once,passive,h)
     {var t95=createDiv(t22);
      t95.setAttribute("onmousewheel","return;");
      if(typeof t95.onmousewheel === "function")
       {var
         _fJ_=
          handler
           (function(e)
             {function _fL_(param){return 0}
              var
               dx=
                (- caml_call2(Optdef[8],e.wheelDeltaX,_fL_) | 0) / 40 | 0;
              function _fM_(param){return e.wheelDelta}
              var
               dy=
                (- caml_call2(Optdef[8],e.wheelDeltaY,_fM_) | 0) / 40 | 0;
              return caml_call3(h,e,dx,dy)});
        return addEventListenerWithOptions
                (e,Event$0[14],capture,once,passive,_fJ_)}
      var
       _fK_=
        handler
         (function(e)
           {var d=e.detail;
            return e.axis === e.HORIZONTAL
                    ?caml_call3(h,e,d,0)
                    :caml_call3(h,e,0,d)});
      return addEventListenerWithOptions
              (e,Event$0[15],capture,once,passive,_fK_)}
    function addMousewheelEventListener(e,h,capt)
     {return addMousewheelEventListenerWith(e,[0,capt],0,0,h)}
    function f(v)
     {var
       match=caml_string_of_jsstring(v),
       switch$0=caml_string_compare(match,cst_KeyH);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 8;
        var switch$1=caml_string_compare(match,cst_Numpad4);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 72;
          var switch$2=caml_string_compare(match,cst_PageUp);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 98;
            var switch$3=caml_string_compare(match,cst_ShiftRight);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 91;
              if(! caml_string_notequal(match,cst_Slash))return 55;
              if(! caml_string_notequal(match,cst_Space))return 41;
              if(! caml_string_notequal(match,cst_Tab))return 39;
              if(! caml_string_notequal(match,cst_VolumeDown))return 103;
              if(! caml_string_notequal(match,cst_VolumeMute))return 102;
              if(! caml_string_notequal(match,cst_VolumeUp))return 104}
            else
             {if(! caml_string_notequal(match,cst_Pause))return 123;
              if(! caml_string_notequal(match,cst_Period))return 54;
              if(! caml_string_notequal(match,cst_PrintScreen))return 120;
              if(! caml_string_notequal(match,cst_Quote))return 50;
              if(! caml_string_notequal(match,cst_ScrollLock))return 119;
              if(! caml_string_notequal(match,cst_Semicolon))return 49;
              if(! caml_string_notequal(match,cst_ShiftLeft))return 90}}
          else
           {var switch$4=caml_string_compare(match,cst_NumpadDivide);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 84;
              if(! caml_string_notequal(match,cst_NumpadEnter))return 83;
              if(! caml_string_notequal(match,cst_NumpadEqual))return 82;
              if(! caml_string_notequal(match,cst_NumpadMultiply))return 78;
              if(! caml_string_notequal(match,cst_NumpadSubtract))return 79;
              if(! caml_string_notequal(match,cst_OSLeft))return 117;
              if(! caml_string_notequal(match,cst_OSRight))return 118;
              if(! caml_string_notequal(match,cst_PageDown))return 99}
            else
             {if(! caml_string_notequal(match,cst_Numpad5))return 73;
              if(! caml_string_notequal(match,cst_Numpad6))return 74;
              if(! caml_string_notequal(match,cst_Numpad7))return 75;
              if(! caml_string_notequal(match,cst_Numpad8))return 76;
              if(! caml_string_notequal(match,cst_Numpad9))return 77;
              if(! caml_string_notequal(match,cst_NumpadAdd))return 80;
              if(! caml_string_notequal(match,cst_NumpadDecimal))return 81}}}
        else
         {var switch$5=caml_string_compare(match,cst_KeyX);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 24;
            var switch$6=caml_string_compare(match,cst_MetaRight);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 89;
              if(! caml_string_notequal(match,cst_Minus))return 37;
              if(! caml_string_notequal(match,cst_NumLock))return 85;
              if(! caml_string_notequal(match,cst_Numpad0))return 68;
              if(! caml_string_notequal(match,cst_Numpad1))return 69;
              if(! caml_string_notequal(match,cst_Numpad2))return 70;
              if(! caml_string_notequal(match,cst_Numpad3))return 71}
            else
             {if(! caml_string_notequal(match,cst_KeyY))return 25;
              if(! caml_string_notequal(match,cst_KeyZ))return 26;
              if(! caml_string_notequal(match,cst_MediaPlayPause))return 107;
              if(! caml_string_notequal(match,cst_MediaStop))return 108;
              if(! caml_string_notequal(match,cst_MediaTrackNext))return 106;
              if(! caml_string_notequal(match,cst_MediaTrackPrevious))
               return 105;
              if(! caml_string_notequal(match,cst_MetaLeft))return 88}}
          else
           {var switch$7=caml_string_compare(match,cst_KeyP);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 16;
              if(! caml_string_notequal(match,cst_KeyQ))return 17;
              if(! caml_string_notequal(match,cst_KeyR))return 18;
              if(! caml_string_notequal(match,cst_KeyS))return 19;
              if(! caml_string_notequal(match,cst_KeyT))return 20;
              if(! caml_string_notequal(match,cst_KeyU))return 21;
              if(! caml_string_notequal(match,cst_KeyV))return 22;
              if(! caml_string_notequal(match,cst_KeyW))return 23}
            else
             {if(! caml_string_notequal(match,cst_KeyI))return 9;
              if(! caml_string_notequal(match,cst_KeyJ))return 10;
              if(! caml_string_notequal(match,cst_KeyK))return 11;
              if(! caml_string_notequal(match,cst_KeyL))return 12;
              if(! caml_string_notequal(match,cst_KeyM))return 13;
              if(! caml_string_notequal(match,cst_KeyN))return 14;
              if(! caml_string_notequal(match,cst_KeyO))return 15}}}}
      else
       {var switch$8=caml_string_compare(match,cst_Digit6);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 33;
          var switch$9=caml_string_compare(match,cst_F6);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 61;
            var switch$10=caml_string_compare(match,cst_KeyA);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 1;
              if(! caml_string_notequal(match,cst_KeyB))return 2;
              if(! caml_string_notequal(match,cst_KeyC))return 3;
              if(! caml_string_notequal(match,cst_KeyD))return 4;
              if(! caml_string_notequal(match,cst_KeyE))return 5;
              if(! caml_string_notequal(match,cst_KeyF))return 6;
              if(! caml_string_notequal(match,cst_KeyG))return 7}
            else
             {if(! caml_string_notequal(match,cst_F7))return 62;
              if(! caml_string_notequal(match,cst_F8))return 63;
              if(! caml_string_notequal(match,cst_F9))return 64;
              if(! caml_string_notequal(match,cst_Home))return 100;
              if(! caml_string_notequal(match,cst_Insert))return 44;
              if(! caml_string_notequal(match,cst_IntlBackslash))return 121;
              if(! caml_string_notequal(match,cst_IntlYen))return 122}}
          else
           {var switch$11=caml_string_compare(match,cst_F1);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 56;
              if(! caml_string_notequal(match,cst_F10))return 65;
              if(! caml_string_notequal(match,cst_F11))return 66;
              if(! caml_string_notequal(match,cst_F12))return 67;
              if(! caml_string_notequal(match,cst_F2))return 57;
              if(! caml_string_notequal(match,cst_F3))return 58;
              if(! caml_string_notequal(match,cst_F4))return 59;
              if(! caml_string_notequal(match,cst_F5))return 60}
            else
             {if(! caml_string_notequal(match,cst_Digit7))return 34;
              if(! caml_string_notequal(match,cst_Digit8))return 35;
              if(! caml_string_notequal(match,cst_Digit9))return 36;
              if(! caml_string_notequal(match,cst_End))return 101;
              if(! caml_string_notequal(match,cst_Enter))return 40;
              if(! caml_string_notequal(match,cst_Equal))return 38;
              if(! caml_string_notequal(match,cst_Escape))return 42}}}
        else
         {var switch$12=caml_string_compare(match,cst_BrowserRefresh);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 113;
            var switch$13=caml_string_compare(match,cst_Delete);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 45;
              if(! caml_string_notequal(match,cst_Digit0))return 27;
              if(! caml_string_notequal(match,cst_Digit1))return 28;
              if(! caml_string_notequal(match,cst_Digit2))return 29;
              if(! caml_string_notequal(match,cst_Digit3))return 30;
              if(! caml_string_notequal(match,cst_Digit4))return 31;
              if(! caml_string_notequal(match,cst_Digit5))return 32}
            else
             {if(! caml_string_notequal(match,cst_BrowserSearch))return 110;
              if(! caml_string_notequal(match,cst_BrowserStop))return 114;
              if(! caml_string_notequal(match,cst_CapsLock))return 46;
              if(! caml_string_notequal(match,cst_Comma))return 53;
              if(! caml_string_notequal(match,cst_ContextMenu))return 109;
              if(! caml_string_notequal(match,cst_ControlLeft))return 86;
              if(! caml_string_notequal(match,cst_ControlRight))return 87}}
          else
           {var switch$14=caml_string_compare(match,cst_Backslash);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 52;
              if(! caml_string_notequal(match,cst_Backspace))return 43;
              if(! caml_string_notequal(match,cst_BracketLeft))return 47;
              if(! caml_string_notequal(match,cst_BracketRight))return 48;
              if(! caml_string_notequal(match,cst_BrowserBack))return 116;
              if(! caml_string_notequal(match,cst_BrowserFavorites))
               return 112;
              if(! caml_string_notequal(match,cst_BrowserForward))return 115;
              if(! caml_string_notequal(match,cst_BrowserHome))return 111}
            else
             {if(! caml_string_notequal(match,cst_AltLeft))return 92;
              if(! caml_string_notequal(match,cst_AltRight))return 93;
              if(! caml_string_notequal(match,cst_ArrowDown))return 97;
              if(! caml_string_notequal(match,cst_ArrowLeft))return 94;
              if(! caml_string_notequal(match,cst_ArrowRight))return 95;
              if(! caml_string_notequal(match,cst_ArrowUp))return 96;
              if(! caml_string_notequal(match,cst_Backquote))return 51}}}}
      return 0}
    function try_key_code_left(param)
     {if(19 <= param)
       {if(91 === param)return 88}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 90;case 1:return 86;default:return 92}}
      return 0}
    function try_key_code_right(param)
     {if(19 <= param)
       {if(91 === param)return 89}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 91;case 1:return 87;default:return 93}}
      return 0}
    function try_key_code_numpad(param)
     {if(47 <= param)
       {var switcher=param - 96 | 0;
        if(! (15 < switcher >>> 0))
         switch(switcher)
          {case 0:return 68;
           case 1:return 69;
           case 2:return 70;
           case 3:return 71;
           case 4:return 72;
           case 5:return 73;
           case 6:return 74;
           case 7:return 75;
           case 8:return 76;
           case 9:return 77;
           case 10:return 78;
           case 11:return 80;
           case 12:break;
           case 13:return 79;
           case 14:return 81;
           default:return 84}}
      else
       if(12 <= param)
        {var switcher$0=param - 12 | 0;
         switch(switcher$0)
          {case 0:return 73;
           case 1:return 83;
           case 21:return 77;
           case 22:return 71;
           case 23:return 69;
           case 24:return 75;
           case 25:return 72;
           case 26:return 76;
           case 27:return 74;
           case 28:return 70;
           case 33:return 68;
           case 34:return 81
           }}
      return 0}
    function try_key_code_normal(param)
     {var switcher=param - 8 | 0;
      if(! (214 < switcher >>> 0))
       {var _fI_=switcher;
        if(67 <= _fI_)
         switch(_fI_)
          {case 67:return 11;
           case 68:return 12;
           case 69:return 13;
           case 70:return 14;
           case 71:return 15;
           case 72:return 16;
           case 73:return 17;
           case 74:return 18;
           case 75:return 19;
           case 76:return 20;
           case 77:return 21;
           case 78:return 22;
           case 79:return 23;
           case 80:return 24;
           case 81:return 25;
           case 82:return 26;
           case 85:return 109;
           case 104:return 56;
           case 105:return 57;
           case 106:return 58;
           case 107:return 59;
           case 108:return 60;
           case 109:return 61;
           case 110:return 62;
           case 111:return 63;
           case 112:return 64;
           case 113:return 65;
           case 114:return 66;
           case 115:return 67;
           case 137:return 119;
           case 178:return 49;
           case 179:return 38;
           case 180:return 53;
           case 181:return 37;
           case 182:return 54;
           case 183:return 55;
           case 184:return 51;
           case 211:return 47;
           case 212:return 52;
           case 213:return 48;
           case 214:return 50
           }
        else
         switch(_fI_)
          {case 0:return 43;
           case 1:return 39;
           case 5:return 40;
           case 11:return 123;
           case 12:return 46;
           case 19:return 42;
           case 24:return 41;
           case 25:return 98;
           case 26:return 99;
           case 27:return 101;
           case 28:return 100;
           case 29:return 94;
           case 30:return 96;
           case 31:return 95;
           case 32:return 97;
           case 34:return 120;
           case 37:return 44;
           case 38:return 45;
           case 40:return 27;
           case 41:return 28;
           case 42:return 29;
           case 43:return 30;
           case 44:return 31;
           case 45:return 32;
           case 46:return 33;
           case 47:return 34;
           case 48:return 35;
           case 49:return 36;
           case 57:return 1;
           case 58:return 2;
           case 59:return 3;
           case 60:return 4;
           case 61:return 5;
           case 62:return 6;
           case 63:return 7;
           case 64:return 8;
           case 65:return 9;
           case 66:return 10
           }}
      return 0}
    function make_unidentified(param){return 0}
    function run_next(value,f,v){return v?v:caml_call1(f,value)}
    function symbol$11(x,f){return caml_call1(f,x)}
    function of_event(evt)
     {var _fB_=evt.keyCode;
      function _fC_(_fH_){return run_next(_fB_,try_key_code_normal,_fH_)}
      var match=evt.location,switcher=match - 1 | 0;
      if(2 < switcher >>> 0)
       var _fD_=make_unidentified;
      else
       switch(switcher)
        {case 0:
          var
           _fy_=evt.keyCode,
           _fD_=function(_fF_){return run_next(_fy_,try_key_code_left,_fF_)};
          break;
         case 1:
          var
           _fz_=evt.keyCode,
           _fD_=function(_fE_){return run_next(_fz_,try_key_code_right,_fE_)};
          break;
         default:
          var
           _fA_=evt.keyCode,
           _fD_=function(_fG_){return run_next(_fA_,try_key_code_numpad,_fG_)}}
      var value=evt.code;
      return symbol$11
              (symbol$11
                (symbol$11
                  (0,
                   function(v)
                    {return v?v:caml_call3(Optdef[7],value,make_unidentified,f)}),
                 _fD_),
               _fC_)}
    function char_of_int(value)
     {if(caml_call2(symbol$5,0,value))
       try
        {var _fw_=[0,caml_call1(Stdlib_uchar[8],value)];return _fw_}
       catch(_fx_){return 0}
      return 0}
    function empty_string(param){return ""}
    function none(param){return 0}
    function of_event$0(evt)
     {var t109=caml_call2(Optdef[8],evt.key,empty_string),match=t109.length;
      return 0 === match
              ?caml_call3(Optdef[7],evt.charCode,none,char_of_int)
              :1 === match?char_of_int(t109.charCodeAt(0) | 0):0}
    function element$1(_fv_){return _fv_}
    function tagged(e)
     {var t111=e.tagName,tag=caml_string_of_jsbytes(t111.toLowerCase());
      if(caml_call2(symbol$8,caml_ml_string_length(tag),0))return [61,e];
      var match=runtime.caml_string_unsafe_get(tag,0),switcher=match - 97 | 0;
      if(! (21 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return caml_string_notequal(tag,cst_a$1)
                  ?caml_string_notequal(tag,cst_area$1)
                    ?caml_string_notequal(tag,cst_audio$1)?[61,e]:[2,e]
                    :[1,e]
                  :[0,e];
         case 1:
          return caml_string_notequal(tag,cst_base$1)
                  ?caml_string_notequal(tag,cst_blockquote$1)
                    ?caml_string_notequal(tag,cst_body$1)
                      ?caml_string_notequal(tag,cst_br$1)
                        ?caml_string_notequal(tag,cst_button$1)?[61,e]:[7,e]
                        :[6,e]
                      :[5,e]
                    :[4,e]
                  :[3,e];
         case 2:
          return caml_string_notequal(tag,cst_canvas$1)
                  ?caml_string_notequal(tag,cst_caption$1)
                    ?caml_string_notequal(tag,cst_col$1)
                      ?caml_string_notequal(tag,cst_colgroup$1)?[61,e]:[11,e]
                      :[10,e]
                    :[9,e]
                  :[8,e];
         case 3:
          return caml_string_notequal(tag,cst_del$1)
                  ?caml_string_notequal(tag,cst_div$1)
                    ?caml_string_notequal(tag,cst_dl$1)?[61,e]:[14,e]
                    :[13,e]
                  :[12,e];
         case 4:return caml_string_notequal(tag,cst_embed$1)?[61,e]:[15,e];
         case 5:
          return caml_string_notequal(tag,cst_fieldset$1)
                  ?caml_string_notequal(tag,cst_form$1)
                    ?caml_string_notequal(tag,cst_frame$1)
                      ?caml_string_notequal(tag,cst_frameset$1)?[61,e]:[18,e]
                      :[19,e]
                    :[17,e]
                  :[16,e];
         case 7:
          return caml_string_notequal(tag,cst_h1$1)
                  ?caml_string_notequal(tag,cst_h2$1)
                    ?caml_string_notequal(tag,cst_h3$1)
                      ?caml_string_notequal(tag,cst_h4$1)
                        ?caml_string_notequal(tag,cst_h5$1)
                          ?caml_string_notequal(tag,cst_h6$1)
                            ?caml_string_notequal(tag,cst_head$1)
                              ?caml_string_notequal(tag,cst_hr$1)
                                ?caml_string_notequal(tag,cst_html$1)?[61,e]:[28,e]
                                :[27,e]
                              :[26,e]
                            :[25,e]
                          :[24,e]
                        :[23,e]
                      :[22,e]
                    :[21,e]
                  :[20,e];
         case 8:
          return caml_string_notequal(tag,cst_iframe$1)
                  ?caml_string_notequal(tag,cst_img$1)
                    ?caml_string_notequal(tag,cst_input$2)
                      ?caml_string_notequal(tag,cst_ins$1)?[61,e]:[32,e]
                      :[31,e]
                    :[30,e]
                  :[29,e];
         case 11:
          return caml_string_notequal(tag,cst_label$1)
                  ?caml_string_notequal(tag,cst_legend$1)
                    ?caml_string_notequal(tag,cst_li$1)
                      ?caml_string_notequal(tag,cst_link$1)?[61,e]:[36,e]
                      :[35,e]
                    :[34,e]
                  :[33,e];
         case 12:
          return caml_string_notequal(tag,cst_map$1)
                  ?caml_string_notequal(tag,cst_meta$1)?[61,e]:[38,e]
                  :[37,e];
         case 14:
          return caml_string_notequal(tag,cst_object$1)
                  ?caml_string_notequal(tag,cst_ol$1)
                    ?caml_string_notequal(tag,cst_optgroup$1)
                      ?caml_string_notequal(tag,cst_option$1)?[61,e]:[42,e]
                      :[41,e]
                    :[40,e]
                  :[39,e];
         case 15:
          return caml_string_notequal(tag,cst_p$1)
                  ?caml_string_notequal(tag,cst_param$1)
                    ?caml_string_notequal(tag,cst_pre$1)?[61,e]:[45,e]
                    :[44,e]
                  :[43,e];
         case 16:return caml_string_notequal(tag,cst_q$1)?[61,e]:[46,e];
         case 18:
          return caml_string_notequal(tag,cst_script$1)
                  ?caml_string_notequal(tag,cst_select$2)
                    ?caml_string_notequal(tag,cst_style$1)?[61,e]:[49,e]
                    :[48,e]
                  :[47,e];
         case 19:
          return caml_string_notequal(tag,cst_table$1)
                  ?caml_string_notequal(tag,cst_tbody$1)
                    ?caml_string_notequal(tag,cst_td$1)
                      ?caml_string_notequal(tag,cst_textarea$1)
                        ?caml_string_notequal(tag,cst_tfoot$1)
                          ?caml_string_notequal(tag,cst_th$1)
                            ?caml_string_notequal(tag,cst_thead$1)
                              ?caml_string_notequal(tag,cst_title$1)
                                ?caml_string_notequal(tag,cst_tr$1)?[61,e]:[58,e]
                                :[57,e]
                              :[56,e]
                            :[55,e]
                          :[54,e]
                        :[53,e]
                      :[52,e]
                    :[51,e]
                  :[50,e];
         case 20:return caml_string_notequal(tag,cst_ul$1)?[61,e]:[59,e];
         case 21:return caml_string_notequal(tag,cst_video$1)?[61,e]:[60,e]
         }
      return [61,e]}
    function opt_tagged(e)
     {function _ft_(e){return [0,tagged(e)]}
      function _fu_(param){return 0}
      return caml_call3(Opt[7],e,_fu_,_ft_)}
    function taggedEvent(ev)
     {function _fe_(ev){return [0,ev]}
      function _ff_(param)
       {function _fh_(ev){return [1,ev]}
        function _fi_(param)
         {function _fk_(ev){return [2,ev]}
          function _fl_(param)
           {function _fn_(ev){return [3,ev]}
            function _fo_(param)
             {function _fq_(ev){return [4,ev]}
              function _fr_(param){return [5,ev]}
              var _fs_=popStateEvent(ev);
              return caml_call3(Opt[7],_fs_,_fr_,_fq_)}
            var _fp_=mouseScrollEvent(ev);
            return caml_call3(Opt[7],_fp_,_fo_,_fn_)}
          var _fm_=wheelEvent(ev);
          return caml_call3(Opt[7],_fm_,_fl_,_fk_)}
        var _fj_=keyboardEvent(ev);
        return caml_call3(Opt[7],_fj_,_fi_,_fh_)}
      var _fg_=mouseEvent(ev);
      return caml_call3(Opt[7],_fg_,_ff_,_fe_)}
    function opt_taggedEvent(ev)
     {function _fc_(ev){return [0,taggedEvent(ev)]}
      function _fd_(param){return 0}
      return caml_call3(Opt[7],ev,_fd_,_fc_)}
    function stopPropagation(ev)
     {function _fa_(param){return ev.stopPropagation()}
      function _fb_(param){return ev.cancelBubble = t25}
      return caml_call3(Optdef[7],ev.stopPropagation,_fb_,_fa_)}
    var
     requestAnimationFrame=
      runtime.caml_js_pure_expr
       (function(param)
         {var
           l=
            [0,
             _i_.requestAnimationFrame,
             [0,
              _i_.mozRequestAnimationFrame,
              [0,
               _i_.webkitRequestAnimationFrame,
               [0,
                _i_.oRequestAnimationFrame,
                [0,_i_.msRequestAnimationFrame,0]]]]];
          try
           {var
             _e9_=function(c){return caml_call1(Optdef[5],c)},
             req=caml_call2(Stdlib_list[38],_e9_,l),
             _e__=function(callback){return req(callback)};
            return _e__}
          catch(_e$_)
           {_e$_ = caml_wrap_exception(_e$_);
            if(_e$_ === Stdlib[8])
             {var
               now=function(param){var t122=new t121();return t122.getTime()},
               last=[0,now(0)];
              return function(callback)
               {var
                 t=now(0),
                 dt=last[1] + 16.6666666666666679 - t,
                 dt$0=dt < 0.?0.:dt;
                last[1] = t;
                _i_.setTimeout(callback,dt$0);
                return 0}}
            throw _e$_}});
    function hasPushState(param)
     {return caml_call1(Optdef[5],_i_.history.pushState)}
    function hasPlaceholder(param)
     {var i=createInput(0,0,t22);return caml_call1(Optdef[5],i.placeholder)}
    function hasRequired(param)
     {var i=createInput(0,0,t22);return caml_call1(Optdef[5],i.required)}
    var overflow_limit=2147483000.;
    function setTimeout(callback,d)
     {var id=[0,0];
      function loop(step,param)
       {if(2147483000. < step)
         var remain=step - 2147483000.,step$0=overflow_limit;
        else
         var remain=0.,step$0=step;
        var
         cb=remain == 0.?callback:function(_e8_){return loop(remain,_e8_)},
         t130=caml_js_wrap_callback(cb);
        id[1] = [0,_i_.setTimeout(t130,step$0)];
        return 0}
      loop(d,0);
      return id}
    function clearTimeout(id)
     {var _e7_=id[1];
      if(_e7_){var x=_e7_[1];id[1] = 0;return _i_.clearTimeout(x)}
      return 0}
    function js_array_of_collection(c){return [].slice.call(c)}
    var
     Js_of_ocaml_Dom_html=
      [0,
       d,
       t22,
       getElementById_opt,
       getElementById_exn,
       getElementById_coerce,
       getElementById,
       location_origin,
       _i_,
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       eventRelatedTarget,
       Event$0,
       addEventListenerWithOptions,
       addEventListener,
       removeEventListener,
       addMousewheelEventListenerWith,
       addMousewheelEventListener,
       createCustomEvent,
       buttonPressed,
       eventAbsolutePosition$0,
       elementClientPosition,
       getDocumentScroll,
       [0,of_event,try_key_code_normal],
       [0,of_event$0],
       createHtml,
       createHead,
       createLink,
       createTitle,
       createMeta,
       createBase,
       createStyle,
       createBody,
       createForm,
       createOptgroup,
       createOption,
       createSelect,
       createInput,
       createTextarea,
       createButton,
       createLabel,
       createFieldset,
       createLegend,
       createUl,
       createOl,
       createDl,
       createLi,
       createDiv,
       createEmbed,
       createP,
       createH1,
       createH2,
       createH3,
       createH4,
       createH5,
       createH6,
       createQ,
       createBlockquote,
       createPre,
       createBr,
       createHr,
       createIns,
       createDel,
       createA,
       createImg,
       createObject,
       createParam,
       createMap,
       createArea,
       createScript,
       createTable,
       createCaption,
       createCol,
       createColgroup,
       createThead,
       createTfoot,
       createTbody,
       createTr,
       createTh,
       createTd,
       createSub,
       createSup,
       createSpan,
       createTt,
       createI,
       createB,
       createBig,
       createSmall,
       createEm,
       createStrong,
       createCite,
       createDfn,
       createCode,
       createSamp,
       createKbd,
       createVar,
       createAbbr,
       createDd,
       createDt,
       createNoscript,
       createAddress,
       createFrameset,
       createFrame,
       createIframe,
       createAudio,
       createVideo,
       Canvas_not_available,
       createCanvas,
       element$1,
       tagged,
       opt_tagged,
       taggedEvent,
       opt_taggedEvent,
       stopPropagation,
       [0,
        element$0,
        a,
        area,
        audio,
        base,
        blockquote,
        body,
        br,
        button,
        canvas,
        caption,
        col,
        colgroup,
        del,
        div,
        embed,
        dl,
        fieldset,
        form,
        frameset,
        frame,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        head,
        hr,
        html,
        iframe,
        img,
        input$0,
        ins,
        label,
        legend,
        li,
        link,
        map$2,
        meta,
        object,
        ol,
        optgroup,
        option$1,
        p,
        param,
        pre,
        q,
        script,
        select$0,
        style,
        table,
        tbody,
        td,
        textarea,
        tfoot,
        th,
        thead,
        title,
        tr,
        ul,
        video,
        mouseEvent,
        keyboardEvent,
        wheelEvent,
        mouseScrollEvent,
        popStateEvent],
       setTimeout,
       clearTimeout,
       js_array_of_collection,
       requestAnimationFrame,
       runtime.caml_js_html_entities,
       onIE,
       hasPushState,
       hasPlaceholder,
       hasRequired];
    caml_register_global(1648,Js_of_ocaml_Dom_html,"Js_of_ocaml__Dom_html");
    var formData=Unsafe[1].FormData,formData_form=Unsafe[1].FormData;
    function filter_map$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map$0(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function have_content(elt)
     {var
       _e5_=caml_call2(symbol$9,elt.name.length,0),
       _e6_=_e5_?1 - (elt.disabled | 0):_e5_;
      return _e6_}
    function form_elements(get,form)
     {var length=form.elements.length;
      function _eT_(i)
       {var t34=form.elements,_e4_=t34.item(i);
        return caml_call1(Opt[10],_e4_)}
      var
       _eU_=caml_call2(Stdlib_array[2],length,_eT_),
       elements=caml_call1(Stdlib_array[11],_eU_);
      function _eV_(param)
       {if(param)
         {var v=param[1],match$3=tagged(v);
          switch(match$3[0])
           {case 31:
             var v$0=match$3[1];
             if(get)var sth=get[1],get$0=sth;else var get$0=0;
             if(have_content(v$0))
              {var
                name$1=caml_string_of_jsstring(v$0.name),
                value=v$0.value,
                t20=v$0.type,
                match=caml_string_of_jsbytes(t20.toLowerCase());
               if(caml_string_notequal(match,cst_checkbox))
                {if(! caml_string_notequal(match,cst_file))
                  {if(get$0)return [0,[0,name$1,[0,-976970511,value]],0];
                   var match$0=caml_call1(Optdef[10],v$0.files);
                   if(match$0)
                    {var list=match$0[1];
                     if(caml_call2(symbol$8,list.length,0))
                      return [0,[0,name$1,[0,-976970511,""]],0];
                     var match$1=caml_call1(Optdef[10],v$0.multiple);
                     if(match$1 && match$1[1])
                      {var
                        _eZ_=function(t28){return list.item(t28)},
                        _e0_=caml_call2(Stdlib_array[2],list.length,_eZ_),
                        _e1_=caml_call1(Stdlib_array[11],_e0_);
                       return filter_map$0
                               (function(f)
                                 {var match=caml_call1(Opt[10],f);
                                  if(match)
                                   {var file=match[1];return [0,[0,name$1,[0,781515420,file]]]}
                                  return 0},
                                _e1_)}
                     var _e2_=list.item(0),match$2=caml_call1(Opt[10],_e2_);
                     if(match$2)
                      {var file=match$2[1];
                       return [0,[0,name$1,[0,781515420,file]],0]}
                     return 0}
                   return 0}
                 var switch$0=0;
                 if(caml_string_notequal(match,cst_password))
                  {if(caml_string_notequal(match,cst_radio))
                    {var switch$1=0;
                     if
                      (caml_string_notequal(match,cst_reset)
                       &&
                       caml_string_notequal(match,cst_submit$0))
                      {if(caml_string_notequal(match,cst_text))
                        return [0,[0,name$1,[0,-976970511,value]],0];
                       switch$0 = 1;
                       switch$1 = 1}
                     if(! switch$1)return 0}}
                 else
                  switch$0 = 1;
                 if(switch$0)return [0,[0,name$1,[0,-976970511,value]],0]}
               return v$0.checked | 0?[0,[0,name$1,[0,-976970511,value]],0]:0}
             return 0;
            case 48:
             var v$1=match$3[1];
             if(have_content(v$1))
              {var name$0=caml_string_of_jsstring(v$1.name);
               if(v$1.multiple | 0)
                {var
                  _eX_=
                   function(i)
                    {var t13=v$1.options,_e3_=t13.item(i);
                     return caml_call1(Opt[10],_e3_)},
                  options=caml_call2(Stdlib_array[2],v$1.options.length,_eX_),
                  _eY_=caml_call1(Stdlib_array[11],options);
                 return filter_map$0
                         (function(param)
                           {if(param)
                             {var e=param[1];
                              return e.selected | 0
                                      ?[0,[0,name$0,[0,-976970511,e.value]]]
                                      :0}
                            return 0},
                          _eY_)}
               return [0,[0,name$0,[0,-976970511,v$1.value]],0]}
             return 0;
            case 53:
             var v$2=match$3[1];
             if(have_content(v$2))
              {var name=caml_string_of_jsstring(v$2.name);
               return [0,[0,name,[0,-976970511,v$2.value]],0]}
             return 0;
            default:return 0}}
        return 0}
      var
       _eW_=caml_call2(Stdlib_list[19],_eV_,elements),
       contents=caml_call1(Stdlib_list[14],_eW_);
      return contents}
    function append(form_contents,form_elt)
     {if(891486873 <= form_contents[1])
       {var list=form_contents[2];list[1] = [0,form_elt,list[1]];return 0}
      var f=form_contents[2],_eR_=form_elt[2],_eS_=form_elt[1];
      if(781515420 <= _eR_[1])
       {var file=_eR_[2],t38=caml_jsstring_of_string(_eS_);
        return f.append(t38,file)}
      var s=_eR_[2],t35=caml_jsstring_of_string(_eS_);
      return f.append(t35,s)}
    function empty_form_contents(param)
     {var match=caml_call1(Optdef[10],formData);
      if(match){var constr=match[1];return [0,808620462,new constr()]}
      return [0,891486873,[0,0]]}
    function post_form_contents(form)
     {var contents=empty_form_contents(0),_eO_=form_elements(0,form);
      function _eP_(_eQ_){return append(contents,_eQ_)}
      caml_call2(Stdlib_list[17],_eP_,_eO_);
      return contents}
    function get_form_contents(form)
     {var _eL_=form_elements(_m_,form);
      function _eM_(param)
       {var _eN_=param[2];
        if(typeof _eN_ !== "number" && -976970511 === _eN_[1])
         {var s=_eN_[2],name=param[1];
          return [0,name,caml_string_of_jsstring(s)]}
        throw [0,Assert_failure,_n_]}
      return caml_call2(Stdlib_list[19],_eM_,_eL_)}
    var
     Js_of_ocaml_Form=
      [0,
       formData,
       formData_form,
       append,
       post_form_contents,
       get_form_contents,
       empty_form_contents,
       form_elements];
    caml_register_global(1649,Js_of_ocaml_Form,"Js_of_ocaml__Form");
    var
     readystatechange=caml_call1(Event[1],cst_readystatechange),
     loadstart$1=caml_call1(Event[1],cst_loadstart$1),
     progress$1=caml_call1(Event[1],cst_progress$1),
     abort$1=caml_call1(Event[1],cst_abort$1),
     error$1=caml_call1(Event[1],cst_error$1),
     load$1=caml_call1(Event[1],cst_load$1),
     timeout=caml_call1(Event[1],cst_timeout),
     loadend$0=caml_call1(Event[1],cst_loadend$0),
     Event$1=
      [0,
       readystatechange,
       loadstart$1,
       progress$1,
       abort$1,
       error$1,
       load$1,
       timeout,
       loadend$0],
     Js_of_ocaml_XmlHttpRequest=[0,runtime.caml_xmlhttprequest_create,Event$1];
    caml_register_global
     (1650,Js_of_ocaml_XmlHttpRequest,"Js_of_ocaml__XmlHttpRequest");
    var t2=Unsafe[1].Worker;
    function create(script)
     {var t1=caml_jsstring_of_string(script);return new t2(t1)}
    function import_scripts(scripts)
     {if(Unsafe[1].importScripts === t39)
       caml_call1(Stdlib[1],cst_Worker_import_scripts_is_u);
      var _eI_=caml_call1(Stdlib_array[12],scripts);
      function _eJ_(s){return caml_jsstring_of_string(s)}
      var _eK_=caml_call2(Stdlib_array[15],_eJ_,_eI_);
      return runtime.caml_js_fun_call(Unsafe[1].importScripts,_eK_)}
    function set_onmessage(handler)
     {if(Unsafe[1].onmessage === t39)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi);
      function js_handler(ev){return caml_call1(handler,ev.data)}
      return Unsafe[1].onmessage = caml_js_wrap_callback(js_handler)}
    function post_message(t10)
     {if(Unsafe[1].postMessage === t39)
       caml_call1(Stdlib[1],cst_Worker_onmessage_is_undefi$0);
      return Unsafe[1].postMessage(t10)}
    var
     Js_of_ocaml_Worker=
      [0,create,import_scripts,set_onmessage,post_message];
    caml_register_global(1651,Js_of_ocaml_Worker,"Js_of_ocaml__Worker");
    var webSocket=Unsafe[1].WebSocket;
    function is_supported(param){return caml_call1(Optdef[5],webSocket)}
    var Js_of_ocaml_WebSockets=[0,webSocket,webSocket,webSocket,is_supported];
    caml_register_global
     (1652,Js_of_ocaml_WebSockets,"Js_of_ocaml__WebSockets");
    var
     defaultContextAttributes=
      {"alpha":t25,
       "depth":t25,
       "stencil":t4,
       "antialias":t25,
       "premultipliedAlpha":t4,
       "preserveDrawingBuffer":t4,
       "preferLowPowerToHighPerformance":t4,
       "failIfMajorPerformanceCaveat":t4},
     webglcontextlost=caml_call1(Event$0[86],cst_webglcontextlost),
     webglcontextrestored=caml_call1(Event$0[86],cst_webglcontextrestored),
     webglcontextcreationerror=
      caml_call1(Event$0[86],cst_webglcontextcreationerror),
     Event$2=
      [0,webglcontextlost,webglcontextrestored,webglcontextcreationerror];
    function getContext(t3)
     {var ctx=t3.getContext("webgl");
      return caml_call1(Opt[5],ctx)?ctx:t3.getContext("experimental-webgl")}
    function getContextWithAttributes(t9,t8)
     {var ctx=t9.getContext("webgl",t8);
      return caml_call1(Opt[5],ctx)?ctx:t9.getContext("experimental-webgl",t8)}
    var
     Js_of_ocaml_WebGL=
      [0,defaultContextAttributes,Event$2,getContext,getContextWithAttributes];
    caml_register_global(1653,Js_of_ocaml_WebGL,"Js_of_ocaml__WebGL");
    function regexp(s)
     {var t0=caml_jsbytes_of_string(s);return new t11(t0,"g")}
    function regexp_case_fold(s)
     {var t3=caml_jsbytes_of_string(s);return new t11(t3,"gi")}
    function regexp_with_flag(s,f)
     {var
       t7=caml_jsstring_of_string(caml_call2(Stdlib[28],cst_g,f)),
       t6=caml_jsbytes_of_string(s);
      return new t11(t6,t7)}
    function blunt_str_array_get(a,i)
     {function _eH_(param){throw [0,Assert_failure,_o_]}
      return caml_string_of_jsbytes(caml_call2(Optdef[8],a[i],_eH_))}
    function string_match(r,s,i)
     {r.lastIndex = i;
      var
       t11=caml_jsbytes_of_string(s),
       _eF_=r.exec(t11),
       _eG_=caml_call2(Opt[3],_eF_,match_result);
      return caml_call1(Opt[10],_eG_)}
    function search_forward(r,s,i)
     {r.lastIndex = i;
      var t15=caml_jsbytes_of_string(s);
      function _eC_(res){return [0,res.index,res]}
      var _eD_=r.exec(t15),_eE_=caml_call2(Opt[3],_eD_,_eC_);
      return caml_call1(Opt[10],_eE_)}
    function matched_string(r){return blunt_str_array_get(r,0)}
    function matched_group(r,i)
     {var _eB_=caml_call2(Optdef[3],r[i],caml_string_of_jsbytes);
      return caml_call1(Optdef[10],_eB_)}
    var t21=new t11("[$]","g");
    function quote_repl(s)
     {var t23=caml_jsbytes_of_string(s);return t23.replace(t21,"$$$$")}
    function global_replace(r,s,s_by)
     {r.lastIndex = 0;
      var t27=quote_repl(s_by),t28=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t28.replace(r,t27))}
    function replace_first(r,s,s_by)
     {var
       match=r.ignoreCase | 0,
       match$0=r.multiline | 0,
       flags=match?match$0?"mi":"i":match$0?"m":"",
       t32=r.source,
       t35=new t11(t32,flags),
       t36=quote_repl(s_by),
       t37=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t37.replace(t35,t36))}
    function list_of_js_array(a)
     {var idx$1=a.length - 1 | 0,accu=0,idx=idx$1;
      for(;;)
       {if(caml_call2(symbol$5,idx,0))return accu;
        var
         idx$0=idx - 1 | 0,
         accu$0=[0,blunt_str_array_get(a,idx),accu],
         accu=accu$0,
         idx=idx$0;
        continue}}
    function split(r,s)
     {r.lastIndex = 0;
      var t42=caml_jsbytes_of_string(s);
      return list_of_js_array(t42.split(r))}
    function bounded_split(r,s,i)
     {r.lastIndex = 0;
      var t47=caml_jsbytes_of_string(s);
      return list_of_js_array(t47.split(r,i))}
    var t48=regexp(cst);
    function quote(s)
     {var t50=caml_jsbytes_of_string(s);
      return caml_string_of_jsbytes(t50.replace(t48,"\\$&"))}
    function regexp_string(s){return regexp(quote(s))}
    function regexp_string_case_fold(s){return regexp_case_fold(quote(s))}
    var
     Js_of_ocaml_Regexp=
      [0,
       regexp,
       regexp_case_fold,
       regexp_with_flag,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_forward,
       matched_string,
       matched_group,
       global_replace,
       replace_first,
       split,
       bounded_split];
    caml_register_global(1654,Js_of_ocaml_Regexp,"Js_of_ocaml__Regexp");
    var Local_exn=[248,cst_Js_of_ocaml_Url_Local_exn,caml_fresh_oo_id(0)];
    function interrupt(param){throw Local_exn}
    var plus_re=regexp_string(cst$0),t14=new t11("\\+","g");
    function urldecode_js_string_string(s)
     {t14.lastIndex = 0;
      return caml_string_of_jsbytes(unescape(s.replace(t14," ")))}
    function urldecode(s)
     {return caml_string_of_jsbytes
              (unescape
                (caml_jsbytes_of_string(global_replace(plus_re,s,cst$1))))}
    function urlencode(opt,s)
     {if(opt)var sth=opt[1],with_plus=sth;else var with_plus=1;
      if(with_plus)
       {var s$0=caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)));
        return global_replace(plus_re,s$0,cst_2B)}
      return caml_string_of_jsbytes(escape(caml_jsbytes_of_string(s)))}
    var
     Not_an_http_protocol=
      [248,cst_Js_of_ocaml_Url_Not_an_htt,caml_fresh_oo_id(0)],
     default_http_port=80,
     default_https_port=443;
    function path_of_path_string(s)
     {var l=caml_ml_string_length(s);
      function aux(i)
       {try
         {var _ez_=caml_call3(String[20],s,i,47),j=_ez_}
        catch(_eA_)
         {_eA_ = caml_wrap_exception(_eA_);
          if(_eA_ !== Stdlib[8])throw _eA_;
          var j=l}
        var word=caml_call3(String[8],s,i,j - i | 0);
        return caml_call2(symbol$10,j,l)?[0,word,0]:[0,word,aux(j + 1 | 0)]}
      var a=aux(0);
      if(a && ! caml_string_notequal(a[1],cst$2))
       {var _ey_=a[2];
        if(! _ey_)return 0;
        if(! caml_string_notequal(_ey_[1],cst$3) && ! _ey_[2])return _p_}
      return a}
    function encode_arguments(l)
     {function _et_(param)
       {var
         v=param[2],
         n=param[1],
         _ev_=urlencode(0,v),
         _ew_=caml_call2(Stdlib[28],cst$4,_ev_),
         _ex_=urlencode(0,n);
        return caml_call2(Stdlib[28],_ex_,_ew_)}
      var _eu_=caml_call2(Stdlib_list[19],_et_,l);
      return caml_call2(String[3],cst$5,_eu_)}
    function decode_arguments_js_string(s)
     {var
       t0=caml_jsstring_of_string(caml_call2(String[1],1,38)),
       arr=s.split(t0),
       len=arr.length;
      function aux(acc,idx)
       {var idx$0=idx;
        for(;;)
         {if(caml_call2(symbol$5,idx$0,0))return acc;
          try
           {var
             _el_=idx$0 - 1 | 0,
             _em_=
              function(s)
               {function _er_(param)
                 {var
                   y=param[2],
                   x=param[1],
                   _es_=urldecode_js_string_string(y);
                  return [0,urldecode_js_string_string(x),_es_]}
                var
                 t2=caml_jsstring_of_string(caml_call2(String[1],1,61)),
                 t5=s.indexOf(t2);
                if(caml_call2(symbol$5,t5,0))
                 var _eq_=t39;
                else
                 var
                  t7=t5 + 1 | 0,
                  _ep_=s.slice(t7),
                  _eq_=[0,s.slice(0,t5),_ep_];
                return caml_call3(Optdef[7],_eq_,interrupt,_er_)},
             _en_=
              aux
               ([0,caml_call3(Optdef[7],arr[idx$0],interrupt,_em_),acc],_el_);
            return _en_}
          catch(_eo_)
           {_eo_ = caml_wrap_exception(_eo_);
            if(_eo_ === Local_exn)
             {var idx$1=idx$0 - 1 | 0,idx$0=idx$1;continue}
            throw _eo_}}}
      return aux(0,len - 1 | 0)}
    function decode_arguments(s)
     {return decode_arguments_js_string(caml_jsbytes_of_string(s))}
    var
     t19=caml_jsbytes_of_string(cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0),
     t24=new t11(t19),
     t21$0=caml_jsbytes_of_string(cst_Ff_Ii_Ll_Ee),
     t26=new t11(t21$0);
    function url_of_js_string(s)
     {function _d4_(res)
       {var
         prot_string=caml_call2(Optdef[8],res[1],interrupt),
         match=caml_string_of_jsbytes(prot_string.toLowerCase());
        if
         (caml_string_notequal(match,cst_file$0)
          &&
          caml_string_notequal(match,cst_file$1))
         {var switch$0=0;
          if
           (caml_string_notequal(match,cst_http)
            &&
            caml_string_notequal(match,cst_http$0))
           {var switch$1=0;
            if
             (caml_string_notequal(match,cst_https)
              &&
              caml_string_notequal(match,cst_https$0))
             switch$1 = 1;
            if(! switch$1){var ssl=1;switch$0 = 2}}
          else
           switch$0 = 1;
          var switch$2=0;
          switch(switch$0)
           {case 1:var ssl=0;switch$2 = 1;break;
            case 0:break;
            default:switch$2 = 1}
          if(switch$2)
           {var
             _ec_=function(param){return caml_jsbytes_of_string(cst$7)},
             path_str=
              urldecode_js_string_string(caml_call2(Optdef[8],res[6],_ec_)),
             _ed_=function(param){return caml_jsbytes_of_string(cst$8)},
             _ee_=
              urldecode_js_string_string(caml_call2(Optdef[8],res[10],_ed_)),
             _ef_=function(param){return caml_jsbytes_of_string(cst$9)},
             _eg_=
              decode_arguments_js_string(caml_call2(Optdef[8],res[8],_ef_)),
             _eh_=path_of_path_string(path_str),
             _ei_=function(param){return caml_jsbytes_of_string(cst$10)},
             s=caml_string_of_jsbytes(caml_call2(Optdef[8],res[4],_ei_)),
             _ej_=
              caml_string_notequal(s,cst$6)?caml_int_of_string(s):ssl?443:80,
             url=
              [0,
               urldecode_js_string_string
                (caml_call2(Optdef[8],res[2],interrupt)),
               _ej_,
               _eh_,
               path_str,
               _eg_,
               _ee_],
             _ek_=ssl?[1,url]:[0,url];
            return [0,_ek_]}}
        throw Not_an_http_protocol}
      function _d5_(param)
       {function _d7_(res)
         {var
           path_str=
            urldecode_js_string_string(caml_call2(Optdef[8],res[2],interrupt));
          function _d__(param){return caml_jsbytes_of_string(cst$11)}
          var _d$_=caml_string_of_jsbytes(caml_call2(Optdef[8],res[6],_d__));
          function _ea_(param){return caml_jsbytes_of_string(cst$12)}
          var
           _eb_=
            decode_arguments_js_string(caml_call2(Optdef[8],res[4],_ea_));
          return [0,[2,[0,path_of_path_string(path_str),path_str,_eb_,_d$_]]]}
        function _d8_(param){return 0}
        var _d9_=t26.exec(s);
        return caml_call3(Opt[7],_d9_,_d8_,_d7_)}
      var _d6_=t24.exec(s);
      return caml_call3(Opt[7],_d6_,_d5_,_d4_)}
    function url_of_string(s)
     {return url_of_js_string(caml_jsbytes_of_string(s))}
    function string_of_url(param)
     {switch(param[0])
       {case 0:
         var
          match=param[1],
          frag=match[6],
          args=match[5],
          path=match[3],
          port=match[2],
          host=match[1];
         if(caml_string_notequal(frag,cst$13))
          var _dr_=urlencode(0,frag),_ds_=caml_call2(Stdlib[28],cst$14,_dr_);
         else
          var _ds_=cst$21;
         if(args)
          var
           _dt_=encode_arguments(args),
           _du_=caml_call2(Stdlib[28],cst$15,_dt_);
         else
          var _du_=cst$20;
         var
          _dv_=caml_call2(Stdlib[28],_du_,_ds_),
          _dw_=function(x){return urlencode(0,x)},
          _dx_=caml_call2(Stdlib_list[19],_dw_,path),
          _dy_=caml_call2(String[3],cst$16,_dx_),
          _dz_=caml_call2(Stdlib[28],_dy_,_dv_),
          _dA_=caml_call2(Stdlib[28],cst$17,_dz_);
         if(80 === port)
          var _dB_=cst$18;
         else
          var
           _dF_=caml_call1(Stdlib[33],port),
           _dB_=caml_call2(Stdlib[28],cst$19,_dF_);
         var
          _dC_=caml_call2(Stdlib[28],_dB_,_dA_),
          _dD_=urlencode(0,host),
          _dE_=caml_call2(Stdlib[28],_dD_,_dC_);
         return caml_call2(Stdlib[28],cst_http$1,_dE_);
        case 1:
         var
          match$0=param[1],
          frag$0=match$0[6],
          args$0=match$0[5],
          path$0=match$0[3],
          port$0=match$0[2],
          host$0=match$0[1];
         if(caml_string_notequal(frag$0,cst$22))
          var
           _dG_=urlencode(0,frag$0),
           _dH_=caml_call2(Stdlib[28],cst$23,_dG_);
         else
          var _dH_=cst$30;
         if(args$0)
          var
           _dI_=encode_arguments(args$0),
           _dJ_=caml_call2(Stdlib[28],cst$24,_dI_);
         else
          var _dJ_=cst$29;
         var
          _dK_=caml_call2(Stdlib[28],_dJ_,_dH_),
          _dL_=function(x){return urlencode(0,x)},
          _dM_=caml_call2(Stdlib_list[19],_dL_,path$0),
          _dN_=caml_call2(String[3],cst$25,_dM_),
          _dO_=caml_call2(Stdlib[28],_dN_,_dK_),
          _dP_=caml_call2(Stdlib[28],cst$26,_dO_);
         if(443 === port$0)
          var _dQ_=cst$27;
         else
          var
           _dU_=caml_call1(Stdlib[33],port$0),
           _dQ_=caml_call2(Stdlib[28],cst$28,_dU_);
         var
          _dR_=caml_call2(Stdlib[28],_dQ_,_dP_),
          _dS_=urlencode(0,host$0),
          _dT_=caml_call2(Stdlib[28],_dS_,_dR_);
         return caml_call2(Stdlib[28],cst_https$1,_dT_);
        default:
         var
          match$1=param[1],
          frag$1=match$1[4],
          args$1=match$1[3],
          path$1=match$1[1];
         if(caml_string_notequal(frag$1,cst$31))
          var
           _dV_=urlencode(0,frag$1),
           _dW_=caml_call2(Stdlib[28],cst$32,_dV_);
         else
          var _dW_=cst$36;
         if(args$1)
          var
           _dX_=encode_arguments(args$1),
           _dY_=caml_call2(Stdlib[28],cst$33,_dX_);
         else
          var _dY_=cst$35;
         var
          _dZ_=caml_call2(Stdlib[28],_dY_,_dW_),
          _d0_=function(x){return urlencode(0,x)},
          _d1_=caml_call2(Stdlib_list[19],_d0_,path$1),
          _d2_=caml_call2(String[3],cst$34,_d1_),
          _d3_=caml_call2(Stdlib[28],_d2_,_dZ_);
         return caml_call2(Stdlib[28],cst_file$2,_d3_)}}
    var _q_=caml_call1(Optdef[2],_i_.location);
    if(caml_call1(Optdef[5],_q_))
     var _r_=_i_.location;
    else
     var
      t42=function(param,_dq_){return 0},
      t41=function(param,_dp_){return 0},
      t40=function(param){return 0},
      _r_=
       {"href":"",
        "protocol":"",
        "host":"",
        "hostname":"",
        "port":"",
        "pathname":"",
        "search":"",
        "hash":"",
        "origin":t39,
        "reload":caml_js_wrap_meth_callback(t40),
        "replace":caml_js_wrap_meth_callback(t41),
        "assign":caml_js_wrap_meth_callback(t42)};
    var
     host=urldecode_js_string_string(_r_.hostname),
     protocol=urldecode_js_string_string(_r_.protocol),
     _s_=0,
     port=
      function(param)
        {try
          {var _dn_=[0,caml_int_of_string(caml_string_of_jsbytes(_r_.port))];
           return _dn_}
         catch(_do_)
          {_do_ = caml_wrap_exception(_do_);
           if(_do_[1] === Stdlib[7])return 0;
           throw _do_}}
       (_s_),
     path_string=urldecode_js_string_string(_r_.pathname),
     path=path_of_path_string(path_string),
     t49=_r_.search;
    if(t49.charAt(0) === "?")
     var t52=_r_.search,_t_=t52.slice(1);
    else
     var _t_=_r_.search;
    var arguments$0=decode_arguments_js_string(_t_);
    function get_fragment(param)
     {function _dk_(res){return caml_string_of_jsstring(res[1])}
      function _dl_(param){return cst$37}
      var t57=new t11("#(.*)"),t58=_r_.href,_dm_=t58.match(t57);
      return caml_call3(Opt[7],_dm_,_dl_,_dk_)}
    function set_fragment(s)
     {return _r_.hash = caml_jsbytes_of_string(urlencode(0,s))}
    function get$2(param){return url_of_js_string(_r_.href)}
    function set$0(u)
     {return _r_.href = caml_jsbytes_of_string(string_of_url(u))}
    var
     as_string=urldecode_js_string_string(_r_.href),
     Js_of_ocaml_Url=
      [0,
       urldecode,
       urlencode,
       default_http_port,
       default_https_port,
       path_of_path_string,
       encode_arguments,
       decode_arguments,
       url_of_string,
       string_of_url,
       [0,
        host,
        port,
        protocol,
        path_string,
        path,
        arguments$0,
        get_fragment,
        set_fragment,
        get$2,
        set$0,
        as_string]];
    caml_register_global(1656,Js_of_ocaml_Url,"Js_of_ocaml__Url");
    var Js_of_ocaml_Lib_version=[0,s,git_version];
    caml_register_global
     (1657,Js_of_ocaml_Lib_version,"Js_of_ocaml__Lib_version");
    function update_file(name,content)
     {var oc=caml_call1(Stdlib[60],name);
      caml_call2(Stdlib[66],oc,content);
      return caml_call1(Stdlib[76],oc)}
    function set_channel_flusher(out_channel,f)
     {var
       f$0=
        caml_js_wrap_callback
         (function(s){return caml_call1(f,caml_string_of_jsbytes(s))});
      return runtime.caml_ml_set_channel_output(out_channel,f$0)}
    function set_channel_filler(in_channel,f)
     {var f$0=caml_js_wrap_callback(f);
      return runtime.caml_ml_set_channel_refill(in_channel,f$0)}
    function mount(path,f)
     {return runtime.caml_mount_autoload
              (path,
               caml_js_wrap_callback
                (function(prefix,path){return caml_call2(f,prefix,path)}))}
    function unmount(path){return runtime.caml_unmount(path)}
    if(caml_call2(String[38],git_version,cst$38))
     var js_of_ocaml_version=s;
    else
     var
      _cn_=caml_call2(Stdlib[28],cst$41,git_version),
      js_of_ocaml_version=caml_call2(Stdlib[28],s,_cn_);
    var
     _u_=runtime.caml_create_file,
     _v_=runtime.caml_read_file_content,
     Js_of_ocaml_Sys_js=
      [0,
       set_channel_flusher,
       set_channel_filler,
       function(_dj_){return runtime.caml_list_mount_point(_dj_)},
       unmount,
       mount,
       _v_,
       _u_,
       update_file,
       js_of_ocaml_version];
    caml_register_global(1658,Js_of_ocaml_Sys_js,"Js_of_ocaml__Sys_js");
    function empty_resize_observer_options(param){return {}}
    var t2$0=Unsafe[1].ResizeObserver;
    function is_supported$0(param){return caml_call1(Optdef[5],t2$0)}
    function observe(node,f,box,param)
     {var t1=caml_js_wrap_callback(f),t4=new t2$0(t1);
      if(box)
       {var box$0=box[1],t8={};t8.box = box$0;t4.observe(node,t8)}
      else
       t4.observe(node);
      return t4}
    var
     Js_of_ocaml_ResizeObserver=
      [0,empty_resize_observer_options,t2$0,is_supported$0,observe];
    caml_register_global
     (1659,Js_of_ocaml_ResizeObserver,"Js_of_ocaml__ResizeObserver");
    function empty_mutation_observer_init(param){return {}}
    var t2$1=Unsafe[1].MutationObserver;
    function is_supported$1(param){return caml_call1(Optdef[5],t2$1)}
    function observe$0
     (node,
      f,
      child_list,
      attributes,
      character_data,
      subtree,
      attribute_old_value,
      character_data_old_value,
      attribute_filter,
      param)
     {function opt_iter(x,f)
       {if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
      var t1=caml_js_wrap_callback(f),t19=new t2$1(t1),t18={};
      opt_iter(child_list,function(v){return t18.childList = v});
      opt_iter(attributes,function(v){return t18.attributes = v});
      opt_iter(character_data,function(v){return t18.characterData = v});
      opt_iter(subtree,function(v){return t18.subtree = v});
      opt_iter
       (attribute_old_value,function(v){return t18.attributeOldValue = v});
      opt_iter
       (character_data_old_value,
        function(v){return t18.characterDataOldValue = v});
      opt_iter
       (attribute_filter,
        function(l)
         {return t18.attributeFilter
                 =
                 caml_js_from_array(caml_call1(Stdlib_array[12],l))});
      t19.observe(node,t18);
      return t19}
    var
     Js_of_ocaml_MutationObserver=
      [0,empty_mutation_observer_init,t2$1,is_supported$1,observe$0];
    caml_register_global
     (1660,Js_of_ocaml_MutationObserver,"Js_of_ocaml__MutationObserver");
    var t1=Unsafe[1].Object;
    function create$0(param){return new t1()}
    function add$0(t,k,v){return t[k.concat("_")] = v}
    function remove(t,k){return delete t[k.concat("_")]}
    function find(t,k){return t[k.concat("_")]}
    function keys(t)
     {var
       t10=Unsafe[1].Object,
       key_array=t10.keys(t),
       res=[0,0],
       _df_=key_array.length - 1 | 0,
       _de_=0;
      if(! (_df_ < 0))
       {var i=_de_;
        for(;;)
         {var
           _dg_=function(param){return caml_call1(Stdlib[2],cst_Jstable_keys)},
           t15=caml_call2(Optdef[8],key_array[i],_dg_),
           t14=t15.length - 1 | 0,
           _dh_=res[1];
          res[1] = [0,t15.substring(0,t14),_dh_];
          var _di_=i + 1 | 0;
          if(_df_ !== i){var i=_di_;continue}
          break}}
      return caml_call1(Stdlib_list[9],res[1])}
    var Js_of_ocaml_Jstable=[0,create$0,add$0,remove,find,keys];
    caml_register_global(1661,Js_of_ocaml_Jstable,"Js_of_ocaml__Jstable");
    var t12=Unsafe[1].JSON;
    function reviver(this$0,key,value)
     {if(typeof value == typeof "foo")return caml_string_of_jsbytes(value);
      if
       (value instanceof array_length
        &&
        4
        ===
        value.length
        &&
        255
        ===
        value[0])
       return runtime.caml_int64_create_lo_mi_hi(value[1],value[2],value[3]);
      return value}
    var t3$0=caml_js_wrap_meth_callback(reviver);
    function unsafe_input(t2){return t12.parse(t2,t3$0)}
    var
     mlString_constr=dummy_string.constructor,
     mlInt64_constr=dummy_int64.constructor;
    function t11$1(key,value)
     {return value instanceof mlString_constr
              ?caml_jsbytes_of_string(value)
              :value instanceof mlInt64_constr
                ?caml_js_from_array([0,255,value.lo,value.mi,value.hi])
                :value}
    function output(t10){return t12.stringify(t10,t11$1)}
    var Js_of_ocaml_Json=[0,output,unsafe_input];
    caml_register_global(1662,Js_of_ocaml_Json,"Js_of_ocaml__Json");
    function string_of_name(param)
     {var _dd_=param;
      if(74 <= _dd_)
       {if(111 <= _dd_)
         switch(_dd_)
          {case 111:return cst_palevioletred;
           case 112:return cst_papayawhip;
           case 113:return cst_peachpuff;
           case 114:return cst_peru;
           case 115:return cst_pink;
           case 116:return cst_plum;
           case 117:return cst_powderblue;
           case 118:return cst_purple;
           case 119:return cst_red;
           case 120:return cst_rosybrown;
           case 121:return cst_royalblue;
           case 122:return cst_saddlebrown;
           case 123:return cst_salmon;
           case 124:return cst_sandybrown;
           case 125:return cst_seagreen;
           case 126:return cst_seashell;
           case 127:return cst_sienna;
           case 128:return cst_silver;
           case 129:return cst_skyblue;
           case 130:return cst_slateblue;
           case 131:return cst_slategray;
           case 132:return cst_slategrey;
           case 133:return cst_snow;
           case 134:return cst_springgreen;
           case 135:return cst_steelblue;
           case 136:return cst_tan;
           case 137:return cst_teal;
           case 138:return cst_thistle;
           case 139:return cst_tomato;
           case 140:return cst_turquoise;
           case 141:return cst_violet;
           case 142:return cst_wheat;
           case 143:return cst_white;
           case 144:return cst_whitesmoke;
           case 145:return cst_yellow;
           default:return cst_yellowgreen}
        switch(_dd_)
         {case 74:return cst_lightpink;
          case 75:return cst_lightsalmon;
          case 76:return cst_lightseagreen;
          case 77:return cst_lightskyblue;
          case 78:return cst_lightslategray;
          case 79:return cst_lightslategrey;
          case 80:return cst_lightsteelblue;
          case 81:return cst_lightyellow;
          case 82:return cst_lime;
          case 83:return cst_limegreen;
          case 84:return cst_linen;
          case 85:return cst_magenta;
          case 86:return cst_maroon;
          case 87:return cst_mediumaquamarine;
          case 88:return cst_mediumblue;
          case 89:return cst_mediumorchid;
          case 90:return cst_mediumpurple;
          case 91:return cst_mediumseagreen;
          case 92:return cst_mediumslateblue;
          case 93:return cst_mediumspringgreen;
          case 94:return cst_mediumturquoise;
          case 95:return cst_mediumvioletred;
          case 96:return cst_midnightblue;
          case 97:return cst_mintcream;
          case 98:return cst_mistyrose;
          case 99:return cst_moccasin;
          case 100:return cst_navajowhite;
          case 101:return cst_navy;
          case 102:return cst_oldlace;
          case 103:return cst_olive;
          case 104:return cst_olivedrab;
          case 105:return cst_orange;
          case 106:return cst_orangered;
          case 107:return cst_orchid;
          case 108:return cst_palegoldenrod;
          case 109:return cst_palegreen;
          default:return cst_paleturquoise}}
      if(37 <= _dd_)
       switch(_dd_)
        {case 37:return cst_darkslategrey;
         case 38:return cst_darkturquoise;
         case 39:return cst_darkviolet;
         case 40:return cst_deeppink;
         case 41:return cst_deepskyblue;
         case 42:return cst_dimgray;
         case 43:return cst_dimgrey;
         case 44:return cst_dodgerblue;
         case 45:return cst_firebrick;
         case 46:return cst_floralwhite;
         case 47:return cst_forestgreen;
         case 48:return cst_fuchsia;
         case 49:return cst_gainsboro;
         case 50:return cst_ghostwhite;
         case 51:return cst_gold;
         case 52:return cst_goldenrod;
         case 53:return cst_gray;
         case 54:return cst_grey;
         case 55:return cst_green;
         case 56:return cst_greenyellow;
         case 57:return cst_honeydew;
         case 58:return cst_hotpink;
         case 59:return cst_indianred;
         case 60:return cst_indigo;
         case 61:return cst_ivory;
         case 62:return cst_khaki;
         case 63:return cst_lavender;
         case 64:return cst_lavenderblush;
         case 65:return cst_lawngreen;
         case 66:return cst_lemonchiffon;
         case 67:return cst_lightblue;
         case 68:return cst_lightcoral;
         case 69:return cst_lightcyan;
         case 70:return cst_lightgoldenrodyellow;
         case 71:return cst_lightgray;
         case 72:return cst_lightgreen;
         default:return cst_lightgrey}
      switch(_dd_)
       {case 0:return cst_aliceblue;
        case 1:return cst_antiquewhite;
        case 2:return cst_aqua;
        case 3:return cst_aquamarine;
        case 4:return cst_azure;
        case 5:return cst_beige;
        case 6:return cst_bisque;
        case 7:return cst_black;
        case 8:return cst_blanchedalmond;
        case 9:return cst_blue;
        case 10:return cst_blueviolet;
        case 11:return cst_brown;
        case 12:return cst_burlywood;
        case 13:return cst_cadetblue;
        case 14:return cst_chartreuse;
        case 15:return cst_chocolate;
        case 16:return cst_coral;
        case 17:return cst_cornflowerblue;
        case 18:return cst_cornsilk;
        case 19:return cst_crimson;
        case 20:return cst_cyan;
        case 21:return cst_darkblue;
        case 22:return cst_darkcyan;
        case 23:return cst_darkgoldenrod;
        case 24:return cst_darkgray;
        case 25:return cst_darkgreen;
        case 26:return cst_darkgrey;
        case 27:return cst_darkkhaki;
        case 28:return cst_darkmagenta;
        case 29:return cst_darkolivegreen;
        case 30:return cst_darkorange;
        case 31:return cst_darkorchid;
        case 32:return cst_darkred;
        case 33:return cst_darksalmon;
        case 34:return cst_darkseagreen;
        case 35:return cst_darkslateblue;
        default:return cst_darkslategray}}
    function name_of_string(s)
     {var switch$0=caml_string_compare(s,cst_lightgrey$0);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 73;
        var switch$1=caml_string_compare(s,cst_paleturquoise$0);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 110;
          var switch$2=caml_string_compare(s,cst_skyblue$0);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 129;
            var switch$3=caml_string_compare(s,cst_thistle$0);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 138;
              if(! caml_string_notequal(s,cst_tomato$0))return 139;
              if(! caml_string_notequal(s,cst_turquoise$0))return 140;
              if(! caml_string_notequal(s,cst_violet$0))return 141;
              if(! caml_string_notequal(s,cst_wheat$0))return 142;
              if(! caml_string_notequal(s,cst_white$0))return 143;
              if(! caml_string_notequal(s,cst_whitesmoke$0))return 144;
              if(! caml_string_notequal(s,cst_yellow$0))return 145;
              if(! caml_string_notequal(s,cst_yellowgreen$0))return 146}
            else
             {if(! caml_string_notequal(s,cst_slateblue$0))return 130;
              if(! caml_string_notequal(s,cst_slategray$0))return 131;
              if(! caml_string_notequal(s,cst_slategrey$0))return 132;
              if(! caml_string_notequal(s,cst_snow$0))return 133;
              if(! caml_string_notequal(s,cst_springgreen$0))return 134;
              if(! caml_string_notequal(s,cst_steelblue$0))return 135;
              if(! caml_string_notequal(s,cst_tan$0))return 136;
              if(! caml_string_notequal(s,cst_teal$0))return 137}}
          else
           {var switch$4=caml_string_compare(s,cst_rosybrown$0);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 120;
              if(! caml_string_notequal(s,cst_royalblue$0))return 121;
              if(! caml_string_notequal(s,cst_saddlebrown$0))return 122;
              if(! caml_string_notequal(s,cst_salmon$0))return 123;
              if(! caml_string_notequal(s,cst_sandybrown$0))return 124;
              if(! caml_string_notequal(s,cst_seagreen$0))return 125;
              if(! caml_string_notequal(s,cst_seashell$0))return 126;
              if(! caml_string_notequal(s,cst_sienna$0))return 127;
              if(! caml_string_notequal(s,cst_silver$0))return 128}
            else
             {if(! caml_string_notequal(s,cst_palevioletred$0))return 111;
              if(! caml_string_notequal(s,cst_papayawhip$0))return 112;
              if(! caml_string_notequal(s,cst_peachpuff$0))return 113;
              if(! caml_string_notequal(s,cst_peru$0))return 114;
              if(! caml_string_notequal(s,cst_pink$0))return 115;
              if(! caml_string_notequal(s,cst_plum$0))return 116;
              if(! caml_string_notequal(s,cst_powderblue$0))return 117;
              if(! caml_string_notequal(s,cst_purple$0))return 118;
              if(! caml_string_notequal(s,cst_red$0))return 119}}}
        else
         {var switch$5=caml_string_compare(s,cst_mediumslateblue$0);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 92;
            var switch$6=caml_string_compare(s,cst_navy$0);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 101;
              if(! caml_string_notequal(s,cst_oldlace$0))return 102;
              if(! caml_string_notequal(s,cst_olive$0))return 103;
              if(! caml_string_notequal(s,cst_olivedrab$0))return 104;
              if(! caml_string_notequal(s,cst_orange$0))return 105;
              if(! caml_string_notequal(s,cst_orangered$0))return 106;
              if(! caml_string_notequal(s,cst_orchid$0))return 107;
              if(! caml_string_notequal(s,cst_palegoldenrod$0))return 108;
              if(! caml_string_notequal(s,cst_palegreen$0))return 109}
            else
             {if(! caml_string_notequal(s,cst_mediumspringgreen$0))return 93;
              if(! caml_string_notequal(s,cst_mediumturquoise$0))return 94;
              if(! caml_string_notequal(s,cst_mediumvioletred$0))return 95;
              if(! caml_string_notequal(s,cst_midnightblue$0))return 96;
              if(! caml_string_notequal(s,cst_mintcream$0))return 97;
              if(! caml_string_notequal(s,cst_mistyrose$0))return 98;
              if(! caml_string_notequal(s,cst_moccasin$0))return 99;
              if(! caml_string_notequal(s,cst_navajowhite$0))return 100}}
          else
           {var switch$7=caml_string_compare(s,cst_limegreen$0);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 83;
              if(! caml_string_notequal(s,cst_linen$0))return 84;
              if(! caml_string_notequal(s,cst_magenta$0))return 85;
              if(! caml_string_notequal(s,cst_maroon$0))return 86;
              if(! caml_string_notequal(s,cst_mediumaquamarine$0))return 87;
              if(! caml_string_notequal(s,cst_mediumblue$0))return 88;
              if(! caml_string_notequal(s,cst_mediumorchid$0))return 89;
              if(! caml_string_notequal(s,cst_mediumpurple$0))return 90;
              if(! caml_string_notequal(s,cst_mediumseagreen$0))return 91}
            else
             {if(! caml_string_notequal(s,cst_lightpink$0))return 74;
              if(! caml_string_notequal(s,cst_lightsalmon$0))return 75;
              if(! caml_string_notequal(s,cst_lightseagreen$0))return 76;
              if(! caml_string_notequal(s,cst_lightskyblue$0))return 77;
              if(! caml_string_notequal(s,cst_lightslategray$0))return 78;
              if(! caml_string_notequal(s,cst_lightslategrey$0))return 79;
              if(! caml_string_notequal(s,cst_lightsteelblue$0))return 80;
              if(! caml_string_notequal(s,cst_lightyellow$0))return 81;
              if(! caml_string_notequal(s,cst_lime$0))return 82}}}}
      else
       {var switch$8=caml_string_compare(s,cst_darkslategray$0);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 36;
          var switch$9=caml_string_compare(s,cst_greenyellow$0);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 56;
            var switch$10=caml_string_compare(s,cst_lavenderblush$0);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 64;
              if(! caml_string_notequal(s,cst_lawngreen$0))return 65;
              if(! caml_string_notequal(s,cst_lemonchiffon$0))return 66;
              if(! caml_string_notequal(s,cst_lightblue$0))return 67;
              if(! caml_string_notequal(s,cst_lightcoral$0))return 68;
              if(! caml_string_notequal(s,cst_lightcyan$0))return 69;
              if(! caml_string_notequal(s,cst_lightgoldenrodyellow$0))
               return 70;
              if(! caml_string_notequal(s,cst_lightgray$0))return 71;
              if(! caml_string_notequal(s,cst_lightgreen$0))return 72}
            else
             {if(! caml_string_notequal(s,cst_grey$0))return 54;
              if(! caml_string_notequal(s,cst_honeydew$0))return 57;
              if(! caml_string_notequal(s,cst_hotpink$0))return 58;
              if(! caml_string_notequal(s,cst_indianred$0))return 59;
              if(! caml_string_notequal(s,cst_indigo$0))return 60;
              if(! caml_string_notequal(s,cst_ivory$0))return 61;
              if(! caml_string_notequal(s,cst_khaki$0))return 62;
              if(! caml_string_notequal(s,cst_lavender$0))return 63}}
          else
           {var switch$11=caml_string_compare(s,cst_floralwhite$0);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 46;
              if(! caml_string_notequal(s,cst_forestgreen$0))return 47;
              if(! caml_string_notequal(s,cst_fuchsia$0))return 48;
              if(! caml_string_notequal(s,cst_gainsboro$0))return 49;
              if(! caml_string_notequal(s,cst_ghostwhite$0))return 50;
              if(! caml_string_notequal(s,cst_gold$0))return 51;
              if(! caml_string_notequal(s,cst_goldenrod$0))return 52;
              if(! caml_string_notequal(s,cst_gray$0))return 53;
              if(! caml_string_notequal(s,cst_green$0))return 55}
            else
             {if(! caml_string_notequal(s,cst_darkslategrey$0))return 37;
              if(! caml_string_notequal(s,cst_darkturquoise$0))return 38;
              if(! caml_string_notequal(s,cst_darkviolet$0))return 39;
              if(! caml_string_notequal(s,cst_deeppink$0))return 40;
              if(! caml_string_notequal(s,cst_deepskyblue$0))return 41;
              if(! caml_string_notequal(s,cst_dimgray$0))return 42;
              if(! caml_string_notequal(s,cst_dimgrey$0))return 43;
              if(! caml_string_notequal(s,cst_dodgerblue$0))return 44;
              if(! caml_string_notequal(s,cst_firebrick$0))return 45}}}
        else
         {var switch$12=caml_string_compare(s,cst_cornsilk$0);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 18;
            var switch$13=caml_string_compare(s,cst_darkkhaki$0);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 27;
              if(! caml_string_notequal(s,cst_darkmagenta$0))return 28;
              if(! caml_string_notequal(s,cst_darkolivegreen$0))return 29;
              if(! caml_string_notequal(s,cst_darkorange$0))return 30;
              if(! caml_string_notequal(s,cst_darkorchid$0))return 31;
              if(! caml_string_notequal(s,cst_darkred$0))return 32;
              if(! caml_string_notequal(s,cst_darksalmon$0))return 33;
              if(! caml_string_notequal(s,cst_darkseagreen$0))return 34;
              if(! caml_string_notequal(s,cst_darkslateblue$0))return 35}
            else
             {if(! caml_string_notequal(s,cst_crimson$0))return 19;
              if(! caml_string_notequal(s,cst_cyan$0))return 20;
              if(! caml_string_notequal(s,cst_darkblue$0))return 21;
              if(! caml_string_notequal(s,cst_darkcyan$0))return 22;
              if(! caml_string_notequal(s,cst_darkgoldenrod$0))return 23;
              if(! caml_string_notequal(s,cst_darkgray$0))return 24;
              if(! caml_string_notequal(s,cst_darkgreen$0))return 25;
              if(! caml_string_notequal(s,cst_darkgrey$0))return 26}}
          else
           {var switch$14=caml_string_compare(s,cst_blue$0);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 9;
              if(! caml_string_notequal(s,cst_blueviolet$0))return 10;
              if(! caml_string_notequal(s,cst_brown$0))return 11;
              if(! caml_string_notequal(s,cst_burlywood$0))return 12;
              if(! caml_string_notequal(s,cst_cadetblue$0))return 13;
              if(! caml_string_notequal(s,cst_chartreuse$0))return 14;
              if(! caml_string_notequal(s,cst_chocolate$0))return 15;
              if(! caml_string_notequal(s,cst_coral$0))return 16;
              if(! caml_string_notequal(s,cst_cornflowerblue$0))return 17}
            else
             {if(! caml_string_notequal(s,cst_aliceblue$0))return 0;
              if(! caml_string_notequal(s,cst_antiquewhite$0))return 1;
              if(! caml_string_notequal(s,cst_aqua$0))return 2;
              if(! caml_string_notequal(s,cst_aquamarine$0))return 3;
              if(! caml_string_notequal(s,cst_azure$0))return 4;
              if(! caml_string_notequal(s,cst_beige$0))return 5;
              if(! caml_string_notequal(s,cst_bisque$0))return 6;
              if(! caml_string_notequal(s,cst_black$0))return 7;
              if(! caml_string_notequal(s,cst_blanchedalmond$0))return 8}}}}
      var _dc_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color_name);
      throw [0,Stdlib[6],_dc_]}
    function rgb_of_name(param)
     {var _db_=param;
      if(74 <= _db_)
       {if(111 <= _db_)
         switch(_db_)
          {case 111:return _bp_;
           case 112:return _bq_;
           case 113:return _br_;
           case 114:return _bs_;
           case 115:return _bt_;
           case 116:return _bu_;
           case 117:return _bv_;
           case 118:return _bw_;
           case 119:return _bx_;
           case 120:return _by_;
           case 121:return _bz_;
           case 122:return _bA_;
           case 123:return _bB_;
           case 124:return _bC_;
           case 125:return _bD_;
           case 126:return _bE_;
           case 127:return _bF_;
           case 128:return _bG_;
           case 129:return _bH_;
           case 130:return _bI_;
           case 131:return _bJ_;
           case 132:return _bK_;
           case 133:return _bL_;
           case 134:return _bM_;
           case 135:return _bN_;
           case 136:return _bO_;
           case 137:return _bP_;
           case 138:return _bQ_;
           case 139:return _bR_;
           case 140:return _bS_;
           case 141:return _bT_;
           case 142:return _bU_;
           case 143:return _bV_;
           case 144:return _bW_;
           case 145:return _bX_;
           default:return _bY_}
        switch(_db_)
         {case 74:return _aQ_;
          case 75:return _aR_;
          case 76:return _aS_;
          case 77:return _aT_;
          case 78:return _aU_;
          case 79:return _aV_;
          case 80:return _aW_;
          case 81:return _aX_;
          case 82:return _aY_;
          case 83:return _aZ_;
          case 84:return _a0_;
          case 85:return _a1_;
          case 86:return _a2_;
          case 87:return _a3_;
          case 88:return _a4_;
          case 89:return _a5_;
          case 90:return _a6_;
          case 91:return _a7_;
          case 92:return _a8_;
          case 93:return _a9_;
          case 94:return _a__;
          case 95:return _a$_;
          case 96:return _ba_;
          case 97:return _bb_;
          case 98:return _bc_;
          case 99:return _bd_;
          case 100:return _be_;
          case 101:return _bf_;
          case 102:return _bg_;
          case 103:return _bh_;
          case 104:return _bi_;
          case 105:return _bj_;
          case 106:return _bk_;
          case 107:return _bl_;
          case 108:return _bm_;
          case 109:return _bn_;
          default:return _bo_}}
      if(37 <= _db_)
       switch(_db_)
        {case 37:return _af_;
         case 38:return _ag_;
         case 39:return _ah_;
         case 40:return _ai_;
         case 41:return _aj_;
         case 42:return _ak_;
         case 43:return _al_;
         case 44:return _am_;
         case 45:return _an_;
         case 46:return _ao_;
         case 47:return _ap_;
         case 48:return _aq_;
         case 49:return _ar_;
         case 50:return _as_;
         case 51:return _at_;
         case 52:return _au_;
         case 53:return _av_;
         case 54:return _aw_;
         case 55:return _ax_;
         case 56:return _ay_;
         case 57:return _az_;
         case 58:return _aA_;
         case 59:return _aB_;
         case 60:return _aC_;
         case 61:return _aD_;
         case 62:return _aE_;
         case 63:return _aF_;
         case 64:return _aG_;
         case 65:return _aH_;
         case 66:return _aI_;
         case 67:return _aJ_;
         case 68:return _aK_;
         case 69:return _aL_;
         case 70:return _aM_;
         case 71:return _aN_;
         case 72:return _aO_;
         default:return _aP_}
      switch(_db_)
       {case 0:return _w_;
        case 1:return _x_;
        case 2:return _y_;
        case 3:return _z_;
        case 4:return _A_;
        case 5:return _B_;
        case 6:return _C_;
        case 7:return _D_;
        case 8:return _E_;
        case 9:return _F_;
        case 10:return _G_;
        case 11:return _H_;
        case 12:return _I_;
        case 13:return _J_;
        case 14:return _K_;
        case 15:return _L_;
        case 16:return _M_;
        case 17:return _N_;
        case 18:return _O_;
        case 19:return _P_;
        case 20:return _Q_;
        case 21:return _R_;
        case 22:return _S_;
        case 23:return _T_;
        case 24:return _U_;
        case 25:return _V_;
        case 26:return _W_;
        case 27:return _X_;
        case 28:return _Y_;
        case 29:return _Z_;
        case 30:return ___;
        case 31:return _$_;
        case 32:return _aa_;
        case 33:return _ab_;
        case 34:return _ac_;
        case 35:return _ad_;
        default:return _ae_}}
    function rgb(a,r,g,b)
     {if(a){var a$0=a[1];return [3,[0,r,g,b,a$0]]}return [1,[0,r,g,b]]}
    function hsl(a,h,s,l)
     {if(a){var a$0=a[1];return [6,[0,h,s,l,a$0]]}return [5,[0,h,s,l]]}
    function string_of_t(param)
     {switch(param[0])
       {case 0:var n=param[1];return string_of_name(n);
        case 1:
         var match=param[1],b=match[3],g=match[2],r=match[1];
         return caml_call4(Stdlib_printf[4],_bZ_,r,g,b);
        case 2:
         var match$0=param[1],b$0=match$0[3],g$0=match$0[2],r$0=match$0[1];
         return caml_call4(Stdlib_printf[4],_b0_,r$0,g$0,b$0);
        case 3:
         var
          match$1=param[1],
          a=match$1[4],
          b$1=match$1[3],
          g$1=match$1[2],
          r$1=match$1[1];
         return caml_call5(Stdlib_printf[4],_b1_,r$1,g$1,b$1,a);
        case 4:
         var
          match$2=param[1],
          a$0=match$2[4],
          b$2=match$2[3],
          g$2=match$2[2],
          r$2=match$2[1];
         return caml_call5(Stdlib_printf[4],_b2_,r$2,g$2,b$2,a$0);
        case 5:
         var match$3=param[1],l=match$3[3],s=match$3[2],h=match$3[1];
         return caml_call4(Stdlib_printf[4],_b3_,h,s,l);
        default:
         var
          match$4=param[1],
          a$1=match$4[4],
          l$0=match$4[3],
          s$0=match$4[2],
          h$0=match$4[1];
         return caml_call5(Stdlib_printf[4],_b4_,h$0,s$0,l$0,a$1)}}
    function hex_of_rgb(param)
     {var blue=param[3],green=param[2],red=param[1];
      function in_range(i)
       {var
         _c9_=caml_call2(symbol$5,i,0),
         _c__=_c9_ || caml_call2(symbol$9,i,255);
        if(_c__)
         {var
           _c$_=caml_call1(Stdlib[33],i),
           _da_=caml_call2(Stdlib[28],_c$_,cst_is_out_of_valid_range);
          throw [0,Stdlib[6],_da_]}
        return _c__}
      in_range(red);
      in_range(green);
      in_range(blue);
      return caml_call4(Stdlib_printf[4],_b5_,red,green,blue)}
    function js_t_of_js_string(s)
     {var
       t0=caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d),
       t13=new t11(t0),
       t2=caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d$0),
       t17=new t11(t2),
       t4=caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d),
       t15=new t11(t4),
       t6=caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d$0),
       t19=new t11(t6),
       t8=caml_jsbytes_of_string(cst_hsl_s_d_s_d_s_d),
       t21=new t11(t8),
       t10=caml_jsbytes_of_string(cst_hsla_s_d_s_d_s_d_d_d),
       t23=new t11(t10);
      if
       (!
        (t13.test(s) | 0)
        &&
        !
        (t15.test(s) | 0)
        &&
        !
        (t17.test(s) | 0)
        &&
        !
        (t19.test(s) | 0)
        &&
        !
        (t21.test(s) | 0)
        &&
        !
        (t23.test(s) | 0))
       {var _c6_=caml_string_of_jsstring(s);
        if(caml_call2(Stdlib_list[36],_c6_,_b6_))return s;
        var
         _c7_=caml_string_of_jsstring(s),
         _c8_=caml_call2(Stdlib[28],_c7_,cst_is_not_a_valid_color);
        throw [0,Stdlib[6],_c8_]}
      return s}
    function js(c)
     {if(0 === c[0])
       {var n=c[1];return caml_jsstring_of_string(string_of_name(n))}
      return caml_jsstring_of_string(string_of_t(c))}
    function ml(c)
     {var s=caml_string_of_jsstring(c);
      try
       {var _cT_=[0,name_of_string(s)];return _cT_}
      catch(_cU_)
       {_cU_ = caml_wrap_exception(_cU_);
        if(_cU_[1] === Stdlib[6])
         {var
           fail=
            function(param)
             {var _c5_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_color$0);
              throw [0,Stdlib[6],_c5_]},
           re_rgb=regexp(cst_rgba_d_d_d_d_d),
           re_rgb_pct=regexp(cst_rgba_d_d_d_d_d$0),
           re_hsl=regexp(cst_hsla_d_d_d_d_d),
           i_of_s_o=
            function(param)
             {if(param)
               {var i=param[1];
                try
                 {var _c3_=caml_int_of_string(i);return _c3_}
                catch(_c4_)
                 {_c4_ = caml_wrap_exception(_c4_);
                  if(_c4_[1] === Stdlib[6])
                   var s=_c4_[2];
                  else
                   {if(_c4_[1] !== Stdlib[7])throw _c4_;var s=_c4_[2]}
                  var
                   _c0_=caml_call2(Stdlib[28],cst$39,s),
                   _c1_=caml_call2(Stdlib[28],i,_c0_),
                   _c2_=caml_call2(Stdlib[28],cst_color_conversion_error,_c1_);
                  throw [0,Stdlib[6],_c2_]}}
              return fail(0)},
           f_of_s=
            function(f)
             {try
               {var _cY_=caml_float_of_string(f);return _cY_}
              catch(_cZ_)
               {_cZ_ = caml_wrap_exception(_cZ_);
                if(_cZ_[1] === Stdlib[6])
                 var s=_cZ_[2];
                else
                 {if(_cZ_[1] !== Stdlib[7])throw _cZ_;var s=_cZ_[2]}
                var
                 _cV_=caml_call2(Stdlib[28],cst$40,s),
                 _cW_=caml_call2(Stdlib[28],f,_cV_),
                 _cX_=caml_call2(Stdlib[28],cst_color_conversion_error$0,_cW_);
                throw [0,Stdlib[6],_cX_]}},
           match=string_match(re_rgb,s,0);
          if(match)
           {var
             r=match[1],
             red=matched_group(r,2),
             green=matched_group(r,3),
             blue=matched_group(r,4),
             alpha=matched_group(r,5),
             match$0=matched_group(r,1);
            if(match$0)
             {var _cB_=match$0[1];
              if(! caml_string_notequal(_cB_,cst_rgb))
               {if(alpha)return fail(0);
                var _cF_=i_of_s_o(blue),_cG_=i_of_s_o(green);
                return [1,[0,i_of_s_o(red),_cG_,_cF_]]}
              if(! caml_string_notequal(_cB_,cst_rgba))
               {if(alpha)
                 {var
                   a=alpha[1],
                   _cC_=f_of_s(a),
                   _cD_=i_of_s_o(blue),
                   _cE_=i_of_s_o(green);
                  return [3,[0,i_of_s_o(red),_cE_,_cD_,_cC_]]}
                return fail(0)}}
            return fail(0)}
          var match$1=string_match(re_rgb_pct,s,0);
          if(match$1)
           {var
             r$0=match$1[1],
             red$0=matched_group(r$0,2),
             green$0=matched_group(r$0,3),
             blue$0=matched_group(r$0,4),
             alpha$0=matched_group(r$0,5),
             match$2=matched_group(r$0,1);
            if(match$2)
             {var _cH_=match$2[1];
              if(! caml_string_notequal(_cH_,cst_rgb$0))
               {if(alpha$0)return fail(0);
                var _cL_=i_of_s_o(blue$0),_cM_=i_of_s_o(green$0);
                return [2,[0,i_of_s_o(red$0),_cM_,_cL_]]}
              if(! caml_string_notequal(_cH_,cst_rgba$0))
               {if(alpha$0)
                 {var
                   a$0=alpha$0[1],
                   _cI_=f_of_s(a$0),
                   _cJ_=i_of_s_o(blue$0),
                   _cK_=i_of_s_o(green$0);
                  return [4,[0,i_of_s_o(red$0),_cK_,_cJ_,_cI_]]}
                return fail(0)}}
            return fail(0)}
          var match$3=string_match(re_hsl,s,0);
          if(match$3)
           {var
             r$1=match$3[1],
             red$1=matched_group(r$1,2),
             green$1=matched_group(r$1,3),
             blue$1=matched_group(r$1,4),
             alpha$1=matched_group(r$1,5),
             match$4=matched_group(r$1,1);
            if(match$4)
             {var _cN_=match$4[1];
              if(! caml_string_notequal(_cN_,cst_hsl))
               {if(alpha$1)return fail(0);
                var _cR_=i_of_s_o(blue$1),_cS_=i_of_s_o(green$1);
                return [5,[0,i_of_s_o(red$1),_cS_,_cR_]]}
              if(! caml_string_notequal(_cN_,cst_hsla))
               {if(alpha$1)
                 {var
                   a$1=alpha$1[1],
                   _cO_=f_of_s(a$1),
                   _cP_=i_of_s_o(blue$1),
                   _cQ_=i_of_s_o(green$1);
                  return [6,[0,i_of_s_o(red$1),_cQ_,_cP_,_cO_]]}
                return fail(0)}}
            return fail(0)}
          return fail(0)}
        throw _cU_}}
    function string_of_t$0(param)
     {if(typeof param === "number")
       return cst_0;
      else
       switch(param[0])
        {case 0:
          var f=param[1];return caml_call3(Stdlib_printf[4],_b7_,f,cst_em$0);
         case 1:
          var f$0=param[1];
          return caml_call3(Stdlib_printf[4],_b8_,f$0,cst_ex);
         case 2:
          var f$1=param[1];
          return caml_call3(Stdlib_printf[4],_b9_,f$1,cst_px);
         case 3:
          var f$2=param[1];
          return caml_call3(Stdlib_printf[4],_b__,f$2,cst_gd);
         case 4:
          var f$3=param[1];
          return caml_call3(Stdlib_printf[4],_b$_,f$3,cst_rem);
         case 5:
          var f$4=param[1];
          return caml_call3(Stdlib_printf[4],_ca_,f$4,cst_vw);
         case 6:
          var f$5=param[1];
          return caml_call3(Stdlib_printf[4],_cb_,f$5,cst_vh);
         case 7:
          var f$6=param[1];
          return caml_call3(Stdlib_printf[4],_cc_,f$6,cst_vm);
         case 8:
          var f$7=param[1];
          return caml_call3(Stdlib_printf[4],_cd_,f$7,cst_ch);
         case 9:
          var f$8=param[1];
          return caml_call3(Stdlib_printf[4],_ce_,f$8,cst_mm);
         case 10:
          var f$9=param[1];
          return caml_call3(Stdlib_printf[4],_cf_,f$9,cst_cm);
         case 11:
          var f$10=param[1];
          return caml_call3(Stdlib_printf[4],_cg_,f$10,cst_in);
         case 12:
          var f$11=param[1];
          return caml_call3(Stdlib_printf[4],_ch_,f$11,cst_pt);
         default:
          var f$12=param[1];
          return caml_call3(Stdlib_printf[4],_ci_,f$12,cst_pc)}}
    function js$0(t){return caml_jsstring_of_string(string_of_t$0(t))}
    function ml$0(t)
     {var s=caml_string_of_jsstring(t);
      if(caml_call2(String[38],s,cst_0$0))return 0;
      function fail(param)
       {var _cA_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length);
        throw [0,Stdlib[6],_cA_]}
      var re=regexp(cst_d_d_s_S),match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cy_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _cx_=caml_call2(Stdlib[28],cst_length_conversion_error,s$0);
              throw [0,Stdlib[6],_cx_]}
            throw exn}
          var f$0=_cy_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cz_=match$1[1],switch$0=caml_string_compare(_cz_,cst_pc$0);
          if(0 <= switch$0)
           {if(! (0 < switch$0))return [13,f$0];
            if(! caml_string_notequal(_cz_,cst_pt$0))return [12,f$0];
            if(! caml_string_notequal(_cz_,cst_px$0))return [2,f$0];
            if(! caml_string_notequal(_cz_,cst_rem$0))return [4,f$0];
            if(! caml_string_notequal(_cz_,cst_vh$0))return [6,f$0];
            if(! caml_string_notequal(_cz_,cst_vm$0))return [7,f$0];
            if(! caml_string_notequal(_cz_,cst_vw$0))return [5,f$0]}
          else
           {if(! caml_string_notequal(_cz_,cst_ch$0))return [8,f$0];
            if(! caml_string_notequal(_cz_,cst_cm$0))return [10,f$0];
            if(! caml_string_notequal(_cz_,cst_em$1))return [0,f$0];
            if(! caml_string_notequal(_cz_,cst_ex$0))return [1,f$0];
            if(! caml_string_notequal(_cz_,cst_gd$0))return [3,f$0];
            if(! caml_string_notequal(_cz_,cst_in$0))return [11,f$0];
            if(! caml_string_notequal(_cz_,cst_mm$0))return [9,f$0]}
          return fail(0)}
        return fail(0)}
      return fail(0)}
    var Length=[0,string_of_t$0,js$0,ml$0];
    function string_of_t$1(param)
     {switch(param[0])
       {case 0:
         var f=param[1];return caml_call3(Stdlib_printf[4],_cj_,f,cst_deg);
        case 1:
         var f$0=param[1];
         return caml_call3(Stdlib_printf[4],_ck_,f$0,cst_grad);
        case 2:
         var f$1=param[1];
         return caml_call3(Stdlib_printf[4],_cl_,f$1,cst_rad);
        default:
         var f$2=param[1];
         return caml_call3(Stdlib_printf[4],_cm_,f$2,cst_turns)}}
    function js$1(t){return caml_jsstring_of_string(string_of_t$1(t))}
    function ml$1(j)
     {var s=caml_string_of_jsstring(j),re=regexp(cst_d_d_deg_grad_rad_turns);
      function fail(param)
       {var _cw_=caml_call2(Stdlib[28],s,cst_is_not_a_valid_length$0);
        throw [0,Stdlib[6],_cw_]}
      var match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _cu_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Stdlib[6])
             {var
               s$0=exn[2],
               _ct_=caml_call2(Stdlib[28],cst_length_conversion_error$0,s$0);
              throw [0,Stdlib[6],_ct_]}
            throw exn}
          var f$0=_cu_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _cv_=match$1[1];
          if(! caml_string_notequal(_cv_,cst_deg$0))return [0,f$0];
          if(! caml_string_notequal(_cv_,cst_grad$0))return [1,f$0];
          if(! caml_string_notequal(_cv_,cst_rad$0))return [2,f$0];
          if(! caml_string_notequal(_cv_,cst_turns$0))return [3,f$0]}
        return fail(0)}
      return fail(0)}
    var
     Angle=[0,string_of_t$1,js$1,ml$1],
     Js_of_ocaml_CSS=
      [0,
       [0,
        string_of_name,
        rgb_of_name,
        hex_of_rgb,
        rgb,
        hsl,
        string_of_t,
        js,
        ml,
        js_t_of_js_string],
       Length,
       Angle];
    caml_register_global(1663,Js_of_ocaml_CSS,"Js_of_ocaml__CSS");
    function listen(opt,target,typ,cb)
     {if(opt)var sth=opt[1],capture=sth;else var capture=0;
      var _cs_=! ! capture;
      return addEventListener
              (target,
               typ,
               full_handler(function(n,e){return ! ! caml_call2(cb,n,e)}),
               _cs_)}
    var Js_of_ocaml_Dom_events=[0,Event$0,listen,removeEventListener];
    caml_register_global
     (1664,Js_of_ocaml_Dom_events,"Js_of_ocaml__Dom_events");
    var
     t0="http://www.w3.org/2000/svg",
     SVGError=[248,cst_Js_of_ocaml_Dom_svg_SVGErr,caml_fresh_oo_id(0)];
    function createElement$0(t2,name)
     {var t1=caml_jsstring_of_string(name);
      return t2.createElementNS("http://www.w3.org/2000/svg",t1)}
    function unsafeCreateElement$0(doc,name){return createElement$0(doc,name)}
    function createA$0(doc){return unsafeCreateElement$0(doc,cst_a$2)}
    function createAltGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_altglyph)}
    function createAltGlyphDef(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphdef)}
    function createAltGlyphItem(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphitem)}
    function createAnimate(doc){return unsafeCreateElement$0(doc,cst_animate)}
    function createAnimateColor(doc)
     {return unsafeCreateElement$0(doc,cst_animatecolor)}
    function createAnimateMotion(doc)
     {return unsafeCreateElement$0(doc,cst_animatemotion)}
    function createAnimateTransform(doc)
     {return unsafeCreateElement$0(doc,cst_animatetransform)}
    function createCircle(doc){return unsafeCreateElement$0(doc,cst_circle)}
    function createClipPath(doc)
     {return unsafeCreateElement$0(doc,cst_clippath)}
    function createCursor(doc){return unsafeCreateElement$0(doc,cst_cursor)}
    function createDefs(doc){return unsafeCreateElement$0(doc,cst_defs)}
    function createDesc(doc){return unsafeCreateElement$0(doc,cst_desc)}
    function createEllipse(doc){return unsafeCreateElement$0(doc,cst_ellipse)}
    function createFilter(doc){return unsafeCreateElement$0(doc,cst_filter)}
    function createFont(doc){return unsafeCreateElement$0(doc,cst_font)}
    function createFontFace(doc)
     {return unsafeCreateElement$0(doc,cst_font_face)}
    function createFontFaceFormat(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_format)}
    function createFontFaceName(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_name)}
    function createFontFaceSrc(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_src)}
    function createFontFaceUri(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_uri)}
    function createForeignObject(doc)
     {return unsafeCreateElement$0(doc,cst_foreignObject)}
    function createG(doc){return unsafeCreateElement$0(doc,cst_g$0)}
    function createGlyph(doc){return unsafeCreateElement$0(doc,cst_glyph)}
    function createGlyphRef(doc)
     {return unsafeCreateElement$0(doc,cst_glyphref)}
    function createhkern(doc){return unsafeCreateElement$0(doc,cst_hkern)}
    function createImage(doc){return unsafeCreateElement$0(doc,cst_image)}
    function createLineElement(doc)
     {return unsafeCreateElement$0(doc,cst_line)}
    function createLinearElement(doc)
     {return unsafeCreateElement$0(doc,cst_lineargradient)}
    function createMask(doc){return unsafeCreateElement$0(doc,cst_mask)}
    function createMetaData(doc)
     {return unsafeCreateElement$0(doc,cst_metadata)}
    function createMissingGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_missing_glyph)}
    function createMPath(doc){return unsafeCreateElement$0(doc,cst_mpath)}
    function createPath(doc){return unsafeCreateElement$0(doc,cst_path)}
    function createPattern(doc){return unsafeCreateElement$0(doc,cst_pattern)}
    function createPolygon(doc){return unsafeCreateElement$0(doc,cst_polygon)}
    function createPolyline(doc)
     {return unsafeCreateElement$0(doc,cst_polyline)}
    function createRadialgradient(doc)
     {return unsafeCreateElement$0(doc,cst_radialgradient)}
    function createRect(doc){return unsafeCreateElement$0(doc,cst_rect)}
    function createScript$0(doc)
     {return unsafeCreateElement$0(doc,cst_script$2)}
    function createSet(doc){return unsafeCreateElement$0(doc,cst_set)}
    function createStop(doc){return unsafeCreateElement$0(doc,cst_stop)}
    function createStyle$0(doc){return unsafeCreateElement$0(doc,cst_style$2)}
    function createSvg(doc){return unsafeCreateElement$0(doc,cst_svg)}
    function createSwitch(doc){return unsafeCreateElement$0(doc,cst_switch)}
    function createSymbol(doc){return unsafeCreateElement$0(doc,cst_symbol)}
    function createTextElement(doc)
     {return unsafeCreateElement$0(doc,cst_text$0)}
    function createTextpath(doc)
     {return unsafeCreateElement$0(doc,cst_textpath)}
    function createTitle$0(doc){return unsafeCreateElement$0(doc,cst_title$2)}
    function createTref(doc){return unsafeCreateElement$0(doc,cst_tref)}
    function createTspan(doc){return unsafeCreateElement$0(doc,cst_tspan)}
    function createUse(doc){return unsafeCreateElement$0(doc,cst_use)}
    function createView(doc){return unsafeCreateElement$0(doc,cst_view)}
    function createvkern(doc){return unsafeCreateElement$0(doc,cst_vkern)}
    var svg_element=Unsafe[1].SVGElement,document$0=Unsafe[1].document;
    function getElementById$0(id)
     {function _cp_(e){if(e instanceof svg_element)return e;throw Stdlib[8]}
      function _cq_(param){throw Stdlib[8]}
      var
       t6=caml_jsstring_of_string(id),
       t7=Unsafe[1].document,
       _cr_=t7.getElementById(t6);
      return caml_call3(Opt[7],_cr_,_cq_,_cp_)}
    function element$2(e){return e instanceof svg_element?e:no_handler}
    function unsafeCoerce$0(e,tag)
     {var t9=e.tagName,_co_=caml_jsstring_of_string(tag);
      return t9.toLowerCase() === _co_?e:no_handler}
    function a$0(e){return unsafeCoerce$0(e,cst_a$3)}
    function altGlyph(e){return unsafeCoerce$0(e,cst_altglyph$0)}
    function altGlyphDef(e){return unsafeCoerce$0(e,cst_altglyphdef$0)}
    function altGlyphItem(e){return unsafeCoerce$0(e,cst_altglyphitem$0)}
    function animate(e){return unsafeCoerce$0(e,cst_animate$0)}
    function animateColor(e){return unsafeCoerce$0(e,cst_animatecolor$0)}
    function animateMotion(e){return unsafeCoerce$0(e,cst_animatemotion$0)}
    function animateTransform(e)
     {return unsafeCoerce$0(e,cst_animatetransform$0)}
    function circle(e){return unsafeCoerce$0(e,cst_circle$0)}
    function clipPath(e){return unsafeCoerce$0(e,cst_clippath$0)}
    function cursor(e){return unsafeCoerce$0(e,cst_cursor$0)}
    function defs(e){return unsafeCoerce$0(e,cst_defs$0)}
    function desc(e){return unsafeCoerce$0(e,cst_desc$0)}
    function ellipse(e){return unsafeCoerce$0(e,cst_ellipse$0)}
    function filter(e){return unsafeCoerce$0(e,cst_filter$0)}
    function font(e){return unsafeCoerce$0(e,cst_font$0)}
    function fontFace(e){return unsafeCoerce$0(e,cst_font_face$0)}
    function fontFaceFormat(e)
     {return unsafeCoerce$0(e,cst_font_face_format$0)}
    function fontFaceName(e){return unsafeCoerce$0(e,cst_font_face_name$0)}
    function fontFaceSrc(e){return unsafeCoerce$0(e,cst_font_face_src$0)}
    function fontFaceUri(e){return unsafeCoerce$0(e,cst_font_face_uri$0)}
    function foreignObject(e){return unsafeCoerce$0(e,cst_foreignobject)}
    function g(e){return unsafeCoerce$0(e,cst_g$1)}
    function glyph(e){return unsafeCoerce$0(e,cst_glyph$0)}
    function glyphRef(e){return unsafeCoerce$0(e,cst_glyphref$0)}
    function hkern(e){return unsafeCoerce$0(e,cst_hkern$0)}
    function image(e){return unsafeCoerce$0(e,cst_image$0)}
    function lineElement(e){return unsafeCoerce$0(e,cst_line$0)}
    function linearElement(e){return unsafeCoerce$0(e,cst_lineargradient$0)}
    function mask(e){return unsafeCoerce$0(e,cst_mask$0)}
    function metaData(e){return unsafeCoerce$0(e,cst_metadata$0)}
    function missingGlyph(e){return unsafeCoerce$0(e,cst_missing_glyph$0)}
    function mPath(e){return unsafeCoerce$0(e,cst_mpath$0)}
    function path$0(e){return unsafeCoerce$0(e,cst_path$0)}
    function pattern(e){return unsafeCoerce$0(e,cst_pattern$0)}
    function polygon(e){return unsafeCoerce$0(e,cst_polygon$0)}
    function polyline(e){return unsafeCoerce$0(e,cst_polyline$0)}
    function radialgradient(e){return unsafeCoerce$0(e,cst_radialgradient$0)}
    function rect(e){return unsafeCoerce$0(e,cst_rect$0)}
    function script$0(e){return unsafeCoerce$0(e,cst_script$3)}
    function set$1(e){return unsafeCoerce$0(e,cst_set$0)}
    function stop(e){return unsafeCoerce$0(e,cst_stop$0)}
    function style$0(e){return unsafeCoerce$0(e,cst_style$3)}
    function svg(e){return unsafeCoerce$0(e,cst_svg$0)}
    function switch$0(e){return unsafeCoerce$0(e,cst_switch$0)}
    function symbol$12(e){return unsafeCoerce$0(e,cst_symbol$0)}
    function textElement(e){return unsafeCoerce$0(e,cst_text$1)}
    function textpath(e){return unsafeCoerce$0(e,cst_textpath$0)}
    function title$0(e){return unsafeCoerce$0(e,cst_title$3)}
    function tref(e){return unsafeCoerce$0(e,cst_tref$0)}
    function tspan(e){return unsafeCoerce$0(e,cst_tspan$0)}
    function use(e){return unsafeCoerce$0(e,cst_use$0)}
    function view(e){return unsafeCoerce$0(e,cst_view$0)}
    function vkern(e){return unsafeCoerce$0(e,cst_vkern$0)}
    var
     Js_of_ocaml_Dom_svg=
      [0,
       t0,
       SVGError,
       createElement$0,
       createA$0,
       createAltGlyph,
       createAltGlyphDef,
       createAltGlyphItem,
       createAnimate,
       createAnimateColor,
       createAnimateMotion,
       createAnimateTransform,
       createCircle,
       createClipPath,
       createCursor,
       createDefs,
       createDesc,
       createEllipse,
       createFilter,
       createFont,
       createFontFace,
       createFontFaceFormat,
       createFontFaceName,
       createFontFaceSrc,
       createFontFaceUri,
       createForeignObject,
       createG,
       createGlyph,
       createGlyphRef,
       createhkern,
       createImage,
       createLineElement,
       createLinearElement,
       createMask,
       createMetaData,
       createMissingGlyph,
       createMPath,
       createPath,
       createPattern,
       createPolygon,
       createPolyline,
       createRadialgradient,
       createRect,
       createScript$0,
       createSet,
       createStop,
       createStyle$0,
       createSvg,
       createSwitch,
       createSymbol,
       createTextElement,
       createTextpath,
       createTitle$0,
       createTref,
       createTspan,
       createUse,
       createView,
       createvkern,
       svg_element,
       document$0,
       getElementById$0,
       [0,
        element$2,
        a$0,
        altGlyph,
        altGlyphDef,
        altGlyphItem,
        animate,
        animateColor,
        animateMotion,
        animateTransform,
        circle,
        clipPath,
        cursor,
        defs,
        desc,
        ellipse,
        filter,
        font,
        fontFace,
        fontFaceFormat,
        fontFaceName,
        fontFaceSrc,
        fontFaceUri,
        foreignObject,
        g,
        glyph,
        glyphRef,
        hkern,
        image,
        lineElement,
        linearElement,
        mask,
        metaData,
        missingGlyph,
        mPath,
        path$0,
        pattern,
        polygon,
        polyline,
        radialgradient,
        rect,
        script$0,
        set$1,
        stop,
        style$0,
        svg,
        switch$0,
        symbol$12,
        textElement,
        textpath,
        title$0,
        tref,
        tspan,
        use,
        view,
        vkern]];
    caml_register_global(1665,Js_of_ocaml_Dom_svg,"Js_of_ocaml__Dom_svg");
    function withCredentials(b)
     {var init={};init.withCredentials = ! ! b;return init}
    var
     eventSource=Unsafe[1].EventSource,
     eventSource_options=Unsafe[1].EventSource,
     Js_of_ocaml_EventSource=
      [0,withCredentials,eventSource,eventSource_options,addEventListener];
    caml_register_global
     (1666,Js_of_ocaml_EventSource,"Js_of_ocaml__EventSource");
    var
     console=runtime.caml_js_get_console(0),
     Js_of_ocaml_Firebug=[0,console];
    caml_register_global(1667,Js_of_ocaml_Firebug,"Js_of_ocaml__Firebug");
    function empty_position_options(param){return {}}
    var
     x=Unsafe[1].navigator,
     geolocation=caml_call1(Optdef[5],x)?x.geolocation:x;
    function is_supported$2(param){return caml_call1(Optdef[5],geolocation)}
    var
     Js_of_ocaml_Geolocation=
      [0,empty_position_options,geolocation,is_supported$2];
    caml_register_global
     (1668,Js_of_ocaml_Geolocation,"Js_of_ocaml__Geolocation");
    function empty_intersection_observer_op(param){return {}}
    var intersectionObserver_unsafe=Unsafe[1].IntersectionObserver;
    function is_supported$3(param)
     {return caml_call1(Optdef[5],intersectionObserver_unsafe)}
    var
     Js_of_ocaml_IntersectionObserv=
      [0,
       empty_intersection_observer_op,
       is_supported$3,
       intersectionObserver_unsafe];
    caml_register_global
     (1669,Js_of_ocaml_IntersectionObserv,"Js_of_ocaml__IntersectionObserver");
    function object_options(param){return {"localeMatcher":"best fit"}}
    function options(param)
     {return {"localeMatcher":"best fit",
              "usage":"sort",
              "sensitivity":"variant",
              "ignorePunctuation":t4,
              "numeric":t4,
              "caseFirst":"false"}}
    var Collator=[0,object_options,options];
    function options$0(param)
     {return {"localeMatcher":"best fit",
              "timeZone":t39,
              "hour12":t39,
              "hourCycle":t39,
              "formatMatcher":"best fit",
              "weekday":t39,
              "era":t39,
              "year":t39,
              "month":t39,
              "day":t39,
              "hour":t39,
              "minute":t39,
              "second":t39,
              "timeZoneName":t39}}
    var DateTimeFormat=[0,object_options,options$0];
    function options$1(param)
     {return {"localeMatcher":"best fit",
              "style":"decimal",
              "currency":t39,
              "currencyDisplay":t39,
              "useGrouping":t25,
              "minimumIntegerDigits":t39,
              "minimumFractionDigits":t39,
              "maximumFractionDigits":t39,
              "minimumSignificantDigits":t39,
              "maximumSignificantDigits":t39}}
    var NumberFormat=[0,object_options,options$1];
    function options$2(param)
     {return {"localeMatcher":"best fit","type":"cardinal"}}
    var
     PluralRules=[0,object_options,options$2],
     intl=Unsafe[1].Intl,
     collator_constr=Unsafe[1].Intl.Collator,
     dateTimeFormat_constr=Unsafe[1].Intl.DateTimeFormat,
     numberFormat_constr=Unsafe[1].Intl.NumberFormat,
     pluralRules_constr=Unsafe[1].Intl.PluralRules;
    function is_supported$4(param){return caml_call1(Optdef[5],intl)}
    var
     Js_of_ocaml_Intl=
      [0,
       Collator,
       DateTimeFormat,
       NumberFormat,
       PluralRules,
       intl,
       collator_constr,
       dateTimeFormat_constr,
       numberFormat_constr,
       pluralRules_constr,
       is_supported$4];
    caml_register_global(1670,Js_of_ocaml_Intl,"Js_of_ocaml__Intl");
    var Js_of_ocaml$0=[0];
    caml_register_global(1671,Js_of_ocaml$0,"Js_of_ocaml");
    return}
  (function(){return this}()));


//# 1 ".ace_js.eobjs/byte/dune__exe__Ace_js.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_compute=caml_string_of_jsbytes("compute"),
     cst_click=caml_string_of_jsbytes("click"),
     cst_main=caml_string_of_jsbytes("main"),
     cst_secondary=caml_string_of_jsbytes("secondary"),
     cst_output=caml_string_of_jsbytes("output"),
     cst_lang=caml_string_of_jsbytes("lang"),
     cst=caml_string_of_jsbytes(""),
     cst$0=caml_string_of_jsbytes("\n=====\n"),
     cst_exit=caml_string_of_jsbytes("exit"),
     cst_Invalid_headers=caml_string_of_jsbytes("Invalid headers."),
     cst_load=caml_string_of_jsbytes("load"),
     Js_of_ocaml_Dom_html=global_data.Js_of_ocaml__Dom_html,
     Stdlib_option=global_data.Stdlib__option,
     Js_of_ocaml_Js=global_data.Js_of_ocaml__Js,
     Stdlib=global_data.Stdlib,
     Settings=global_data.Settings,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib_format=global_data.Stdlib__format,
     Fs=global_data.Fs,
     Preprocess=global_data.Preprocess,
     Exit=global_data.Exit,
     Ace_common=global_data.Ace_common,
     Stdlib_printexc=global_data.Stdlib__printexc;
    function treat_input(lang,str)
     {caml_call1(Settings[4],lang);
      var
       buffer=caml_call1(Stdlib_buffer[1],1000),
       fmt=caml_call1(Stdlib_format[109],buffer);
      try
       {var
         fs=caml_call1(Fs[1],str),
         match=caml_call1(Fs[3],fs),
         program=match[2],
         headers=match[1],
         env=caml_call2(Preprocess[5],fmt,headers),
         match$0=caml_call2(Preprocess[2],headers,cst_exit);
        if(typeof match$0 === "number")
         var headers2=0,exit=0;
        else
         if(0 === match$0[0])
          var
           fn=match$0[1],
           match$1=caml_call2(Fs[4],fn,fs),
           ast=match$1[2],
           headers$0=match$1[1],
           exit$0=caml_call3(Exit[3],fmt,env,[0,headers$0,ast]),
           headers2=headers$0,
           exit=[0,exit$0];
         else
          var
           _l_=caml_call1(Stdlib[2],cst_Invalid_headers),
           headers2=_l_[2],
           exit=_l_[1];
        caml_call5(Ace_common[2],fmt,env,[0,headers,headers2],program,exit)}
      catch(e)
       {e = caml_wrap_exception(e);
        var _k_=caml_call1(Stdlib_printexc[1],e);
        caml_call2(Stdlib_buffer[14],buffer,_k_)}
      caml_call2(Stdlib_format[36],fmt,0);
      return caml_call1(Stdlib_buffer[2],buffer)}
    function is_blank_str(s)
     {var i$1=runtime.caml_ml_string_length(s) - 1 | 0,i=i$1;
      for(;;)
       {if(0 <= i)
         {var c=runtime.caml_string_get(s,i);
          if(32 !== c && 9 !== c && 10 !== c && 13 !== c)return 0;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        return 1}}
    function compute(param)
     {var
       _f_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_main,Js_of_ocaml_Dom_html[117][55]),
       main_input=caml_call1(Stdlib_option[4],_f_),
       _g_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_secondary,Js_of_ocaml_Dom_html[117][55]),
       secondary_input=caml_call1(Stdlib_option[4],_g_),
       _h_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_output,Js_of_ocaml_Dom_html[117][55]),
       output=caml_call1(Stdlib_option[4],_h_),
       _i_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_lang,Js_of_ocaml_Dom_html[117][50]),
       lang=caml_call1(Stdlib_option[4],_i_),
       main_input$0=caml_string_of_jsstring(main_input.value),
       secondary_input$0=caml_string_of_jsstring(secondary_input.value),
       _j_=
        is_blank_str(secondary_input$0)
         ?cst
         :caml_call2(Stdlib[28],cst$0,secondary_input$0),
       input=caml_call2(Stdlib[28],main_input$0,_j_),
       lang$0=caml_string_of_jsstring(lang.value),
       res=treat_input(lang$0,input);
      output.value = runtime.caml_jsstring_of_string(res);
      return Js_of_ocaml_Js[7]}
    function init(param)
     {var
       _c_=
        caml_call2
         (Js_of_ocaml_Dom_html[5],cst_compute,Js_of_ocaml_Dom_html[117][9]),
       compute_button=caml_call1(Stdlib_option[4],_c_),
       _d_=caml_call1(Js_of_ocaml_Dom_html[10],compute),
       _e_=caml_call1(Js_of_ocaml_Dom_html[15][86],cst_click);
      caml_call4(Js_of_ocaml_Dom_html[17],compute_button,_e_,_d_,! ! 0);
      return Js_of_ocaml_Js[8]}
    var
     _a_=caml_call1(Js_of_ocaml_Dom_html[10],init),
     _b_=caml_call1(Js_of_ocaml_Dom_html[15][86],cst_load);
    caml_call4(Js_of_ocaml_Dom_html[17],Js_of_ocaml_Dom_html[8],_b_,_a_,! ! 0);
    var Dune_exe_Ace_js=[0,treat_input,is_blank_str,compute,init];
    runtime.caml_register_global(27,Dune_exe_Ace_js,"Dune__exe__Ace_js");
    return}
  (function(){return this}()));


//# 1 ".js/stdlib/std_exit.cmo.js"
(function(joo_global_object)
   {"use strict";
    var runtime=joo_global_object.jsoo_runtime;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    var global_data=runtime.caml_get_global_data(),Stdlib=global_data.Stdlib;
    caml_call1(Stdlib[103],0);
    var Std_exit=[0];
    runtime.caml_register_global(1,Std_exit,"Std_exit");
    return}
  (function(){return this}()));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJhY2VfanMuYmMuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiY2FtbF9pbnQ2NF9pc196ZXJvIiwieCIsImNhbWxfc3RyX3JlcGVhdCIsIm4iLCJzIiwiciIsImwiLCJjYW1sX2ludDY0X29mZnNldCIsIk1hdGgiLCJjYW1sX3JhaXNlX2NvbnN0YW50IiwidGFnIiwiY2FtbF9nbG9iYWxfZGF0YSIsImNhbWxfcmFpc2VfemVyb19kaXZpZGUiLCJNbEludDY0IiwibG8iLCJtaSIsImhpIiwidGhpcyIsInhoaSIsImgiLCJzaWduIiwib2Zmc2V0IiwibW9kdWx1cyIsImRpdmlzb3IiLCJxdW90aWVudCIsInkiLCJxIiwiY2FtbF9pbnQ2NF9vZl9pbnQzMiIsImNhbWxfaW50NjRfdG9faW50MzIiLCJjYW1sX2ludDY0X2lzX25lZ2F0aXZlIiwiY2FtbF9pbnQ2NF9uZWciLCJjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMiLCJhIiwiaSIsImxlbiIsImYiLCJTdHJpbmciLCJudWxsIiwiY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyIsImNhbWxfanNieXRlc19vZl9zdHJpbmciLCJjYW1sX3JhaXNlX3dpdGhfYXJnIiwiYXJnIiwianNvb19pc19hc2NpaSIsImNhbWxfdXRmMTZfb2ZfdXRmOCIsImIiLCJ0IiwiYyIsImMxIiwiYzIiLCJ2IiwiaiIsIk1sQnl0ZXMiLCJjb250ZW50cyIsImxlbmd0aCIsImNvbnRlbnQiLCJjYW1sX2J5dGVzX29mX2pzYnl0ZXMiLCJjYW1sX3N0cmluZ19vZl9qc2J5dGVzIiwiY2FtbF9yYWlzZV93aXRoX3N0cmluZyIsIm1zZyIsImNhbWxfaW52YWxpZF9hcmd1bWVudCIsImNhbWxfcGFyc2VfZm9ybWF0IiwiZm10IiwiY2FtbF9maW5pc2hfZm9ybWF0dGluZyIsInJhd2J1ZmZlciIsImJ1ZmZlciIsImNhbWxfaW50NjRfZm9ybWF0Iiwid2Jhc2UiLCJjdnRibCIsInAiLCJjYW1sX2V4cG0xX2Zsb2F0IiwieiIsImNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIiwiam9vX2dsb2JhbF9vYmplY3QiLCJjYW1sX2N1cnJlbnRfZGlyIiwiY2FtbF9tYWtlX3BhdGgiLCJuYW1lIiwiY29tcCIsIm5jb21wIiwiY2FtbF9pc19tbF9ieXRlcyIsImNhbWxfaXNfbWxfc3RyaW5nIiwiY2FtbF9ieXRlc19vZl9hcnJheSIsImNhbWxfYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF91dGY4X29mX3V0ZjE2IiwiZCIsImNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmciLCJjYW1sX3N0cmluZ19vZl9qc3N0cmluZyIsImNhbWxfcmFpc2Vfc3lzX2Vycm9yIiwiY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUiLCJjYW1sX2J5dGVzX2JvdW5kX2Vycm9yIiwiY2FtbF9ieXRlc191bnNhZmVfZ2V0IiwiY2FtbF9ieXRlc19nZXQiLCJjYW1sX2NyZWF0ZV9ieXRlcyIsImNhbWxfbWxfYnl0ZXNfbGVuZ3RoIiwiY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IiwiQXJyYXkiLCJjYW1sX2JsaXRfYnl0ZXMiLCJzMSIsImkxIiwiczIiLCJpMiIsImNhbWxfYmxpdF9zdHJpbmciLCJlIiwiTWxGaWxlIiwiTWxGYWtlRmlsZSIsIm9sZCIsImJ1ZiIsInBvcyIsImNsZW4iLCJuZXdfc3RyIiwib2xkX2RhdGEiLCJNbEZha2VEZXZpY2UiLCJyb290IiwicmVzIiwibmFtZV9zbGFzaCIsIlJlZ0V4cCIsInNlZW4iLCJtIiwib2siLCJmaWxlIiwiYnl0ZXMiLCJjYW1sX21sX3N0cmluZ19sZW5ndGgiLCJjYW1sX3N0cmluZ191bnNhZmVfZ2V0IiwiY2FtbF9hcnJheV9vZl9zdHJpbmciLCJjYW1sX2FycmF5X29mX2J5dGVzIiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9ieXRlc19zZXQiLCJNbE5vZGVGaWxlIiwiZmQiLCJyZXF1aXJlIiwiZXJyIiwiYnVmX29mZnNldCIsIk1sTm9kZURldmljZSIsImNvbnN0cyIsImtleSIsIm8iLCJjYW1sX3Jvb3QiLCJmc19ub2RlX3N1cHBvcnRlZCIsImpzb29fbW91bnRfcG9pbnQiLCJyZXNvbHZlX2ZzX2RldmljZSIsInBhdGgiLCJjYW1sX3N5c19pc19kaXJlY3RvcnkiLCJjYW1sX3JhaXNlX25vdF9mb3VuZCIsImNhbWxfc3lzX2dldGVudiIsImciLCJ1bmRlZmluZWQiLCJzaGlmdF9yaWdodF9uYXQiLCJuYXQxIiwib2ZzMSIsImxlbjEiLCJuYXQyIiwib2ZzMiIsIm5iaXRzIiwid3JhcCIsImNhbWxfbmFtZWRfdmFsdWVzIiwiY2FtbF9uYW1lZF92YWx1ZSIsIm5tIiwiY2FtbF9ncl9zdGF0ZSIsImNhbWxfZ3Jfc3RhdGVfZ2V0IiwiY2FtbF9ncl9wb2ludF9jb2xvciIsImltIiwiTWxPYmplY3RUYWJsZSIsIk5haXZlTG9va3VwIiwib2JqcyIsImNhbWxfZmFpbHdpdGgiLCJjYW1sX3N5c19yZW5hbWUiLCJvX3Jvb3QiLCJuX3Jvb3QiLCJjYW1sX2xvZzEwX2Zsb2F0IiwiY2FtbF9ydW50aW1lX3dhcm5pbmdzIiwiY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyIsImJvb2wiLCJjYW1sX2NsYXNzaWZ5X2Zsb2F0IiwiaXNGaW5pdGUiLCJpc05hTiIsImNhbWxfbWxfcmVmaWxsX2lucHV0IiwiY2hhbiIsInN0ciIsInN0cl9sZW4iLCJjYW1sX21sX2NoYW5uZWxzIiwiY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0IiwiY2hhbmlkIiwiY2FtbF9hcnJheV9ib3VuZF9lcnJvciIsImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lIiwiY2FtbF9nY19taW5vciIsImNhbWxfaW50NjRfb2ZfYnl0ZXMiLCJjYW1sX2JhX3VpbnQ4X2dldDY0IiwiYmEiLCJpMCIsIm9mcyIsImIxIiwiYjIiLCJiMyIsImI0IiwiYjUiLCJiNiIsImI3IiwiYjgiLCJjYW1sX2ludDY0X3RvX2J5dGVzIiwiY2FtbF9pbnQ2NF9tYXJzaGFsIiwid3JpdGVyIiwic2l6ZXMiLCJjYW1sX2JhX251bV9kaW1zIiwiY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY3JlYXRlX2ZpbGUiLCJjYW1sX2ZzX2luaXQiLCJ0bXAiLCJjYW1sX3NldF9wYXJzZXJfdHJhY2UiLCJjYW1sX2xpc3Rfb2ZfanNfYXJyYXkiLCJ1bml4X2dldHRpbWVvZmRheSIsIkRhdGUiLCJjYW1sX211bCIsImNhbWxfaGFzaF9taXhfaW50IiwibnVtX2RpZ2l0c19uYXQiLCJuYXQiLCJjYW1sX2hhc2hfbmF0IiwiY2FtbF9jYWxsX2dlbiIsImFyZ3MiLCJhcmdzTGVuIiwiZXh0cmFfYXJncyIsImFyZ3VtZW50cyIsIm5hcmdzIiwiY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc3lzX2NoZGlyIiwiZGlyIiwiY2FtbF9nY19jb3VudGVycyIsImNhbWxfZ3Jfc3luY2hyb25pemUiLCJsb2cyX29rIiwianNvb19mbG9vcl9sb2cyIiwiSW5maW5pdHkiLCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQiLCJmbG9hdDMyYSIsImludDMyYSIsImNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpIiwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IiwiZXhwIiwiayIsInIzIiwicjIiLCJyMSIsImNhbWxfYmFfc2VyaWFsaXplIiwic3oiLCJjb21wbGV4IiwiY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudCIsImtpbmQiLCJjYW1sX2JhX2NyZWF0ZV9idWZmZXIiLCJzaXplIiwidmlldyIsImRhdGEiLCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMiLCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMiLCJOYU4iLCJjYW1sX2JhX2dldF9zaXplIiwiZGltcyIsIm5fZGltcyIsImNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIiwiY2FtbF9pbnQ2NF9oaTMyIiwiY2FtbF9pbnQ2NF9sbzMyIiwiY2FtbF9iYV9jdXN0b21fbmFtZSIsIk1sX0JpZ2FycmF5IiwibGF5b3V0IiwicmUiLCJ0b3RhbCIsImsxIiwiazIiLCJNbF9CaWdhcnJheV9jXzFfMSIsImNhbWxfYmFfY3JlYXRlX3Vuc2FmZSIsInNpemVfcGVyX2VsZW1lbnQiLCJjYW1sX2JhX2Rlc2VyaWFsaXplIiwicmVhZGVyIiwibnVtX2RpbXMiLCJzaXplX2RpbSIsInNpemVfZGltX2hpIiwic2l6ZV9kaW1fbG8iLCJzaXh0eSIsImludDY0IiwiY2FtbF9iYV9jb21wYXJlIiwiY2FtbF9oYXNoX21peF9pbnQ2NCIsImNhbWxfaGFzaF9taXhfZmxvYXQiLCJ2MCIsImNhbWxfYmFfaGFzaCIsIm51bV9lbHRzIiwidyIsImNhbWxfaW50MzJfdW5tYXJzaGFsIiwiY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF91bm1hcnNoYWwiLCJjYW1sX2ludDY0X2NvbXBhcmUiLCJjYW1sX2ludDY0X2hhc2giLCJjYW1sX2N1c3RvbV9vcHMiLCJjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20iLCJjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20iLCJudW0iLCJjdXN0b20iLCJzd2FwIiwiY2FtbF9jb21wYXJlX3ZhbF90YWciLCJOdW1iZXIiLCJjYW1sX2ludF9jb21wYXJlIiwiY2FtbF9ieXRlc19jb21wYXJlIiwiY2FtbF9zdHJpbmdfY29tcGFyZSIsImNhbWxfY29tcGFyZV92YWwiLCJzdGFjayIsInRhZ19hIiwidGFnX2IiLCJjYW1sX2dyZWF0ZXJ0aGFuIiwiZGl2X2hlbHBlciIsImRpdl9kaWdpdF9uYXQiLCJuYXRxIiwib2ZzcSIsIm5hdHIiLCJvZnNyIiwicmVtIiwibnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0Iiwic2hpZnRfbGVmdF9uYXQiLCJNbE5hdCIsImNyZWF0ZV9uYXQiLCJhcnIiLCJzZXRfdG9femVyb19uYXQiLCJpbmNyX25hdCIsImNhcnJ5X2luIiwiY2FycnkiLCJhZGRfbmF0IiwibGVuMiIsIm5hdF9vZl9hcnJheSIsIm11bHRfZGlnaXRfbmF0IiwibmF0MyIsIm9mczMiLCJ4MSIsIngyIiwieDMiLCJkZWNyX25hdCIsImJvcnJvdyIsInN1Yl9uYXQiLCJjb21wYXJlX25hdCIsImRpdl9uYXQiLCJxdW8iLCJjYW1sX2JhX2JsaXQiLCJzcmMiLCJkc3QiLCJpc19kaWdpdF9pbnQiLCJjYW1sX2ludDY0X2RpdiIsImNhbWxfanNfaHRtbF9lbnRpdGllcyIsImVudGl0eSIsInRlbXAiLCJkb2N1bWVudCIsImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQiLCJjYW1sX2ludDY0X29mX2Zsb2F0IiwiY2FtbF9tbF9jaGFubmVsX3NpemVfNjQiLCJjYW1sX2JhX3NldF8yIiwiY2FtbF9hcmd2IiwibWFpbiIsImFyZ3YiLCJhcmdzMiIsImNhbWxfZXhlY3V0YWJsZV9uYW1lIiwiY2FtbF9qc19ldmFsX3N0cmluZyIsImV2YWwiLCJjYW1sX0NhbWxpbnRlcm5hbE1vZF9pbml0X21vZCIsImxvYyIsInNoYXBlIiwidW5kZWZfbW9kdWxlIiwiX3giLCJsb29wIiwic3RydWN0IiwiaWR4Iiwic2VyaWFsaXplX25hdCIsImNhbWxfbWVtcHJvZl9zZXQiLCJfY29udHJvbCIsImNhbWxfc3lzX2V4aXQiLCJjb2RlIiwiY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3IiLCJjYW1sX2pzX2Zyb21fYXJyYXkiLCJjYW1sX2JhX3Jlc2hhcGUiLCJ2aW5kIiwibmV3X2RpbSIsImNhbWxfb29fbGFzdF9pZCIsImNhbWxfc2V0X29vX2lkIiwiY2FtbF9ncl9maWxsX3JlY3QiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYSIsInN0cjEiLCJwb3MxIiwiYmEyIiwicG9zMiIsInNsaWNlIiwiY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlIiwianNuYW1lIiwiY2FtbF9nZXRfZ2xvYmFsX2RhdGEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIiwiY2FtbF9iYV91aW50OF9nZXQxNiIsImNhbWxfY29tcGFyZSIsImNhbWxfZnJlc2hfb29faWQiLCJjYW1sX2ludDY0X3RvX2Zsb2F0IiwiY2FtbF9iYV9nZXRfMSIsImNhbWxfYmlnc3RyaW5nX21lbWNtcCIsImNhbWxfbmV3X3N0cmluZyIsImNhbWxfYmFfdWludDhfZ2V0MzIiLCJjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoIiwiY2FtbF9vYmpfYmxvY2siLCJjYW1sX2dyX2NsZWFyX2dyYXBoIiwiYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciIsImJzIiwiY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZCIsIl91bml0IiwibHhvcl9kaWdpdF9uYXQiLCJjYW1sX2ZpbmFsX3JlbGVhc2UiLCJjYW1sX2pzX3RvX2FycmF5IiwiY2FtbF9ncl9wbG90IiwiY29sb3IiLCJjYW1sX2J5dGVzX3NldDY0IiwiaTY0IiwiY2FtbF9ieXRlc19zZXQxNiIsImkxNiIsImNhbWxfc3RyaW5nX3NldDE2IiwiY2FtbF9pbnQ2NF9ic3dhcCIsImNhbWxfZmlsbF9ieXRlcyIsImNhbWxfZmlsbF9zdHJpbmciLCJjYW1sX2djX21ham9yIiwiY2FtbF9sZXhfYXJyYXkiLCJjYW1sX2xleF9lbmdpbmUiLCJ0YmwiLCJzdGFydF9zdGF0ZSIsImxleGJ1ZiIsImxleF9idWZmZXIiLCJsZXhfYnVmZmVyX2xlbiIsImxleF9zdGFydF9wb3MiLCJsZXhfY3Vycl9wb3MiLCJsZXhfbGFzdF9wb3MiLCJsZXhfbGFzdF9hY3Rpb24iLCJsZXhfZW9mX3JlYWNoZWQiLCJsZXhfYmFzZSIsImxleF9iYWNrdHJrIiwibGV4X2RlZmF1bHQiLCJsZXhfdHJhbnMiLCJsZXhfY2hlY2siLCJzdGF0ZSIsImJhc2UiLCJiYWNrdHJrIiwiY2FtbF9zeXNfZmlsZV9leGlzdHMiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9hcnJheV9zdWIiLCJhMiIsImNhbWxfYnl0ZXNfZXF1YWwiLCJjYW1sX2dyX3NpemVfeCIsImNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfY3lnd2luIiwiY2FtbF9jb3NoX2Zsb2F0IiwiY2FtbF9lcGhlX2tleV9vZmZzZXQiLCJjYW1sX3dlYWtfY2hlY2siLCJjYW1sX2VwaGVfY2hlY2tfa2V5IiwiY2FtbF9oYXNoX21peF9maW5hbCIsImNhbWxfZ3JfdGV4dF9zaXplIiwidHh0IiwiY2FtbF9sZXhfcnVuX21lbSIsIm1lbSIsImN1cnJfcG9zIiwiY2FtbF9sZXhfcnVuX3RhZyIsImNhbWxfbmV3X2xleF9lbmdpbmUiLCJsZXhfbWVtIiwibGV4X2Jhc2VfY29kZSIsImxleF9iYWNrdHJrX2NvZGUiLCJsZXhfZGVmYXVsdF9jb2RlIiwibGV4X3RyYW5zX2NvZGUiLCJsZXhfY2hlY2tfY29kZSIsImxleF9jb2RlIiwicGNfb2ZmIiwicHN0YXRlIiwiYmFzZV9jb2RlIiwiY2FtbF9iYV91aW50OF9zZXQ2NCIsImNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfbGVzc2VxdWFsIiwiY2FtbF9tbF9mbHVzaCIsIm91dHB1dCIsImNhbWxfbWxfc2Vla19vdXRfNjQiLCJjb21wYXJlX25hdF9yZWFsIiwiY2FtbF9nY19zZXQiLCJjYW1sX2pzX2dldCIsImNhbWxfZ2NfY29tcGFjdGlvbiIsImNhbWxfd2Vha19nZXQiLCJjYW1sX2VwaGVfZ2V0X2tleSIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEiLCJ3aW5fY2xlYW51cCIsImNhbWxfc3lzX2Nsb3NlIiwiY2FtbF9tbF9jbG9zZV9jaGFubmVsIiwiY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UiLCJleG4iLCJmb3JjZSIsImNhbWxfc3lzX2lzYXR0eSIsIl9jaGFuIiwiaXNfZGlnaXRfemVybyIsInVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyIsImNhbWxfanNfc2V0IiwiY2FtbF9hcnJheV9nZXQiLCJhcnJheSIsImluZGV4IiwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUiLCJjYW1sX2ludDY0X3N1YiIsImNhbWxfbWxfc2Vla19pbl82NCIsImNhbWxfaW50NjRfc2hpZnRfbGVmdCIsImNhbWxfbm90ZXF1YWwiLCJjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrIiwiY2FtbF9pc19qcyIsImNhbWxfYmFfZGltIiwiY2FtbF9iYV9kaW1fMSIsInVuaXhfbG9jYWx0aW1lIiwiZF9udW0iLCJqYW51YXJ5Zmlyc3QiLCJkb3kiLCJqYW4iLCJqdWwiLCJzdGRUaW1lem9uZU9mZnNldCIsImNhbWxfanNfbWV0aF9jYWxsIiwiY2FtbF93ZWFrX2NyZWF0ZSIsImNhbWxfZXBoZV9jcmVhdGUiLCJjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIiwidW5peF9ta3RpbWUiLCJ0bSIsInRtMiIsImNhbWxfdHJhbXBvbGluZSIsImNhbWxfYnl0ZXNfZ2V0NjQiLCJjYW1sX3dlYWtfc2V0IiwiY2FtbF9zeXNfcmVtb3ZlIiwiY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IiLCJjYW1sX3N0cmluZ19nZXQzMiIsImNhbWxfaHlwb3RfZmxvYXQiLCJjYW1sX2pzX2NhbGwiLCJjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIiwiY2FtbF9lcGhlX3Vuc2V0X2tleSIsImNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyIiwiY2FtbF9oYXNoX21peF9qc2J5dGVzIiwiY2FtbF9oYXNoX21peF9ieXRlcyIsImNhbWxfYnl0ZXNfbGVzc3RoYW4iLCJjYW1sX2dyX2ZpbGxfcG9seSIsImFyIiwiY2FtbF9nY19xdWlja19zdGF0IiwiY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSIsImNhbWxfbWxfaW5wdXRfaW50IiwiY2FtbF9ncl9kaXNwbGF5X21vZGUiLCJudGhfZGlnaXRfbmF0IiwiY2FtbF9hcnJheV9ibGl0IiwiYTEiLCJjYW1sX2Zsb2F0X29mX3N0cmluZyIsIm0zIiwibWFudGlzc2EiLCJwYXJzZUludCIsImV4cG9uZW50IiwiY2FtbF9zeXNfZ2V0Y3dkIiwiY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiIsImNhbWxfbGlzdF90b19qc19hcnJheSIsImNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlIiwiY2FtbF9vdXRwdXRfdmFsIiwiV3JpdGVyIiwidmFsdWUiLCJmbGFncyIsIm5vX3NoYXJpbmciLCJjbG9zdXJlcyIsImludGVybl9vYmpfdGFibGUiLCJtZW1vIiwiZXhpc3Rpbmdfb2Zmc2V0IiwiZXh0ZXJuX3JlYyIsIm9wcyIsInN6XzMyXzY0IiwiaGVhZGVyX3BvcyIsIm9sZF9wb3MiLCJ0eXBlX29mX3YiLCJjYW1sX3N0cmluZ19vZl9hcnJheSIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyIsImNhbWxfcmFpc2Vfbm90X2FfZGlyIiwiY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQiLCJjbWQiLCJ1bml4X2lzYXR0eSIsImZpbGVEZXNjcmlwdG9yIiwidHR5IiwiY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24iLCJkZXNlcmlhbGl6ZV9uYXQiLCJpbml0aWFsaXplX25hdCIsImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3ciLCJqc19wcmludF9zdGRvdXQiLCJjYW1sX2NvcHlzaWduX2Zsb2F0IiwiY2FtbF9ncl9zZXRfdGV4dF9zaXplIiwiY2FtbF9tZDVfYnl0ZXMiLCJhZGQiLCJ4eCIsImZmIiwiZ2ciLCJoaCIsImlpIiwibWQ1IiwiY2FtbF9iYV9zZXRfZ2VuZXJpYyIsImNhbWxfZXBoZV9zZXRfa2V5IiwiY2FtbF9ieXRlc19sZXNzZXF1YWwiLCJjYW1sX3N0cmluZ19sZXNzZXF1YWwiLCJjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwiLCJjYW1sX2ludDY0X2FkZCIsImNhbWxfbmV4dGFmdGVyX2Zsb2F0IiwiYml0cyIsIm9uZSIsImNhbWxfZ3Jfc2l6ZV95IiwiY2FtbF9tbF9wb3NfaW4iLCJjYW1sX2ludDY0X2FuZCIsImNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSIsImNhbWxfc3RkX291dHB1dCIsInNsZW4iLCJqc19wcmludF9zdGRlcnIiLCJjYW1sX3N5c19vcGVuX2ludGVybmFsIiwiaW5mbyIsImNhbWxfc3lzX29wZW4iLCJfcGVybXMiLCJNbFN0cmluZ1JlYWRlciIsImNhbWxfZmxvYXRfb2ZfYnl0ZXMiLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIiwiX21hZ2ljIiwiX2Jsb2NrX2xlbiIsIm51bV9vYmplY3RzIiwiX3NpemVfMzIiLCJfc2l6ZV82NCIsIm9ial9jb3VudGVyIiwiaW50ZXJuX3JlYyIsImhlYWRlciIsImV4cGVjdGVkX3NpemUiLCJjYW1sX3N0cmluZ19vZl9ieXRlcyIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyIsImNhbWxfc3RyaW5nX2dldCIsInJlX21hdGNoIiwicmVfd29yZF9sZXR0ZXJzIiwib3Bjb2RlcyIsImlzX3dvcmRfbGV0dGVyIiwiaW5fYml0c2V0IiwicmVfbWF0Y2hfaW1wbCIsInBhcnRpYWwiLCJwcm9nIiwiY3Bvb2wiLCJub3JtdGFibGUiLCJudW1ncm91cHMiLCJudW1yZWdpc3RlcnMiLCJzdGFydGNoYXJzIiwicGMiLCJxdWl0IiwiZ3JvdXBzIiwicmVfcmVnaXN0ZXIiLCJiYWNrdHJhY2siLCJpdGVtIiwicHVzaCIsImFjY2VwdCIsInJlc3VsdCIsInByZWZpeF9tYXRjaCIsIm9wIiwic2FyZyIsInVhcmciLCJncm91cCIsIkVycm9yIiwicmVfc2VhcmNoX2JhY2t3YXJkIiwiY2FtbF9qc19mcm9tX3N0cmluZyIsImNhbWxfYmFfc3ViIiwiY2hhbmdlZF9kaW0iLCJtdWwiLCJuZXdfZGltcyIsIm5ld19kYXRhIiwiY2FtbF9nY19mdWxsX21ham9yIiwiY2FtbF9ieXRlc19zZXQzMiIsImkzMiIsImNhbWxfZ3Jfc2lnaW9fc2lnbmFsIiwiY2FtbF9iYV91aW50OF9zZXQzMiIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4IiwiY2FtbF9zaWduYml0X2Zsb2F0IiwiY2FtbF9ncl9jdXJyZW50X3giLCJjYW1sX2dyX3NldF9saW5lX3dpZHRoIiwiY2FtbF9ncl9zZXRfZm9udCIsImNhbWxfZ3Jfc2V0X2NvbG9yIiwiY29udmVydCIsIm51bWJlciIsImNfc3RyIiwiY2FtbF9ncl9tb3ZldG8iLCJjYW1sX2dyX3Jlc2l6ZV93aW5kb3ciLCJjYW1sX2dyX3N0YXRlX2luaXQiLCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkiLCJ0YSIsImNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSIsImNhbWxfbWxfc2Vla19vdXQiLCJjYW1sX2pzX3R5cGVvZiIsImNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlIiwiYnQiLCJjYW1sX2dyX2xpbmV0byIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZSIsImNhbWxfYmFfZGltXzMiLCJjYW1sX2VwaGVfZGF0YV9vZmZzZXQiLCJjYW1sX2VwaGVfY2hlY2tfZGF0YSIsImNhbWxfYnl0ZXNfZ2V0MTYiLCJjYW1sX29ial9tYWtlX2ZvcndhcmQiLCJjYW1sX2pzX2Zyb21fYm9vbCIsImNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZSIsImNhbWxfZ3JfY2xvc2VfZ3JhcGgiLCJjYW1sX2NyZWF0ZV9zdHJpbmciLCJjYW1sX21kNV9zdHJpbmciLCJjYW1sX21kNV9jaGFuIiwiY2hhbl9sZW4iLCJjYW1sX29ial9kdXAiLCJjYW1sX3dlYWtfZ2V0X2NvcHkiLCJjYW1sX21sX291dHB1dF9ieXRlcyIsInN0cmluZyIsImpzc3RyaW5nIiwiaWQiLCJjYW1sX21sX291dHB1dCIsImNhbWxfZXBoZV9nZXRfZGF0YSIsImNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlIiwidW5pdCIsImNhbWxfdHJhbXBvbGluZV9yZXR1cm4iLCJjYW1sX2FycmF5X2FwcGVuZCIsImwxIiwibDIiLCJjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbCIsImNhbWxfanNfZXhwciIsImNhbWxfaW50NjRfbXVsIiwiY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQiLCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyIsImNhbWxfaGFzaF91bml2X3BhcmFtIiwiY291bnQiLCJsaW1pdCIsIm9iaiIsImhhc2hfYWNjdSIsImhhc2hfYXV4IiwianNieXRlcyIsImNhbWxfc3RyaW5nX2VxdWFsIiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIiwicmVfcmVwbGFjZW1lbnRfdGV4dCIsInJlcGwiLCJvcmlnIiwiY3VyIiwic3RhcnQiLCJlbmQiLCJjYW1sX3B1cmVfanNfZXhwciIsImJsaXRfbmF0IiwiY2FtbF9pbnQ2NF91bHQiLCJjYW1sX2ludDY0X3hvciIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMiLCJiYTEiLCJieXRlczIiLCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIiwiY2FtbF90b19qc19zdHJpbmciLCJjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UiLCJjYW1sX3BhcnNlX2RpZ2l0IiwiY2FtbF9pbnQ2NF9vZl9zdHJpbmciLCJiYXNlNjQiLCJ0aHJlc2hvbGQiLCJyZV9zZWFyY2hfZm9yd2FyZCIsImNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9tYWtlX3ZlY3QiLCJpbml0IiwiY2FtbF9tbF9zZWVrX2luIiwiY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkiLCJjYW1sX21sX291dHB1dF9jaGFyIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIiwiY2FtbF9vYmpfaXNfYmxvY2siLCJjYW1sX21sX2lucHV0X2NoYXIiLCJjYW1sX29ial9zZXRfcmF3X2ZpZWxkIiwiY2FtbF9qc192YXIiLCJjYW1sX3RydW5jX2Zsb2F0IiwiY2FtbF9lcGhlX2JsaXRfZGF0YSIsImNhbWxfaXNfcHJpbnRhYmxlIiwiY2FtbF9lcXVhbCIsInJlX3BhcnRpYWxfbWF0Y2giLCJjYW1sX3N5c19yYW5kb21fc2VlZCIsIm5vdyIsImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8yIiwid2luX2hhbmRsZV9mZCIsImNhbWxfYmFfdWludDhfc2V0MTYiLCJjYW1sX2pzX2RlbGV0ZSIsImNhbWxfaW50X29mX3N0cmluZyIsImNhbWxfbGlzdF9tb3VudF9wb2ludCIsInByZXYiLCJjYW1sX21hcnNoYWxfY29uc3RhbnRzIiwiY2FtbF9vYmpfcmF3X2ZpZWxkIiwiY2FtbF9qc19lcXVhbHMiLCJiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2dyX2FyY19hdXgiLCJjdHgiLCJjeCIsImN5IiwicnkiLCJyeCIsInJvdCIsInhQb3MiLCJ5UG9zIiwieFBvc19wcmV2IiwieVBvc19wcmV2Iiwic3BhY2UiLCJkZWx0YSIsImNhbWxfZ3JfZmlsbF9hcmMiLCJjYW1sX2JhX3NsaWNlIiwibnVtX2luZHMiLCJzdWJfZGltcyIsImNhbWxfbWFyc2hhbF9kYXRhX3NpemUiLCJnZXQzMiIsImNhbWxfaW5wdXRfdmFsdWUiLCJjYW1sX2JhX2tpbmQiLCJjYW1sX2pzX2Z1bl9jYWxsIiwiY2FtbF9qc19wdXJlX2V4cHIiLCJjb21wYXJlX2RpZ2l0c19uYXQiLCJjYW1sX21sX2lucHV0IiwiY2FtbF9ncl93YWl0X2V2ZW50IiwiX2V2bCIsImNhbWxfZ3Jfc2lnaW9faGFuZGxlciIsImNhbWxfaGFzaF9taXhfYmlnc3RyaW5nIiwiY2FtbF9yZWNvcmRfYmFja3RyYWNlIiwidW5peF9nbXRpbWUiLCJjYW1sX3N5c19nZXRfY29uZmlnIiwiY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlIiwidW5peF90aW1lIiwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdCIsImJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIiLCJhYiIsImNhbWxfbW9kIiwiY2FtbF9iYV9pbml0IiwicmVfc3RyaW5nX21hdGNoIiwiQmlnU3RyaW5nUmVhZGVyIiwiY2FtbF9ncl9kdW1wX2ltYWdlIiwiY2FtbF9iYV9nZXRfZ2VuZXJpYyIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9iYWNrdHJhY2UiLCJjYW1sX2Zvcm1hdF9mbG9hdCIsInRvRml4ZWQiLCJkcCIsInByZWMiLCJjYW1sX21vdW50X2F1dG9sb2FkIiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYSIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nIiwiY2FtbF9zdHJpbmdfbGVzc3RoYW4iLCJjYW1sX3N0cmluZ19ncmVhdGVydGhhbiIsImNhbWxfZGl2IiwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkiLCJjYW1sX21lbXByb2Zfc3RhcnQiLCJyYXRlIiwic3RhY2tfc2l6ZSIsInRyYWNrZXIiLCJjYW1sX3N5c19nZXRfYXJndiIsImNhbWxfanNfdG9fYm9vbCIsImNhbWxfZ3JfY3JlYXRlX2ltYWdlIiwiY2FtbF9lcGhlX2dldF9rZXlfY29weSIsImNhbWxfbGVzc3RoYW4iLCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90IiwiY2FtbF9yZWdpc3Rlcl9nbG9iYWwiLCJuYW1lX29wdCIsIm11bHRfbmF0IiwibGVuMyIsInNxdWFyZV9uYXQiLCJjYW1sX2pzX2Zyb21fZmxvYXQiLCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIiwiY2FtbF9nY19zdGF0IiwiY2FtbF9zeXNfbW9kaWZ5X2FyZ3YiLCJjYW1sX21ldGhvZF9jYWNoZSIsImNhbWxfZ2V0X3B1YmxpY19tZXRob2QiLCJjYWNoZWlkIiwibWV0aHMiLCJsaSIsImNhbWxfanNfZ2V0X2NvbnNvbGUiLCJjYW1sX3N5c191bnNhZmVfZ2V0ZW52IiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4iLCJjaGFubmVsIiwiYmlnc3RyaW5nX29mX3R5cGVkX2FycmF5IiwiY2FtbF9yb3VuZF9mbG9hdCIsImNhbWxfb2pzX25ld19hcnIiLCJGIiwiY29tcGxlbWVudF9uYXQiLCJjYW1sX2pzX3JlZ2V4cHMiLCJjYW1sX2pzX2h0bWxfZXNjYXBlIiwiY2FtbF9iYV9kaW1fMiIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyIsImNhbWxfc2luaF9mbG9hdCIsImNhbWxfbGRleHBfZmxvYXQiLCJjYW1sX2dyX3N0YXRlX3NldCIsImNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QiLCJhcml0eSIsImNhbWxfYmFfc2V0XzEiLCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayIsImxhbmRfZGlnaXRfbmF0IiwiY2FtbF9pbnQ2NF9tb2QiLCJjYW1sX29ial9zZXRfdGFnIiwiY2FtbF9jcmVhdGVfZmlsZV9leHRlcm4iLCJjYW1sX2ludDMyX2Jzd2FwIiwid2luX3N0YXJ0dXAiLCJjYW1sX2JhX3NldF8zIiwiY2FtbF9qc19pbnN0YW5jZW9mIiwiY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmciLCJudGhfZGlnaXRfbmF0X25hdGl2ZSIsInNldF9kaWdpdF9uYXRfbmF0aXZlIiwiZGlnaXQiLCJjYW1sX3N0cmluZ19zZXQ2NCIsImNhbWxfZ3Jfc3RhdGVfY3JlYXRlIiwiY2FudmFzIiwiY29udGV4dCIsImNhbWxfanNfd3JhcF9jYWxsYmFjayIsImNhbWxfZ3JfZHJhd19hcmMiLCJjYW1sX2JhX21hcF9maWxlIiwidmZkIiwic2hhcmVkIiwiY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZSIsImFyZ24iLCJjYW1sX2JhX2NyZWF0ZV9mcm9tIiwiZGF0YTEiLCJkYXRhMiIsImpzdHlwIiwiY2FtbF90YW5oX2Zsb2F0IiwiY2FtbF9ncl9kcmF3X3N0ciIsImR4IiwiY2FtbF9ncl9kcmF3X3N0cmluZyIsImNhbWxfZ3JfZHJhd19jaGFyIiwiY2FtbF91bm1vdW50IiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyIsImNhbWxfbWxfcG9zX2luXzY0IiwiY2FtbF9ncl9kcmF3X2ltYWdlIiwiaW1hZ2UiLCJjYW1sX3JlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSIsIl9jaGFubmVsIiwiY2FtbF9zdHJpbmdfc2V0IiwiY2FtbF9tbF9wb3Nfb3V0IiwiY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCIsImNhbWxfYnl0ZXNfbm90ZXF1YWwiLCJjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyIsImNhbWxfanNfb2JqZWN0IiwiY2FtbF9iYV9jcmVhdGUiLCJkaW1zX21sIiwiY2FtbF93ZWFrX2JsaXQiLCJjYW1sX2dyX3JlbWVtYmVyX21vZGUiLCJjYW1sX2Jzd2FwMTYiLCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZSIsIm1vZGUiLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyIiwiY2FtbF9ncl9kcmF3X3JlY3QiLCJjYW1sX3N0cmluZ19nZXQxNiIsImNhbWxfZXBoZV91bnNldF9kYXRhIiwiY2FtbF9vdXRwdXRfdmFsdWUiLCJjYW1sX2JhX2dldF8zIiwiY2FtbF9lcGhlX2JsaXRfa2V5IiwiY2FtbF9pbml0aWFsX3RpbWUiLCJjYW1sX3N5c190aW1lIiwiY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfaGFzaF9taXhfc3RyaW5nIiwiY2FtbF9oYXNoIiwic2VlZCIsInF1ZXVlIiwicmQiLCJ3ciIsImNhbWxfb2JqX3RhZyIsIkZ1bmN0aW9uIiwiY2FtbF9iYV90b190eXBlZF9hcnJheSIsImNhbWxfanNfZXhwb3J0X3ZhciIsIm1vZHVsZSIsImNhbWxfYnl0ZXNfZ2V0MzIiLCJjYW1sX2ZyZXhwX2Zsb2F0IiwibmVnIiwiY2FtbF9zdHJpbmdfZ2V0NjQiLCJjYW1sX21sX3Bvc19vdXRfNjQiLCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyIsImNhbWxfZmxvYXRhcnJheV9ibGl0IiwiY2FtbF9zZXRfc3RhdGljX2VudiIsImNhbWxfYmFfY2hhbmdlX2xheW91dCIsImNhbWxfanNfbmV3IiwiY2FtbF9ncl9jdXJyZW50X3kiLCJjYW1sX2Zvcm1hdF9pbnQiLCJjYW1sX29ial90cnVuY2F0ZSIsImNhbWxfanNfdG9fc3RyaW5nIiwiaXNfZGlnaXRfb2RkIiwiY2FtbF9ydW50aW1lX3ZhcmlhbnQiLCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQiLCJjYW1sX2FycmF5X2NvbmNhdCIsImNhbWxfZ3Jfb3Blbl9ncmFwaCIsImdldCIsInNwZWNzIiwidGFyZ2V0Iiwic3RhdHVzIiwid2luIiwiZG9jIiwidGl0bGUiLCJib2R5IiwiY2FtbF9lcGhlX3NldF9kYXRhIiwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3QiLCJjYW1sX21lbXByb2Zfc3RvcCIsImNhbWxfZ3JlYXRlcmVxdWFsIiwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UiLCJjYW1sX2xvZzFwX2Zsb2F0IiwiY2FtbF9pbnQ2NF9vciIsImNhbWxfbGF6eV9tYWtlX2ZvcndhcmQiLCJsb3JfZGlnaXRfbmF0IiwiY2FtbF9ncl9ibGl0X2ltYWdlIiwiaW0yIiwiY2FtbF9ncl93aW5kb3dfaWQiLCJjYW1sX2pzX29uX2llIiwidWEiLCJjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IiwiY2FtbF9iYV9sYXlvdXQiLCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImNhbWxfYXJyYXlfc2V0IiwibmV3dmFsIiwiY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwiLCJzZXRfZGlnaXRfbmF0IiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kIiwicmVhbCIsImNhbWxfZ3JfZG9jX29mX3N0YXRlIiwiY2FtbF9tbF9vdXRwdXRfaW50IiwiY2FtbF9vYmpfd2l0aF90YWciLCJjYW1sX21sX2NoYW5uZWxfc2l6ZSIsImNhbWxfcmF3X2JhY2t0cmFjZV9zbG90IiwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQiLCJzdHlsZSIsImV4cF9zaWduIiwic2lnbl9zdHIiLCJjc3QiLCJ4X3N0ciIsImNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCIsImNhbWxfYmFja3RyYWNlX3N0YXR1cyIsImNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlciIsImNhbWxfc3lzX2FyZ3YiLCJjYW1sX2JhX2ZpbGwiLCJjYW1sX21vZGZfZmxvYXQiLCJjYW1sX2djX2dldCIsImNhbWxfZmxvYXRfY29tcGFyZSIsImNhbWxfc3RyaW5nX3NldDMyIiwiY2FtbF9wYXJzZV9lbmdpbmUiLCJ0YWJsZXMiLCJlbnYiLCJFUlJDT0RFIiwidGVzdHNoaWZ0Iiwic2hpZnQiLCJzaGlmdF9yZWNvdmVyIiwicmVkdWNlIiwiUkVBRF9UT0tFTiIsIlJBSVNFX1BBUlNFX0VSUk9SIiwiR1JPV19TVEFDS1NfMSIsIkdST1dfU1RBQ0tTXzIiLCJDT01QVVRFX1NFTUFOVElDX0FDVElPTiIsIkNBTExfRVJST1JfRlVOQ1RJT04iLCJlbnZfc19zdGFjayIsImVudl92X3N0YWNrIiwiZW52X3N5bWJfc3RhcnRfc3RhY2siLCJlbnZfc3ltYl9lbmRfc3RhY2siLCJlbnZfc3RhY2tzaXplIiwiZW52X3N0YWNrYmFzZSIsImVudl9jdXJyX2NoYXIiLCJlbnZfbHZhbCIsImVudl9zeW1iX3N0YXJ0IiwiZW52X3N5bWJfZW5kIiwiZW52X2FzcCIsImVudl9ydWxlX2xlbiIsImVudl9ydWxlX251bWJlciIsImVudl9zcCIsImVudl9zdGF0ZSIsImVudl9lcnJmbGFnIiwidGJsX3RyYW5zbF9jb25zdCIsInRibF90cmFuc2xfYmxvY2siLCJ0YmxfbGhzIiwidGJsX2xlbiIsInRibF9kZWZyZWQiLCJ0YmxfZGdvdG8iLCJ0Ymxfc2luZGV4IiwidGJsX3JpbmRleCIsInRibF9naW5kZXgiLCJ0YmxfdGFibGVzaXplIiwidGJsX3RhYmxlIiwidGJsX2NoZWNrIiwibjEiLCJuMiIsInN0YXRlMSIsInNwIiwiZXJyZmxhZyIsImFzcCIsImNhbWxfYXJyYXlfZmlsbCIsImNhbWxfc3RyaW5nX25vdGVxdWFsIiwiY2FtbF9ieXRlc19ncmVhdGVydGhhbiIsImNhbWxfZ3JfbWFrZV9pbWFnZSIsImNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0IiwiY2FtbF9yZWFkX2ZpbGVfY29udGVudCIsImNhbWxfanNfdG9fZmxvYXQiLCJlcnJfbm9fcHJlZCIsImVycl9ub19zdWNjIiwiemVybyQyIiwib25lJDIiLCJtaW51c19vbmUkMiIsIm1pbl9pbnQkMiIsIm1heF9pbnQkMiIsImR1bW15X3BvcyIsInplcm9fcG9zIiwic3ViX2Zvcm1hdCIsImZvcm1hdHRpbmdfbGl0IiwibG9jZm10IiwibnVsbCQwIiwiY3VycmVudF9kaXJfbmFtZSIsInBhcmVudF9kaXJfbmFtZSIsImRpcl9zZXAiLCJxdW90ZXF1b3RlIiwibnVsbCQxIiwiY3VycmVudF9kaXJfbmFtZSQwIiwicGFyZW50X2Rpcl9uYW1lJDAiLCJkaXJfc2VwJDAiLCJudWxsJDIiLCJjdXJyZW50X2Rpcl9uYW1lJDEiLCJwYXJlbnRfZGlyX25hbWUkMSIsImRpcl9zZXAkMSIsInplcm8kNCIsIm9uZSQ0IiwiaSIsImVyYXNlX3JlbCIsInJlc3QiLCJyZXN0JDAiLCJyZXN0JDEiLCJyZXN0JDIiLCJyZXN0JDMiLCJyZXN0JDQiLCJyZXN0JDUiLCJyZXN0JDYiLCJyZXN0JDciLCJ0eSIsInJlc3QkOCIsInR5MSIsInJlc3QkOSIsInJlc3QkMTAiLCJyZXN0JDExIiwicmVzdCQxMiIsInJlc3QkMTMiLCJjb25jYXRfZm10dHkiLCJmbXR0eTEiLCJmbXR0eTIiLCJ0eTIiLCJjb25jYXRfZm10IiwiZm10MSIsImZtdDIiLCJwYWQiLCJwYWQkMCIsInByZWMiLCJwYWQkMSIsImljb252IiwicHJlYyQwIiwicGFkJDIiLCJpY29udiQwIiwicHJlYyQxIiwicGFkJDMiLCJpY29udiQxIiwicHJlYyQyIiwicGFkJDQiLCJpY29udiQyIiwicHJlYyQzIiwicGFkJDUiLCJmY29udiIsInBhZCQ2Iiwic3RyIiwiY2hyIiwiZm10dHkiLCJwYWQkNyIsImZtdHR5JDAiLCJwYWQkOCIsInJlc3QkMTQiLCJyZXN0JDE1IiwicmVzdCQxNiIsImZtdGluZ19saXQiLCJyZXN0JDE3IiwiZm10aW5nX2dlbiIsInJlc3QkMTgiLCJyZXN0JDE5IiwiY2hhcl9zZXQiLCJ3aWR0aF9vcHQiLCJyZXN0JDIwIiwiY291bnRlciIsInJlc3QkMjEiLCJyZXN0JDIyIiwiaWduIiwicmVzdCQyMyIsImYiLCJhcml0eSIsInYiLCJyIiwiY3VyIiwic2VlbiIsIm4iLCJmYWlsd2l0aCIsInMiLCJpbnZhbGlkX2FyZyIsIm1pbiIsIngiLCJ5IiwibWF4IiwiYWJzIiwibG5vdCIsImluZmluaXR5IiwibmVnX2luZmluaXR5IiwibmFuIiwibWF4X2Zsb2F0IiwibWluX2Zsb2F0IiwiZXBzaWxvbiIsIm1heF9pbnQiLCJtaW5faW50Iiwic3ltYm9sIiwiczEiLCJzMiIsImwxIiwibDIiLCJjaGFyX29mX2ludCIsInN0cmluZ19vZl9ib29sIiwiYiIsImJvb2xfb2Zfc3RyaW5nIiwiYm9vbF9vZl9zdHJpbmdfb3B0Iiwic3RyaW5nX29mX2ludCIsImludF9vZl9zdHJpbmdfb3B0IiwidmFsaWRfZmxvYXRfbGV4ZW0iLCJsIiwiaSQwIiwidG9fc3RyaW5nIiwib2Zfc3RyaW5nX29wdCIsImFwcGVuZCIsInRsIiwiaGQiLCJzdGRpbiIsInN0ZG91dCIsInN0ZGVyciIsIm9wZW5fb3V0X2dlbiIsIm1vZGUiLCJwZXJtIiwibmFtZSIsImMiLCJvcGVuX291dCIsIm9wZW5fb3V0X2JpbiIsImZsdXNoX2FsbCIsIml0ZXIiLCJhIiwib3V0cHV0X2J5dGVzIiwib2MiLCJvdXRwdXRfc3RyaW5nIiwib3V0cHV0Iiwib2ZzIiwibGVuIiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF92YWx1ZSIsImNoYW4iLCJjbG9zZV9vdXQiLCJjbG9zZV9vdXRfbm9lcnIiLCJvcGVuX2luX2dlbiIsIm9wZW5faW4iLCJvcGVuX2luX2JpbiIsImlucHV0IiwiaWMiLCJ1bnNhZmVfcmVhbGx5X2lucHV0Iiwib2ZzJDAiLCJsZW4kMCIsImxlbiQxIiwib2ZzJDEiLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwiaW5wdXRfbGluZSIsImJ1aWxkX3Jlc3VsdCIsImJ1ZiIsImFjY3UiLCJiZWciLCJhY2N1JDAiLCJyZXMiLCJjbG9zZV9pbl9ub2VyciIsInByaW50X2NoYXIiLCJwcmludF9zdHJpbmciLCJwcmludF9ieXRlcyIsInByaW50X2ludCIsInByaW50X2Zsb2F0IiwicHJpbnRfZW5kbGluZSIsInByaW50X25ld2xpbmUiLCJwcmVycl9jaGFyIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfYnl0ZXMiLCJwcmVycl9pbnQiLCJwcmVycl9mbG9hdCIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9uZXdsaW5lIiwicmVhZF9saW5lIiwicmVhZF9pbnQiLCJyZWFkX2ludF9vcHQiLCJyZWFkX2Zsb2F0IiwicmVhZF9mbG9hdF9vcHQiLCJzdHJpbmdfb2ZfZm9ybWF0Iiwic3ltYm9sJDAiLCJzdHIyIiwic3RyMSIsImV4aXRfZnVuY3Rpb24iLCJhdF9leGl0IiwiZl95ZXRfdG9fcnVuIiwib2xkX2V4aXQiLCJuZXdfZXhpdCQwIiwibmV3X2V4aXQiLCJzdWNjZXNzIiwiZG9fYXRfZXhpdCIsImV4aXQiLCJyZXRjb2RlIiwic2V0X2JpbmFyeV9tb2RlX2luIiwiY2xvc2VfaW4iLCJpbl9jaGFubmVsX2xlbmd0aCIsInBvc19pbiIsInNlZWtfaW4iLCJpbnB1dF92YWx1ZSIsImlucHV0X2JpbmFyeV9pbnQiLCJpbnB1dF9ieXRlIiwiaW5wdXRfY2hhciIsInNldF9iaW5hcnlfbW9kZV9vdXQiLCJvdXRfY2hhbm5lbF9sZW5ndGgiLCJwb3Nfb3V0Iiwic2Vla19vdXQiLCJvdXRwdXRfYmluYXJ5X2ludCIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2NoYXIiLCJmbHVzaCIsImVtcHR5IiwicmV0dXJuJDAiLCJjb25zIiwibmV4dCIsImFwcGVuZCQwIiwic2VxMSIsInNlcTIiLCJtYXAiLCJzZXEiLCJmaWx0ZXJfbWFwIiwic2VxJDAiLCJmaWx0ZXIiLCJmbGF0X21hcCQwIiwiZmxhdF9tYXBfYXBwJDAiLCJ0YWlsIiwiZmxhdF9tYXBfYXBwIiwiZmxhdF9tYXAiLCJmb2xkX2xlZnQiLCJhY2MiLCJhY2MkMCIsImFjYyQxIiwidW5mb2xkIiwidSIsInUkMCIsIm5vbmUiLCJzb21lIiwidmFsdWUiLCJvIiwiZGVmYXVsdCQwIiwiZ2V0JDAiLCJiaW5kIiwiam9pbiIsIm1hcCQwIiwiZm9sZCIsIml0ZXIkMCIsImlzX25vbmUiLCJpc19zb21lIiwiZXF1YWwiLCJlcSIsIm8wIiwibzEiLCJ2MSIsInYwIiwiY29tcGFyZSIsImNtcCIsInRvX3Jlc3VsdCIsInRvX2xpc3QiLCJ0b19zZXEiLCJsZWZ0IiwicmlnaHQiLCJpc19sZWZ0IiwiaXNfcmlnaHQiLCJmaW5kX2xlZnQiLCJmaW5kX3JpZ2h0IiwibWFwX2xlZnQiLCJlIiwibWFwX3JpZ2h0IiwibWFwJDEiLCJ2JDAiLCJmb2xkJDAiLCJlcXVhbCQwIiwiZTEiLCJtYXRjaCIsInYyIiwidjIkMCIsImNvbXBhcmUkMCIsIm9rIiwiZXJyb3IiLCJ2YWx1ZSQwIiwiZ2V0X29rIiwiZ2V0X2Vycm9yIiwiYmluZCQwIiwiam9pbiQwIiwibWFwJDIiLCJtYXBfZXJyb3IiLCJmb2xkJDEiLCJpdGVyJDEiLCJpdGVyX2Vycm9yIiwiaXNfb2siLCJpc19lcnJvciIsImVxdWFsJDEiLCJyMCIsImNvbXBhcmUkMSIsInRvX29wdGlvbiIsInRvX2xpc3QkMCIsInRvX3NlcSQwIiwiZXF1YWwkMiIsImNvbXBhcmUkMiIsInRvX2Zsb2F0IiwidG9fc3RyaW5nJDAiLCJlc2NhcGVkIiwicyQwIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibG93ZXJjYXNlX2FzY2lpIiwidXBwZXJjYXNlX2FzY2lpIiwiY29tcGFyZSQzIiwiYzEiLCJjMiIsImVxdWFsJDMiLCJtaW4kMCIsIm1heCQwIiwibG9fYm91bmQiLCJoaV9ib3VuZCIsImJvbSIsInJlcCIsInN1Y2MiLCJwcmVkIiwiaXNfdmFsaWQiLCJvZl9pbnQiLCJpc19jaGFyIiwib2ZfY2hhciIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsImVxdWFsJDQiLCJjb21wYXJlJDQiLCJoYXNoIiwibWF0Y2gkMSIsImxlbmd0aCIsInBhcmFtJDAiLCJjb25zJDAiLCJudGgiLCJsJDAiLCJuJDAiLCJsJDEiLCJuJDEiLCJudGhfb3B0IiwicmV2X2FwcGVuZCIsImwxJDAiLCJsMiQwIiwibDEkMSIsImwyJDEiLCJyZXYiLCJpbml0X2F1eCIsInJldl9pbml0X3RocmVzaG9sZCIsInBhcmFtIiwiYWNjdSQxIiwiYTIiLCJhMSIsInAiLCJwYWlyIiwicmVzdWx0IiwieHMiLCJ4JDAiLCJyeSIsInJ4IiwidDIiLCJoMiIsInQxIiwiaDEiLCJyZXZfc29ydCIsIngyIiwieDEiLCJ0bCQxIiwieDMiLCJ4MiQwIiwieDEkMCIsIm4xIiwibjIiLCJzb3J0IiwidGwkMCIsImMkMCIsImMkMSIsImMkMiIsImMkMyIsImMkNCIsImMkNSIsImMkNiIsImFjY3UkMiIsImF1eCIsImRpcmVjdCIsImRlcHRoIiwic3ltYm9sJDEiLCJkc3RvZmYiLCJzcmNvZmYiLCJjcHlsZW4iLCJvZnMxIiwib2ZzMiIsInNlcCIsInNlcGxlbiIsImRzdCIsImlzX3NwYWNlIiwiaiIsImFwcGx5MSIsImluZGV4X3JlYyIsImxpbSIsImkkMSIsImluZGV4X3JlY19vcHQiLCJyaW5kZXhfcmVjIiwicmluZGV4X3JlY19vcHQiLCJuZXdfbGVuIiwibmV3X2J1ZiIsImlzX3NwYWNlJDAiLCJpbmRleF9yZWMkMCIsImluZGV4X3JlY19vcHQkMCIsInJpbmRleF9yZWMkMCIsInJpbmRleF9yZWNfb3B0JDAiLCJnIiwiZXF1YWwkOCIsImNvbXBhcmUkOCIsInRvX3N0cmluZyQyIiwidG9fYnVmZmVyIiwiYnVmZiIsImZsYWdzIiwiaGVhZGVyX3NpemUiLCJkYXRhX3NpemUiLCJ0b3RhbF9zaXplIiwiZnJvbV9ieXRlcyIsImZyb21fc3RyaW5nIiwiaXNfYmxvY2siLCJkb3VibGVfZmllbGQiLCJzZXRfZG91YmxlX2ZpZWxkIiwibWFyc2hhbCIsIm9iaiIsInVubWFyc2hhbCIsInBvcyIsImZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3RvciIsImxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yXyIsImxhenlfdGFnIiwiY2xvc3VyZV90YWciLCJvYmplY3RfdGFnIiwiaW5maXhfdGFnIiwiZm9yd2FyZF90YWciLCJub19zY2FuX3RhZyIsImFic3RyYWN0X3RhZyIsInN0cmluZ190YWciLCJkb3VibGVfdGFnIiwiZG91YmxlX2FycmF5X3RhZyIsImN1c3RvbV90YWciLCJpbnRfdGFnIiwib3V0X29mX2hlYXBfdGFnIiwidW5hbGlnbmVkX3RhZyIsImluZm8iLCJzdGFydF9lbnYiLCJvZl92YWwiLCJzbG90IiwiaWQiLCJleHRlbnNpb25fY29uc3RydWN0b3IiLCJleHRlbnNpb25fbmFtZSIsImV4dGVuc2lvbl9pZCIsIm1heF9lcGhlX2xlbmd0aCIsImNyZWF0ZSIsImxlbmd0aCQwIiwicmFpc2VfaWZfaW52YWxpZF9vZmZzZXQiLCJtc2ciLCJnZXRfa2V5IiwiZ2V0X2tleV9jb3B5Iiwic2V0X2tleSIsInVuc2V0X2tleSIsImNoZWNrX2tleSIsImJsaXRfa2V5IiwiZTIiLCJvMiIsInN4Iiwic3kiLCJpbml0IiwibGEiLCJsYiIsInJlcyQwIiwibGlzdF9sZW5ndGgiLCJwYXJhbSQxIiwiaGQkMCIsIm1heHNvbiIsImkzMSIsInRyaWNrbGVkb3duIiwidHJpY2tsZSIsImJ1YmJsZWRvd24iLCJidWJibGUiLCJpJDIiLCJlJDAiLCJmYXRoZXIiLCJtZXJnZSIsInNyYzFvZnMiLCJzcmMxbGVuIiwic3JjMiIsInNyYzJvZnMiLCJzcmMybGVuIiwiZHN0b2ZzIiwic3JjMXIiLCJzcmMyciIsInMyJDEiLCJzMSQxIiwiaTEiLCJpMiIsImQiLCJpMiQwIiwiZCQwIiwiczIkMCIsImkxJDAiLCJkJDEiLCJzMSQwIiwiaXNvcnR0byIsInNyY29mcyIsInNvcnR0byIsInQiLCJ6ZXJvIiwib25lIiwibWludXNfb25lIiwiaXNfZmluaXRlIiwiaXNfaW5maW5pdGUiLCJpc19uYW4iLCJwaSIsImlzX2ludGVnZXIiLCJzdWNjJDAiLCJwcmVkJDAiLCJlcXVhbCQ5IiwibWluJDEiLCJtYXgkMSIsIm1pbl9tYXgiLCJtaW5fbnVtIiwibWF4X251bSIsIm1pbl9tYXhfbnVtIiwiaGFzaCQwIiwidW5zYWZlX2ZpbGwiLCJjaGVjayIsIm1ha2UkMiIsImluaXQkMyIsImFwcGVuZCQyIiwiY29uY2F0JDIiLCJobGVuIiwic3ViJDIiLCJjb3B5JDIiLCJmaWxsJDEiLCJibGl0JDIiLCJzcmMiLCJzb2ZzIiwiZG9mcyIsInRvX2xpc3QkMiIsIm9mX2xpc3QkMCIsImgiLCJpdGVyJDYiLCJpdGVyMiQxIiwibWFwJDciLCJtYXAyJDEiLCJpdGVyaSQzIiwibWFwaSQzIiwiZm9sZF9sZWZ0JDIiLCJmb2xkX3JpZ2h0JDEiLCJleGlzdHMkMSIsImZvcl9hbGwkMSIsIm1lbSQxIiwibWVtX2llZWUiLCJzb3J0JDAiLCJzdGFibGVfc29ydCIsInRvX3NlcSQ1IiwidG9fc2VxaSQyIiwib2Zfc2VxJDMiLCJtYXBfdG9fYXJyYXkiLCJtYXBfZnJvbV9hcnJheSIsInplcm8kMCIsIm9uZSQwIiwibWludXNfb25lJDAiLCJhYnMkMCIsIm1heF9pbnQkMCIsIm1pbl9pbnQkMCIsImxvZ25vdCIsImVxdWFsJDEwIiwiY29tcGFyZSQ5IiwidG9fc3RyaW5nJDMiLCJ6ZXJvJDEiLCJvbmUkMSIsIm1pbnVzX29uZSQxIiwic3VjYyQxIiwicHJlZCQxIiwiYWJzJDEiLCJtaW5faW50JDEiLCJtYXhfaW50JDEiLCJsb2dub3QkMCIsInVuc2lnbmVkX3RvX2ludCIsInRvX3N0cmluZyQ0Iiwib2Zfc3RyaW5nX29wdCQwIiwiY29tcGFyZSQxMCIsImVxdWFsJDExIiwidW5zaWduZWRfY29tcGFyZSIsIm0iLCJ1bnNpZ25lZF9kaXYiLCJxIiwidW5zaWduZWRfcmVtIiwic3VjYyQyIiwicHJlZCQyIiwiYWJzJDIiLCJsb2dub3QkMSIsIm1heF9pbnQkMyIsInVuc2lnbmVkX3RvX2ludCQwIiwidG9fc3RyaW5nJDUiLCJvZl9zdHJpbmdfb3B0JDEiLCJjb21wYXJlJDExIiwiZXF1YWwkMTIiLCJ1bnNpZ25lZF9jb21wYXJlJDAiLCJ1bnNpZ25lZF9kaXYkMCIsInVuc2lnbmVkX3JlbSQwIiwiemVybyQzIiwib25lJDMiLCJtaW51c19vbmUkMyIsInN1Y2MkMyIsInByZWQkMyIsImFicyQzIiwibWluX2ludCQzIiwibWF4X2ludCQ0IiwibG9nbm90JDIiLCJ1bnNpZ25lZF90b19pbnQkMSIsInRvX3N0cmluZyQ2Iiwib2Zfc3RyaW5nX29wdCQyIiwiY29tcGFyZSQxMiIsImVxdWFsJDEzIiwidW5zaWduZWRfY29tcGFyZSQxIiwidW5zaWduZWRfZGl2JDEiLCJ1bnNpZ25lZF9yZW0kMSIsImVuZ2luZSIsInRibCIsInN0YXRlIiwibmV3X2VuZ2luZSIsImZyb21fZnVuY3Rpb24iLCJvcHQiLCJzdGgiLCJ3aXRoX3Bvc2l0aW9ucyIsImF1eF9idWZmZXIiLCJsZXhidWYiLCJyZWFkIiwibmV3bGVuIiwibmV3YnVmIiwiZnJvbV9jaGFubmVsIiwiZnJvbV9zdHJpbmckMCIsInNldF9wb3NpdGlvbiIsInBvc2l0aW9uIiwic2V0X2ZpbGVuYW1lIiwiZm5hbWUiLCJsZXhlbWUiLCJzdWJfbGV4ZW1lIiwic3ViX2xleGVtZV9vcHQiLCJzdWJfbGV4ZW1lX2NoYXIiLCJzdWJfbGV4ZW1lX2NoYXJfb3B0IiwibGV4ZW1lX2NoYXIiLCJsZXhlbWVfc3RhcnQiLCJsZXhlbWVfZW5kIiwibGV4ZW1lX3N0YXJ0X3AiLCJsZXhlbWVfZW5kX3AiLCJuZXdfbGluZSIsImxjcCIsImZsdXNoX2lucHV0IiwiZW52IiwiZ3Jvd19zdGFja3MiLCJvbGRzaXplIiwibmV3c2l6ZSIsIm5ld19zIiwibmV3X3YiLCJuZXdfc3RhcnQiLCJuZXdfZW5kIiwiY2xlYXJfcGFyc2VyIiwiY3VycmVudF9sb29rYWhlYWRfZnVuIiwieXlwYXJzZSIsInRhYmxlcyIsInN0YXJ0IiwibGV4ZXIiLCJpbml0X2FzcCIsImluaXRfc3AiLCJpbml0X3N0YWNrYmFzZSIsImluaXRfc3RhdGUiLCJpbml0X2N1cnJfY2hhciIsImluaXRfbHZhbCIsImluaXRfZXJyZmxhZyIsImNtZCIsImFyZyIsImFyZyQwIiwiYXJnJDEiLCJjbWQkMCIsImV4biIsImN1cnJfY2hhciIsInRvayIsInBlZWtfdmFsIiwic3ltYm9sX3N0YXJ0X3BvcyIsInN0IiwiZW4iLCJzeW1ib2xfZW5kX3BvcyIsInJoc19zdGFydF9wb3MiLCJyaHNfZW5kX3BvcyIsInN5bWJvbF9zdGFydCIsInN5bWJvbF9lbmQiLCJyaHNfc3RhcnQiLCJyaHNfZW5kIiwiaXNfY3VycmVudF9sb29rYWhlYWQiLCJwYXJzZV9lcnJvciIsImhlaWdodCIsImhsIiwiaCQwIiwiaHIiLCJiYWwiLCJsciIsImx2IiwibGwiLCJscnIiLCJscnYiLCJscmwiLCJyciIsInJ2IiwicmwiLCJybHIiLCJybHYiLCJybGwiLCJhZGQiLCJzaW5nbGV0b24iLCJhZGRfbWluX2VsZW1lbnQiLCJhZGRfbWF4X2VsZW1lbnQiLCJyaCIsImxoIiwibWluX2VsdCIsIm1pbl9lbHRfb3B0IiwibWF4X2VsdCIsIm1heF9lbHRfb3B0IiwicmVtb3ZlX21pbl9lbHQiLCJyJDAiLCJjb25jYXQiLCJzcGxpdCIsInByZXMiLCJwcmVzJDAiLCJpc19lbXB0eSIsIm1lbSIsInJlbW92ZSIsInVuaW9uIiwicjIiLCJyMSIsInIyJDAiLCJyMSQwIiwiaW50ZXIiLCJzcGxpdF9iaXMiLCJkaXNqb2ludCIsImRpZmYiLCJjb25zX2VudW0iLCJzJDEiLCJlJDEiLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJzdWJzZXQiLCJmb3JfYWxsIiwiZXhpc3RzIiwicHYiLCJwYXJ0aXRpb24iLCJsZiIsImx0IiwicmYiLCJydCIsImNhcmRpbmFsIiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJmaW5kIiwiZmluZF9maXJzdCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0IiwiZmluZF9sYXN0X29wdCIsImZpbmRfb3B0IiwidHJ5X2pvaW4iLCJ0JDAiLCJ2JDEiLCJvZl9saXN0Iiwic3ViIiwibCQzIiwieDAiLCJsJDQiLCJ4MCQwIiwibCQ1IiwieDAkMSIsIm5sIiwibWlkIiwibCQyIiwieDQiLCJhZGRfc2VxIiwib2Zfc2VxIiwic2VxX29mX2VudW0iLCJzbm9jX2VudW0iLCJyZXZfc2VxX29mX2VudW0iLCJ0b19yZXZfc2VxIiwidG9fc2VxX2Zyb20iLCJsb3ciLCJsZCIsImxyZCIsInJkIiwicmxkIiwiZGF0YSIsIm1pbl9iaW5kaW5nIiwibWluX2JpbmRpbmdfb3B0IiwibWF4X2JpbmRpbmciLCJtYXhfYmluZGluZ19vcHQiLCJyZW1vdmVfbWluX2JpbmRpbmciLCJ1cGRhdGUiLCJkYXRhJDAiLCJtYXBpIiwibSQwIiwiYWRkX21pbl9iaW5kaW5nIiwiayIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJmdmQiLCJtJDEiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjcmVhdGUkMCIsImNsZWFyIiwiY29weSQzIiwicHVzaCIsInBvcCIsInBvcF9vcHQiLCJ0b3AiLCJ0b3Bfb3B0IiwibGVuZ3RoJDEiLCJpdGVyJDciLCJmb2xkJDIiLCJ0b19zZXEkNiIsIm9mX3NlcSQ0IiwiY3JlYXRlJDEiLCJjbGVhciQwIiwiY2VsbCIsInBlZWsiLCJjb250ZW50IiwicGVla19vcHQiLCJ0YWtlIiwidGFrZV9vcHQiLCJjb3B5JDQiLCJxX3JlcyIsInByZXYiLCJpc19lbXB0eSQwIiwibGVuZ3RoJDIiLCJpdGVyJDgiLCJmb2xkJDMiLCJ0cmFuc2ZlciIsInExIiwicTIiLCJ0b19zZXEkNyIsImFkZF9zZXEkMCIsIm9mX3NlcSQ1IiwicmFpc2VfdW5kZWZpbmVkIiwiZm9yY2VfbGF6eV9ibG9jayIsImJsayIsImNsb3N1cmUiLCJmb3JjZV92YWxfbGF6eV9ibG9jayIsImZvcmNlIiwibHp2IiwiZm9yY2VfdmFsIiwiZnJvbV9mdW4iLCJmcm9tX3ZhbCIsImlzX3ZhbCIsImNvdW50IiwiZmlsbF9idWZmIiwiZ2V0X2RhdGEiLCJkMTEiLCJhJDAiLCJhJDEiLCJwZWVrX2RhdGEiLCJwZWVrJDAiLCJqdW5rX2RhdGEiLCJqdW5rIiwibmdldF9kYXRhIiwiYWwiLCJucGVlayIsImVtcHR5JDEiLCJpdGVyJDkiLCJzdHJtIiwiZnJvbSIsIm9mX2xpc3QkMSIsIm9mX3N0cmluZyQwIiwib2ZfYnl0ZXMiLCJvZl9jaGFubmVsIiwiaWFwcCIsImljb25zIiwiaXNpbmciLCJsYXBwIiwibGNvbnMiLCJsc2luZyIsInNlbXB0eSIsInNsYXp5IiwiZHVtcF9kYXRhIiwiZHVtcCIsImNyZWF0ZSQyIiwiY29udGVudHMiLCJ0b19ieXRlcyIsInN1YiQzIiwiYmxpdCQzIiwibnRoJDAiLCJsZW5ndGgkMyIsImNsZWFyJDEiLCJyZXNldCIsInJlc2l6ZSIsIm1vcmUiLCJvbGRfcG9zIiwib2xkX2xlbiIsIm5ld19idWZmZXIiLCJhZGRfY2hhciIsImFkZF91dGZfOF91Y2hhciIsInBvcyQwIiwicG9zJDEiLCJhZGRfdXRmXzE2YmVfdWNoYXIiLCJoaSIsImxvIiwiYWRkX3V0Zl8xNmxlX3VjaGFyIiwiYWRkX3N1YnN0cmluZyIsIm9mZnNldCIsIm5ld19wb3NpdGlvbiIsImFkZF9zdWJieXRlcyIsImFkZF9zdHJpbmciLCJhZGRfYnl0ZXMiLCJhZGRfYnVmZmVyIiwiYnMiLCJhZGRfY2hhbm5lbCIsImFscmVhZHlfcmVhZCIsInRvX3JlYWQiLCJhbHJlYWR5X3JlYWQkMCIsInRvX3JlYWQkMCIsIm91dHB1dF9idWZmZXIiLCJhZGRfc3Vic3RpdHV0ZSIsImxpbSQxIiwicHJldmlvdXMiLCJpJDciLCJjdXJyZW50IiwiaSQ4Iiwib3BlbmluZyIsImkkNiIsImxpbSQwIiwiaSQzIiwic3RvcCIsImkkNCIsImkkNSIsImskMiIsImskMCIsImskMSIsIm5leHRfaSIsImlkZW50IiwiaSQ5IiwiaSQxMCIsImkkMTEiLCJ0cnVuY2F0ZSIsInRvX3NlcSQ4IiwidG9fc2VxaSQzIiwiYWRkX3NlcSQxIiwib2Zfc2VxJDYiLCJhZGRfaW50OCIsImFkZF9pbnQxNl9uZSIsImFkZF9pbnQzMl9uZSIsImFkZF9pbnQ2NF9uZSIsImFkZF9pbnQxNl9sZSIsImFkZF9pbnQxNl9iZSIsImFkZF9pbnQzMl9sZSIsImFkZF9pbnQzMl9iZSIsImFkZF9pbnQ2NF9sZSIsImFkZF9pbnQ2NF9iZSIsImNyZWF0ZV9jaGFyX3NldCIsImFkZF9pbl9jaGFyX3NldCIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiY2hhcl9zZXQkMCIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQiLCJmbXQiLCJwYWRfb3B0JDAiLCJwYWRfb3B0JDEiLCJwYWRfb3B0JDIiLCJwYWRfb3B0JDMiLCJwYWRfb3B0JDQiLCJwcmVjX29wdCIsInBhZF9vcHQkNSIsIm5kZWMiLCJwYWRfb3B0JDYiLCJwYWRfb3B0JDciLCJwYWRfb3B0JDgiLCJkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiIsImJ1ZmZlcl9jcmVhdGUiLCJpbml0X3NpemUiLCJidWZmZXJfY2hlY2tfc2l6ZSIsIm92ZXJoZWFkIiwibWluX2xlbiIsIm5ld19zdHIiLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsInN0cl9sZW4iLCJidWZmZXJfY29udGVudHMiLCJjaGFyX29mX2ljb252IiwiY2hhcl9vZl9mY29udiIsImNGIiwiYnByaW50X3BhZHR5IiwicGFkdHkiLCJicHJpbnRfaWdub3JlZF9mbGFnIiwiaWduX2ZsYWciLCJicHJpbnRfcGFkX29wdCIsImJwcmludF9wYWRkaW5nIiwicGFkdHkkMCIsImJwcmludF9wcmVjaXNpb24iLCJicHJpbnRfaWNvbnZfZmxhZyIsImJwcmludF9hbHRpbnRfZm10IiwiYnByaW50X2Zjb252X2ZsYWciLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQiLCJzdHIkMCIsImJwcmludF9jaGFyX2xpdGVyYWwiLCJicHJpbnRfc3RyaW5nX2xpdGVyYWwiLCJicHJpbnRfZm10dHkiLCJzdWJfZm10dHkiLCJzdWJfZm10dHkkMCIsImludF9vZl9jdXN0b21fYXJpdHkiLCJzdHJpbmdfb2ZfZm10IiwiZm10JDEiLCJjaHIkMCIsInN0ciQxIiwiaXNfYWxvbmUkMCIsImlzX2Fsb25lIiwiYWZ0ZXIiLCJiZWZvcmUiLCJqJDAiLCJqJDEiLCJmbXQkMCIsInN5bW0iLCJ0cmFucyIsInJlc3QyIiwicmVzdDIkMCIsInJlc3QyJDEiLCJyZXN0MiQyIiwicmVzdDIkMyIsInJlc3QyJDQiLCJyZXN0MiQ1IiwicmVzdDIkNiIsInJlc3QyJDciLCJyZXN0MiQ4IiwidHkyMiIsInR5MjEiLCJmbXR0eV9yZWxfZGV0IiwiZjQiLCJmMiIsInJlc3QyJDkiLCJyZXN0MiQxMCIsInJlc3QyJDExIiwicmVzdDIkMTIiLCJyZXN0MiQxMyIsImRlIiwiZWQiLCJhZiIsImZhIiwiZGUkMCIsImVkJDAiLCJhZiQwIiwiZmEkMCIsImRlJDEiLCJlZCQxIiwiYWYkMSIsImZhJDEiLCJkZSQyIiwiZWQkMiIsImFmJDIiLCJmYSQyIiwiZGUkMyIsImVkJDMiLCJhZiQzIiwiZmEkMyIsImRlJDQiLCJlZCQ0IiwiYWYkNCIsImZhJDQiLCJkZSQ1IiwiZWQkNSIsImFmJDUiLCJmYSQ1IiwiZGUkNiIsImVkJDYiLCJhZiQ2IiwiZmEkNiIsImRlJDciLCJlZCQ3IiwiYWYkNyIsImZhJDciLCJkZSQ4IiwiZWQkOCIsImFmJDgiLCJmYSQ4IiwiamQiLCJkaiIsImdhIiwiYWciLCJkZSQ5IiwiZWQkOSIsImFmJDkiLCJmYSQ5IiwiZGUkMTAiLCJlZCQxMCIsImFmJDEwIiwiZmEkMTAiLCJkZSQxMSIsImVkJDExIiwiYWYkMTEiLCJmYSQxMSIsImRlJDEyIiwiZWQkMTIiLCJhZiQxMiIsImZhJDEyIiwiZGUkMTMiLCJlZCQxMyIsImFmJDEzIiwiZmEkMTMiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IiwiZm10dHlfb2ZfY3VzdG9tIiwiYXJpdHkkMCIsImZtdHR5X29mX2ZtdCIsInR5X3Jlc3QiLCJwcmVjX3R5IiwidHlfcmVzdCQwIiwicHJlY190eSQwIiwidHlfcmVzdCQxIiwicHJlY190eSQxIiwidHlfcmVzdCQyIiwicHJlY190eSQyIiwidHlfcmVzdCQzIiwicHJlY190eSQzIiwiZm10dHkkMSIsImZtdHR5JDIiLCJmbXR0eSQzIiwidHkkMCIsImZtdHR5JDQiLCJmbXR0eSQ1IiwidHlwZV9wYWRkaW5nIiwidyIsInR5cGVfcGFkcHJlYyIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aSIsInR5cGVfZm9ybWF0X2dlbiIsImZtdHR5X3Jlc3QiLCJzdWJfZm10dHlfcmVzdCIsInN1Yl9mbXR0eV9yZXN0JDAiLCJmbXR0eV9yZXN0JDAiLCJzdWJfZm10dHlfcmVzdCQxIiwic3ViX2ZtdHR5X3Jlc3QkMiIsImZtdHR5X3Jlc3QkMSIsInN1Yl9mbXR0eV9yZXN0JDMiLCJmbXQkMiIsInN1Yl9mbXR0eV9yZXN0JDQiLCJmbXR0eV9yZXN0JDIiLCJzdWJfZm10dHlfcmVzdCQ1IiwiZm10JDMiLCJzdWJfZm10dHlfcmVzdCQ2IiwiZm10dHlfcmVzdCQzIiwic3ViX2ZtdHR5X3Jlc3QkNyIsImZtdCQ0Iiwic3ViX2ZtdHR5X3Jlc3QkOCIsImZtdHR5X3Jlc3QkNCIsInN1Yl9mbXR0eV9yZXN0JDkiLCJmbXQkNSIsInN1Yl9mbXR0eV9yZXN0JDEwIiwiZm10dHlfcmVzdCQ1Iiwic3ViX2ZtdHR5X3Jlc3QkMTEiLCJmbXQkNiIsInN1Yl9mbXR0eV9yZXN0JDEyIiwiZm10dHlfcmVzdCQ2Iiwic3ViX2ZtdHR5X3Jlc3QkMTMiLCJmbXQkNyIsInN1Yl9mbXR0eV9yZXN0JDE0IiwiZm10dHlfcmVzdCQ3Iiwic3ViMl9mbXR0eSIsInN1Yl9mbXR0eV9yZXN0JDE1Iiwic3ViMl9mbXR0eSQwIiwiZm10JDgiLCJzdWJfZm10dHlfcmVzdCQxNiIsImZtdHR5X3Jlc3QkOCIsInN1YjJfZm10dHkkMSIsInN1YjFfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNyIsInN1YjJfZm10dHkkMiIsInN1YjFfZm10dHkkMCIsImZtdCQ5Iiwic3ViX2ZtdHR5X3Jlc3QkMTgiLCJmbXR0eV9yZXN0JDkiLCJzdWJfZm10dHlfcmVzdCQxOSIsImZtdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDIwIiwiZm10dHlfcmVzdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDIxIiwiZm10JDExIiwic3ViX2ZtdHR5X3Jlc3QkMjIiLCJmbXR0eV9yZXN0JDExIiwic3ViX2ZtdHR5X3Jlc3QkMjMiLCJmbXQkMTIiLCJzdWJfZm10dHlfcmVzdCQyNCIsImZtdHR5X3Jlc3QkMTIiLCJzdWJfZm10dHlfcmVzdCQyNSIsImZtdCQxMyIsInN1Yl9mbXR0eV9yZXN0JDI2IiwiZm10X3Jlc3QiLCJmbXRfcmVzdCQwIiwiZm10X3Jlc3QkMSIsImZtdF9yZXN0JDIiLCJmbXRfcmVzdCQzIiwiZm10X3Jlc3QkNCIsImZtdF9yZXN0JDUiLCJwcmVjJDQiLCJmbXR0eSQ2IiwiZm10X3Jlc3QkNiIsInByZWMkNSIsInByZWMkNiIsImZtdHR5JDciLCJmbXRfcmVzdCQ3IiwicHJlYyQ3IiwicHJlYyQ4IiwiZm10dHkkOCIsImZtdF9yZXN0JDgiLCJmbXR0eSQ5IiwiZm10X3Jlc3QkOSIsImZtdHR5JDEwIiwiZm10X3Jlc3QkMTAiLCJmbXR0eSQxMSIsImZtdF9yZXN0JDExIiwiZm10dHkkMTIiLCJmbXRfcmVzdCQxMiIsImZtdHR5JDEzIiwic3ViX2ZtdHR5MSIsImZtdF9yZXN0JDEzIiwic3ViX2ZtdHR5JDEiLCJmbXR0eSQxNCIsImZtdCQxNCIsImZtdF9yZXN0JDE0IiwiZm10dHkkMTUiLCJmbXQkMTUiLCJmbXRfcmVzdCQxNSIsImZtdHR5JDE2IiwiZm10JDE2IiwiZm10X3Jlc3QkMTYiLCJmbXR0eSQxNyIsImZtdCQxNyIsImZtdF9yZXN0JDE3IiwiZm9ybWF0dGluZ19nZW4iLCJmbXR0eTMiLCJmbXQzIiwiZm10MSQwIiwiZm10dHkyJDAiLCJmbXQyJDAiLCJmbXR0eTMkMCIsImZtdDMkMCIsImZtdHR5X3Jlc3QkMTMiLCJmbXRfcmVzdCQxOCIsImZtdHR5JDE4IiwiZm10JDE4IiwiZm10dHlfcmVzdCQxNCIsImZtdF9yZXN0JDE5IiwiZm10dHkkMTkiLCJmbXQkMTkiLCJmbXR0eV9yZXN0JDE1IiwiZm10X3Jlc3QkMjAiLCJmbXR0eSQyMCIsImZtdCQyMCIsInR5cGVfaWdub3JlZF9wYXJhbV9vbmUiLCJmbXR0eV9yZXN0JDE2IiwiZm10dHkkMjEiLCJmbXQkMjEiLCJzdWJfZm10dHkkMiIsInN1Yl9mbXR0eSQzIiwiZm10dHkkMjIiLCJmbXQkMjIiLCJzdWJfZm10dHkkNCIsInR5cGVfZm9ybWF0IiwicmVjYXN0IiwiZml4X3BhZGRpbmciLCJ3aWR0aCQwIiwiZml4X2ludF9wcmVjaXNpb24iLCJyZXMkMSIsInN0cmluZ190b19jYW1sX3N0cmluZyIsImZvcm1hdF9vZl9mY29udiIsInN5bWIiLCJ0cmFuc2Zvcm1faW50X2FsdCIsImRpZ2l0cyIsInB1dCIsImNvbnZlcnRfaW50IiwiY29udmVydF9pbnQzMiIsImNvbnZlcnRfbmF0aXZlaW50IiwiY29udmVydF9pbnQ2NCIsImNvbnZlcnRfZmxvYXQiLCJoZXgiLCJzaWduIiwiY2FtbF9zcGVjaWFsX3ZhbCIsInN0cmluZ19vZl9mbXR0eSIsIm1ha2VfcHJpbnRmJDAiLCJuZXdfYWNjIiwibWFrZV9wcmludGYiLCJtYWtlX3BhZGRpbmciLCJtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiIsInAkMCIsInAkMSIsImFjYyQyIiwiYWNjJDMiLCJhY2MkNCIsImskMyIsImthY2MiLCJrJDQiLCJtYWtlX2lnbm9yZWRfcGFyYW0kMCIsIm1ha2VfY3VzdG9tJDAiLCJtYWtlX2ludmFsaWRfYXJnIiwibWFrZV9mcm9tX2ZtdHR5JDAiLCJtYWtlX2Zyb21fZm10dHkiLCJtYWtlX2N1c3RvbSIsIm1ha2VfaWdub3JlZF9wYXJhbSIsIm1ha2VfaXByaW50ZiQwIiwibWFrZV9pcHJpbnRmIiwiZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24iLCJrb2MiLCJyZXN0JDI0IiwicmVzdCQyNSIsImZuX29mX2N1c3RvbV9hcml0eSQwIiwiZm5fb2ZfY3VzdG9tX2FyaXR5Iiwib3V0cHV0X2FjYyIsInAkMiIsInAkMyIsInAkNCIsImJ1ZnB1dF9hY2MiLCJzdHJwdXRfYWNjIiwiZmFpbHdpdGhfbWVzc2FnZSIsIm9wZW5fYm94X29mX3N0cmluZyIsImludmFsaWRfYm94IiwicGFyc2Vfc3BhY2VzIiwicGFyc2VfbHdvcmQiLCJwYXJzZV9pbnQiLCJ3c3RhcnQiLCJ3ZW5kIiwiYm94X25hbWUiLCJuc3RhcnQiLCJuZW5kIiwiaW5kZW50IiwiZXhwX2VuZCIsImJveF90eXBlIiwibWFrZV9wYWRkaW5nX2ZtdF9lYmIiLCJtYWtlX3BhZHByZWNfZm10X2ViYiIsImZtdF9lYmJfb2Zfc3RyaW5nIiwibGVnYWN5X2JlaGF2aW9yIiwiZmxhZyIsImxlZ2FjeV9iZWhhdmlvciQwIiwiaW52YWxpZF9mb3JtYXRfbWVzc2FnZSIsInVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCIsImVuZF9pbmQiLCJpbnZhbGlkX2Zvcm1hdF93aXRob3V0IiwiZXhwZWN0ZWRfY2hhcmFjdGVyIiwiZXhwZWN0ZWQiLCJhZGRfbGl0ZXJhbCIsImxpdF9zdGFydCIsInNpemUiLCJwYXJzZV9wb3NpdGl2ZSIsInN0cl9pbmQkMCIsInN0cl9pbmQkMSIsInBhcnNlX2ludGVnZXIiLCJuZXh0X2luZCIsImluY29tcGF0aWJsZV9mbGFnIiwicGN0X2luZCIsIm9wdGlvbiIsInN1YmZtdCIsImNvbXB1dGVfaW50X2NvbnYiLCJwbHVzIiwic3BhY2UiLCJwbHVzJDAiLCJzcGFjZSQwIiwic2VhcmNoX3N1YmZvcm1hdF9lbmQiLCJzdWJfZW5kIiwic3RyX2luZCQyIiwic3ViX2VuZCQwIiwic3RyX2luZCQzIiwic3ViX2VuZCQxIiwic3RyX2luZCQ0Iiwic3RyX2luZCQ1Iiwic3ViX2VuZCQyIiwic3RyX2luZCQ2Iiwic3RyX2luZCQ3IiwicGFyc2VfbWFnaWNfc2l6ZSIsInN0cl9pbmRfMSIsInN0cl9pbmRfMiIsInN0cl9pbmRfMyIsInBhcnNlIiwicGFyc2VfZ29vZF9icmVhayIsImZvcm1hdHRpbmdfbGl0JDAiLCJzdHJfaW5kXzQiLCJzdHJfaW5kXzUiLCJwYXJzZV90YWciLCJpc19vcGVuX3RhZyIsImluZCIsInN1Yl9zdHIiLCJzdWJfZm10Iiwic3ViX2Zvcm1hdCQwIiwiZm9ybWF0dGluZyQwIiwiZm9ybWF0dGluZyIsInBhcnNlX2ZsYWdzIiwibWludXMiLCJzZXRfZmxhZyIsIm5ld19pbmQiLCJwYXJzZV9hZnRlcl9wYWRkaW5nIiwicGFyc2VfbGl0ZXJhbCIsInBhcnNlX2FmdGVyX3ByZWNpc2lvbiIsInN5bWIkMCIsIm1pbnVzJDAiLCJwYXJzZV9jb252ZXJzaW9uIiwicGFyc2VfY29udiIsInBhZHByZWMiLCJwbHVzX3VzZWQiLCJoYXNoX3VzZWQiLCJzcGFjZV91c2VkIiwiaWduX3VzZWQiLCJwYWRfdXNlZCIsInByZWNfdXNlZCIsImdldF9wbHVzIiwiZ2V0X2hhc2giLCJnZXRfc3BhY2UiLCJnZXRfaWduIiwiZ2V0X3BhZCIsImdldF9wcmVjIiwiZ2V0X3BhZHByZWMiLCJnZXRfaW50X3BhZCIsImNoZWNrX25vXzAiLCJvcHRfb2ZfcGFkIiwid2lkdGgkMSIsImdldF9wYWRfb3B0IiwiZ2V0X3BhZHByZWNfb3B0IiwiZm10X3Jlc3VsdCIsImlnbm9yZWQkMiIsImNvdW50ZXIkMCIsImlnbm9yZWQkNiIsImlnbm9yZWQkNyIsImFkZF9yYW5nZSIsImZhaWxfc2luZ2xlX3BlcmNlbnQiLCJwYXJzZV9jaGFyX3NldF9jb250ZW50IiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciQwIiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciIsInJldmVyc2UiLCJjaGFyX3NldCQxIiwiaWdub3JlZCQ5IiwiY2hhcl9mb3JtYXQiLCJmbXRfcmVzdCQyMSIsImZtdF9yZXN0JDIyIiwicGFkJDkiLCJmbXRfcmVzdCQyMyIsImlnbm9yZWQkMTAiLCJmbXRfcmVzdCQyNCIsInBhZCQxMCIsImZtdF9yZXN0JDI1Iiwic3ViX2ZtdCQwIiwiZm10X3Jlc3QkMjYiLCJpZ25vcmVkJDExIiwiaWdub3JlZCQzIiwiaWdub3JlZCQ1IiwiaWdub3JlZCQ4Iiwic3BhY2UkMSIsImhhc2gkMSIsInBsdXMkMiIsImtpbmQiLCJpZ25vcmVkJDQiLCJpZ25vcmVkIiwiaWdub3JlZCQwIiwiaWdub3JlZCQxIiwicGx1cyQxIiwiaWduJDAiLCJmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IiwiZm9ybWF0X29mX3N0cmluZ19mb3JtYXQiLCJrZnByaW50ZiIsImticHJpbnRmIiwiaWtmcHJpbnRmIiwiZnByaW50ZiIsImJwcmludGYiLCJpZnByaW50ZiIsImlicHJpbnRmIiwicHJpbnRmIiwiZXByaW50ZiIsImtzcHJpbnRmIiwic3ByaW50ZiIsImFzc29jMyIsInkyIiwieTEiLCJzcGxpdCQwIiwibWFrZV9zeW1saXN0IiwicHJlZml4Iiwic3VmZml4IiwiaGVscF9hY3Rpb24iLCJhZGRfaGVscCIsInNwZWNsaXN0IiwiYWRkMiIsInVzYWdlX2IiLCJlcnJtc2ciLCJkb2MiLCJzcGVjIiwia2V5IiwidXNhZ2Vfc3RyaW5nIiwidXNhZ2UiLCJib29sX29mX3N0cmluZ19vcHQkMCIsImludF9vZl9zdHJpbmdfb3B0JDAiLCJmbG9hdF9vZl9zdHJpbmdfb3B0IiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfIiwiYWxsb3dfZXhwYW5kIiwiYXJndiIsImFub25mdW4iLCJpbml0cG9zIiwiY29udmVydF9lcnJvciIsInByb2duYW1lIiwiZm9sbG93JDAiLCJhY3Rpb24iLCJrZXl3b3JkIiwibm9fYXJnJDAiLCJmb2xsb3ciLCJub19hcmciLCJnZXRfYXJnJDAiLCJnZXRfYXJnIiwiY29uc3VtZV9hcmckMCIsImNvbnN1bWVfYXJnIiwidHJlYXRfYWN0aW9uJDAiLCJ0cmVhdF9hY3Rpb24iLCJmJDAiLCJmJDEiLCJyJDEiLCJmJDIiLCJyJDIiLCJhcmckMiIsImYkMyIsImFyZyQzIiwieCQxIiwiciQzIiwiYXJnJDQiLCJ4JDIiLCJzcGVjcyIsImYkNCIsImFyZyQ1IiwiZiQ1IiwiZiQ2IiwiZiQ3IiwiYXJnJDYiLCJuZXdhcmciLCJwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyIsInBhcnNlX2FyZ3ZfZHluYW1pYyIsImN1cnJlbnQkMCIsInBhcnNlX2FyZ3YiLCJtc2ckMCIsIm1zZyQxIiwicGFyc2VfZHluYW1pYyIsInBhcnNlX2V4cGFuZCIsInNlY29uZF93b3JkIiwibG9vcCIsIm1heF9hcmdfbGVuIiwia3dkIiwicmVwbGFjZV9sZWFkaW5nX3RhYiIsImFsaWduIiwibGltaXQiLCJjb21wbGV0ZWQiLCJrc2QiLCJjdXRjb2wkMCIsInNwYWNlcyQwIiwiY3V0Y29sIiwia3dkX2xlbiIsInNwYWNlcyIsInJlYWRfYXV4IiwidHJpbSIsImZpbGUiLCJ3b3JkcyIsInN0YXNoIiwid29yZCIsInJlYWRfYXJnIiwicmVhZF9hcmcwIiwid3JpdGVfYXV4IiwiYXJncyIsIndyaXRlX2FyZyIsIndyaXRlX2FyZzAiLCJwcmludGVycyIsImZpZWxkIiwib3RoZXJfZmllbGRzIiwidXNlX3ByaW50ZXJzIiwiY29udiIsInRvX3N0cmluZ19kZWZhdWx0IiwiY2hhciQwIiwibGluZSIsImNoYXIkMSIsImxpbmUkMCIsImZpbGUkMCIsImNoYXIkMiIsImxpbmUkMSIsImZpbGUkMSIsImNvbnN0cnVjdG9yIiwidG9fc3RyaW5nJDciLCJwcmludCIsImZjdCIsImNhdGNoJDAiLCJyYXdfYmFja3RyYWNlX2VudHJpZXMiLCJidCIsImNvbnZlcnRfcmF3X2JhY2t0cmFjZSIsImZvcm1hdF9iYWNrdHJhY2Vfc2xvdCIsImlzX3JhaXNlIiwicHJpbnRfcmF3X2JhY2t0cmFjZSIsIm91dGNoYW4iLCJyYXdfYmFja3RyYWNlIiwiYmFja3RyYWNlIiwicHJpbnRfYmFja3RyYWNlIiwicmF3X2JhY2t0cmFjZV90b19zdHJpbmciLCJiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSIsImJhY2t0cmFjZV9zbG90X2lzX2lubGluZSIsImJhY2t0cmFjZV9zbG90X2xvY2F0aW9uIiwiYmFja3RyYWNlX3Nsb3RfZGVmbmFtZSIsImJhY2t0cmFjZV9zbG90cyIsImJhY2t0cmFjZV9zbG90c19vZl9yYXdfZW50cnkiLCJlbnRyeSIsInJhd19iYWNrdHJhY2VfbGVuZ3RoIiwiZ2V0X2JhY2t0cmFjZSIsInJlZ2lzdGVyX3ByaW50ZXIiLCJmbiIsIm9sZF9wcmludGVycyIsIm5ld19wcmludGVycyIsImV4bl9zbG90IiwiZXhuX3Nsb3RfaWQiLCJleG5fc2xvdF9uYW1lIiwiZXJyb3JzIiwiZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuIiwic3RhdHVzIiwidW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJjb25zdCQwIiwiZmxpcCIsIm5lZ2F0ZSIsInByb3RlY3QiLCJmaW5hbGx5JDAiLCJ3b3JrIiwiZmluYWxseV9ub19leG4iLCJ3b3JrX2V4biIsIndvcmtfYnQiLCJwcmludF9zdGF0IiwiYWxsb2NhdGVkX2J5dGVzIiwibWEiLCJwcm8iLCJtaSIsImNyZWF0ZV9hbGFybSIsImRlbGV0ZV9hbGFybSIsIm51bGxfdHJhY2tlciIsInNhbXBsaW5nX3JhdGUiLCJ0cmFja2VyIiwiY2FsbHN0YWNrX3NpemUiLCJzdHJpbmciLCJieXRlcyIsInN1YnN0cmluZyIsInN1YmJ5dGVzIiwiZmlsZW5hbWUiLCJvdXRwdXQkMCIsImRpZ2VzdCIsImlucHV0JDAiLCJjaGFyX2hleCIsInRvX2hleCIsImZyb21faGV4IiwiZGlnaXQiLCJuZXdfc3RhdGUiLCJhc3NpZ24iLCJzdDEiLCJzdDIiLCJmdWxsX2luaXQiLCJzZWVkIiwic2VlZCQwIiwibWFrZSQzIiwibWFrZV9zZWxmX2luaXQiLCJjb3B5JDUiLCJiaXRzIiwiY3VydmFsIiwibmV3dmFsIiwibmV3dmFsMzAiLCJpbnQkMCIsImJvdW5kIiwiaW50MzIiLCJiMSIsImIyIiwiaW50NjQiLCJiMyIsIm5hdGl2ZWludCIsImZsb2F0JDAiLCJib29sIiwiYml0cyQwIiwiaW50JDEiLCJpbnQzMiQwIiwibmF0aXZlaW50JDAiLCJpbnQ2NCQwIiwiZmxvYXQkMSIsInNjYWxlIiwiYm9vbCQwIiwiZnVsbF9pbml0JDAiLCJpbml0JDQiLCJzZWxmX2luaXQiLCJnZXRfc3RhdGUiLCJzZXRfc3RhdGUiLCJvbmdvaW5nX3RyYXZlcnNhbCIsImZsaXBfb25nb2luZ190cmF2ZXJzYWwiLCJwYXJhbXMiLCJyYW5kb21pemVkX2RlZmF1bHQiLCJyYW5kb21pemVkIiwicmFuZG9taXplIiwiaXNfcmFuZG9taXplZCIsInBybmciLCJwb3dlcl8yX2Fib3ZlIiwiY3JlYXRlJDMiLCJpbml0aWFsX3NpemUiLCJyYW5kb20iLCJjbGVhciQyIiwicmVzZXQkMCIsImNvcHlfYnVja2V0bGlzdCIsImtleSQwIiwibmV4dCQwIiwiY29weSQ2IiwibGVuZ3RoJDQiLCJpbnNlcnRfYWxsX2J1Y2tldHMiLCJpbmRleGZ1biIsImlucGxhY2UiLCJvZGF0YSIsIm5kYXRhIiwibnNpemUiLCJuZGF0YV90YWlsIiwiY2VsbCQwIiwibmlkeCIsIm1hdGNoJDAiLCJyZXNpemUkMCIsIm9zaXplIiwiaXRlciQxMCIsImRvX2J1Y2tldCIsIm9sZF90cmF2IiwiZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCIsImZpbHRlcl9tYXBfaW5wbGFjZSIsImZvbGQkNCIsImIkMCIsImJ1Y2tldF9sZW5ndGgiLCJzdGF0cyIsIm1ibCIsImhpc3RvIiwidG9fc2VxJDkiLCJ0YmxfZGF0YSIsImJ1Y2siLCJidWNrJDAiLCJidWNrJDEiLCJ0b19zZXFfa2V5cyIsInRvX3NlcV92YWx1ZXMiLCJrZXlfaW5kZXgiLCJidWNrZXQiLCJrMSIsIm5leHQxIiwiazIiLCJuZXh0MiIsImszIiwiZDMiLCJuZXh0MyIsImZpbmRfYWxsIiwiZmluZF9pbl9idWNrZXQiLCJyZXBsYWNlIiwicmVwbGFjZV9zZXEiLCJjb3B5Iiwic3oiLCJoYXNoX3BhcmFtIiwic2VlZGVkX2hhc2giLCJhZGQkMCIsImZpbmQkMCIsImZpbmRfb3B0JDAiLCJmaW5kX2FsbCQwIiwibWVtJDIiLCJhZGRfc2VxJDIiLCJvZl9zZXEkNyIsInJlYnVpbGQiLCJ3ZWFrX2NyZWF0ZSIsImxlbmd0aCQ1IiwicmFpc2VfaWZfaW52YWxpZF9vZmZzZXQkMCIsInNldCQwIiwiZ2V0JDEiLCJnZXRfY29weSIsImNoZWNrJDAiLCJibGl0JDQiLCJmaWxsJDIiLCJhciIsImVtcHR5YnVja2V0IiwiZ2V0X2luZGV4Iiwic3okMCIsInN6JDEiLCJjb3VudF9idWNrZXQiLCJhZGRfYXV4Iiwic2V0dGVyIiwiaW5kZXgiLCJidWNrZXQkMCIsImhhc2hlcyIsIm5ld3N6IiwibmV3YnVja2V0JDAiLCJuZXdoYXNoZXMiLCJoYnVja2V0IiwicHJldl9sZW4iLCJsaXZlIiwiaiQyIiwibmV3YnVja2V0IiwibmV3dCIsIm9iIiwib2giLCJzZXR0ZXIkMCIsIm5iIiwibmkiLCJmaW5kX29yIiwiaWZub3Rmb3VuZCIsImZpbmRfc2hhZG93IiwiaWZmb3VuZCIsImxlbnMiLCJ0b3RsZW4iLCJpZCQwIiwidW5rbm93biIsInBwX2VucXVldWUiLCJ0b2tlbiIsInBwX2luZmluaXR5IiwicHBfb3V0cHV0X3N0cmluZyIsInBwX291dHB1dF9uZXdsaW5lIiwiZm9ybWF0X3BwX3RleHQiLCJ0ZXh0IiwiZm9ybWF0X3N0cmluZyIsImJyZWFrX25ld19saW5lIiwicmVhbF9pbmRlbnQiLCJicmVha19saW5lIiwiYnJlYWtfc2FtZV9saW5lIiwiYWR2YW5jZV9sZWZ0Iiwic2l6ZSQwIiwicGVuZGluZ19jb3VudCIsInNpemUkMSIsInRhYnMiLCJhZGRfdGFiIiwibHMiLCJ0YWdfbmFtZSIsIm1hcmtlciIsImJyZWFrcyIsImZpdHMiLCJvZmYiLCJib3hfdHlwZSQwIiwib2ZmJDAiLCJpbnNlcnRpb25fcG9pbnQiLCJ0YWJzJDAiLCJmaXJzdCIsImhlYWQiLCJ0YWIiLCJvZmYkMSIsImluc2VydGlvbl9wb2ludCQwIiwid2lkdGgkMiIsImJveF90eXBlJDEiLCJ0Ym94IiwidGFnX25hbWUkMCIsIm1hcmtlciQwIiwiZW5xdWV1ZV9hZHZhbmNlIiwiZW5xdWV1ZV9zdHJpbmdfYXMiLCJpbml0aWFsaXplX3NjYW5fc3RhY2siLCJzdGFjayIsInF1ZXVlX2VsZW0iLCJzZXRfc2l6ZSIsImxlZnRfdG90YWwiLCJzY2FuX3B1c2giLCJlbGVtIiwicHBfb3Blbl9ib3hfZ2VuIiwiYnJfdHkiLCJwcF9jbG9zZV9ib3giLCJwcF9vcGVuX3N0YWciLCJwcF9jbG9zZV9zdGFnIiwicHBfb3Blbl90YWciLCJwcF9jbG9zZV90YWciLCJwcF9zZXRfcHJpbnRfdGFncyIsInBwX3NldF9tYXJrX3RhZ3MiLCJwcF9nZXRfcHJpbnRfdGFncyIsInBwX2dldF9tYXJrX3RhZ3MiLCJwcF9zZXRfdGFncyIsInBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbiIsInBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbiIsInBjdCIsInBvdCIsIm1jdCIsIm1vdCIsInBwX3Jpbml0IiwicHBfZmx1c2hfcXVldWUiLCJwcF9wcmludF9hc19zaXplIiwicHBfcHJpbnRfYXMiLCJpc2l6ZSIsInBwX3ByaW50X3N0cmluZyIsInBwX3ByaW50X2ludCIsInBwX3ByaW50X2Zsb2F0IiwicHBfcHJpbnRfYm9vbCIsInBwX3ByaW50X2NoYXIiLCJwcF9vcGVuX2hib3giLCJwcF9vcGVuX3Zib3giLCJwcF9vcGVuX2h2Ym94IiwicHBfb3Blbl9ob3Zib3giLCJwcF9vcGVuX2JveCIsInBwX3ByaW50X25ld2xpbmUiLCJwcF9wcmludF9mbHVzaCIsInBwX2ZvcmNlX25ld2xpbmUiLCJwcF9wcmludF9pZl9uZXdsaW5lIiwicHBfcHJpbnRfY3VzdG9tX2JyZWFrIiwicHBfcHJpbnRfYnJlYWsiLCJwcF9wcmludF9zcGFjZSIsInBwX3ByaW50X2N1dCIsInBwX29wZW5fdGJveCIsInBwX2Nsb3NlX3Rib3giLCJwcF9wcmludF90YnJlYWsiLCJwcF9wcmludF90YWIiLCJwcF9zZXRfdGFiIiwicHBfc2V0X21heF9ib3hlcyIsInBwX2dldF9tYXhfYm94ZXMiLCJwcF9vdmVyX21heF9ib3hlcyIsInBwX3NldF9lbGxpcHNpc190ZXh0IiwicHBfZ2V0X2VsbGlwc2lzX3RleHQiLCJwcF9saW1pdCIsInBwX3NldF9tYXhfaW5kZW50IiwicHBfZ2V0X21heF9pbmRlbnQiLCJwcF9zZXRfbWFyZ2luIiwibmV3X21heF9pbmRlbnQiLCJ2YWxpZGF0ZV9nZW9tZXRyeSIsIm1hcmdpbiIsIm1heF9pbmRlbnQiLCJjaGVja19nZW9tZXRyeSIsImdlb21ldHJ5IiwicHBfZ2V0X21hcmdpbiIsInBwX3NldF9mdWxsX2dlb21ldHJ5IiwicHBfc2V0X2dlb21ldHJ5IiwicHBfc2FmZV9zZXRfZ2VvbWV0cnkiLCJwcF9nZXRfZ2VvbWV0cnkiLCJwcF91cGRhdGVfZ2VvbWV0cnkiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMiLCJwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGkiLCJkaXNwbGF5X25ld2xpbmUiLCJibGFua19saW5lIiwiZGlzcGxheV9pbmRlbnQiLCJwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwiZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnIiwiZGVmYXVsdF9wcF9tYXJrX2Nsb3NlX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfb3Blbl90YWciLCJkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZyIsInBwX21ha2VfZm9ybWF0dGVyIiwicHBfcXVldWUiLCJzeXNfdG9rIiwic2Nhbl9zdGFjayIsImZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIiwib3V0X2Z1bnMiLCJtYWtlX2Zvcm1hdHRlciIsInBwZiIsImZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCIsImZvcm1hdHRlcl9vZl9idWZmZXIiLCJwcF9idWZmZXJfc2l6ZSIsInBwX21ha2VfYnVmZmVyIiwic3RkYnVmIiwic3RkX2Zvcm1hdHRlciIsImVycl9mb3JtYXR0ZXIiLCJzdHJfZm9ybWF0dGVyIiwiZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciIsImZsdXNoX3N0cl9mb3JtYXR0ZXIiLCJtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwic29iIiwiZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJmbHVzaF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiaXRlbXMiLCJhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0iLCJpdGVtIiwiZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9iIiwib3Blbl9oYm94Iiwib3Blbl92Ym94Iiwib3Blbl9odmJveCIsIm9wZW5faG92Ym94Iiwib3Blbl9ib3giLCJjbG9zZV9ib3giLCJvcGVuX3RhZyIsImNsb3NlX3RhZyIsIm9wZW5fc3RhZyIsImNsb3NlX3N0YWciLCJwcmludF9hcyIsInByaW50X3N0cmluZyQwIiwicHJpbnRfaW50JDAiLCJwcmludF9mbG9hdCQwIiwicHJpbnRfY2hhciQwIiwicHJpbnRfYm9vbCIsInByaW50X2JyZWFrIiwicHJpbnRfY3V0IiwicHJpbnRfc3BhY2UiLCJmb3JjZV9uZXdsaW5lIiwicHJpbnRfZmx1c2giLCJwcmludF9uZXdsaW5lJDAiLCJwcmludF9pZl9uZXdsaW5lIiwib3Blbl90Ym94IiwiY2xvc2VfdGJveCIsInByaW50X3RicmVhayIsInNldF90YWIiLCJwcmludF90YWIiLCJzZXRfbWFyZ2luIiwiZ2V0X21hcmdpbiIsInNldF9tYXhfaW5kZW50IiwiZ2V0X21heF9pbmRlbnQiLCJzZXRfZ2VvbWV0cnkiLCJzYWZlX3NldF9nZW9tZXRyeSIsImdldF9nZW9tZXRyeSIsInVwZGF0ZV9nZW9tZXRyeSIsInNldF9tYXhfYm94ZXMiLCJnZXRfbWF4X2JveGVzIiwib3Zlcl9tYXhfYm94ZXMiLCJzZXRfZWxsaXBzaXNfdGV4dCIsImdldF9lbGxpcHNpc190ZXh0Iiwic2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCIsInNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInNldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsInNldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIiwic2V0X3ByaW50X3RhZ3MiLCJnZXRfcHJpbnRfdGFncyIsInNldF9tYXJrX3RhZ3MiLCJnZXRfbWFya190YWdzIiwic2V0X3RhZ3MiLCJwcF9wcmludF9saXN0IiwicHBfdiIsIm9wdCQwIiwicHBfc2VwIiwidnMiLCJvcHQkMSIsInBwX3ByaW50X3NlcSIsInNlcSQxIiwic2VxJDIiLCJwcF9wcmludF90ZXh0IiwicHBfcHJpbnRfb3B0aW9uIiwicHBfcHJpbnRfcmVzdWx0IiwiY29tcHV0ZV90YWciLCJ0YWdfYWNjIiwib3V0cHV0X2Zvcm1hdHRpbmdfbGl0Iiwib3V0cHV0X2FjYyQwIiwiYnR5IiwicCQ1IiwicCQ2Iiwic3RycHV0X2FjYyQwIiwia2ZwcmludGYkMCIsImlrZnByaW50ZiQwIiwiaWZwcmludGYkMCIsImZwcmludGYkMCIsInByaW50ZiQwIiwiZXByaW50ZiQwIiwia2RwcmludGYiLCJkcHJpbnRmIiwia3ByaW50ZiIsInNwcmludGYkMCIsImthc3ByaW50ZiIsImFzcHJpbnRmIiwiZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVycyIsInBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdSIsInBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdSIsInNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdCIsImdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdCIsImJwcmludGYkMCIsInBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsInN0cmluZ2lmeSIsInBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsImZ1bnMiLCJtYXJrX29wZW5fdGFnIiwibWFya19jbG9zZV90YWciLCJwcmludF9vcGVuX3RhZyIsInByaW50X2Nsb3NlX3RhZyIsInNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsIm51bGxfY2hhciIsIm5leHRfY2hhciIsImliIiwicGVla19jaGFyIiwiY2hlY2tlZF9wZWVrX2NoYXIiLCJlbmRfb2ZfaW5wdXQiLCJiZWdpbm5pbmdfb2ZfaW5wdXQiLCJuYW1lX29mX2lucHV0IiwiY2hhcl9jb3VudCIsInJlc2V0X3Rva2VuIiwiaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIiLCJ0b2tlbl9zdHJpbmciLCJ0b2tlbl9idWZmZXIiLCJza2lwX2NoYXIiLCJpZ25vcmVfY2hhciIsInN0b3JlX2NoYXIiLCJkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplIiwiY3JlYXRlJDQiLCJpbmFtZSIsImZyb21fc3RyaW5nJDEiLCJmcm9tX2Z1bmN0aW9uJDAiLCJzY2FuX2Nsb3NlX2F0X2VuZCIsInNjYW5fcmFpc2VfYXRfZW5kIiwiZnJvbV9pYyIsInNjYW5fY2xvc2VfaWMiLCJlb2YiLCJzdGRpYiIsIm9wZW5faW5fZmlsZSIsImZyb21fZmlsZSIsImZyb21fZmlsZV9iaW4iLCJmcm9tX2NoYW5uZWwkMCIsImNsb3NlX2luJDAiLCJpYyQwIiwibWVtbyIsIm1lbW9fZnJvbV9pYyIsIm1lbW9fZnJvbV9jaGFubmVsIiwiYmFkX2lucHV0IiwiYmFkX2lucHV0X2VzY2FwZSIsImJhZF90b2tlbl9sZW5ndGgiLCJtZXNzYWdlIiwiYmFkX2Zsb2F0IiwiYmFkX2hleF9mbG9hdCIsImNoYXJhY3Rlcl9taXNtYXRjaCIsImNpIiwiY2hlY2tfdGhpc19jaGFyIiwiY2hlY2tfY2hhciIsInRva2VuX2NoYXIiLCJ0b2tlbl9ib29sIiwiaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIiLCJ0b2tlbl9pbnRfbGl0ZXJhbCIsInRva2VuX2Zsb2F0Iiwic2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIiLCJzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50Iiwic2Nhbl9kaWdpdF9wbHVzIiwiYmFzaXMiLCJkaWdpdHAiLCJ3aWR0aCQzIiwiaXNfYmluYXJ5X2RpZ2l0Iiwic2Nhbl9iaW5hcnlfaW50IiwiaXNfb2N0YWxfZGlnaXQiLCJzY2FuX29jdGFsX2ludCIsImlzX2hleGFfZGlnaXQiLCJzY2FuX2hleGFkZWNpbWFsX2ludCIsInNjYW5fc2lnbiIsInNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbCIsInNjYW5faW50X2NvbnZlcnNpb24iLCJzY2FuX2ZyYWN0aW9uYWxfcGFydCIsInNjYW5fZXhwb25lbnRfcGFydCIsInNjYW5fZmxvYXQiLCJwcmVjaXNpb24iLCJwcmVjaXNpb24kMCIsImNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIiwic2Nhbl9oZXhfZmxvYXQiLCJ3aWR0aCQ0Iiwid2lkdGgkNSIsIndpZHRoJDYiLCJ3aWR0aCQxMCIsIndpZHRoJDciLCJ3aWR0aCQ4Iiwid2lkdGgkOSIsInNjYW5fY2FtbF9mbG9hdF9yZXN0Iiwid2lkdGhfcHJlY2lzaW9uIiwiZnJhY193aWR0aCIsInNjYW5fY2FtbF9mbG9hdCIsInNjYW5fc3RyaW5nIiwic3RwIiwic2Nhbl9jaGFyIiwiaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciIsImNoZWNrX25leHRfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3JfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIiwic2Nhbl9iYWNrc2xhc2hfY2hhciIsImMwIiwiZ2V0X2RpZ2l0IiwiZ2V0X2RpZ2l0JDAiLCJjMSQwIiwiYzIkMCIsInNjYW5fY2FtbF9jaGFyIiwiZmluZF9zdG9wIiwic2Nhbl9jYW1sX3N0cmluZyIsImZpbmRfc3RvcCQwIiwic2tpcF9zcGFjZXMiLCJzY2FuX2NoYXJzX2luX2NoYXJfc2V0Iiwic2Nhbl9pbmRpYyIsInNjYW5fY2hhcnMiLCJzY2FuZl9iYWRfaW5wdXQiLCJnZXRfY291bnRlciIsIndpZHRoX29mX3BhZF9vcHQiLCJzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IiwiZm10aW5nIiwidGFrZV9mb3JtYXRfcmVhZGVycyQwIiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyQwIiwicmVhZGVyIiwibmV3X2siLCJyZWFkZXJzX3Jlc3QiLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzIiwiZm10JDIzIiwiZm10JDI0IiwiZm10JDI1IiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyIsIm1ha2Vfc2NhbmYiLCJyZWFkZXJzIiwic2NhbiQwIiwic3RyX3Jlc3QiLCJwYWRfcHJlY19zY2FuZiIsInNjYW4kMSIsInNjYW4kMiIsInNjYW4iLCJzY2FuJDMiLCJzY2FuJDQiLCJjb252JDAiLCJzY2FuJDUiLCJjb252JDEiLCJzY2FuJDYiLCJjb252JDIiLCJzY2FuJDciLCJzY2FuJDgiLCJmbXRpbmdfbGl0JDAiLCJzdHAkMCIsInMkMiIsInN0cl9yZXN0JDAiLCJyZXN0JDI2IiwiYXJnX3Jlc3QiLCJrc2NhbmYiLCJlZiIsImFwcGx5IiwiYXJncyQwIiwiZXhjIiwiYnNjYW5mIiwia3NzY2FuZiIsInNzY2FuZiIsInNjYW5mIiwiYnNjYW5mX2Zvcm1hdCIsImZvcm1hdCIsInNzY2FuZl9mb3JtYXQiLCJmb3JtYXRfZnJvbV9zdHJpbmciLCJ1bmVzY2FwZWQiLCJrZnNjYW5mIiwiZnNjYW5mIiwicmVnaXN0ZXIiLCJyZWdpc3Rlcl9leGNlcHRpb24iLCJvJDAiLCJwYXJhbXMkMCIsImluaXRpYWxfb2JqZWN0X3NpemUiLCJkdW1teV9pdGVtIiwidGFnIiwiY29tcGFyZSQxMyIsImNvbXBhcmUkMTQiLCJjb21wYXJlJDE1IiwiZHVtbXlfdGFibGUiLCJ0YWJsZV9jb3VudCIsImR1bW15X21ldCIsImZpdF9zaXplIiwibmV3X3RhYmxlIiwicHViX2xhYmVscyIsIm1ldGhvZHMiLCJyZXNpemUkMSIsImFycmF5IiwibmV3X3NpemUiLCJvbGRfc2l6ZSIsIm5ld19idWNrIiwibWV0aG9kX2NvdW50IiwiaW5zdF92YXJfY291bnQiLCJuZXdfbWV0aG9kIiwidGFibGUiLCJnZXRfbWV0aG9kX2xhYmVsIiwibGFiZWwiLCJnZXRfbWV0aG9kX2xhYmVscyIsIm5hbWVzIiwic2V0X21ldGhvZCIsImVsZW1lbnQiLCJnZXRfbWV0aG9kIiwidG9fbGlzdCQzIiwiYXJyIiwibmFycm93IiwidmFycyIsInZpcnRfbWV0aHMiLCJjb25jcl9tZXRocyIsInZhcnMkMCIsInZpcnRfbWV0aHMkMCIsImNvbmNyX21ldGhzJDAiLCJ2aXJ0X21ldGhfbGFicyIsImNvbmNyX21ldGhfbGFicyIsImxhYiIsInR2YXJzIiwiYnlfbmFtZSIsImJ5X2xhYmVsIiwibWV0IiwiaG0iLCJ3aWRlbiIsInNhdmVkX3ZhcnMiLCJzYXZlZF9oaWRkZW5fbWV0aHMiLCJuZXdfc2xvdCIsIm5ld192YXJpYWJsZSIsInRvX2FycmF5IiwibmV3X21ldGhvZHNfdmFyaWFibGVzIiwibWV0aHMiLCJ2YWxzIiwibWV0aHMkMCIsIm5tZXRocyIsIm52YWxzIiwiZ2V0X3ZhcmlhYmxlIiwiZ2V0X3ZhcmlhYmxlcyIsImFkZF9pbml0aWFsaXplciIsImNyZWF0ZV90YWJsZSIsInB1YmxpY19tZXRob2RzIiwidGFncyIsImluaXRfY2xhc3MiLCJpbmhlcml0cyIsImNsYSIsInN1cGVyJDAiLCJubSIsIm1ha2VfY2xhc3MiLCJwdWJfbWV0aHMiLCJjbGFzc19pbml0IiwiZW52X2luaXQiLCJtYWtlX2NsYXNzX3N0b3JlIiwiaW5pdF90YWJsZSIsImR1bW15X2NsYXNzIiwibG9jIiwidW5kZWYiLCJjcmVhdGVfb2JqZWN0IiwiY3JlYXRlX29iamVjdF9vcHQiLCJvYmpfMCIsIml0ZXJfZiIsInJ1bl9pbml0aWFsaXplcnMiLCJpbml0cyIsInJ1bl9pbml0aWFsaXplcnNfb3B0IiwiY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpIiwiZ2V0X2RhdGEkMCIsImJ1aWxkX3BhdGgiLCJrZXlzIiwibG9va3VwX3RhYmxlcyIsInJvb3QiLCJ0YWJsZXMkMiIsInRhYmxlcyQwIiwidGFibGVzJDEiLCJuZXdfY2FjaGUiLCJzZXRfbWV0aG9kcyIsImNsbyIsImNsbyQwIiwibiQyIiwibiQzIiwibiQ0IiwibiQ1IiwibiQ2IiwieCQzIiwibiQ3IiwieCQ0IiwibiQ4IiwibiQ5IiwieCQ1IiwiZiQ4IiwiZSQyIiwibiQxMCIsIngkNiIsImYkOSIsIm4kMTEiLCJ4JDciLCJuJDEyIiwieCQ4IiwibiQxMyIsIm4kMTQiLCJlJDMiLCJuJDE1IiwibSQyIiwieCQ5IiwibSQzIiwibiQxNiIsIm0kNCIsImUkNCIsIm4kMTciLCJtJDUiLCJuJDE4Iiwic3RhdHMkMCIsImluaXRpYWxfYnVmZmVyIiwiYnVmZmVyIiwiYnVmcG9zIiwicmVzZXRfYnVmZmVyIiwic3RvcmUiLCJuZXdidWZmZXIiLCJnZXRfc3RyaW5nIiwibWFrZV9sZXhlciIsImtleXdvcmRzIiwia3dkX3RhYmxlIiwiaWRlbnRfb3Jfa2V5d29yZCIsImtleXdvcmRfb3JfZXJyb3IiLCJjb21tZW50IiwiZXNjYXBlIiwiZW5kX2V4cG9uZW50X3BhcnQiLCJleHBvbmVudF9wYXJ0IiwibnVtYmVyIiwiaWRlbnQyIiwibmVnX251bWJlciIsIm5leHRfdG9rZW4kMCIsIm1heWJlX2NvbW1lbnQiLCJuZXh0X3Rva2VuIiwiaGtleSIsImNsZWFuIiwiaW5zZXJ0X2J1Y2tldCIsImNvbnRhaW5lciIsInJlbW92ZV9idWNrZXQiLCJoayIsInJlcGxhY2VfYnVja2V0IiwibmV3X2QiLCJidWNrZXRfbGVuZ3RoX2FsaXZlIiwic3RhdHNfYWxpdmUiLCJjcmVhdGUkNSIsImdldF9rZXkkMCIsImdldF9rZXlfY29weSQwIiwic2V0X2tleSQwIiwidW5zZXRfa2V5JDAiLCJjaGVja19rZXkkMCIsImJsaXRfa2V5JDAiLCJnZXRfZGF0YSQxIiwiZ2V0X2RhdGFfY29weSIsInNldF9kYXRhIiwidW5zZXRfZGF0YSIsImNoZWNrX2RhdGEiLCJibGl0X2RhdGEiLCJzZXRfa2V5X2RhdGEiLCJjcmVhdGUkNiIsImdldF9rZXkxIiwiZ2V0X2tleTFfY29weSIsInNldF9rZXkxIiwidW5zZXRfa2V5MSIsImNoZWNrX2tleTEiLCJnZXRfa2V5MiIsImdldF9rZXkyX2NvcHkiLCJzZXRfa2V5MiIsInVuc2V0X2tleTIiLCJjaGVja19rZXkyIiwiYmxpdF9rZXkxIiwiYmxpdF9rZXkyIiwiYmxpdF9rZXkxMiIsImdldF9kYXRhJDIiLCJnZXRfZGF0YV9jb3B5JDAiLCJzZXRfZGF0YSQwIiwidW5zZXRfZGF0YSQwIiwiY2hlY2tfZGF0YSQwIiwiYmxpdF9kYXRhJDAiLCJrMiQwIiwiazEkMCIsImNyZWF0ZSQ3IiwibGVuZ3RoJDYiLCJnZXRfa2V5JDEiLCJnZXRfa2V5X2NvcHkkMSIsInNldF9rZXkkMSIsInVuc2V0X2tleSQxIiwiY2hlY2tfa2V5JDEiLCJibGl0X2tleSQxIiwiZ2V0X2RhdGEkMyIsImdldF9kYXRhX2NvcHkkMSIsInNldF9kYXRhJDEiLCJ1bnNldF9kYXRhJDEiLCJjaGVja19kYXRhJDEiLCJibGl0X2RhdGEkMSIsImtpIiwiazAiLCJnZW5lcmljX2Jhc2VuYW1lIiwiaXNfZGlyX3NlcCIsImdlbmVyaWNfZGlybmFtZSIsImlzX3JlbGF0aXZlIiwiaXNfaW1wbGljaXQiLCJjaGVja19zdWZmaXgiLCJzdWZmIiwiY2hvcF9zdWZmaXhfb3B0IiwibGVuX3MiLCJsZW5fZiIsInF1b3RlIiwicXVvdGVfY29tbWFuZCIsImJhc2VuYW1lIiwiZGlybmFtZSIsImlzX2Rpcl9zZXAkMCIsImlzX3JlbGF0aXZlJDAiLCJpc19pbXBsaWNpdCQwIiwiY2hlY2tfc3VmZml4JDAiLCJjaG9wX3N1ZmZpeF9vcHQkMCIsInRlbXBfZGlyX25hbWUiLCJxdW90ZSQwIiwiYWRkX2JzIiwibG9vcCQwIiwibG9vcF9icyIsInF1b3RlX2NtZF9maWxlbmFtZSIsInF1b3RlX2NvbW1hbmQkMCIsImRyaXZlX2FuZF9wYXRoIiwiZGlybmFtZSQwIiwicGF0aCIsImRyaXZlIiwiZGlyIiwiYmFzZW5hbWUkMCIsImJhc2VuYW1lJDEiLCJkaXJuYW1lJDEiLCJudWxsJDMiLCJjdXJyZW50X2Rpcl9uYW1lJDIiLCJwYXJlbnRfZGlyX25hbWUkMiIsImRpcl9zZXAkMiIsImlzX2Rpcl9zZXAkMSIsImlzX3JlbGF0aXZlJDEiLCJpc19pbXBsaWNpdCQxIiwiY2hlY2tfc3VmZml4JDEiLCJjaG9wX3N1ZmZpeF9vcHQkMSIsInRlbXBfZGlyX25hbWUkMCIsInF1b3RlJDEiLCJxdW90ZV9jb21tYW5kJDEiLCJiYXNlbmFtZSQyIiwiZGlybmFtZSQyIiwiY29uY2F0JDMiLCJjaG9wX3N1ZmZpeCIsImV4dGVuc2lvbl9sZW4iLCJleHRlbnNpb24iLCJjaG9wX2V4dGVuc2lvbiIsInJlbW92ZV9leHRlbnNpb24iLCJwcm5nJDAiLCJ0ZW1wX2ZpbGVfbmFtZSIsInRlbXBfZGlyIiwicm5kIiwiY3VycmVudF90ZW1wX2Rpcl9uYW1lIiwic2V0X3RlbXBfZGlyX25hbWUiLCJnZXRfdGVtcF9kaXJfbmFtZSIsInRlbXBfZmlsZSIsInRyeV9uYW1lIiwiY291bnRlciQxIiwib3Blbl90ZW1wX2ZpbGUiLCJzdGgkMCIsInBlcm1zIiwic3RoJDEiLCJhZGQkMSIsInN1YiQ0IiwibmVnIiwiY29uaiIsIm11bCIsImRpdiIsImludiIsIm5vcm0yIiwibm9ybSIsInEkMCIsInBvbGFyIiwic3FydCIsInckMCIsImV4cCIsImxvZyIsInBvdyIsImZsb2F0MzIiLCJmbG9hdDY0IiwiaW50OF9zaWduZWQiLCJpbnQ4X3Vuc2lnbmVkIiwiaW50MTZfc2lnbmVkIiwiaW50MTZfdW5zaWduZWQiLCJpbnQzMiQxIiwiaW50NjQkMSIsImludCQyIiwibmF0aXZlaW50JDEiLCJjb21wbGV4MzIiLCJjb21wbGV4NjQiLCJraW5kX3NpemVfaW5fYnl0ZXMiLCJjX2xheW91dCIsImZvcnRyYW5fbGF5b3V0IiwiY2xvb3AiLCJpZHgiLCJjb2wiLCJmbG9vcCIsImluaXQkNSIsImxheW91dCIsImRpbXMiLCJkbGVuIiwic2l6ZV9pbl9ieXRlcyIsImNyZWF0ZSQ4IiwiZ2V0JDIiLCJzZXQkMSIsInNpemVfaW5fYnl0ZXMkMCIsIm9mX3ZhbHVlIiwiY3JlYXRlJDkiLCJkaW0iLCJzaXplX2luX2J5dGVzJDEiLCJzbGljZSIsImluaXQkNiIsIm9mX2FycmF5IiwiYmEiLCJjcmVhdGUkMTAiLCJkaW0xIiwiZGltMiIsInNpemVfaW5fYnl0ZXMkMiIsInNsaWNlX2xlZnQiLCJzbGljZV9yaWdodCIsImluaXQkNyIsIm9mX2FycmF5JDAiLCJyb3ciLCJjcmVhdGUkMTEiLCJkaW0zIiwic2l6ZV9pbl9ieXRlcyQzIiwic2xpY2VfbGVmdF8xIiwic2xpY2VfcmlnaHRfMSIsInNsaWNlX2xlZnRfMiIsInNsaWNlX3JpZ2h0XzIiLCJpbml0JDgiLCJvZl9hcnJheSQxIiwiYXJyYXkwX29mX2dlbmFycmF5IiwiYXJyYXkxX29mX2dlbmFycmF5IiwiYXJyYXkyX29mX2dlbmFycmF5IiwiYXJyYXkzX29mX2dlbmFycmF5IiwicmVzaGFwZV8wIiwicmVzaGFwZV8xIiwicmVzaGFwZV8yIiwicmVzaGFwZV8zIiwic3BhY2luZ19jaGFyIiwiaW52YWxpZF9jaGFyIiwibW9kcyIsIm9jYW1sX2xleF90YWJsZXMiLCJlbnVtZXJhdGVfZmlsZXMiLCJkaXJuYW1lIiwiZXh0IiwieCIsInVpbnQzMl9vZl9zdHIiLCJzdHIiLCJzdHIkMCIsImk2NCIsInVpbnQzMl90b19pbnQiLCJ2IiwiaSIsImludDY0X29mX3VpbnQzMiIsImR1bW15X2ZtdCIsImNvbmNhdF9zdHJpbmdzIiwibHN0IiwicHAiLCJmbXQiLCJpbnQzMl9mcm9tX2xvd19oaWdoIiwibCIsImgiLCJpbnQzMl90b19sb3dfaGlnaCIsInN1YnN0cnVjdHVyZXNfb3JkZXIiLCJkYXRhX29mZnNldCIsImxlbiIsInBpZF9vZmZzZXQiLCJvdGlkX29mZnNldCIsImNoZWNrc3VtX29mZnNldCIsInBrbW5fZnJvbV9ieXRlcyIsImJ1ZiIsInBpZCIsIm90aWQiLCJzdWJzdHJ1Y3R1cmVfcG9zaXRpb24iLCJzcyIsIm9yZGVyIiwiaSQwIiwiaSQxIiwic3Vic3RydWN0dXJlX29mZnNldCIsInBrbW4iLCJwIiwiZW5jcnlwdF9hbGlnbmVkX2ludDMyIiwia2V5IiwiY2hlY2tzdW1fZGlmZl9mb3JfYWxpZ25lZF9pbnQzIiwibyIsIm4iLCJobyIsImxvIiwiaG4iLCJsbiIsImRpZmYiLCJlbmNfZGVjIiwib2Zmc2V0Iiwib2Zmc2V0JDAiLCJvZmZzZXQkMSIsImV4dHJhY3RfZGF0YSIsInJlcyIsInVwZGF0ZV93aXRoX2RhdGEiLCJkYXRhIiwiYWNjIiwibG93IiwiY2hlY2tzdW0iLCJuYiIsImFjYyQwIiwic3BlY2llc19vZmZzZXQiLCJzcGVjaWVzX29mZnNldF9yZWxhdGl2ZV90b19kYXQiLCJpdmVhX29mZnNldCIsIml2ZWFfZGF0YV90b19pdnMiLCJocCIsImRhdGEkMCIsImF0ayIsImRhdGEkMSIsImRlZiIsImRhdGEkMiIsInNwZWVkIiwiZGF0YSQzIiwic3BfYXRrIiwiZGF0YSQ0Iiwic3BfZGVmIiwiZGF0YSQ1IiwiaXZzX3RvX2l2ZWFfZGF0YSIsImRhdGEkNiIsImRhdGEkNyIsImRhdGEkOCIsImRhdGEkOSIsImRhdGEkMTAiLCJkYXRhJDExIiwibGFuZyIsInR3ZWFrZXJfbW9kZSIsImhleF9ib3hfbW9kZSIsImNvbmZpZ3VyZSIsImxhbmd1YWdlIiwibXVsdF9tb2QiLCJ5IiwibSIsInR3b19iaWdfaW50IiwiYSIsImIiLCJhX2ludiIsImJfaW52IiwiYl8xIiwiY3ljbGVfcGFydF9wcm9kdWN0IiwibWFzazMyIiwiZXZlbiIsIm9kZCIsIm1wb3ciLCJiYXNlIiwiZXhwIiwiYmFzZSQwIiwiZXhwJDAiLCJiYXNlJDEiLCJleHAkMSIsImJhc2UkMiIsInBvdyIsInNlZWQiLCJiaWdfaW50X29mX3VpbnQzMiIsImkzMiIsInVpbnQzMl9vZl9iaWdpbnQiLCJiaSIsIm1heGludDMyIiwibWluaW50MzIiLCJ0b3RhbCIsImJpJDAiLCJybmdfb2YiLCJhUHJlc3NlcyIsIm1vcmVBUHJlc3NlcyIsIm9sZF9yb2QiLCJnb29kX3JvZCIsInN1cGVyX3JvZCIsIm5leHRfc2VlZCIsInByZXZfc2VlZCIsImN5Y2xlX3RvIiwic2VlZCQwIiwicG93ZXIiLCJtJDAiLCJiaXRtYXNrIiwibHMiLCJsJDAiLCJiaXQiLCJiJDAiLCJiaXQkMCIsImkkMiIsInNlZWRfYXQiLCJjeWNsZSIsImN5Y2xlJDAiLCJvcDEiLCJhdXgiLCJiZXN0X3NlZWRfZm9yX3JvZCIsInJvdXRlMTE5IiwiZmVlYmFzIiwidGFyZ2V0X3NlZWQiLCJyb2QiLCJ0YXJnZXRfc2VlZCQwIiwibWF4QWRkaXRpb25hbE9mZnNldHMiLCJiZXN0UmVzdWx0cyIsInN0YXJ0aW5nX3NlZWQiLCJvZmZzZXQxMTkiLCJhZGRpdGlvbmFsT2Zmc2V0IiwibWluUm91bmRzIiwiYml0ZVJvbGwiLCJiaXRlUmVzdWx0IiwiYWR2YW5jZW1lbnQiLCJiaXRlUm9sbCQwIiwiZmVlYmFzUmVzdWx0IiwiYWR2YW5jZW1lbnQkMCIsImJyIiwicyIsImFkdiIsInMkMCIsImFkdiQwIiwicyQxIiwibWFpbiIsIm1haW5fMSIsIm1haW5fMyIsInJvZG5hbWUiLCJzZWVkJDEiLCJzaG93X3ZpY2luaXR5IiwicHJpbnRfY3ljbGUiLCJzdGFydCIsInN0b3AiLCJzdGFydF9zZWVkIiwibWFpbl92aWNpbml0eSIsImoiLCJtYWluXzIiLCJnYW1lX3NhdmVfQSIsImdhbWVfc2F2ZV9CIiwic2VjdGlvbl9zaXplIiwic2VjdGlvbl9pZF9vZmZzZXQiLCJjaGVja3N1bV9vZmZzZXQkMCIsInNhdmVfaW5kZXhfb2Zmc2V0IiwiYm94X25hbWVzX3NlY3Rpb25faWQiLCJib3hfbmFtZXNfc2VjdGlvbl9kYXRhX2xlbmd0aCIsImJveF9uYW1lc19vZmZzZXQiLCJib3hfbmFtZXNfbGVuZ3RoIiwidGVhbV9pdGVtc19zZWN0aW9uX2lkIiwidGVhbV9pdGVtc19zZWN0aW9uX2RhdGFfbGVuZ3RoIiwidGVhbV9zaXplX29mZnNldCIsInBrbW5fZGF0YV9zaXplIiwicmVhZF9zZWN0aW9uIiwiaW5jIiwic2VjdGlvbl9pZCIsInJidWYiLCJhZGRyIiwiaWQiLCJpbmRleCIsImluZGV4YSIsImFkZHJhIiwiaW5kZXhiIiwiYWRkcmIiLCJ3cml0ZV9zZWN0aW9uIiwib2MiLCJjb21wdXRlX2NoZWNrc3VtIiwiaGlnaCIsImV4dHJhY3RfYm94X25hbWVzX2Zyb21fc2VjdGlvbiIsInVwZGF0ZV9ib3hfbmFtZXMiLCJib3hfbmFtZXMiLCJlbXB0eV9wa21uIiwiZXh0cmFjdF90ZWFtX2Zyb21fc2VjdGlvbiIsInVwZGF0ZV90ZWFtIiwicGttbnMiLCJ1cGRhdGVfcGttbiIsImdldF9wYXJhbSIsIm5hbWUiLCJsc3QkMCIsImxzdCQxIiwibHN0JDIiLCJldmFsX21ldGFfZXhwciIsImVudiIsImUiLCJlJDAiLCJlMiIsImUxIiwib3AiLCJpMSIsImkyIiwiZSQxIiwib3AkMCIsImUyJDAiLCJlMSQwIiwiZTAiLCJpMCIsImVtcHR5X2VudiIsImVudl9mcm9tX2hlYWRlcnMiLCJoZWFkZXJzIiwidHJlYXRfZGVmIiwicHJpbnRlZCIsImV4cHIiLCJwcmludCIsInByaW50ZWQkMCIsImNvbmNhdF9lbnYiLCJlbnYxIiwiZW52MiIsImsiLCJtYWluJDAiLCJtYWluXzEkMCIsIm1haW5fNiIsImxpdmVhIiwiaGl2ZWEiLCJpdmVhIiwidWl2ZWEiLCJ1aXZlYSQwIiwiaXZlYSQwIiwiaGl2ZWEkMCIsImxpdmVhJDAiLCJjaGVja3N1bV9kaWZmIiwibWFpbl81IiwibWFpbl80IiwidmlkIiwic2lkIiwidGlkIiwibWlzY19wb3MiLCJpdmVhX29mZnNldCQwIiwibWFpbl8zJDAiLCJtYWluXzIkMCIsImxwaWQiLCJocGlkIiwiYTEiLCJhMiIsImEzIiwiYTQiLCJ2MSIsInYyIiwidjMiLCJ2NCIsInY1IiwidjYiLCJ2NyIsInY4Iiwic2IiLCJzbCIsImZwIiwiaXAiLCJzcCIsImxyIiwicGMiLCJzaWduX3BsdXMiLCJzaWduX21pbnVzIiwibWFzazgiLCJtYXNrOSIsIm1hc2sxMiIsImFkZF9jb25kaXRpb25fY29kZSIsImMiLCJhZGRfcm5fY29kZSIsInJuIiwiYWRkX3JkX2NvZGUiLCJyZCIsInJvdGF0ZV9yaWdodCIsImxiIiwidiQwIiwicm90YXRlX2xlZnQiLCJoYiIsImFkZHJfbW9kZV8xIiwicnMiLCJpbW0iLCJvdGhlcnMiLCJpbW04IiwicnIiLCJwb3NzaWJpbGl0aWVzIiwicm0iLCJwX2FuZF93IiwiYWRkcl90eXAiLCJhcm1fdG9fYmluYXJ5IiwiYXJtIiwiaSQzIiwicm8iLCJjb25kIiwidHlwIiwiaW5zdHIiLCJjaGVja19wb3N0X2FkZHIiLCJvcGNvZGUiLCJ2JDMiLCJzaWduIiwicmVnIiwic2lnbiQwIiwic2lnbiQxIiwidyIsInUiLCJwJDAiLCJ3JDAiLCJhZGRyX21vZGUiLCJ2JDEiLCJzaWduJDIiLCJpbW1lZEwiLCJpbW1lZEgiLCJ2JDIiLCJzaWduJDMiLCJybSQwIiwic2lnbiQ0IiwidyQxIiwicCQxIiwidSQwIiwicCQyIiwidyQyIiwicmQkMCIsImNvbmQkMCIsImluc3RyJDAiLCJvcGNvZGUkMCIsInNjb2RlIiwic2NvZGUkMCIsInYkNCIsIm9wMiIsInJuJDAiLCJyZCQxIiwiY29uZCQxIiwiaW5zdHIkMSIsIm9wY29kZSQxIiwic2NvZGUkMSIsInNjb2RlJDIiLCJ2JDUiLCJ0YXJnZXQiLCJjb25kJDIiLCJvcGNvZGUkMiIsInYkNiIsIm1zOSIsImltbSQwIiwicm0kMSIsImNvbmQkMyIsIm9wY29kZSQzIiwidiQ3IiwicmV2ZXJzZV9lbmRpYW5uZXNzIiwiY2hhcnNldF9lbmciLCJjaGFyc2V0X2l0YSIsImNoYXJzZXRfc3BhIiwiY3MiLCJpJDQiLCJjaGFyc2V0X2ZyYSIsImNoYXJzZXRfamFwIiwiY2hhcnNldF9mdWxsIiwiY2hhcnNldCIsImlzX2NvZGVfYXZhaWxhYmxlIiwiY29kZSIsImlzX2NvZGVfcmVhZGFibGUiLCJpc19jb2RlX3VzZWQiLCJjaGFyX2F0IiwicmVhZGFibGVfY2hhcl9hdCIsIndyaXRhYmxlX2NoYXJfYXQiLCJlbmNvZGVfd3JpdGFibGVfY2hhciIsImVvZiIsInNwYWNlIiwiY29kZXNfZm9yX2NvbW1hbmQiLCJjb21tYW5kX2Zvcl9jb2RlcyIsImNvZGVzIiwiYzQiLCJjMyIsImMyIiwiYzEiLCJjb2Rlc190b19jaGFycyIsImNoYXJzX2Zvcl9jb21tYW5kIiwicHBfY2hhcnMiLCJwcF9jaGFyc19yYXciLCJpc19jb2RlX3dyaXRhYmxlIiwiZmlyc3RfY29kZSIsImYiLCJjb2RlcyQwIiwiY29kZXMkMSIsImZpcnN0X3dyaXRhYmxlX2NvZGUiLCJpc19jb2RlX3dyaXRhYmxlX29yX29uZV9lb2YiLCJwcmVmZXJyZWRfY29kZSIsImlzX2Z1bGxfb2Zfc3BhY2VzIiwiY29tcGFyZSIsInBhZGRpbmdfY29kZSIsImFjYyQxIiwibWF4IiwiaW1tZWQ4IiwiaW1tZWQ4JDAiLCJjb25zdGFudHNfc2V0IiwiY29uc3RhbnRzX3NldF9ub19jYXJyeSIsImNvbnN0YW50cyIsInJldl9jb25zdGFudHMiLCJuc2V0IiwiY29uc3RhbnRzX21vdl9tdm4iLCJuc2V0JDAiLCJjb25zdGFudHNfbW92X212bl9zdHJpY3QiLCJyZXZfY29uc3RhbnRzX21vdl9tdm4iLCJyZXZfY29uc3RhbnRzX21vdl9tdm5fc3RyaWN0IiwidGFkMCIsInJlbW92ZV93aGlsZSIsInN5bnRoZXNpcyIsImNvbnN0YW50c19jYXQiLCJhZGRpdGl2ZSIsImluY3IiLCJtYXhfY2FyZCIsImlzX3ZhbGlkX2ZzdCIsImlzX3ZhbGlkIiwidGFkMF9sZW4iLCJ0YWQwJDAiLCJyZW1vdmUiLCJuZXh0IiwicmMiLCJyYyQwIiwiZGVwdGgiLCJyZW1fZGVwdGgiLCJpaSIsImZzdCIsInJjJDEiLCJyZW1haW5kZXIiLCJmaWx0ZXJlZF9yZXZfY29uc3RhbnRzIiwicmVtb3ZlX2luaXQiLCJvcF9pbml0IiwiaW5pdF9yYyIsInRyeV9uYiIsInRyeV9uYiQwIiwic3ludGhlc2lzX29wdGltYWwiLCJpbmNyX2FkZCIsImluY3Jfc3ViIiwiY2FyZCIsImNhcmQkMCIsInN5bnRoZXNpc190ZXN0IiwiaXNfY29tbWFuZF92YWxpZCIsInR3ZWFrX2NvbW1hbmQiLCJvcHRpbWl6ZSIsInN0cmljdCIsIm9wdGltaXplX3dpdGhfY2FyZCIsInBhZCIsImNtZCIsIm1rX2NtZF9maXJzdCIsIm5mc3QiLCJjb25zdGFudF9zZXRfbW92IiwiaXNfbW92IiwibWtfY21kIiwiYWRkIiwiY21kJDAiLCJpc19hZGRpdGlvbiIsIm1rX2NtZF9maXJzdCQwIiwibWtfY21kJDAiLCJpc19hZGRpdGlvbiQwIiwibXVzdF9hZGQiLCJhZGRpdGl2ZSQwIiwiZnN0JDAiLCJwYWRkaW5nIiwidHdlYWtfYXJtIiwiZG9fbm90X3R3ZWFrX2FybSIsInByZXByb2Nlc3MiLCJ1aSIsImNvbWJpbmVfb3B0IiwibzEiLCJvMiIsImNvbWJpbmVfYm9vbCIsImIxIiwiYjIiLCJyZWNvZ25pemVfbW9kaWZpZXJzIiwic3RyJDMiLCJuJDIiLCJtb2RzJDEiLCJubW9kcyIsIm4kMCIsInN0ciQxIiwiaSQ1IiwibiQxIiwic3RyJDIiLCJpJDYiLCJpJDciLCJpJDgiLCJ4JDAiLCJsJDEiLCJ4JDEiLCJtb2RzJDAiLCJyZWdpc3Rlcl9vZl9zdHIiLCJnZXRfcmVnaXN0ZXIiLCJhcmciLCJnZXRfcmQiLCJhcmdzIiwiZ2V0X3JuIiwiZ2V0X29wMiIsImdldF9ybyIsInIiLCJnZXRfdGFyZ2V0IiwiY21kX3RvX2FybSIsImNtZCQxIiwiY21kJDIiLCJwb3MiLCJ0eXAkMCIsInR5cCQxIiwiYyQwIiwidG9fYXJtIiwiYXN0IiwiZVJSIiwibWVuaGlyX2Rpc2NhcmQiLCJtZW5oaXJfZW52IiwibGV4ZXIiLCJsZXhidWYiLCJ0b2siLCJtZW5oaXJfZXJyb3JjYXNlIiwibWVuaGlyX3N0YWNrIiwibWVuaGlyX3MiLCJtZW5oaXJfc3RhY2skMCIsIm1lbmhpcl9zJDAiLCJtZW5oaXJfcyQxIiwibWVuaGlyX3N0YWNrJDEiLCJtZW5oaXJfcyQyIiwibWVuaGlyX3N0YWNrJDIiLCJtZW5oaXJfcyQzIiwibWVuaGlyX3N0YWNrJDMiLCJtZW5oaXJfcyQ0IiwibWVuaGlyX3N0YWNrJDQiLCJtZW5oaXJfcyQ1IiwibWVuaGlyX3N0YWNrJDUiLCJtZW5oaXJfcyQ2IiwibWVuaGlyX3N0YWNrJDYiLCJtZW5oaXJfcyQ3IiwibWVuaGlyX3N0YWNrJDciLCJtZW5oaXJfcyQ4IiwibWVuaGlyX3N0YWNrJDgiLCJtZW5oaXJfcyQ5IiwibWVuaGlyX3N0YWNrJDkiLCJtZW5oaXJfcyQxMCIsIm1lbmhpcl9zdGFjayQxMCIsIm1lbmhpcl9zJDExIiwibWVuaGlyX3N0YWNrJDExIiwibWVuaGlyX3MkMTIiLCJtZW5oaXJfc3RhY2skMTIiLCJtZW5oaXJfcyQxMyIsIm1lbmhpcl9zdGFjayQxMyIsIm1lbmhpcl9zJDE0IiwibWVuaGlyX3N0YWNrJDE0IiwibWVuaGlyX3MkMTUiLCJtZW5oaXJfc3RhY2skMTUiLCJtZW5oaXJfcyQxNiIsIm1lbmhpcl9zdGFjayQxNiIsIm1lbmhpcl9zJDE3IiwibWVuaGlyX3N0YWNrJDE3IiwibWVuaGlyX3MkMTgiLCJtZW5oaXJfc3RhY2skMTgiLCJtZW5oaXJfcyQxOSIsIm1lbmhpcl9zdGFjayQxOSIsIm1lbmhpcl9zJDIwIiwibWVuaGlyX3N0YWNrJDIwIiwibWVuaGlyX3MkMjEiLCJtZW5oaXJfc3RhY2skMjEiLCJtZW5oaXJfcyQyMiIsIm1lbmhpcl9zdGFjayQyMiIsIm1lbmhpcl9zJDIzIiwibWVuaGlyX3N0YWNrJDIzIiwibWVuaGlyX3MkMjQiLCJtZW5oaXJfc3RhY2skMjQiLCJtZW5oaXJfcyQyNSIsIm1lbmhpcl9zdGFjayQyNSIsIm1lbmhpcl9zJDI2IiwibWVuaGlyX3N0YWNrJDI2IiwibWVuaGlyX3MkMjciLCJtZW5oaXJfc3RhY2skMjciLCJtZW5oaXJfcyQyOCIsIm1lbmhpcl9zdGFjayQyOCIsIm1lbmhpcl9zJDI5IiwibWVuaGlyX3N0YWNrJDI5IiwibWVuaGlyX3MkMzAiLCJtZW5oaXJfc3RhY2skMzAiLCJtZW5oaXJfcyQzMSIsIm1lbmhpcl9zdGFjayQzMSIsIm1lbmhpcl9zJDMyIiwibWVuaGlyX3N0YWNrJDMyIiwibWVuaGlyX3MkMzMiLCJtZW5oaXJfc3RhY2skMzMiLCJtZW5oaXJfcyQzNCIsIm1lbmhpcl9zdGFjayQzNCIsIm1lbmhpcl9zJDM1IiwibWVuaGlyX3N0YWNrJDM1IiwibWVuaGlyX3MkMzYiLCJtZW5oaXJfc3RhY2skMzYiLCJtZW5oaXJfZmFpbCIsIm1lbmhpcl9nb3RvX2FzdCIsIm1lbmhpcl9nb3RvX2hlYWRlcnMiLCJkIiwibWVuaGlyX3J1bjE1IiwibWVuaGlyX2VudiQwIiwibWVuaGlyX3J1bjYiLCJtZW5oaXJfcnVuOCIsIm1lbmhpcl9ydW45IiwibWVuaGlyX3J1bjEwIiwibWVuaGlyX3J1bjEyIiwibWVuaGlyX3J1bjciLCJtZW5oaXJfcnVuMTEiLCJtZW5oaXJfcnVuMTciLCJtZW5oaXJfcnVuMTkiLCJtZW5oaXJfcnVuMjEiLCJtZW5oaXJfcnVuMzgiLCJtZW5oaXJfcnVuMjkiLCJtZW5oaXJfcnVuMjMiLCJtZW5oaXJfcnVuMjciLCJtZW5oaXJfcnVuMzEiLCJtZW5oaXJfcnVuNDAiLCJtZW5oaXJfcnVuMzMiLCJtZW5oaXJfcnVuMjUiLCJtZW5oaXJfcnVuNDQiLCJtZW5oaXJfcnVuNDYiLCJtZW5oaXJfcnVuMzUiLCJtZW5oaXJfZ290b19vZmZzZXQiLCJ0b2skMCIsIm1lbmhpcl9lbnYkMSIsImlkJDAiLCJtZW5oaXJfZ290b19hcmciLCJpZCQxIiwibWVuaGlyX2dvdG9fbWV0YV9leHByIiwibWVuaGlyX2dvdG9fZGVmaW5pdGlvbiIsInRvayQxIiwidG9rJDIiLCJ0b2skMyIsImUyJDEiLCJlMSQxIiwidG9rJDQiLCJ0b2skNSIsInRvayQ2IiwiZTIkMiIsImUxJDIiLCJ2JDgiLCJ0b2skNyIsImUyJDMiLCJlMSQzIiwidiQ5IiwidG9rJDgiLCJlMiQ0IiwiZTEkNCIsInYkMTAiLCJ0b2skOSIsImUyJDUiLCJlMSQ1IiwidiQxMSIsInRvayQxMCIsImUyJDYiLCJlMSQ2IiwidiQxMiIsInRvayQxMSIsImUyJDciLCJlMSQ3IiwidiQxMyIsImUyJDgiLCJlMSQ4IiwidiQxNCIsImUyJDkiLCJlMSQ5IiwidiQxNSIsInRvayQxMiIsImUyJDEwIiwiZTEkMTAiLCJ2JDE2IiwidG9rJDEzIiwiZTIkMTEiLCJlMSQxMSIsInYkMTciLCJlMiQxMiIsImUxJDEyIiwidiQxOCIsInRvayQxNCIsImUyJDEzIiwiZTEkMTMiLCJ2JDE5IiwidiQyMCIsInRvayQxNSIsIm1lbmhpcl9lbnYkMiIsInYkMjEiLCJlJDIiLCJtZW5oaXJfc3RhY2skMzciLCJ2JDIyIiwiZSQzIiwibWVuaGlyX3N0YWNrJDM4IiwidiQyMyIsImUkNCIsIm1lbmhpcl9zdGFjayQzOSIsInYkMjQiLCJ0b2skMTYiLCJtZW5oaXJfZW52JDMiLCJlJDUiLCJzdGFydHBvc18xIiwibWVuaGlyX3MkMzgiLCJtZW5oaXJfc3RhY2skNDEiLCJ2JDI1IiwibWVuaGlyX2dvdG9fbnVtYmVyIiwibWVuaGlyX3MkMzciLCJtZW5oaXJfc3RhY2skNDAiLCJtZW5oaXJfZ290b19jb21tYW5kIiwibWVuaGlyX3J1bjEkMCIsIm1lbmhpcl9yZWR1Y2UyNiQwIiwic3RhcnRwb3MiLCJtZW5oaXJfcnVuNTkiLCJtZW5oaXJfcnVuNSIsIm1lbmhpcl9ydW40IiwibWVuaGlyX3J1bjYyIiwibWVuaGlyX3J1bjY1IiwibWVuaGlyX3J1bjY2IiwibWVuaGlyX3J1bjU0IiwibWVuaGlyX3J1bjc5IiwibWVuaGlyX3J1bjc4IiwibWVuaGlyX2dvdG9fbG9wdGlvbl9zZXBhcmF0ZWRfIiwibWF0Y2giLCJzdGFydHBvc19pZCIsInN0YXJ0cG9zX2lkJDAiLCJzdGFydHBvc19pZCQxIiwic3RhcnRwb3NfaSIsIm1lbmhpcl9lbnYkNCIsIm1lbmhpcl9lbnYkNSIsIm1lbmhpcl9lbnYkMTEiLCJ4cyIsIm1lbmhpcl9lbnYkNiIsInN0YXJ0cG9zJDAiLCJtZW5oaXJfZW52JDciLCJtZW5oaXJfZW52JDgiLCJtZW5oaXJfZW52JDkiLCJtZW5oaXJfZW52JDEwIiwibWVuaGlyX3JlZHVjZTI2IiwibWVuaGlyX3J1bjEiLCJuZXh0X2xpbmUiLCJlb2ZfcmVhY2hlZCIsInJlYWRfY29tbWVudCQwIiwib2NhbWxfbGV4X3JlYWRfY29tbWVudF9yZWMkMCIsIm9jYW1sX2xleF9zdGF0ZSIsIm9jYW1sX2xleF9zdGF0ZSQwIiwib2NhbWxfbGV4X3N0YXRlJDEiLCJyZWFkX2NvbW1lbnQiLCJvY2FtbF9sZXhfcmVhZF9jb21tZW50X3JlYyIsInJlYWRfc3RyaW5nJDAiLCJvY2FtbF9sZXhfcmVhZF9zdHJpbmdfcmVjJDAiLCJyZWFkX3N0cmluZyIsIm9jYW1sX2xleF9yZWFkX3N0cmluZ19yZWMiLCJyZWFkJDAiLCJvY2FtbF9sZXhfcmVhZF9yZWMkMCIsInJlYWQiLCJvY2FtbF9sZXhfcmVhZF9yZWMiLCJwcmludF9wb3NpdGlvbiIsInByaW50X2xleGJ1Zl9wb3MiLCJwYXJzZV93aXRoX2Vycm9yIiwibXNnIiwiZnJvbV9sZXhidWYiLCJoZWFkZXJzJDAiLCJoZWFkZXJzJDEiLCJhc3QkMCIsImZyb21fZmlsZW5hbWUiLCJmaWxlbmFtZSIsImNoYW5uZWwiLCJmcm9tX3N0ciIsInBhcnNlZF9hc3RfdG9fYXJtIiwicGFyc2VkX2NvbnRlbnRfdG9fYXJtIiwiZW52JDAiLCJwYXJzZSIsIm1haW5fZmlsZSIsImZuIiwiZm4kMCIsImZyb21fZmlsZW5hbWUkMCIsImZyb21fc3RyJDAiLCJtZiIsImdldF9maWxlIiwiZmlsZXMiLCJsb2FkX2Zyb21fZGlyIiwicGF0aCIsImxvYWRfZnJvbV9wYXJzZWRfZmlsZSIsImxvYWRfZnJvbV9maWxlIiwiZ2V0X3ByZWZlcnJlZCIsImRlZmF1bHQkMCIsInN0cmluZ19vZl91Y2hhciIsInVjaGFyIiwiYnVmZmVyIiwiZGVjb21wb3NlX2ludG9fdWNoYXJzIiwidWMiLCJ1YyQwIiwibWFpbiQxIiwibWFpbl8xJDEiLCJhdXgyIiwiYXV4NCIsImVuY29kaW5nIiwiZW5jb2RpbmckMCIsImVuY29kaW5nJDEiLCJlbmNvZGluZyQyIiwiZGVmYXVsdF9maWxsZXJzIiwibmJfYm94ZXMiLCJub19lb2YiLCJwYWRfbmIiLCJmaWxsZXJzIiwicG9zJDAiLCJmaXRfY29kZV9hdF9wb3MiLCJvcHQiLCJjb2RlcyQ5Iiwic3RoIiwiaXNfb2tfaGVyZSIsImNvZGVzJDIiLCJjb2RlcyQzIiwiY29kZXMkNCIsImNvZGVzJDUiLCJjJDEiLCJjb2RlcyQ2IiwibmV4dCQwIiwiY29kZXMkNyIsImNvZGVzJDgiLCJjJDIiLCJhY2MkMiIsIm5vcF9jb2RlIiwiYWRkX2NvZGVzX2FmdGVyIiwiZmluYWwkMCIsIm5jIiwic3BsaXRfcmF3X2ludG9fYm94ZXMiLCJyYXciLCJmaWxsX2xhc3QiLCJmaW5pc2hlZCIsImN1cnJlbnQiLCJmaW5pc2hlZCQwIiwiY3VycmVudCQwIiwiY3VycmVudCQxIiwiZml0X2NvZGVzX2ludG9fYm94ZXMiLCJzdGgkMCIsInN0aCQxIiwic3RoJDIiLCJleGl0IiwiZXhpdCQwIiwiZWNvZGUiLCJwYWRkaW5nJDAiLCJyZXMkMCIsInJlcyQxIiwicmVzJDIiLCJyZXN1bHQiLCJwcmVmaXgiLCJzdWZmaXhfbGVuIiwic3VmZml4IiwiZml0X2NvZGVzX2ludG9faGV4X2JveGVzIiwiaGV4MSIsImhleDIiLCJwcF9ib3hlc19uYW1lcyIsInBwX2JveCIsImNoYXJzIiwicHBfYm94X3JhdyIsInBwX2hleCIsImNvbmRfdG9fc3RyIiwic2lnbl90b19zdHIiLCJzX3RvX3N0ciIsImxfdG9fc3RyIiwicHJpbnRfcmVnaXN0ZXIiLCJwcmludF9pbW1lZGlhdGUiLCJwcmludF9vcGVyYW5kIiwicHJpbnRfaW1tZWRpYXRlX29mZnNldCIsInByaW50X3JlZ2lzdGVyX29mZnNldCIsInJvJDAiLCJybyQxIiwicyQyIiwicHBfYXJtIiwidHJlYXRfY29tbWFuZCIsImhleHMiLCJoZXgiLCJtYWluJDIiLCJwYXJzZWQiLCJoZWFkZXJzMiIsIm9ubHlyYXciLCJoZWFkZXJfbmFtZSIsIm5vcF9jb2RlX2FsdCIsInN0YXJ0JDAiLCJmaWxsZXJzJDAiLCJib3hlc19jb2RlcyIsInNpemUiLCJqb29fZ2xvYmFsX29iamVjdCIsIm51bGwiLCJ1bmRlZmluZWQiLCJleG4iLCJldmVudCIsInRyZWF0X2lucHV0IiwibGFuZyIsInN0ciIsImJ1ZmZlciIsImZtdCIsImZzIiwicHJvZ3JhbSIsImhlYWRlcnMiLCJlbnYiLCJoZWFkZXJzMiIsImV4aXQiLCJmbiIsImFzdCIsImhlYWRlcnMkMCIsImV4aXQkMCIsImUiLCJpc19ibGFua19zdHIiLCJzIiwiaSQxIiwiaSIsImMiLCJpJDAiLCJjb21wdXRlIiwibWFpbl9pbnB1dCIsInNlY29uZGFyeV9pbnB1dCIsIm91dHB1dCIsIm1haW5faW5wdXQkMCIsInNlY29uZGFyeV9pbnB1dCQwIiwiaW5wdXQiLCJsYW5nJDAiLCJyZXMiLCJpbml0IiwiY29tcHV0ZV9idXR0b24iXSwic291cmNlcyI6WyIvYnVpbHRpbi8raW50NjQuanMiLCIvYnVpbHRpbi8rbWxCeXRlcy5qcyIsIi9idWlsdGluLytmYWlsLmpzIiwiL2J1aWx0aW4vK3N0ZGxpYi5qcyIsIi9idWlsdGluLytmb3JtYXQuanMiLCIvYnVpbHRpbi8raWVlZV83NTQuanMiLCIvYnVpbHRpbi8rZnMuanMiLCIvYnVpbHRpbi8rc3lzLmpzIiwiL2J1aWx0aW4vK2ZzX2Zha2UuanMiLCIvYnVpbHRpbi8rZnNfbm9kZS5qcyIsIi9idWlsdGluLytuYXQuanMiLCIvYnVpbHRpbi8rZ3JhcGhpY3MuanMiLCIvYnVpbHRpbi8rbWFyc2hhbC5qcyIsIi9idWlsdGluLytpby5qcyIsIi9idWlsdGluLytnYy5qcyIsIi9idWlsdGluLytiaWdhcnJheS5qcyIsIi9idWlsdGluLytqc2xpYi5qcyIsIi9idWlsdGluLytwYXJzaW5nLmpzIiwiL2J1aWx0aW4vK2pzbGliX2pzX29mX29jYW1sLmpzIiwiL2J1aWx0aW4vK3VuaXguanMiLCIvYnVpbHRpbi8raW50cy5qcyIsIi9idWlsdGluLytoYXNoLmpzIiwiL2J1aWx0aW4vK2NvbXBhcmUuanMiLCIvYnVpbHRpbi8raW50ZXJuYWxNb2QuanMiLCIvYnVpbHRpbi8rb2JqLmpzIiwiL2J1aWx0aW4vK2JpZ3N0cmluZy5qcyIsIi9idWlsdGluLytiYWNrdHJhY2UuanMiLCIvYnVpbHRpbi8rbGV4aW5nLmpzIiwiL2J1aWx0aW4vK2FycmF5LmpzIiwiL2J1aWx0aW4vK3dlYWsuanMiLCIvYnVpbHRpbi8rbWQ1LmpzIiwiL2J1aWx0aW4vK3N0ci5qcyIsIi9idWlsdGluLytiaWdzdHJpbmctY3N0cnVjdC5qcyIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC91Y2hhci5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9pbnQ2NC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9sZXhpbmcubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3ByaW50ZXhjLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2ZpbGVuYW1lLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2NvbXBsZXgubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvY2FtbGludGVybmFsRm9ybWF0QmFzaWNzLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbEF0b21pYy5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9zdGRsaWIubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvcGVydmFzaXZlcy5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9mbG9hdC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9uYXRpdmVpbnQubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvbGlzdC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9zZXEubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvb3B0aW9uLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2VpdGhlci5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9yZXN1bHQubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvYm9vbC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9jaGFyLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2J5dGVzLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3N0cmluZy5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC91bml0Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL21hcnNoYWwubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvb2JqLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2FycmF5Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2ludC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9pbnQzMi5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9wYXJzaW5nLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3NldC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9tYXAubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvc3RhY2subWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvcXVldWUubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvY2FtbGludGVybmFsTGF6eS5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9sYXp5Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3N0cmVhbS5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9idWZmZXIubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvcHJpbnRmLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2FyZy5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9mdW4ubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvZ2MubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvZGlnZXN0Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3JhbmRvbS5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9oYXNodGJsLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3dlYWsubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvZm9ybWF0Lm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL3NjYW5mLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2NhbGxiYWNrLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbE9PLm1sIiwiL2hvbWUvbWljay8ub3BhbS80LjEyLjAvbGliL29jYW1sL2dlbmxleC5tbCIsIi9ob21lL21pY2svLm9wYW0vNC4xMi4wL2xpYi9vY2FtbC9lcGhlbWVyb24ubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvYmlnYXJyYXkubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvQm94ZXMvY2hhcnNldC5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9BUk0vcGFyc2VyX2FzdC5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9JTy9sZXhlci5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9JTy91dGlscy5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9Qb2tlbW9uL3N0cnVjdHVyZS5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9NYWluL3NldHRpbmdzLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L1Bva2Vtb24vc2VlZC5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9NYWluL3NlZWRfdG9vbHNfY29tbW9uLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L1NhdmUvc2F2ZS5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9JTy9wcmVwcm9jZXNzLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L01haW4vcGttbl9kYXRhX2NvbW1vbi5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9BUk0vYXJtLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0JveGVzL2JveGVzLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0JveGVzL25hbWUubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvQVJNL29wdGltaXplci5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9JTy9wYXJzZXIubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvSU8vcGFyc2VyLm1seSIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9JTy9sZXhlci5tbGwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvSU8vcGFyc2UubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvSU8vZnMubWwiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvQm94ZXMvZXhpdC5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9NYWluL2VuY29kZXJfY29tbW9uLm1sIiwiL21udC9jL1VzZXJzL01pY2svRGVza3RvcC9FbWVyYWxkQUNFL19idWlsZC9kZWZhdWx0L0FSTS9hcm1fcHJpbnRlci5tbCIsIi9tbnQvYy9Vc2Vycy9NaWNrL0Rlc2t0b3AvRW1lcmFsZEFDRS9fYnVpbGQvZGVmYXVsdC9NYWluL2FjZV9jb21tb24ubWwiLCIiLCIvbW50L2MvVXNlcnMvTWljay9EZXNrdG9wL0VtZXJhbGRBQ0UvX2J1aWxkL2RlZmF1bHQvTWFpbi9hY2VfanMubWwiLCIvaG9tZS9taWNrLy5vcGFtLzQuMTIuMC9saWIvb2NhbWwvc3RkX2V4aXQubWwiXSwibWFwcGluZ3MiOiI7Ozs7SUEwT0EsU0FBU0EsbUJBQW1CQyxHQUFLLFNBQVEsVUFBWTtJQ3pMckQsU0FBU0MsZ0JBQWdCQyxFQUFHQztNQUMxQixHQUFHRCxPQUFRO01BQ1gsR0FBSUMsU0FBVSxPQUFRLFNBQVNEO01BQy9CLElBQU0sS0FBUTtNQUNkO09BQVEsQ0FDTixHQUFJQSxNQUFPRSxLQUFLRDtRQUNoQkQ7UUFDQSxHQUFJQSxPQUFRLE9BQU9FO1FBQ25CRCxLQUFLQTtRQUNMRTtRQUNBLEdBQUlBLE9BQVEsYUFNaEI7SUQ3Q0EsSUFBSUMsa0JBQW9CO0lFQXhCLFNBQVNFLG9CQUFxQkMsS0FBTyxNQUFNQSxHQUFLO0lDMkNoRCxJQUFJQztJRFJKLFNBQVNDO01BQ1Asb0JBQW9CRCxrQ0FDdEI7SUZqQ0EsU0FBU0UsUUFBU0MsR0FBR0MsR0FBR0M7TUFDdEJDLFVBQVVILGNBQ1ZHLFVBQVVGLGNBQ1ZFLFVBQVVELFdBQ1o7SUFDQUg7SUFDQUE7O2VBQ0UsV0FBV0EsUUFBUUksUUFBUUEsUUFBUUEsUUFE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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VTs7Ozs7OztJYzdCMUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ2tCSytpQztLQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDd0JBQztLQUNBQztLQUNBQztLQUlBQztLQUNBQzs7OztLQ3pCQUM7S0FvSEFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ205RU1DO0tBUVFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ2xsRmRDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3NFRUM7S0FDQUM7S0FDQUM7S0FDQUM7OztLQS9FWUM7S0FxSFpDO0tBQ0FDO0tBQ0FDO0tBQ0FDOzs7S0FtSUFDO0tBQ0FDO0tBQ0FDO0tBQ0FDOzs7S0MxUEZDO0tBQ0FDO0tBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QkN2VXJDNkMsT0R1VXFDLFVBQXpCN0MsR0FBNEM7SUE5Sy9DLFNDbEpUNkYsY0RpVWNyRjtNQUNoQixjQ3pVRXFDLE9Ed1VjckM7TUFDUSxvQkN6VXRCcUM7TUR5VStDLHFCQ3pVL0NBLE9EeVUyRDtJQWhMbEQsU0NqSlRpRDtNRGtVbUIsb0JDMVVuQmpELFdEMFU0QyxxQkMxVTVDQSxPRDBVd0Q7SUFqTC9DLFNDaEpUa0QsV0RxVVc1QyxHQUFJLDJCQzdVZkwsT0Q2VVdLLEVBQXdCO0lBckwxQixTQy9JVDZDLGFEcVVheEYsR0FBSSxxQkM5VWpCc0MsT0Q4VWF0QyxFQUEwQjtJQXRMOUIsU0M5SVR5RixZRHFVWXpGLEdBQUksb0JDL1VoQnNDLE9EK1VZdEMsRUFBeUI7SUF2TDVCLFNDN0lUMEYsVURxVVVwSztNQUF5QixxQkNoVm5DZ0gsT0RnVm1DLDRCQUF6QmhILEdBQTBDO0lBeEwzQyxTQzVJVHFLLFlEcVVZbkcsR0FBeUIscUJDalZyQzhDLE9EaVZxQyxVQUF6QjlDLEdBQTRDO0lBekwvQyxTQzNJVG9HLGNEcVVjNUY7TUFDaEIsY0NuVkVzQyxPRGtWY3RDO01BQ1Esb0JDblZ0QnNDO01EbVYrQyxxQkNuVi9DQSxPRG1WMkQ7SUEzTGxELFNDMUlUdUQ7TURzVW1CLG9CQ3BWbkJ2RCxXRG9WNEMscUJDcFY1Q0EsT0RvVndEO0lBNUwvQyxTQ3pJVHdELGlCRHlVZSxjQ3pWZnpELFFEeVZlLGtCQzFWZkQsTUQwVjZDO0lBaE1wQyxTQ3hJVDJELGdCRHlVd0MsMEJBQWIsYUFBYTtJQWpNL0IsU0N2SVRDLG9CRHlVbUMsc0NBQWE7SUFsTXZDLFNDdElUQyxrQkR5VTRDLDRCQUFiLGFBQWE7SUFuTW5DLFNDcklUQyxzQkR5VXVDLGtDQUFhO0lBcE0zQyxTQzFFVEMsd0JYNU9MLElVb2hCcUNqSTtJQTlOdkIsU0N0RVRrSTtNRDRTTTtPQUZzQ0M7T0FBTnRKO09BQWhCdUo7T0FBTnhKO09BRVYsWUFGZ0J3SixLQUVULGFBRitCRDtNQUN0QyxxQkFEVXZKLEtBQXNCQztJQVF0QixJQUFoQndKLGlCQ2xX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Q0FDO1FBd0JBRTtPQWtDRkM7T0FHQUM7T0FHQUM7T0FHQUM7O09BT0FDO09BQ0FDO09BQ0FDO09BQ0FDOztVcERoWkw7Ozs7Ozs7SW9EQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQzRTS0M7S0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDeE1VQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDbEZWQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUNDQzJ2QjtLREREO2dCQ0NDQztLRERELElDQ0NDO0lEREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRCQ0NZQyxLQUFPLE1BQU1BLEdBQXZCOzswQkRERjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQ0NDQyxNREREOzs7Ozs7Ozs7O3lCQ0NDQSxNREREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ0FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQ01LQyxZQUFZQyxLQUFLQztNQUNuQix1QkFEY0Q7TUFFRDs7T0FDSCxrQ0FETkU7TUFDTTtRQUVDOzZCQUxRRDtTQU1RLHVCQURyQkc7U0FDcUI7O1NBQ2YsNkJBSlJELElBR0dHO1NBR0csaUNBSEhBO1FBR0c7YUFER0UsV0FBTkM7O1NBQ0c7VUFHaUI7V0FEYkM7V0FDYSx5QkFEYkEsR0FOUk47V0FPcUI7O1dBQ1YsMEJBVmJELElBSUVJLE9BS0tLLFVBQVNEO1dBSlBILFNBSUZJO1dBSkpILFFBS0dJOztVQUVDOztXQVBFTDtXQUFOQztRQVNMLHlCQWRFTixJQUlFSSxPQURDRCxRQUVNRSxVQUZHSCxRQUVUSTtZQVVBSzs7UUFBOEIsc0NBQTlCQTtRQUFLLDZCQWhCUlo7TUFpQkosNkJBaEJJQztNQWdCSixtQ0FqQklELE9Ba0JrQjthQUVwQmEsYUFBYUM7TUFDZixzQ0FEZUEsV0FDREU7TUFDWjtnQkFEWUE7VUFHRixJQUFKQyxFQUFJLHdCQUpHSCxFQUNERTtvQkFHTkMscUNBRUM7VUFGRyxJQUM0QyxJQUoxQ0Q7O1FBQ0UsU0FNVzthQUV6Qkc7TUFHRTs7OztPQURGO09BS0U7OztPQURGO09BS0U7OztPQURGO09BS0U7OztPQURGO09BRzhDLHFDQWhCNUNDO09BaUJzRCwwQ0FidERDO09BZUM7cUJBRkRHOztVQUdXLDRCQUhYQTtPQUNRLDRCQUZSRDtPQU1nQywrQkFWaEN6QjtPQVdNLGdCQURONEIsT0FKQUQ7TUFWQUgsZUFnQmMsZ0NBRGRLOzhCQUVJO2FBRU5DO01BR0U7Ozs7T0FERjtPQUkwQix3Q0FsQzFCVDtPQWtDQTtNQURGLG9DQUpJVTtNQU1ELHdCQUNNO0lBR2dCOzZDQVh2QkQ7S0FXRjtJQURNO0lBQ21CLHVCQXZFdkIvQixZQXNCQWdCLGFBVUFNLFFBNEJBUztJQVlDO1VEOUVOOzs7Ozs7O0lDQUE7Ozs7SUNrQlM7OztVRGxCVCIsInNvdXJjZXNDb250ZW50IjpbIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mZnNldFxudmFyIGNhbWxfaW50NjRfb2Zmc2V0ID0gTWF0aC5wb3coMiwgLTI0KTtcblxuLy9Qcm92aWRlczogTWxJbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZmZzZXQsIGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbmZ1bmN0aW9uIE1sSW50NjQgKGxvLG1pLGhpKSB7XG4gIHRoaXMubG8gPSBsbyAmIDB4ZmZmZmZmO1xuICB0aGlzLm1pID0gbWkgJiAweGZmZmZmZjtcbiAgdGhpcy5oaSA9IGhpICYgMHhmZmZmO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBcIl9qXCJcbk1sSW50NjQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvLHRoaXMubWksdGhpcy5oaSk7XG59XG5cbk1sSW50NjQucHJvdG90eXBlLnVjb21wYXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgaWYgKHRoaXMuaGkgPiB4LmhpKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMuaGkgPCB4LmhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGhpID0gdGhpcy5oaSA8PCAxNjtcbiAgdmFyIHhoaSA9IHguaGkgPDwgMTY7XG4gIGlmIChoaSA+IHhoaSkgcmV0dXJuIDE7XG4gIGlmIChoaSA8IHhoaSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5taSA+IHgubWkpIHJldHVybiAxO1xuICBpZiAodGhpcy5taSA8IHgubWkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubG8gPiB4LmxvKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubG8gPCB4LmxvKSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG8gPSAtIHRoaXMubG87XG4gIHZhciBtaSA9IC0gdGhpcy5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IC0gdGhpcy5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKyB4LmxvO1xuICB2YXIgbWkgPSB0aGlzLm1pICsgeC5taSArIChsbyA+PiAyNCk7XG4gIHZhciBoaSA9IHRoaXMuaGkgKyB4LmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyAtIHgubG87XG4gIHZhciBtaSA9IHRoaXMubWkgLSB4Lm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gdGhpcy5oaSAtIHguaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvICogeC5sbztcbiAgdmFyIG1pID0gKChsbyAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgdGhpcy5taSAqIHgubG8gKyB0aGlzLmxvICogeC5taTtcbiAgdmFyIGhpID0gKChtaSAqIGNhbWxfaW50NjRfb2Zmc2V0KSB8IDApICsgdGhpcy5oaSAqIHgubG8gKyB0aGlzLm1pICogeC5taSArIHRoaXMubG8gKiB4LmhpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAodGhpcy5sb3x0aGlzLm1pfHRoaXMuaGkpID09IDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmhpIDw8IDE2KSA8IDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQodGhpcy5sbyAmIHgubG8sIHRoaXMubWkgJiB4Lm1pLCB0aGlzLmhpICYgeC5oaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvfHgubG8sIHRoaXMubWl8eC5taSwgdGhpcy5oaXx4LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvXngubG8sIHRoaXMubWleeC5taSwgdGhpcy5oaV54LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X2xlZnQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgaWYgKHMgPCAyNCkge1xuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAodGhpcy5sbyA8PCBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubWkgPDwgcykgfCAodGhpcy5sbyA+PiAoMjQgLSBzKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5oaSA8PCBzKSB8ICh0aGlzLm1pID4+ICgyNCAtIHMpKSk7XG4gIH1cbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvIDw8IChzIC0gMjQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMubWkgPDwgKHMgLSAyNCkpIHwgKHRoaXMubG8gPj4gKDQ4IC0gcykpKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KDAsIDAsIHRoaXMubG8gPDwgKHMgLSA0OCkpXG59XG5NbEludDY0LnByb3RvdHlwZS5zaGlmdF9yaWdodF91bnNpZ25lZCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5sbyA+PiBzKSB8ICh0aGlzLm1pIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLm1pID4+IHMpIHwgKHRoaXMuaGkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPj4gcykpO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAodGhpcy5oaSA+PiAocyAtIDI0KSksXG4gICAgICAwKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0ICh0aGlzLmhpID4+IChzIC0gNDgpLCAwLCAwKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0ID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIHZhciBoID0gKHRoaXMuaGkgPDwgMTYpID4+IDE2O1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5sbyA+PiBzKSB8ICh0aGlzLm1pIDw8ICgyNCAtIHMpKSxcbiAgICAgICh0aGlzLm1pID4+IHMpIHwgKGggPDwgKDI0IC0gcykpLFxuICAgICAgKCh0aGlzLmhpIDw8IDE2KSA+PiBzKSA+Pj4gMTYpO1xuICB2YXIgc2lnbiA9ICh0aGlzLmhpIDw8IDE2KSA+PiAzMTtcbiAgaWYgKHMgPCA0OClcbiAgICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgICAgKHRoaXMubWkgPj4gKHMgLSAyNCkpIHwgKHRoaXMuaGkgPDwgKDQ4IC0gcykpLFxuICAgICAgKHRoaXMuaGkgPDwgMTYpID4+IChzIC0gMjQpID4+IDE2LFxuICAgICAgc2lnbiAmIDB4ZmZmZik7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAoKHRoaXMuaGkgPDwgMTYpID4+IChzIC0gMzIpLCBzaWduLCBzaWduKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxzbDEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGkgPSAodGhpcy5oaSA8PCAxKSB8ICh0aGlzLm1pID4+IDIzKTtcbiAgdGhpcy5taSA9ICgodGhpcy5taSA8PCAxKSB8ICh0aGlzLmxvID4+IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5sbyA9ICh0aGlzLmxvIDw8IDEpICYgMHhmZmZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5sc3IxID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxvID0gKCh0aGlzLmxvID4+PiAxKSB8ICh0aGlzLm1pIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5taSA9ICgodGhpcy5taSA+Pj4gMSkgfCAodGhpcy5oaSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHRoaXMuaGkgPSB0aGlzLmhpID4+PiAxO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudWRpdm1vZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgbW9kdWx1cyA9IHRoaXMuY29weSgpO1xuICB2YXIgZGl2aXNvciA9IHguY29weSgpO1xuICB2YXIgcXVvdGllbnQgPSBuZXcgTWxJbnQ2NCgwLDAsMCk7XG4gIHdoaWxlIChtb2R1bHVzLnVjb21wYXJlKGRpdmlzb3IpID4gMCkge1xuICAgIG9mZnNldCsrO1xuICAgIGRpdmlzb3IubHNsMSgpO1xuICB9XG4gIHdoaWxlIChvZmZzZXQgPj0gMCkge1xuICAgIG9mZnNldCAtLTtcbiAgICBxdW90aWVudC5sc2wxKCk7XG4gICAgaWYgKG1vZHVsdXMudWNvbXBhcmUoZGl2aXNvcikgPj0gMCkge1xuICAgICAgcXVvdGllbnQubG8gKys7XG4gICAgICBtb2R1bHVzID0gbW9kdWx1cy5zdWIoZGl2aXNvcik7XG4gICAgfVxuICAgIGRpdmlzb3IubHNyMSgpO1xuICB9XG4gIHJldHVybiB7IHF1b3RpZW50IDogcXVvdGllbnQsIG1vZHVsdXMgOiBtb2R1bHVzIH07XG59XG5NbEludDY0LnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAoeSlcbntcbiAgdmFyIHggPSB0aGlzO1xuICBpZiAoeS5pc1plcm8oKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4LmhpIF4geS5oaTtcbiAgaWYgKHguaGkgJiAweDgwMDApIHggPSB4Lm5lZygpO1xuICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gIHZhciBxID0geC51ZGl2bW9kKHkpLnF1b3RpZW50O1xuICBpZiAoc2lnbiAmIDB4ODAwMCkgcSA9IHEubmVnKCk7XG4gIHJldHVybiBxO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24gKHkpXG57XG4gIHZhciB4ID0gdGhpcztcbiAgaWYgKHkuaXNaZXJvKCkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geC5oaTtcbiAgaWYgKHguaGkgJiAweDgwMDApIHggPSB4Lm5lZygpO1xuICBpZiAoeS5oaSAmIDB4ODAwMCkgeSA9IHkubmVnKCk7XG4gIHZhciByID0geC51ZGl2bW9kKHkpLm1vZHVsdXM7XG4gIGlmIChzaWduICYgMHg4MDAwKSByID0gci5uZWcoKTtcbiAgcmV0dXJuIHI7XG59XG5NbEludDY0LnByb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubG8gfCAodGhpcy5taSA8PCAyNCk7XG59XG5NbEludDY0LnByb3RvdHlwZS50b0Zsb2F0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLmhpIDw8IDE2KSAqIE1hdGgucG93KDIsIDMyKSArIHRoaXMubWkgKiBNYXRoLnBvdygyLCAyNCkpICsgdGhpcy5sbztcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbdGhpcy5oaSA+PiA4LFxuICAgICAgICAgIHRoaXMuaGkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubWkgPj4gMTYsXG4gICAgICAgICAgKHRoaXMubWkgPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubWkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubG8gPj4gMTYsXG4gICAgICAgICAgKHRoaXMubG8gPj4gOCkgJiAweGZmLFxuICAgICAgICAgIHRoaXMubG8gJiAweGZmXTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxvMzIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvIHwgKCh0aGlzLm1pICYgMHhmZikgPDwgMjQpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuaGkzMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICgodGhpcy5taSA+Pj4gOCkgJiAweGZmZmYpIHwgKHRoaXMuaGkgPDwgMTYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VsdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bHQoeCx5KSB7IHJldHVybiB4LnVjb21wYXJlKHkpIDwgMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY29tcGFyZSh4LHksIHRvdGFsKSB7IHJldHVybiB4LmNvbXBhcmUoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X25lZyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9uZWcgKHgpIHsgcmV0dXJuIHgubmVnKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FkZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hZGQgKHgsIHkpIHsgcmV0dXJuIHguYWRkKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zdWIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc3ViICh4LCB5KSB7IHJldHVybiB4LnN1Yih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbXVsIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tdWwoeCx5KSB7IHJldHVybiB4Lm11bCh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfemVybyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc196ZXJvKHgpIHsgcmV0dXJuICt4LmlzWmVybygpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaXNfbmVnYXRpdmUoeCkgeyByZXR1cm4gK3guaXNOZWcoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2FuZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9hbmQgKHgsIHkpIHsgcmV0dXJuIHguYW5kKHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb3IgKHgsIHkpIHsgcmV0dXJuIHgub3IoeSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF94b3IgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfeG9yICh4LCB5KSB7IHJldHVybiB4Lnhvcih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfbGVmdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0ICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X2xlZnQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCAoeCwgcykgeyByZXR1cm4geC5zaGlmdF9yaWdodChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZGl2IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2RpdiAoeCwgeSkgeyByZXR1cm4geC5kaXYoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21vZCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tb2QgKHgsIHkpIHsgcmV0dXJuIHgubW9kKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9pbnQzMiAoeCkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoeCAmIDB4ZmZmZmZmLCAoeCA+PiAyNCkgJiAweGZmZmZmZiwgKHggPj4gMzEpICYgMHhmZmZmKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2ludDMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2ludDMyICh4KSB7IHJldHVybiB4LnRvSW50KCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3RvX2Zsb2F0ICh4KSB7IHJldHVybiB4LnRvRmxvYXQgKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoeCkge1xuICBpZiAoeCA8IDApIHggPSBNYXRoLmNlaWwoeCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChcbiAgICB4ICYgMHhmZmZmZmYsXG4gICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmZmYsXG4gICAgTWF0aC5mbG9vcih4ICogY2FtbF9pbnQ2NF9vZmZzZXQgKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zvcm1hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9mb3JtYXQsIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfbmVnYXRpdmUsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mb3JtYXQgKGZtdCwgeCkge1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSkge1xuICAgIGYuc2lnbiA9IC0xOyB4ID0gY2FtbF9pbnQ2NF9uZWcoeCk7XG4gIH1cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIHZhciB3YmFzZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZi5iYXNlKTtcbiAgdmFyIGN2dGJsID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIGRvIHtcbiAgICB2YXIgcCA9IHgudWRpdm1vZCh3YmFzZSk7XG4gICAgeCA9IHAucXVvdGllbnQ7XG4gICAgYnVmZmVyID0gY3Z0YmwuY2hhckF0KGNhbWxfaW50NjRfdG9faW50MzIocC5tb2R1bHVzKSkgKyBidWZmZXI7XG4gIH0gd2hpbGUgKCEgY2FtbF9pbnQ2NF9pc196ZXJvKHgpKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBidWZmZXIubGVuZ3RoO1xuICAgIGlmIChuID4gMCkgYnVmZmVyID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgYnVmZmVyO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIGJ1ZmZlcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfZmFpbHdpdGgsIGNhbWxfcGFyc2VfZGlnaXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdWx0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9zdHJpbmcocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgYmFzZTY0ID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihiYXNlKTtcbiAgdmFyIHRocmVzaG9sZCA9XG4gICAgICBuZXcgTWxJbnQ2NCgweGZmZmZmZiwgMHhmZmZmZmZmLCAweGZmZmYpLnVkaXZtb2QoYmFzZTY0KS5xdW90aWVudDtcbiAgdmFyIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB2YXIgcmVzID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgZm9yICg7Oykge1xuICAgIGkrKztcbiAgICBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgICBpZiAoYyA9PSA5NSkgY29udGludWU7XG4gICAgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gICAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgYnJlYWs7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIG11bHRpcGxpY2F0aW9uIGJhc2UgKiByZXMgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQodGhyZXNob2xkLCByZXMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgICBkID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihkKTtcbiAgICByZXMgPSBjYW1sX2ludDY0X2FkZChjYW1sX2ludDY0X211bChiYXNlNjQsIHJlcyksIGQpO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBhZGRpdGlvbiAoYmFzZSAqIHJlcykgKyBkICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHJlcywgZCkpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChiYXNlID09IDEwICYmIGNhbWxfaW50NjRfdWx0KG5ldyBNbEludDY0KDAsIDAsIDB4ODAwMCksIHJlcykpXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIGlmIChzaWduIDwgMCkgcmVzID0gY2FtbF9pbnQ2NF9uZWcocmVzKTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKGxvLCBtaSwgaGkpe1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSlcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsbywgaGkpe1xuICByZXR1cm4gbmV3IE1sSW50NjQgKFxuICAgIGxvICYgMHhmZmZmZmYsXG4gICAgKChsbyA+Pj4gMjQpICYgMHhmZikgfCAoKGhpICYgMHhmZmZmKSA8PCA4KSxcbiAgICAoaGkgPj4+IDE2KSAmIDB4ZmZmZik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2xvMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbG8zMih2KXsgcmV0dXJuIHYubG8zMigpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9oaTMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2hpMzIodil7IHJldHVybiB2LmhpMzIoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSkge1xuICByZXR1cm4gbmV3IE1sSW50NjQoYVs3XSA8PCAwIHwgKGFbNl0gPDwgOCkgfCAoYVs1XSA8PCAxNiksXG4gICAgICAgICAgICAgICAgICAgICBhWzRdIDw8IDAgfCAoYVszXSA8PCA4KSB8IChhWzJdIDw8IDE2KSxcbiAgICAgICAgICAgICAgICAgICAgIGFbMV0gPDwgMCB8IChhWzBdIDw8IDgpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fYnl0ZXMoeCkgeyByZXR1cm4geC50b0FycmF5KCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hhc2ggY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGFzaCh2KXtcbiAgcmV0dXJuICh2LmxvMzIoKSkgXiAodi5oaTMyKCkpXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAtMjAxNCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBBbiBPQ2FtbCBzdHJpbmcgaXMgYW4gb2JqZWN0IHdpdGggdGhyZWUgZmllbGRzOlxuLy8gLSB0YWcgJ3QnXG4vLyAtIGxlbmd0aCAnbCdcbi8vIC0gY29udGVudHMgJ2MnXG4vL1xuLy8gVGhlIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcgY2FuIGJlIGVpdGhlciBhIEphdmFTY3JpcHQgYXJyYXkgb3Jcbi8vIGEgSmF2YVNjcmlwdCBzdHJpbmcuIFRoZSBsZW5ndGggb2YgdGhpcyBzdHJpbmcgY2FuIGJlIGxlc3MgdGhhbiB0aGVcbi8vIGxlbmd0aCBvZiB0aGUgT0NhbWwgc3RyaW5nLiBJbiB0aGlzIGNhc2UsIHJlbWFpbmluZyBieXRlcyBhcmVcbi8vIGFzc3VtZWQgdG8gYmUgemVyb2VzLiBBcnJheXMgYXJlIG11dGFibGUgYnV0IGNvbnN1bWVzIG1vcmUgbWVtb3J5XG4vLyB0aGFuIHN0cmluZ3MuIEEgY29tbW9uIHBhdHRlcm4gaXMgdG8gc3RhcnQgZnJvbSBhbiBlbXB0eSBzdHJpbmcgYW5kXG4vLyBwcm9ncmVzc2l2ZWx5IGZpbGwgaXQgZnJvbSB0aGUgc3RhcnQuIFBhcnRpYWwgc3RyaW5ncyBtYWtlcyBpdFxuLy8gcG9zc2libGUgdG8gaW1wbGVtZW50IHRoaXMgZWZmaWNpZW50bHkuXG4vL1xuLy8gV2hlbiBjb252ZXJ0aW5nIHRvIGFuZCBmcm9tIFVURi0xNiwgd2Uga2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZVxuLy8gc3RyaW5nIGlzIGNvbXBvc2VkIG9ubHkgb2YgQVNDSUkgY2hhcmFjdGVycyAoaW4gd2hpY2ggY2FzZSwgbm9cbi8vIGNvbnZlcnNpb24gbmVlZHMgdG8gYmUgcGVyZm9ybWVkKSBvciBub3QuXG4vL1xuLy8gVGhlIHN0cmluZyB0YWcgY2FuIHRodXMgdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczpcbi8vICAgZnVsbCBzdHJpbmcgICAgIEJZVEUgfCBVTktOT1dOOiAgICAgIDBcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBBU0NJSTogICAgICAgIDlcbi8vICAgICAgICAgICAgICAgICAgIEJZVEUgfCBOT1RfQVNDSUk6ICAgIDhcbi8vICAgc3RyaW5nIHByZWZpeCAgIFBBUlRJQUw6ICAgICAgICAgICAgIDJcbi8vICAgYXJyYXkgICAgICAgICAgIEFSUkFZOiAgICAgICAgICAgICAgIDRcbi8vXG4vLyBPbmUgY2FuIHVzZSBiaXQgbWFza2luZyB0byBkaXNjcmltaW5hdGUgdGhlc2UgZGlmZmVyZW50IGNhc2VzOlxuLy8gICBrbm93bl9lbmNvZGluZyh4KSA9IHgmOFxuLy8gICBpc19hc2NpaSh4KSA9ICAgICAgIHgmMVxuLy8gICBraW5kKHgpID0gICAgICAgICAgIHgmNlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cl9yZXBlYXRcbmZ1bmN0aW9uIGNhbWxfc3RyX3JlcGVhdChuLCBzKSB7XG4gIGlmKG4gPT0gMCkgcmV0dXJuIFwiXCI7XG4gIGlmIChzLnJlcGVhdCkge3JldHVybiBzLnJlcGVhdChuKTt9IC8vIEVDTUFzY3JpcHQgNiBhbmQgRmlyZWZveCAyNCtcbiAgdmFyIHIgPSBcIlwiLCBsID0gMDtcbiAgZm9yKDs7KSB7XG4gICAgaWYgKG4gJiAxKSByICs9IHM7XG4gICAgbiA+Pj0gMTtcbiAgICBpZiAobiA9PSAwKSByZXR1cm4gcjtcbiAgICBzICs9IHM7XG4gICAgbCsrO1xuICAgIGlmIChsID09IDkpIHtcbiAgICAgIHMuc2xpY2UoMCwxKTsgLy8gZmxhdHRlbiB0aGUgc3RyaW5nXG4gICAgICAvLyB0aGVuLCB0aGUgZmxhdHRlbmluZyBvZiB0aGUgd2hvbGUgc3RyaW5nIHdpbGwgYmUgZmFzdGVyLFxuICAgICAgLy8gYXMgaXQgd2lsbCBiZSBjb21wb3NlZCBvZiBsYXJnZXIgcGllY2VzXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuLy9XZWFrZGVmXG4vLyBQcmUgRUNNQVNjcmlwdCA1LCBbYXBwbHldIHdvdWxkIG5vdCBzdXBwb3J0IGFycmF5LWxpa2Ugb2JqZWN0LlxuLy8gSW4gc3VjaCBzZXR1cCwgVHlwZWRfYXJyYXkgd291bGQgYmUgaW1wbGVtZW50ZWQgYXMgcG9seWZpbGwsIGFuZCBbZi5hcHBseV0gd291bGRcbi8vIGZhaWwgaGVyZS4gTWFyayB0aGUgcHJpbWl0aXZlIGFzIFdlYWtkZWYsIHNvIHRoYXQgcGVvcGxlIGNhbiBvdmVycmlkZSBpdCBlYXNpbHkuXG5mdW5jdGlvbiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMgKGEsIGksIGxlbikge1xuICB2YXIgZiA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4gIGlmIChpID09IDAgJiYgbGVuIDw9IDQwOTYgJiYgbGVuID09IGEubGVuZ3RoKSByZXR1cm4gZi5hcHBseSAobnVsbCwgYSk7XG4gIHZhciBzID0gXCJcIjtcbiAgZm9yICg7IDAgPCBsZW47IGkgKz0gMTAyNCxsZW4tPTEwMjQpXG4gICAgcyArPSBmLmFwcGx5IChudWxsLCBhLnNsaWNlKGksaSArIE1hdGgubWluKGxlbiwgMTAyNCkpKTtcbiAgcmV0dXJuIHM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmOF9vZl91dGYxNlxuZnVuY3Rpb24gY2FtbF91dGY4X29mX3V0ZjE2KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBiLCBjLCBkLCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYyA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhjMCB8IChjID4+IDYpKTtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhkZmZmKSB7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlMCB8IChjID4+IDEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA+PSAweGRiZmYgfHwgaSArIDEgPT0gbCB8fFxuICAgICAgICAgICAgICAgKGQgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBkID4gMHhkZmZmKSB7XG4gICAgICAvLyBVbm1hdGNoZWQgc3Vycm9nYXRlIHBhaXIsIHJlcGxhY2VkIGJ5IFxcdWZmZmQgKHJlcGxhY2VtZW50IGNoYXJhY3RlcilcbiAgICAgIHQgKz0gXCJcXHhlZlxceGJmXFx4YmRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaSsrO1xuICAgICAgYyA9IChjIDw8IDEwKSArIGQgLSAweDM1ZmRjMDA7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmMCB8IChjID4+IDE4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDEyKSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfVxuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBjYW1sX3V0ZjE2X29mX3V0Zjgocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IFwiXCIsIGMsIGMxLCBjMiwgdiwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMxID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjMSA8IDB4ODApIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgKGogPCBsKSAmJiAoYzEgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgdiA9IDE7XG4gICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgIGMgPSBjMiArIChjMSA8PCA2KTtcbiAgICAgIGlmIChjMSA8IDB4ZTApIHtcbiAgICAgICAgdiA9IGMgLSAweDMwODA7XG4gICAgICAgIGlmICh2IDwgMHg4MCkgdiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gMjtcbiAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkpIHtcbiAgICAgICAgICBjID0gYzIgKyAoYyA8PCA2KTtcbiAgICAgICAgICBpZiAoYzEgPCAweGYwKSB7XG4gICAgICAgICAgICB2ID0gYyAtIDB4ZTIwODA7XG4gICAgICAgICAgICBpZiAoKHYgPCAweDgwMCkgfHwgKCh2ID49IDB4ZDdmZikgJiYgKHYgPCAweGUwMDApKSkgdiA9IDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHYgPSAzO1xuICAgICAgICAgICAgaWYgKCgrK2kgPCBsKSAmJiAoKChjMiA9IHMuY2hhckNvZGVBdChpKSkgJiAtNjQpID09IDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoYzEgPCAweGY1KSkge1xuICAgICAgICAgICAgICB2ID0gYzIgLSAweDNjODIwODAgKyAoYyA8PCA2KTtcbiAgICAgICAgICAgICAgaWYgKHYgPCAweDEwMDAwIHx8IHYgPiAweDEwZmZmZikgdiA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2IDwgNCkgeyAvLyBJbnZhbGlkIHNlcXVlbmNlXG4gICAgICBpIC09IHY7XG4gICAgICB0ICs9IFwiXFx1ZmZmZFwiO1xuICAgIH0gZWxzZSBpZiAodiA+IDB4ZmZmZilcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ3YzAgKyAodiA+PiAxMCksIDB4ZGMwMCArICh2ICYgMHgzRkYpKVxuICAgIGVsc2VcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh2KTtcbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGpzb29faXNfYXNjaWlcbmZ1bmN0aW9uIGpzb29faXNfYXNjaWkgKHMpIHtcbiAgLy8gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBnZXRzIGJldHRlciBhdCBhcm91bmQgdGhpcyBwb2ludCBmb3IgYWxsIGJyb3dzZXJzXG4gIGlmIChzLmxlbmd0aCA8IDI0KSB7XG4gICAgLy8gU3BpZGVybW9ua2V5IGdldHMgbXVjaCBzbG93ZXIgd2hlbiBzLmxlbmd0aCA+PSAyNCAob24gNjQgYml0IGFyY2hzKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykgaWYgKHMuY2hhckNvZGVBdChpKSA+IDEyNykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2VcbiAgICByZXR1cm4gIS9bXlxceDAwLVxceDdmXS8udGVzdChzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSkge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGlmIChpID49IHMuYy5sZW5ndGgpIHJldHVybiAwO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYy5jaGFyQ29kZUF0KGkpO1xuICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgcmV0dXJuIHMuY1tpXVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgLy8gVGhlIE9DYW1sIGNvbXBpbGVyIHVzZXMgQ2hhci51bnNhZmVfY2hyIG9uIGludGVnZXJzIGxhcmdlciB0aGFuIDI1NSFcbiAgYyAmPSAweGZmO1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIHtcbiAgICBpZiAoaSA9PSBzLmMubGVuZ3RoKSB7XG4gICAgICBzLmMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoYyk7XG4gICAgICBpZiAoaSArIDEgPT0gcy5sKSBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpO1xuICB9XG4gIHMuY1tpXSA9IGM7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gMSkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MTYocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDEpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSk7XG4gIHJldHVybiAoYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAzKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMiksXG4gICAgICBiNCA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0LCBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDMyKHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDEpLFxuICAgICAgYjMgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIC0gNykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIGopO1xuICB9XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBuZXcgQXJyYXkoOCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspe1xuICAgIGFbNyAtIGpdID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjIgPSAweEZGICYgaTE2ID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMTY7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MTZcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDE2XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQxNihzLGksaTE2KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjQgPSAweEZGICYgaTMyID4+IDI0LFxuICAgICAgYjMgPSAweEZGICYgaTMyID4+IDE2LFxuICAgICAgYjIgPSAweEZGICYgaTMyID4+IDgsXG4gICAgICBiMSA9IDB4RkYgJiBpMzI7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAyLCBiMyk7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDMsIGI0KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MzJcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDMyXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQzMlxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCl7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDcpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGEgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGk2NCk7XG4gIGZvcih2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyA3IC0gaiwgYVtqXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3NldDY0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQ2NFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0NjQocyxpLGk2NCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyAocykge1xuICB2YXIgdGFnID0gOSAvKiBCWVRFUyB8IEFTQ0lJICovO1xuICBpZiAoIWpzb29faXNfYXNjaWkocykpXG4gICAgdGFnID0gOCAvKiBCWVRFUyB8IE5PVF9BU0NJSSAqLywgcyA9IGNhbWxfdXRmOF9vZl91dGYxNihzKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKHRhZywgcywgcy5sZW5ndGgpO1xufVxuXG5cbi8vUHJvdmlkZXM6IE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMsIGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gTWxCeXRlcyAodGFnLCBjb250ZW50cywgbGVuZ3RoKSB7XG4gIHRoaXMudD10YWc7IHRoaXMuYz1jb250ZW50czsgdGhpcy5sPWxlbmd0aDtcbn1cbk1sQnl0ZXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgc3dpdGNoICh0aGlzLnQpIHtcbiAgY2FzZSA5OiAvKkJZVEVTIHwgQVNDSUkqL1xuICAgIHJldHVybiB0aGlzLmM7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyh0aGlzKTtcbiAgY2FzZSAwOiAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICBpZiAoanNvb19pc19hc2NpaSh0aGlzLmMpKSB7XG4gICAgICB0aGlzLnQgPSA5OyAvKkJZVEVTIHwgQVNDSUkqL1xuICAgICAgcmV0dXJuIHRoaXMuYztcbiAgICB9XG4gICAgdGhpcy50ID0gODsgLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gIGNhc2UgODogLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgfVxufTtcbk1sQnl0ZXMucHJvdG90eXBlLnRvVXRmMTYgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIHIgPSB0aGlzLnRvU3RyaW5nKCk7XG4gIGlmKHRoaXMudCA9PSA5KSByZXR1cm4gclxuICByZXR1cm4gY2FtbF91dGYxNl9vZl91dGY4KHIpO1xufVxuTWxCeXRlcy5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoKXtcbiAgdmFyIGNvbnRlbnQgPSB0aGlzLnQgPT0gNCA/IHRoaXMuYy5zbGljZSgpIDogdGhpcy5jO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGhpcy50LGNvbnRlbnQsdGhpcy5sKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQllURVMgKi9cbiAgaWYgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8pXG4gICAgcy5jICs9IGNhbWxfc3RyX3JlcGVhdChzLmwgLSBzLmMubGVuZ3RoLCAnXFwwJylcbiAgZWxzZVxuICAgIHMuYyA9IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAocy5jLCAwLCBzLmMubGVuZ3RoKTtcbiAgcy50ID0gMDsgLypCWVRFUyB8IFVOS09XTiovXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5IChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEFSUkFZICovXG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkpIHtcbiAgICB2YXIgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KHMubCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkocy5sKTtcbiAgfVxuICB2YXIgYiA9IHMuYywgbCA9IGIubGVuZ3RoLCBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gIGZvciAobCA9IHMubDsgaSA8IGw7IGkrKykgYVtpXSA9IDA7XG4gIHMuYyA9IGE7XG4gIHMudCA9IDQ7IC8qIEFSUkFZICovXG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9ieXRlcyAocykge1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgcmV0dXJuIHMuYztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9vZl9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfb2Zfc3RyaW5nIChzKSB7XG4gIHZhciBsID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgdmFyIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocyxpKTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGlmKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9jcmVhdGVfc3RyaW5nKGxlbikge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHJpbmcuY3JlYXRlXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcyxjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2J5dGVzKGxlbikge1xuICBpZiAobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQnl0ZXMuY3JlYXRlXCIpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXMobGVuPzI6OSxcIlwiLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhhLDAsYS5sZW5ndGgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9hcnJheSAoYSkge1xuICByZXR1cm4gbmV3IE1sQnl0ZXMoNCxhLGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19jb21wYXJlIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfY29tcGFyZShzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/LTE6KHMxLmMgPiBzMi5jKT8xOjA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19lcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPT0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ub3RlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19lcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzdGhhbiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczIsczEpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMyLHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMyLCBzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmlsbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfZmlsbF9ieXRlcyhzLCBpLCBsLCBjKSB7XG4gIGlmIChsID4gMCkge1xuICAgIGlmIChpID09IDAgJiYgKGwgPj0gcy5sIHx8IChzLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGwgPj0gcy5jLmxlbmd0aCkpKSB7XG4gICAgICBpZiAoYyA9PSAwKSB7XG4gICAgICAgIHMuYyA9IFwiXCI7XG4gICAgICAgIHMudCA9IDI7IC8qIFBBUlRJQUwgKi9cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMuYyA9IGNhbWxfc3RyX3JlcGVhdCAobCwgU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgIHMudCA9IChsID09IHMubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzKTtcbiAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSBzLmNbaV0gPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9maWxsX2J5dGVzXG52YXIgY2FtbF9maWxsX3N0cmluZyA9IGNhbWxfZmlsbF9ieXRlc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JsaXRfYnl0ZXMoczEsIGkxLCBzMiwgaTIsIGxlbikge1xuICBpZiAobGVuID09IDApIHJldHVybiAwO1xuICBpZiAoKGkyID09IDApICYmXG4gICAgICAobGVuID49IHMyLmwgfHwgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGxlbiA+PSBzMi5jLmxlbmd0aCkpKSB7XG4gICAgczIuYyA9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2UgaWYgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGkyID09IHMyLmMubGVuZ3RoKSB7XG4gICAgczIuYyArPSAoczEudCA9PSA0IC8qIEFSUkFZICovKT9cbiAgICAgIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyhzMS5jLCBpMSwgbGVuKTpcbiAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIHtcbiAgICBpZiAoczIudCAhPSA0IC8qIEFSUkFZICovKSBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkoczIpO1xuICAgIHZhciBjMSA9IHMxLmMsIGMyID0gczIuYztcbiAgICBpZiAoczEudCA9PSA0IC8qIEFSUkFZICovKSB7XG4gICAgICBpZiAoaTIgPD0gaTEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkgYzIgW2kyICsgaV0gPSBjMSBbaTEgKyBpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGwgPSBNYXRoLm1pbiAobGVuLCBjMS5sZW5ndGggLSBpMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykgYzIgW2kyICsgaV0gPSBjMS5jaGFyQ29kZUF0KGkxICsgaSk7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2JsaXRfc3RyaW5nKGEsYixjLGQsZSkge1xuICAgIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhhKSxiLGMsZCxlKTtcbiAgICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9ieXRlc19sZW5ndGgocykgeyByZXR1cm4gcy5sIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBzLmNoYXJDb2RlQXQoaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ191bnNhZmVfc2V0XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpIHtcbiAgcmV0dXJuIHMubGVuZ3RoXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2NvbXBhcmUgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfY29tcGFyZShzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8tMTooczEgPiBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiAoczEgPD0gczIpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW4gY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiAoczEgPCBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7XG4gICAgKHMudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMuYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl9qc2J5dGVzKGNhbWxfanNieXRlc19vZl9zdHJpbmcocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoeCkgeyByZXR1cm4geCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmMTZfb2ZfdXRmOFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSB7XG4gIGlmKGpzb29faXNfYXNjaWkocykpXG4gICAgcmV0dXJuIHM7XG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWksIGNhbWxfdXRmOF9vZl91dGYxNiwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICBpZiAoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKVxuICBlbHNlIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfdXRmOF9vZl91dGYxNihzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIG5ldyBNbEJ5dGVzKDAscyxzLmxlbmd0aCk7IH1cblxuXG4vLyBUaGUgc2VjdGlvbiBiZWxvdyBzaG91bGQgYmUgdXNlZCB3aGVuIHVzZS1qcy1zdHJpbmc9ZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocyxpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQocyxpLGMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgocylcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19jb21wYXJlXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19jb21wYXJlKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19lcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19lcXVhbFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW5cbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMSxzMilcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHsgcmV0dXJuIHMgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB7IHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocyk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIGlmICgocy50ICYgNikgIT0gMCAvKiBCWVRFUyAqLykgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIHMuYyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocyl7XG4gIHJldHVybiBzLnRvVXRmMTYoKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfdXRmMTZfanNzdHJpbmcocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaXNfbWxfYnl0ZXMocykge1xuICByZXR1cm4gKHMgaW5zdGFuY2VvZiBNbEJ5dGVzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9zdHJpbmdcbi8vUmVxdWlyZXM6IGpzb29faXNfYXNjaWlcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gKHR5cGVvZiBzID09PSBcInN0cmluZ1wiICYmICEvW15cXHgwMC1cXHhmZl0vLnRlc3QocykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9pc19tbF9zdHJpbmcocykge1xuICByZXR1cm4gY2FtbF9pc19tbF9ieXRlcyhzKTtcbn1cblxuLy8gVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgZGVwcmVjYXRlZFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nKHMpIHsgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbmV3X3N0cmluZyAocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19mcm9tX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RvX2pzX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3RvX2pzX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdG9fc3RyaW5nIChzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhzKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUmFpc2UgZXhjZXB0aW9uXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9jb25zdGFudCAodGFnKSB7IHRocm93IHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50ICh0YWcpIHsgcmV0dXJuIHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3dpdGhfYXJnICh0YWcsIGFyZykgeyB0aHJvdyBbMCwgdGFnLCBhcmddOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKHRhZywgbXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhtc2cpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mYWlsd2l0aCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2ZhaWx3aXRoIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsIG1zZyk7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfaW52YWxpZF9hcmd1bWVudCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5JbnZhbGlkX2FyZ3VtZW50LCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkVuZF9vZl9maWxlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5EaXZpc2lvbl9ieV96ZXJvKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLk5vdF9mb3VuZCk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpIHtcbiAgaWYoZi5mdW4pXG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5mdW4sIGFyZ3MpO1xuICAvL0ZJWE1FLCBjYW4gaGFwcGVuIHdpdGggdG9vIG1hbnkgYXJndW1lbnRzXG4gIGlmKHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmO1xuICB2YXIgbiA9IGYubGVuZ3RoIHwgMDtcbiAgaWYobiA9PT0gMCkgcmV0dXJuIGYuYXBwbHkobnVsbCxhcmdzKTtcbiAgdmFyIGFyZ3NMZW4gPSBhcmdzLmxlbmd0aCB8IDA7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW4gfCAwO1xuICBpZiAoZCA9PSAwKVxuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICBlbHNlIGlmIChkIDwgMCkge1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuYXBwbHkobnVsbCxhcmdzLnNsaWNlKDAsbikpLGFyZ3Muc2xpY2UobikpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKXtcbiAgICAgIHZhciBleHRyYV9hcmdzID0gKGFyZ3VtZW50cy5sZW5ndGggPT0gMCk/MTphcmd1bWVudHMubGVuZ3RoO1xuICAgICAgdmFyIG5hcmdzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoK2V4dHJhX2FyZ3MpO1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKSBuYXJnc1tpXSA9IGFyZ3NbaV07XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkgbmFyZ3NbYXJncy5sZW5ndGgraV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBuYXJncylcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZXNcbnZhciBjYW1sX25hbWVkX3ZhbHVlcyA9IHt9O1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlIChjb25zdCxjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlKG5tLHYpIHtcbiAgY2FtbF9uYW1lZF92YWx1ZXNbY2FtbF9qc2J5dGVzX29mX3N0cmluZyhubSldID0gdjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG5mdW5jdGlvbiBjYW1sX25hbWVkX3ZhbHVlKG5tKSB7XG4gIHJldHVybiBjYW1sX25hbWVkX3ZhbHVlc1tubV1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nbG9iYWxfZGF0YVxudmFyIGNhbWxfZ2xvYmFsX2RhdGEgPSBbMF07XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChjb25zdCwgc2hhbGxvdywgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAobiwgdiwgbmFtZV9vcHQpIHtcbiAgaWYobmFtZV9vcHQgJiYgam9vX2dsb2JhbF9vYmplY3QudG9wbGV2ZWxSZWxvYylcbiAgICBuID0gam9vX2dsb2JhbF9vYmplY3QudG9wbGV2ZWxSZWxvYyhuYW1lX29wdCk7XG4gIGNhbWxfZ2xvYmFsX2RhdGFbbiArIDFdID0gdjtcbiAgaWYobmFtZV9vcHQpIGNhbWxfZ2xvYmFsX2RhdGFbbmFtZV9vcHRdID0gdjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfZ2xvYmFsX2RhdGEgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9nZXRfZ2xvYmFsX2RhdGEgKCkgeyByZXR1cm4gY2FtbF9nbG9iYWxfZGF0YTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX3ByaW50YWJsZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2lzX3ByaW50YWJsZShjKSB7IHJldHVybiArKGMgPiAzMSAmJiBjIDwgMTI3KTsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBGb3JtYXRcblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9mb3JtYXRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9mb3JtYXQgKGZtdCkge1xuICBmbXQgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCk7XG4gIHZhciBsZW4gPSBmbXQubGVuZ3RoO1xuICBpZiAobGVuID4gMzEpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImZvcm1hdF9pbnQ6IGZvcm1hdCB0b28gbG9uZ1wiKTtcbiAgdmFyIGYgPVxuICAgICAgeyBqdXN0aWZ5OicrJywgc2lnbnN0eWxlOictJywgZmlsbGVyOicgJywgYWx0ZXJuYXRlOmZhbHNlLFxuICAgICAgICBiYXNlOjAsIHNpZ25lZGNvbnY6ZmFsc2UsIHdpZHRoOjAsIHVwcGVyY2FzZTpmYWxzZSxcbiAgICAgICAgc2lnbjoxLCBwcmVjOi0xLCBjb252OidmJyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBmbXQuY2hhckF0KGkpO1xuICAgIHN3aXRjaCAoYykge1xuICAgIGNhc2UgJy0nOlxuICAgICAgZi5qdXN0aWZ5ID0gJy0nOyBicmVhaztcbiAgICBjYXNlICcrJzogY2FzZSAnICc6XG4gICAgICBmLnNpZ25zdHlsZSA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJzAnOlxuICAgICAgZi5maWxsZXIgPSAnMCc7IGJyZWFrO1xuICAgIGNhc2UgJyMnOlxuICAgICAgZi5hbHRlcm5hdGUgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzogY2FzZSAnNSc6XG4gICAgY2FzZSAnNic6IGNhc2UgJzcnOiBjYXNlICc4JzogY2FzZSAnOSc6XG4gICAgICBmLndpZHRoID0gMDtcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi53aWR0aCA9IGYud2lkdGggKiAxMCArIGM7IGkrK1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnLic6XG4gICAgICBmLnByZWMgPSAwO1xuICAgICAgaSsrO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLnByZWMgPSBmLnByZWMgKiAxMCArIGM7IGkrK1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgIGNhc2UgJ2QnOiBjYXNlICdpJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAndSc6XG4gICAgICBmLmJhc2UgPSAxMDsgYnJlYWs7XG4gICAgY2FzZSAneCc6XG4gICAgICBmLmJhc2UgPSAxNjsgYnJlYWs7XG4gICAgY2FzZSAnWCc6XG4gICAgICBmLmJhc2UgPSAxNjsgZi51cHBlcmNhc2UgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlICdvJzpcbiAgICAgIGYuYmFzZSA9IDg7IGJyZWFrO1xuICAgIGNhc2UgJ2UnOiBjYXNlICdmJzogY2FzZSAnZyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLmNvbnYgPSBjOyBicmVhaztcbiAgICBjYXNlICdFJzogY2FzZSAnRic6IGNhc2UgJ0cnOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgZi51cHBlcmNhc2UgPSB0cnVlO1xuICAgICAgZi5jb252ID0gYy50b0xvd2VyQ2FzZSAoKTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHJhd2J1ZmZlcikge1xuICBpZiAoZi51cHBlcmNhc2UpIHJhd2J1ZmZlciA9IHJhd2J1ZmZlci50b1VwcGVyQ2FzZSgpO1xuICB2YXIgbGVuID0gcmF3YnVmZmVyLmxlbmd0aDtcbiAgLyogQWRqdXN0IGxlbiB0byByZWZsZWN0IGFkZGl0aW9uYWwgY2hhcnMgKHNpZ24sIGV0YykgKi9cbiAgaWYgKGYuc2lnbmVkY29udiAmJiAoZi5zaWduIDwgMCB8fCBmLnNpZ25zdHlsZSAhPSAnLScpKSBsZW4rKztcbiAgaWYgKGYuYWx0ZXJuYXRlKSB7XG4gICAgaWYgKGYuYmFzZSA9PSA4KSBsZW4gKz0gMTtcbiAgICBpZiAoZi5iYXNlID09IDE2KSBsZW4gKz0gMjtcbiAgfVxuICAvKiBEbyB0aGUgZm9ybWF0dGluZyAqL1xuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJyAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIGlmIChmLnNpZ25lZGNvbnYpIHtcbiAgICBpZiAoZi5zaWduIDwgMCkgYnVmZmVyICs9ICctJztcbiAgICBlbHNlIGlmIChmLnNpZ25zdHlsZSAhPSAnLScpIGJ1ZmZlciArPSBmLnNpZ25zdHlsZTtcbiAgfVxuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDgpIGJ1ZmZlciArPSAnMCc7XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gMTYpIGJ1ZmZlciArPSBcIjB4XCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcwJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJzAnO1xuICBidWZmZXIgKz0gcmF3YnVmZmVyO1xuICBpZiAoZi5qdXN0aWZ5ID09ICctJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhidWZmZXIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGpzb29fZmxvb3JfbG9nMlxudmFyIGxvZzJfb2sgPSBNYXRoLmxvZzIgJiYgTWF0aC5sb2cyKDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3KSA9PSAxMDIwXG5mdW5jdGlvbiBqc29vX2Zsb29yX2xvZzIoeCkge1xuICBpZihsb2cyX29rKSByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmxvZzIoeCkpXG4gIHZhciBpID0gMDtcbiAgaWYgKHggPT0gMCkgcmV0dXJuIC1JbmZpbml0eTtcbiAgaWYoeD49MSkge3doaWxlICh4Pj0yKSB7eC89MjsgaSsrfSB9XG4gIGVsc2Uge3doaWxlICh4IDwgMSkge3gqPTI7IGktLX0gfTtcbiAgcmV0dXJuIGk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyLCBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaVxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMSwgMCwgMHg3ZmYwKTtcbiAgICBpZiAoeCA+IDApXG4gICAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkoMCwgMCwgMHg3ZmYwKVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweGZmZjApXG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8weDgwMDA6KHg+PTApPzA6MHg4MDAwO1xuICBpZiAoc2lnbikgeCA9IC14O1xuICAvLyBJbnQ2NC5iaXRzX29mX2Zsb2F0IDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3ID0gMHg3ZmIwMDAwMDAwMDAwMDAwTFxuICAvLyB1c2luZyBNYXRoLkxPRzJFKk1hdGgubG9nKHgpIGluIHBsYWNlIG9mIE1hdGgubG9nMiByZXN1bHQgaW4gcHJlY2lzaW9uIGxvc3RcbiAgdmFyIGV4cCA9IGpzb29fZmxvb3JfbG9nMih4KSArIDEwMjM7XG4gIGlmIChleHAgPD0gMCkge1xuICAgIGV4cCA9IDA7XG4gICAgeCAvPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgfSBlbHNlIHtcbiAgICB4IC89IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICAgIGlmICh4IDwgMTYpIHtcbiAgICAgIHggKj0gMjsgZXhwIC09MTsgfVxuICAgIGlmIChleHAgPT0gMCkge1xuICAgICAgeCAvPSAyOyB9XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLDI0KTtcbiAgdmFyIHIzID0geHwwO1xuICB4ID0gKHggLSByMykgKiBrO1xuICB2YXIgcjIgPSB4fDA7XG4gIHggPSAoeCAtIHIyKSAqIGs7XG4gIHZhciByMSA9IHh8MDtcbiAgcjMgPSAocjMgJjB4ZikgfCBzaWduIHwgZXhwIDw8IDQ7XG4gIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaShyMSwgcjIsIHIzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCAoeCkge1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQzMkFycmF5KDEpO1xuICBmbG9hdDMyYVswXSA9IHg7XG4gIHZhciBpbnQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW50MzJBcnJheShmbG9hdDMyYS5idWZmZXIpO1xuICByZXR1cm4gaW50MzJhWzBdIHwgMDtcbn1cblxuLy9GUCBsaXRlcmFscyBjYW4gYmUgd3JpdHRlbiB1c2luZyB0aGUgaGV4YWRlY2ltYWxcbi8vbm90YXRpb24gMHg8bWFudGlzc2EgaW4gaGV4PnA8ZXhwb25lbnQ+IGZyb20gSVNPIEM5OS5cbi8vaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWhleGZsb2F0L2Jsb2IvbWFzdGVyL2hleGZsb2F0LmpzXG4vL1Byb3ZpZGVzOiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgKHgsIHByZWMsIHN0eWxlKSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhcIm5hblwiKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKCh4ID4gMCk/XCJpbmZpbml0eVwiOlwiLWluZmluaXR5XCIpO1xuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MTooeD49MCk/MDoxO1xuICBpZihzaWduKSB4ID0gLXg7XG4gIHZhciBleHAgPSAwO1xuICBpZiAoeCA9PSAwKSB7IH1cbiAgZWxzZSBpZiAoeCA8IDEpIHtcbiAgICB3aGlsZSAoeCA8IDEgJiYgZXhwID4gLTEwMjIpICB7IHggKj0gMjsgZXhwLS0gfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlICh4ID49IDIpIHsgeCAvPSAyOyBleHArKyB9XG4gIH1cbiAgdmFyIGV4cF9zaWduID0gZXhwIDwgMCA/ICcnIDogJysnO1xuICB2YXIgc2lnbl9zdHIgPSAnJztcbiAgaWYgKHNpZ24pIHNpZ25fc3RyID0gJy0nXG4gIGVsc2Uge1xuICAgIHN3aXRjaChzdHlsZSl7XG4gICAgY2FzZSA0MyAvKiAnKycgKi86IHNpZ25fc3RyID0gJysnOyBicmVhaztcbiAgICBjYXNlIDMyIC8qICcgJyAqLzogc2lnbl9zdHIgPSAnICc7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAocHJlYyA+PSAwICYmIHByZWMgPCAxMykge1xuICAgIC8qIElmIGEgcHJlY2lzaW9uIGlzIGdpdmVuLCBhbmQgaXMgc21hbGwsIHJvdW5kIG1hbnRpc3NhIGFjY29yZGluZ2x5ICovXG4gICAgdmFyIGNzdCA9IE1hdGgucG93KDIscHJlYyAqIDQpO1xuICAgIHggPSBNYXRoLnJvdW5kKHggKiBjc3QpIC8gY3N0O1xuICB9XG4gIHZhciB4X3N0ciA9IHgudG9TdHJpbmcoMTYpO1xuICBpZihwcmVjID49IDApe1xuICAgIHZhciBpZHggPSB4X3N0ci5pbmRleE9mKCcuJyk7XG4gICAgaWYoaWR4PDApIHtcbiAgICAgIHhfc3RyICs9ICcuJyArIGNhbWxfc3RyX3JlcGVhdChwcmVjLCAnMCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzaXplID0gaWR4KzErcHJlYztcbiAgICAgIGlmKHhfc3RyLmxlbmd0aCA8IHNpemUpXG4gICAgICAgIHhfc3RyICs9IGNhbWxfc3RyX3JlcGVhdChzaXplIC0geF9zdHIubGVuZ3RoLCAnMCcpO1xuICAgICAgZWxzZVxuICAgICAgICB4X3N0ciA9IHhfc3RyLnN1YnN0cigwLHNpemUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKHNpZ25fc3RyICsgJzB4JyArIHhfc3RyICsgJ3AnICsgZXhwX3NpZ24gKyBleHAudG9TdHJpbmcoMTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGxvID0geC5sbztcbiAgdmFyIG1pID0geC5taTtcbiAgdmFyIGhpID0geC5oaTtcbiAgdmFyIGV4cCA9IChoaSAmIDB4N2ZmZikgPj4gNDtcbiAgaWYgKGV4cCA9PSAyMDQ3KSB7XG4gICAgaWYgKChsb3xtaXwoaGkmMHhmKSkgPT0gMClcbiAgICAgIHJldHVybiAoaGkgJiAweDgwMDApPygtSW5maW5pdHkpOkluZmluaXR5O1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBOYU47XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLC0yNCk7XG4gIHZhciByZXMgPSAobG8qayttaSkqaysoaGkmMHhmKTtcbiAgaWYgKGV4cCA+IDApIHtcbiAgICByZXMgKz0gMTY7XG4gICAgcmVzICo9IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICB9IGVsc2VcbiAgICByZXMgKj0gTWF0aC5wb3coMiwtMTAyNik7XG4gIGlmIChoaSAmIDB4ODAwMCkgcmVzID0gLSByZXM7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV4dGFmdGVyX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9pbnQ2NF9hZGQsIGNhbWxfaW50NjRfc3ViLGNhbWxfaW50NjRfb2ZfaW50MzJcbmZ1bmN0aW9uIGNhbWxfbmV4dGFmdGVyX2Zsb2F0ICh4LHkpIHtcbiAgaWYoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiBOYU47XG4gIGlmKHg9PXkpIHJldHVybiB5O1xuICBpZih4PT0wKXtcbiAgICBpZih5IDwgMClcbiAgICAgIHJldHVybiAtTWF0aC5wb3coMiwgLTEwNzQpXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE1hdGgucG93KDIsIC0xMDc0KVxuICB9XG4gIHZhciBiaXRzID0gY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KHgpO1xuICB2YXIgb25lID0gY2FtbF9pbnQ2NF9vZl9pbnQzMigxKTtcbiAgaWYgKCh4PHkpID09ICh4PjApKVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X2FkZChiaXRzLCBvbmUpXG4gIGVsc2VcbiAgICBiaXRzID0gY2FtbF9pbnQ2NF9zdWIoYml0cywgb25lKVxuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGJpdHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3RydW5jX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX3RydW5jX2Zsb2F0KHgpe1xuICByZXR1cm4gTWF0aC50cnVuYyh4KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGludDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KDEpO1xuICBpbnQzMmFbMF0gPSB4O1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQzMkFycmF5KGludDMyYS5idWZmZXIpO1xuICByZXR1cm4gZmxvYXQzMmFbMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2xhc3NpZnlfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY2xhc3NpZnlfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIGlmIChNYXRoLmFicyh4KSA+PSAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgcmV0dXJuIDA7XG4gICAgaWYgKHggIT0gMCkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDI7XG4gIH1cbiAgcmV0dXJuIGlzTmFOKHgpPzQ6Mztcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbW9kZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tb2RmX2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICB2YXIgbmVnID0gKDEveCkgPCAwO1xuICAgIHggPSBNYXRoLmFicyh4KTtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IgKHgpO1xuICAgIHZhciBmID0geCAtIGk7XG4gICAgaWYgKG5lZykgeyBpID0gLWk7IGYgPSAtZjsgfVxuICAgIHJldHVybiBbMCwgZiwgaV07XG4gIH1cbiAgaWYgKGlzTmFOICh4KSkgcmV0dXJuIFswLCBOYU4sIE5hTl07XG4gIHJldHVybiBbMCwgMS94LCB4XTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbGRleHBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbGRleHBfZmxvYXQgKHgsZXhwKSB7XG4gIGV4cCB8PSAwO1xuICBpZiAoZXhwID4gMTAyMykge1xuICAgIGV4cCAtPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgaWYgKGV4cCA+IDEwMjMpIHsgIC8vIGluIGNhc2UgeCBpcyBzdWJub3JtYWxcbiAgICAgIGV4cCAtPSAxMDIzO1xuICAgICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4cCA8IC0xMDIzKSB7XG4gICAgZXhwICs9IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAtMTAyMyk7XG4gIH1cbiAgeCAqPSBNYXRoLnBvdygyLCBleHApO1xuICByZXR1cm4geDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZnJleHBfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9mcmV4cF9mbG9hdCAoeCkge1xuICBpZiAoKHggPT0gMCkgfHwgIWlzRmluaXRlKHgpKSByZXR1cm4gWzAsIHgsIDBdO1xuICB2YXIgbmVnID0geCA8IDA7XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHZhciBleHAgPSBNYXRoLm1heCgtMTAyMywganNvb19mbG9vcl9sb2cyKHgpICsgMSk7XG4gIHggKj0gTWF0aC5wb3coMiwtZXhwKTtcbiAgd2hpbGUgKHggPCAwLjUpIHtcbiAgICB4ICo9IDI7XG4gICAgZXhwLS07XG4gIH1cbiAgd2hpbGUgKHggPj0gMSkge1xuICAgIHggKj0gMC41O1xuICAgIGV4cCsrO1xuICB9XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHJldHVybiBbMCwgeCwgZXhwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2Zsb2F0X2NvbXBhcmUgKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHJldHVybiAwO1xuICBpZiAoeCA8IHkpIHJldHVybiAtMTtcbiAgaWYgKHggPiB5KSByZXR1cm4gMTtcbiAgaWYgKHggPT09IHgpIHJldHVybiAxO1xuICBpZiAoeSA9PT0geSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb3B5c2lnbl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3B5c2lnbl9mbG9hdCAoeCwgeSkge1xuICBpZiAoeSA9PSAwKSB5ID0gMSAvIHk7XG4gIHggPSBNYXRoLmFicyh4KTtcbiAgcmV0dXJuICh5IDwgMCk/KC14KTp4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NpZ25iaXRfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc2lnbmJpdF9mbG9hdCh4KSB7XG4gIGlmICh4ID09IDApIHggPSAxIC8geDtcbiAgcmV0dXJuICh4IDwgMCk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4cG0xX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2V4cG0xX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gTWF0aC5leHAoeCksIHogPSB5IC0gMTtcbiAgcmV0dXJuIChNYXRoLmFicyh4KT4xP3o6KHo9PTA/eDp4KnovTWF0aC5sb2coeSkpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sb2cxcF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sb2cxcF9mbG9hdCAoeCkge1xuICB2YXIgeSA9IDEgKyB4LCB6ID0geSAtIDE7XG4gIHJldHVybiAoej09MD94OngqTWF0aC5sb2coeSkveik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaHlwb3RfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaHlwb3RfZmxvYXQgKHgsIHkpIHtcbiAgdmFyIHggPSBNYXRoLmFicyh4KSwgeSA9IE1hdGguYWJzKHkpO1xuICB2YXIgYSA9IE1hdGgubWF4KHgsIHkpLCBiID0gTWF0aC5taW4oeCx5KSAvIChhP2E6MSk7XG4gIHJldHVybiAoYSAqIE1hdGguc3FydCgxICsgYipiKSk7XG59XG5cbi8vIEZJWDogdGhlc2UgZml2ZSBmdW5jdGlvbnMgb25seSBnaXZlIGFwcHJveGltYXRlIHJlc3VsdHMuXG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzEwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzEwX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLkxPRzEwRSAqIE1hdGgubG9nKHgpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2Nvc2hfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY29zaF9mbG9hdCAoeCkgeyByZXR1cm4gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKSAvIDI7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc2luaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaW5oX2Zsb2F0ICh4KSB7IHJldHVybiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gMjsgfVxuLy9Qcm92aWRlczogY2FtbF90YW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3RhbmhfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSBNYXRoLmV4cCh4KSwgeiA9IE1hdGguZXhwKC14KTtcbiAgcmV0dXJuICh5IC0geikgLyAoeSArIHopO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JvdW5kX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX3JvdW5kX2Zsb2F0ICh4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfZm9ybWF0X2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuZnVuY3Rpb24gY2FtbF9mb3JtYXRfZmxvYXQgKGZtdCwgeCkge1xuICBmdW5jdGlvbiB0b0ZpeGVkKHgsZHApIHtcbiAgICBpZiAoTWF0aC5hYnMoeCkgPCAxLjApIHtcbiAgICAgIHJldHVybiB4LnRvRml4ZWQoZHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZSA9IHBhcnNlSW50KHgudG9TdHJpbmcoKS5zcGxpdCgnKycpWzFdKTtcbiAgICAgIGlmIChlID4gMjApIHtcbiAgICAgICAgZSAtPSAyMDtcbiAgICAgICAgeCAvPSBNYXRoLnBvdygxMCxlKTtcbiAgICAgICAgeCArPSAobmV3IEFycmF5KGUrMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgaWYoZHAgPiAwKSB7XG4gICAgICAgICAgeCA9IHggKyAnLicgKyAobmV3IEFycmF5KGRwKzEpKS5qb2luKCcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgICB9XG4gICAgICBlbHNlIHJldHVybiB4LnRvRml4ZWQoZHApXG4gICAgfVxuICB9XG4gIHZhciBzLCBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgdmFyIHByZWMgPSAoZi5wcmVjIDwgMCk/NjpmLnByZWM7XG4gIGlmICh4IDwgMCB8fCAoeCA9PSAwICYmIDEveCA9PSAtSW5maW5pdHkpKSB7IGYuc2lnbiA9IC0xOyB4ID0gLXg7IH1cbiAgaWYgKGlzTmFOKHgpKSB7IHMgPSBcIm5hblwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlIGlmICghaXNGaW5pdGUoeCkpIHsgcyA9IFwiaW5mXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2VcbiAgICBzd2l0Y2ggKGYuY29udikge1xuICAgIGNhc2UgJ2UnOlxuICAgICAgdmFyIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyk7XG4gICAgICAvLyBleHBvbmVudCBzaG91bGQgYmUgYXQgbGVhc3QgdHdvIGRpZ2l0c1xuICAgICAgdmFyIGkgPSBzLmxlbmd0aDtcbiAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZic6XG4gICAgICBzID0gdG9GaXhlZCh4LCBwcmVjKTsgYnJlYWs7XG4gICAgY2FzZSAnZyc6XG4gICAgICBwcmVjID0gcHJlYz9wcmVjOjE7XG4gICAgICBzID0geC50b0V4cG9uZW50aWFsKHByZWMgLSAxKTtcbiAgICAgIHZhciBqID0gcy5pbmRleE9mKCdlJyk7XG4gICAgICB2YXIgZXhwID0gK3Muc2xpY2UoaiArIDEpO1xuICAgICAgaWYgKGV4cCA8IC00IHx8IHggPj0gMWUyMSB8fCB4LnRvRml4ZWQoMCkubGVuZ3RoID4gcHJlYykge1xuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb2VzXG4gICAgICAgIHZhciBpID0gaiAtIDE7IHdoaWxlIChzLmNoYXJBdChpKSA9PSAnMCcpIGktLTtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSkgKyBzLnNsaWNlKGopO1xuICAgICAgICBpID0gcy5sZW5ndGg7XG4gICAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHAgPSBwcmVjO1xuICAgICAgICBpZiAoZXhwIDwgMCkgeyBwIC09IGV4cCArIDE7IHMgPSB4LnRvRml4ZWQocCk7IH1cbiAgICAgICAgZWxzZSB3aGlsZSAocyA9IHgudG9GaXhlZChwKSwgcy5sZW5ndGggPiBwcmVjICsgMSkgcC0tO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgICB2YXIgaSA9IHMubGVuZ3RoIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICAgIGlmIChzLmNoYXJBdChpKSA9PSAnLicpIGktLTtcbiAgICAgICAgICBzID0gcy5zbGljZSgwLCBpICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2Zfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2Zfc3RyaW5nKHMpIHtcbiAgdmFyIHJlcztcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocylcbiAgcmVzID0gK3M7XG4gIGlmICgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSByZXR1cm4gcmVzO1xuICBzID0gcy5yZXBsYWNlKC9fL2csXCJcIik7XG4gIHJlcyA9ICtzO1xuICBpZiAoKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHx8IC9eWystXT9uYW4kL2kudGVzdChzKSkgcmV0dXJuIHJlcztcbiAgdmFyIG0gPSAvXiAqKFsrLV0/KTB4KFswLTlhLWZdKylcXC4/KFswLTlhLWZdKilwKFsrLV0/WzAtOV0rKS9pLmV4ZWMocyk7XG4gIC8vICAgICAgICAgIDEgICAgICAgIDIgICAgICAgICAgICAgMyAgICAgICAgICAgNFxuICBpZihtKXtcbiAgICB2YXIgbTMgPSBtWzNdLnJlcGxhY2UoLzArJC8sJycpO1xuICAgIHZhciBtYW50aXNzYSA9IHBhcnNlSW50KG1bMV0gKyBtWzJdICsgbTMsIDE2KTtcbiAgICB2YXIgZXhwb25lbnQgPSAobVs0XXwwKSAtIDQqbTMubGVuZ3RoO1xuICAgIHJlcyA9IG1hbnRpc3NhICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYoL15cXCs/aW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIEluZmluaXR5O1xuICBpZigvXi1pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gLUluZmluaXR5O1xuICBjYW1sX2ZhaWx3aXRoKFwiZmxvYXRfb2Zfc3RyaW5nXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBEdW1teSBmaWxlc3lzdGVtXG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VycmVudF9kaXJcbmlmKGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MgJiYgam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5jd2QpXG4gIHZhciBjYW1sX2N1cnJlbnRfZGlyID0gam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy5jd2QoKS5yZXBsYWNlKC9cXFxcL2csJy8nKTtcbmVsc2VcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSAgXCIvc3RhdGljXCI7XG5pZihjYW1sX2N1cnJlbnRfZGlyLnNsaWNlKC0xKSAhPT0gXCIvXCIpIGNhbWxfY3VycmVudF9kaXIgKz0gXCIvXCJcblxuLy9Qcm92aWRlczogY2FtbF9yb290XG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG52YXIgY2FtbF9yb290ID0gY2FtbF9jdXJyZW50X2Rpci5tYXRjaCgvW15cXC9dKlxcLy8pWzBdO1xuXG5cbi8vUHJvdmlkZXM6IE1sRmlsZVxuZnVuY3Rpb24gTWxGaWxlKCl7ICB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9wYXRoXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tYWtlX3BhdGggKG5hbWUpIHtcbiAgbmFtZT1jYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgaWYobmFtZS5jaGFyQ29kZUF0KDApICE9IDQ3KVxuICAgIG5hbWUgPSBjYW1sX2N1cnJlbnRfZGlyICsgbmFtZTtcbiAgdmFyIGNvbXAgPSBuYW1lLnNwbGl0KFwiL1wiKTtcbiAgdmFyIG5jb21wID0gW11cbiAgZm9yKHZhciBpID0gMDsgaTxjb21wLmxlbmd0aDsgaSsrKXtcbiAgICBzd2l0Y2goY29tcFtpXSl7XG4gICAgY2FzZSBcIi4uXCI6IGlmKG5jb21wLmxlbmd0aD4xKSBuY29tcC5wb3AoKTsgYnJlYWs7XG4gICAgY2FzZSBcIi5cIjogYnJlYWs7XG4gICAgY2FzZSBcIlwiOiBpZihuY29tcC5sZW5ndGggPT0gMCkgbmNvbXAucHVzaChcIlwiKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogbmNvbXAucHVzaChjb21wW2ldKTticmVha1xuICAgIH1cbiAgfVxuICBuY29tcC5vcmlnID0gbmFtZTtcbiAgcmV0dXJuIG5jb21wO1xufVxuXG4vL1Byb3ZpZGVzOmpzb29fbW91bnRfcG9pbnRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgTWxOb2RlRGV2aWNlLCBjYW1sX3Jvb3QsIGZzX25vZGVfc3VwcG9ydGVkXG52YXIganNvb19tb3VudF9wb2ludCA9IFtdXG5pZiAoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290LGRldmljZTpuZXcgTWxOb2RlRGV2aWNlKGNhbWxfcm9vdCl9KTtcbn0gZWxzZSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290KX0pO1xufVxuanNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCtcInN0YXRpYy9cIiwgZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290K1wic3RhdGljL1wiKX0pO1xuXG4vL1Byb3ZpZGVzOmNhbWxfbGlzdF9tb3VudF9wb2ludFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9saXN0X21vdW50X3BvaW50KCl7XG4gIHZhciBwcmV2ID0gMFxuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKyl7XG4gICAgdmFyIG9sZCA9IHByZXY7XG4gICAgcHJldiA9IFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCksIG9sZF1cbiAgfVxuICByZXR1cm4gcHJldjtcbn1cblxuLy9Qcm92aWRlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50XG5mdW5jdGlvbiByZXNvbHZlX2ZzX2RldmljZShuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpO1xuICB2YXIgbmFtZV9zbGFzaCA9IG5hbWUgKyBcIi9cIjtcbiAgdmFyIHJlcztcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbSA9IGpzb29fbW91bnRfcG9pbnRbaV07XG4gICAgaWYobmFtZV9zbGFzaC5zZWFyY2gobS5wYXRoKSA9PSAwXG4gICAgICAgJiYgKCFyZXMgfHwgcmVzLnBhdGgubGVuZ3RoIDwgbS5wYXRoLmxlbmd0aCkpXG4gICAgICByZXMgPSB7cGF0aDptLnBhdGgsZGV2aWNlOm0uZGV2aWNlLHJlc3Q6bmFtZS5zdWJzdHJpbmcobS5wYXRoLmxlbmd0aCxuYW1lLmxlbmd0aCl9O1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW91bnRfYXV0b2xvYWRcbi8vUmVxdWlyZXM6IE1sRmFrZURldmljZSwgY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnRcbmZ1bmN0aW9uIGNhbWxfbW91bnRfYXV0b2xvYWQobmFtZSxmKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpICsgXCIvXCI7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpuYW1lLGRldmljZTpuZXcgTWxGYWtlRGV2aWNlKG5hbWUsZil9KVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF91bm1vdW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX21ha2VfcGF0aFxuZnVuY3Rpb24gY2FtbF91bm1vdW50KG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIikgKyBcIi9cIjtcbiAgdmFyIGlkeCA9IC0xO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKylcbiAgICBpZihqc29vX21vdW50X3BvaW50W2ldLnBhdGggPT0gbmFtZSkgaWR4ID0gaTtcbiAgaWYoaWR4ID4gLTEpIGpzb29fbW91bnRfcG9pbnQuc3BsaWNlKGlkeCwxKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0Y3dkXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRjd2QoKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGNhbWxfY3VycmVudF9kaXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jaGRpclxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19jaGRpcihkaXIpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShkaXIpO1xuICBpZihyb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KSkge1xuICAgIGlmKHJvb3QucmVzdCkgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aCArIHJvb3QucmVzdCArIFwiL1wiO1xuICAgIGVsc2UgY2FtbF9jdXJyZW50X2RpciA9IHJvb3QucGF0aDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShkaXIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSl7XG4gIG5hbWUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9hX2RpclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2FfZGlyKG5hbWUpe1xuICBuYW1lID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKTtcbiAgY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG5hbWUgKyBcIjogTm90IGEgZGlyZWN0b3J5XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19maWxlX2V4aXN0c1xuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2ZpbGVfZXhpc3RzIChuYW1lKSB7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHJldHVybiByb290LmRldmljZS5leGlzdHMocm9vdC5yZXN0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVhZF9kaXJlY3Rvcnlcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyLCByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfcmVhZF9kaXJlY3RvcnkobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBhID0gcm9vdC5kZXZpY2UucmVhZGRpcihyb290LnJlc3QpO1xuICB2YXIgbCA9IG5ldyBBcnJheShhLmxlbmd0aCArIDEpO1xuICBsWzBdID0gMDtcbiAgZm9yKHZhciBpPTA7aTxhLmxlbmd0aDtpKyspXG4gICAgbFtpKzFdID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhhW2ldKTtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbW92ZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW1vdmUobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBvayA9IHJvb3QuZGV2aWNlLnVubGluayhyb290LnJlc3QpO1xuICBpZihvayA9PSAwKSBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5pc19kaXIocm9vdC5yZXN0KTtcbiAgcmV0dXJuIGE/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW5hbWVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW5hbWUobyxuKXtcbiAgdmFyIG9fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG8pO1xuICB2YXIgbl9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobik7XG4gIGlmKG9fcm9vdC5kZXZpY2UgIT0gbl9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBjYW5ub3QgbW92ZSBmaWxlIGJldHdlZW4gdHdvIGZpbGVzeXN0ZW1cIik7XG4gIGlmKCFvX3Jvb3QuZGV2aWNlLnJlbmFtZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBubyBpbXBsZW1lbnRlZFwiKTtcbiAgb19yb290LmRldmljZS5yZW5hbWUob19yb290LnJlc3QsIG5fcm9vdC5yZXN0KTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlKHZmZCwga2luZCwgbGF5b3V0LCBzaGFyZWQsIGRpbXMsIHBvcykge1xuICAvLyB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW3ZmZF07XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2JhX21hcF9maWxlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZVxuLy9SZXF1aXJlczogY2FtbF9iYV9tYXBfZmlsZVxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZShhcmd2LGFyZ24pe1xuICByZXR1cm4gY2FtbF9iYV9tYXBfZmlsZShhcmd2WzBdLGFyZ3ZbMV0sYXJndlsyXSxhcmd2WzNdLGFyZ3ZbNF0sYXJndls1XSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlX2V4dGVybihuYW1lLGNvbnRlbnQpe1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlKVxuICAgIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KTtcbiAgZWxzZSB7XG4gICAgaWYoIWpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wKSBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCA9IFtdO1xuICAgIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wLnB1c2goe25hbWU6bmFtZSxjb250ZW50OmNvbnRlbnR9KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mc19pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9maWxlXG5mdW5jdGlvbiBjYW1sX2ZzX2luaXQgKCl7XG4gIHZhciB0bXA9am9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXBcbiAgaWYodG1wKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgaSsrKXtcbiAgICAgIGNhbWxfY3JlYXRlX2ZpbGUodG1wW2ldLm5hbWUsdG1wW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlID0gY2FtbF9jcmVhdGVfZmlsZTtcbiAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAgPSBbXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCkge1xuICB2YXIgbmFtZSA9ICh0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpOm5hbWU7XG4gIHZhciBjb250ZW50ID0gKHR5cGVvZiBjb250ZW50ID09IFwic3RyaW5nXCIpP2NhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY29udGVudCk6Y29udGVudDtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYoISByb290LmRldmljZS5yZWdpc3RlcikgY2FtbF9mYWlsd2l0aChcImNhbm5vdCByZWdpc3RlciBmaWxlXCIpO1xuICByb290LmRldmljZS5yZWdpc3Rlcihyb290LnJlc3QsY29udGVudCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlYWRfZmlsZV9jb250ZW50XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZSwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9yZWFkX2ZpbGVfY29udGVudCAobmFtZSkge1xuICB2YXIgbmFtZSA9ICh0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiKT9jYW1sX3N0cmluZ19vZl9qc2J5dGVzKG5hbWUpOm5hbWU7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgdmFyIGZpbGUgPSByb290LmRldmljZS5vcGVuKHJvb3QucmVzdCx7cmRvbmx5OjF9KTtcbiAgICB2YXIgbGVuICA9IGZpbGUubGVuZ3RoKCk7XG4gICAgdmFyIGJ1ZiAgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGZpbGUucmVhZCgwLGJ1ZiwwLGxlbik7XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ1ZilcbiAgfVxuICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKTtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gU3lzXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLlN5c19lcnJvciwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZXhpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3N5c19leGl0IChjb2RlKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmKGcucXVpdCkgZy5xdWl0KGNvZGUpO1xuICAvL25vZGVqc1xuICBpZihnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLmV4aXQpXG4gICAgZy5wcm9jZXNzLmV4aXQoY29kZSk7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkZ1bmN0aW9uICdleGl0JyBub3QgaW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3N0YXRpY19lbnZcbmZ1bmN0aW9uIGNhbWxfc2V0X3N0YXRpY19lbnYoayx2KXtcbiAgaWYoIWpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudilcbiAgICBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnYgPSB7fVxuICBqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZba10gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGVudiAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIG4gPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhuYW1lKTtcbiAgLy9ub2RlanMgZW52XG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuZW52XG4gICAgICYmIGcucHJvY2Vzcy5lbnZbbl0gIT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhnLnByb2Nlc3MuZW52W25dKTtcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52XG4gICAgICYmIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltuXSlcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W25dKVxuICBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdW5zYWZlX2dldGVudlxuLy9SZXF1aXJlczogY2FtbF9zeXNfZ2V0ZW52XG5mdW5jdGlvbiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52KG5hbWUpe1xuICByZXR1cm4gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xudmFyIGNhbWxfYXJndiA9ICgoZnVuY3Rpb24gKCkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgbWFpbiA9IFwiYS5vdXRcIjtcbiAgdmFyIGFyZ3MgPSBbXVxuXG4gIGlmKGcucHJvY2Vzc1xuICAgICAmJiBnLnByb2Nlc3MuYXJndlxuICAgICAmJiBnLnByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGFyZ3YgPSBnLnByb2Nlc3MuYXJndlxuICAgIC8vbm9kZWpzXG4gICAgbWFpbiA9IGFyZ3ZbMV07XG4gICAgYXJncyA9IGFyZ3Yuc2xpY2UoMik7XG4gIH1cblxuICB2YXIgcCA9IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKG1haW4pO1xuICB2YXIgYXJnczIgPSBbMCwgcF07XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKVxuICAgIGFyZ3MyLnB1c2goY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcoYXJnc1tpXSkpO1xuICByZXR1cm4gYXJnczI7XG59KSgpKVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG52YXIgY2FtbF9leGVjdXRhYmxlX25hbWUgPSBjYW1sX2FyZ3ZbMV1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2FyZ3YgKGEpIHtcbiAgcmV0dXJuIFswLCBjYW1sX2FyZ3ZbMV0sIGNhbWxfYXJndl07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfYXJndlxuZnVuY3Rpb24gY2FtbF9zeXNfYXJndiAoYSkge1xuICByZXR1cm4gY2FtbF9hcmd2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19tb2RpZnlfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19tb2RpZnlfYXJndihhcmcpe1xuICBjYW1sX2FyZ3YgPSBhcmc7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG5mdW5jdGlvbiBjYW1sX3N5c19leGVjdXRhYmxlX25hbWUoYSl7XG4gIHJldHVybiBjYW1sX2V4ZWN1dGFibGVfbmFtZVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kKGNtZCl7XG4gIHZhciBjbWQgPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhjbWQpO1xuICBpZiAodHlwZW9mIHJlcXVpcmUgIT0gXCJ1bmRlZmluZWRcIlxuICAgICAgJiYgcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmMpIHtcbiAgICB0cnkge3JlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYyhjbWQse3N0ZGlvOiAnaW5oZXJpdCd9KTsgcmV0dXJuIDB9XG4gICAgY2F0Y2ggKGUpIHtyZXR1cm4gMX1cbiAgfVxuICBlbHNlIHJldHVybiAxMjc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWUgbXV0YWJsZVxudmFyIGNhbWxfaW5pdGlhbF90aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAqIDAuMDAxO1xuZnVuY3Rpb24gY2FtbF9zeXNfdGltZSAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICByZXR1cm4gbm93ICogMC4wMDEgLSBjYW1sX2luaXRpYWxfdGltZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZV9pbmNsdWRlX2NoaWxkcmVuXG4vL1JlcXVpcmVzOiBjYW1sX3N5c190aW1lXG5mdW5jdGlvbiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW4oYikge1xuICByZXR1cm4gY2FtbF9zeXNfdGltZSgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yYW5kb21fc2VlZCBtdXRhYmxlXG4vL1RoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gYW4gYXJyYXkgc2luY2UgT0NhbWwgNC4wLi4uXG5mdW5jdGlvbiBjYW1sX3N5c19yYW5kb21fc2VlZCAoKSB7XG4gIHZhciBub3cgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICB2YXIgeCA9IG5vd14weGZmZmZmZmZmKk1hdGgucmFuZG9tKCk7XG4gIHJldHVybiBbMCx4XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmlnX2VuZGlhbiAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X3dvcmRfc2l6ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2ludF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIGNvbnN0XG4vLyBtYXhfaW50IC8gNCBzbyB0aGF0IHRoZSBmb2xsb3dpbmcgZG9lcyBub3Qgb3ZlcmZsb3dcbi8vbGV0IG1heF9zdHJpbmdfbGVuZ3RoID0gd29yZF9zaXplIC8gOCAqIG1heF9hcnJheV9sZW5ndGggLSAxOztcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgKCkgeyByZXR1cm4gKDB4N0ZGRkZGRkYvNCkgfCAwO31cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV91bml4ICgpIHsgcmV0dXJuIDE7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X29zdHlwZV9jeWd3aW4gKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcImpzX29mX29jYW1sXCIpXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2NvbmZpZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0X2NvbmZpZyAoKSB7XG4gIHJldHVybiBbMCwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlVuaXhcIiksIDMyLCAwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNhdHR5XG5mdW5jdGlvbiBjYW1sX3N5c19pc2F0dHkoX2NoYW4pIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV92YXJpYW50XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfdmFyaWFudChfdW5pdCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyhfdW5pdCkge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIoKXtyZXR1cm4gMH1cblxuLy9Qcm92aWRlczogdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nXG5mdW5jdGlvbiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmcgKCkge3JldHVybiAwO31cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xudmFyIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyAoYm9vbCkge1xuICBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSBib29sO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3J1bnRpbWVfd2FybmluZ3M7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9zcGFjZXRpbWVfZW5hYmxlZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9lbmFibGVkKF91bml0KSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lKF9jaGFubmVsKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJTcGFjZXRpbWUgcHJvZmlsaW5nIG9ubHkgd29ya3MgZm9yIG5hdGl2ZSBjb2RlXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogTWxGYWtlRGV2aWNlXG4vL1JlcXVpcmVzOiBNbEZha2VGaWxlLCBjYW1sX2NyZWF0ZV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9hcnJheSwgY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfYnl0ZXNfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbmZ1bmN0aW9uIE1sRmFrZURldmljZSAocm9vdCwgZikge1xuICB0aGlzLmNvbnRlbnQ9e307XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHRoaXMubG9va3VwRnVuID0gZjtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubm0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAodGhpcy5yb290ICsgbmFtZSk7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIXRoaXMuY29udGVudFtuYW1lXSAmJiB0aGlzLmxvb2t1cEZ1bikge1xuICAgIHZhciByZXMgPSB0aGlzLmxvb2t1cEZ1bihjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHRoaXMucm9vdCksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSkpO1xuICAgIGlmKHJlcyAhPT0gMCkgdGhpcy5jb250ZW50W25hbWVdPW5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHJlc1sxXSkpO1xuICB9XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgLy8gVGhlIHJvb3Qgb2YgdGhlIGRldmljZSBleGlzdHNcbiAgaWYobmFtZSA9PSBcIlwiKSByZXR1cm4gMTtcbiAgLy8gQ2hlY2sgaWYgYSBkaXJlY3RvcnkgZXhpc3RzXG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgKyBcIi9cIik7XG4gIHZhciByID0gbmV3IFJlZ0V4cChcIl5cIiArIG5hbWVfc2xhc2gpO1xuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgaWYgKG4ubWF0Y2gocikpIHJldHVybiAxXG4gIH1cbiAgLy8gQ2hlY2sgaWYgYSBmaWxlIGV4aXN0c1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lXT8xOjA7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoobmFtZSArIFwiL1wiKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCArIFwiKFteL10qKVwiKTtcbiAgdmFyIHNlZW4gPSB7fVxuICB2YXIgYSA9IFtdO1xuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgdmFyIG0gPSBuLm1hdGNoKHIpO1xuICAgIGlmKG0gJiYgIXNlZW5bbVsxXV0pIHtzZWVuW21bMV1dID0gdHJ1ZTsgYS5wdXNoKG1bMV0pfVxuICB9XG4gIHJldHVybiBhO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5pc19kaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBuYW1lX3NsYXNoID0gKG5hbWUgPT0gXCJcIik/XCJcIjoobmFtZSArIFwiL1wiKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCArIFwiKFteL10qKVwiKTtcbiAgdmFyIGEgPSBbXTtcbiAgZm9yKHZhciBuIGluIHRoaXMuY29udGVudCkge1xuICAgIHZhciBtID0gbi5tYXRjaChyKTtcbiAgICBpZihtKSByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG9rID0gdGhpcy5jb250ZW50W25hbWVdP3RydWU6ZmFsc2U7XG4gIGRlbGV0ZSB0aGlzLmNvbnRlbnRbbmFtZV07XG4gIHJldHVybiBvaztcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgaWYoZi5yZG9ubHkgJiYgZi53cm9ubHkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB0aGlzLmxvb2t1cChuYW1lKTtcbiAgaWYgKHRoaXMuY29udGVudFtuYW1lXSkge1xuICAgIGlmICh0aGlzLmlzX2RpcihuYW1lKSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogaXMgYSBkaXJlY3RvcnlcIik7XG4gICAgaWYgKGYuY3JlYXRlICYmIGYuZXhjbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICB2YXIgZmlsZSA9IHRoaXMuY29udGVudFtuYW1lXTtcbiAgICBpZihmLnRydW5jYXRlKSBmaWxlLnRydW5jYXRlKCk7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH0gZWxzZSBpZiAoZi5jcmVhdGUpIHtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudFtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSAodGhpcy5ubShuYW1lKSk7XG4gIH1cbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5yZWdpc3Rlcj0gZnVuY3Rpb24gKG5hbWUsY29udGVudCl7XG4gIGlmKHRoaXMuY29udGVudFtuYW1lXSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgaWYoY2FtbF9pc19tbF9ieXRlcyhjb250ZW50KSlcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjb250ZW50KTtcbiAgaWYoY2FtbF9pc19tbF9zdHJpbmcoY29udGVudCkpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheSlcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX2FycmF5KGNvbnRlbnQpKTtcbiAgZWxzZSBpZih0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIilcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQudG9TdHJpbmcpIHtcbiAgICB2YXIgYnl0ZXMgPSBjYW1sX2J5dGVzX29mX3N0cmluZyhjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhjb250ZW50LnRvU3RyaW5nKCkpKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShieXRlcyk7XG4gIH1cbiAgZWxzZSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiByZWdpc3RlcmluZyBmaWxlIHdpdGggaW52YWxpZCBjb250ZW50IHR5cGVcIik7XG59XG5cbk1sRmFrZURldmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbEZha2VEZXZpY2VcblxuLy9Qcm92aWRlczogTWxGYWtlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ibGl0X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19nZXRcbmZ1bmN0aW9uIE1sRmFrZUZpbGUoY29udGVudCl7XG4gIHRoaXMuZGF0YSA9IGNvbnRlbnQ7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5NbEZha2VGaWxlLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHZhciBvbGQgPSB0aGlzLmRhdGE7XG4gIHRoaXMuZGF0YSA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbnwwKTtcbiAgY2FtbF9ibGl0X2J5dGVzKG9sZCwgMCwgdGhpcy5kYXRhLCAwLCBsZW4pO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FtbF9tbF9ieXRlc19sZW5ndGgodGhpcy5kYXRhKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBpZihvZmZzZXQgKyBsZW4gPj0gY2xlbikge1xuICAgIHZhciBuZXdfc3RyID0gY2FtbF9jcmVhdGVfYnl0ZXMob2Zmc2V0ICsgbGVuKTtcbiAgICB2YXIgb2xkX2RhdGEgPSB0aGlzLmRhdGE7XG4gICAgdGhpcy5kYXRhID0gbmV3X3N0cjtcbiAgICBjYW1sX2JsaXRfYnl0ZXMob2xkX2RhdGEsIDAsIHRoaXMuZGF0YSwgMCwgY2xlbik7XG4gIH1cbiAgY2FtbF9ibGl0X3N0cmluZyhidWYsIHBvcywgdGhpcy5kYXRhLCBvZmZzZXQsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBjYW1sX2JsaXRfYnl0ZXModGhpcy5kYXRhLCBvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZF9vbmUgPSBmdW5jdGlvbihvZmZzZXQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19nZXQodGhpcy5kYXRhLCBvZmZzZXQpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZUZpbGVcbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCAoKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy52ZXJzaW9ucyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLnBsYXRmb3JtICE9PSBcImJyb3dzZXJcIilcbn1cblxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sTm9kZUZpbGUsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBNbE5vZGVEZXZpY2Uocm9vdCkge1xuICB0aGlzLmZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUubm0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAodGhpcy5yb290ICsgbmFtZSk7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlYWRkaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMucmVhZGRpclN5bmModGhpcy5ubShuYW1lKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5pc19kaXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNEaXJlY3RvcnkoKT8xOjA7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS51bmxpbmsgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICAgIHRoaXMuZnMudW5saW5rU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBiXG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIHZhciBjb25zdHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvcih2YXIga2V5IGluIGYpe1xuICAgIHN3aXRjaChrZXkpe1xuICAgIGNhc2UgXCJyZG9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fUkRPTkxZOyBicmVhaztcbiAgICBjYXNlIFwid3Jvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1dST05MWTsgYnJlYWs7XG4gICAgY2FzZSBcImFwcGVuZFwiICA6XG4gICAgICByZXMgfD0gY29uc3RzLk9fV1JPTkxZIHwgY29uc3RzLk9fQVBQRU5EO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNyZWF0ZVwiICAgOiByZXMgfD0gY29uc3RzLk9fQ1JFQVQ7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cnVuY2F0ZVwiIDogcmVzIHw9IGNvbnN0cy5PX1RSVU5DOyAgICBicmVhaztcbiAgICBjYXNlIFwiZXhjbFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19FWENMOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJpbmFyeVwiICAgOiByZXMgfD0gY29uc3RzLk9fQklOQVJZOyAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0ZXh0XCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX1RFWFQ7ICAgICBicmVhaztcbiAgICBjYXNlIFwibm9uYmxvY2tcIiA6IHJlcyB8PSBjb25zdHMuT19OT05CTE9DSzsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgdmFyIGZkID0gdGhpcy5mcy5vcGVuU3luYyh0aGlzLm5tKG5hbWUpLCByZXMpO1xuICAgIHJldHVybiBuZXcgTWxOb2RlRmlsZShmZCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKG8sbikge1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVuYW1lU3luYyh0aGlzLm5tKG8pLCB0aGlzLm5tKG4pKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbE5vZGVEZXZpY2VcblxuLy9Qcm92aWRlczogTWxOb2RlRmlsZVxuLy9SZXF1aXJlczogTWxGaWxlLCBjYW1sX2FycmF5X29mX3N0cmluZywgY2FtbF9hcnJheV9vZl9ieXRlcywgY2FtbF9ieXRlc19zZXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBNbE5vZGVGaWxlKGZkKXtcbiAgdGhpcy5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIHRoaXMuZmQgPSBmZDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcblxuTWxOb2RlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB0cnkge1xuICAgIHRoaXMuZnMuZnRydW5jYXRlU3luYyh0aGlzLmZkLGxlbnwwKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5mc3RhdFN5bmModGhpcy5mZCkuc2l6ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB2YXIgYSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKGJ1Zik7XG4gIGlmKCEgKGEgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KSlcbiAgICBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYSk7XG4gIHZhciBidWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXIuZnJvbShhKTtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLndyaXRlU3luYyh0aGlzLmZkLCBidWZmZXIsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKG9mZnNldCxidWYsYnVmX29mZnNldCxsZW4pe1xuICB2YXIgYSA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMoYnVmKTtcbiAgaWYoISAoYSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkpKVxuICAgIGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShhKTtcbiAgdmFyIGJ1ZmZlciA9IGpvb19nbG9iYWxfb2JqZWN0LkJ1ZmZlci5mcm9tKGEpO1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYnVmZmVyLCBidWZfb2Zmc2V0LCBsZW4sIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIGNhbWxfYnl0ZXNfc2V0KGJ1ZixidWZfb2Zmc2V0ICsgaSxidWZmZXJbYnVmX29mZnNldCtpXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLnJlYWRfb25lID0gZnVuY3Rpb24ob2Zmc2V0KXtcbiAgdmFyIGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSgxKTtcbiAgdmFyIGJ1ZmZlciA9IGpvb19nbG9iYWxfb2JqZWN0LkJ1ZmZlci5mcm9tKGEpO1xuICB0cnkge1xuICAgIHRoaXMuZnMucmVhZFN5bmModGhpcy5mZCwgYnVmZmVyLCAwLCAxLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclswXTtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICB0aGlzLmZzLmNsb3NlU3luYyh0aGlzLmZkKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5cbk1sTm9kZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRmlsZTtcbiIsIi8vUHJvdmlkZXM6IGluaXRpYWxpemVfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IHNlcmlhbGl6ZV9uYXQsIGRlc2VyaWFsaXplX25hdCwgY2FtbF9oYXNoX25hdFxuZnVuY3Rpb24gaW5pdGlhbGl6ZV9uYXQoKSB7XG4gIGNhbWxfY3VzdG9tX29wc1tcIl9uYXRcIl0gPVxuICAgIHsgZGVzZXJpYWxpemUgOiBkZXNlcmlhbGl6ZV9uYXQsXG4gICAgICBzZXJpYWxpemUgOiBzZXJpYWxpemVfbmF0LFxuICAgICAgaGFzaCA6IGNhbWxfaGFzaF9uYXRcbiAgICB9XG59XG5cbi8vUHJvdmlkZXM6IE1sTmF0XG5mdW5jdGlvbiBNbE5hdCh4KXtcbiAgdGhpcy5kYXRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkludDMyQXJyYXkoeCk7XG4gIC8vIGxlbmd0aF9uYXQgaXNuJ3QgZXh0ZXJuYWwsIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGUgT2JqLnNpemVcbiAgLy8gd29yayBvdXQgcmlnaHQuIFRoZSArMiB0byBhcnJheSBsZW5ndGggc2VlbXMgdG8gd29yay5cbiAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoICsgMlxufVxuXG5NbE5hdC5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBcIl9uYXRcIjtcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX25hdFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbmF0KHgpIHtcbiAgdmFyIGxlbiA9IG51bV9kaWdpdHNfbmF0KHgsIDAsIHguZGF0YS5sZW5ndGgpO1xuICB2YXIgaCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgeC5kYXRhW2ldKTtcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBuYXRfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBuYXRfb2ZfYXJyYXkobCl7XG4gIHJldHVybiBuZXcgTWxOYXQobCk7XG59XG5cbi8vUHJvdmlkZXM6IGNyZWF0ZV9uYXRcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBjcmVhdGVfbmF0KHNpemUpIHtcbiAgdmFyIGFyciA9IG5ldyBNbE5hdChzaXplKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGFyci5kYXRhW2ldID0gLTE7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLy9Qcm92aWRlczogc2V0X3RvX3plcm9fbmF0XG5mdW5jdGlvbiBzZXRfdG9femVyb19uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAwO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBibGl0X25hdFxuZnVuY3Rpb24gYmxpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMiwgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gbmF0Mi5kYXRhW29mczIraV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IHNldF9kaWdpdF9uYXRcbmZ1bmN0aW9uIHNldF9kaWdpdF9uYXQobmF0LCBvZnMsIGRpZ2l0KSB7XG4gIG5hdC5kYXRhW29mc10gPSBkaWdpdDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IG50aF9kaWdpdF9uYXRcbmZ1bmN0aW9uIG50aF9kaWdpdF9uYXQobmF0LCBvZnMpIHtcbiAgcmV0dXJuIG5hdC5kYXRhW29mc107XG59XG5cbi8vUHJvdmlkZXM6IHNldF9kaWdpdF9uYXRfbmF0aXZlXG5mdW5jdGlvbiBzZXRfZGlnaXRfbmF0X25hdGl2ZShuYXQsIG9mcywgZGlnaXQpIHtcbiAgbmF0LmRhdGFbb2ZzXSA9IGRpZ2l0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbnRoX2RpZ2l0X25hdF9uYXRpdmVcbmZ1bmN0aW9uIG50aF9kaWdpdF9uYXRfbmF0aXZlKG5hdCwgb2ZzKSB7XG4gIHJldHVybiBuYXQuZGF0YVtvZnNdO1xufVxuXG4vL1Byb3ZpZGVzOiBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gbnVtX2RpZ2l0c19uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmKG5hdC5kYXRhW29mcytpXSAhPSAwKSByZXR1cm4gaSsxO1xuICB9XG4gIHJldHVybiAxOyAvLyAwIGNvdW50cyBhcyAxIGRpZ2l0XG59XG5cbi8vUHJvdmlkZXM6IG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdFxuZnVuY3Rpb24gbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0KG5hdCwgb2ZzKSB7XG4gIHZhciBhID0gbmF0LmRhdGFbb2ZzXTtcbiAgdmFyIGIgPSAwO1xuICBpZihhICYgMHhGRkZGMDAwMCkgeyBiICs9MTY7IGEgPj4+PTE2OyB9XG4gIGlmKGEgJiAweEZGMDApICAgICB7IGIgKz0gODsgYSA+Pj49IDg7IH1cbiAgaWYoYSAmIDB4RjApICAgICAgIHsgYiArPSA0OyBhID4+Pj0gNDsgfVxuICBpZihhICYgMTIpICAgICAgICAgeyBiICs9IDI7IGEgPj4+PSAyOyB9XG4gIGlmKGEgJiAyKSAgICAgICAgICB7IGIgKz0gMTsgYSA+Pj49IDE7IH1cbiAgaWYoYSAmIDEpICAgICAgICAgIHsgYiArPSAxOyB9XG4gIHJldHVybiAzMiAtIGI7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X2ludFxuZnVuY3Rpb24gaXNfZGlnaXRfaW50KG5hdCwgb2ZzKSB7XG4gIGlmIChuYXQuZGF0YVtvZnNdID49IDApIHJldHVybiAxXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF96ZXJvXG5mdW5jdGlvbiBpc19kaWdpdF96ZXJvKG5hdCwgb2ZzKSB7XG4gIGlmKG5hdC5kYXRhW29mc10gPT0gMCkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpc19kaWdpdF9vZGRcbmZ1bmN0aW9uIGlzX2RpZ2l0X29kZChuYXQsIG9mcykge1xuICBpZihuYXQuZGF0YVtvZnNdICYgMSkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBpbmNyX25hdFxuZnVuY3Rpb24gaW5jcl9uYXQobmF0LCBvZnMsIGxlbiwgY2FycnlfaW4pIHtcbiAgdmFyIGNhcnJ5ID0gY2FycnlfaW47XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcytpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAoeCB8IDApO1xuICAgIGlmKHggPT0gKHggPj4+IDApKSB7XG4gICAgICBjYXJyeSA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgY2FycnkgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogYWRkX25hdFxuLy9SZXF1aXJlczogaW5jcl9uYXRcbmZ1bmN0aW9uIGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGNhcnJ5ID0gY2FycnlfaW47XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICsgY2Fycnk7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSB4XG4gICAgaWYoeCA9PSAoeCA+Pj4gMCkpIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FycnkgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5jcl9uYXQobmF0MSwgb2ZzMStsZW4yLCBsZW4xLWxlbjIsIGNhcnJ5KTtcbn1cblxuLy9Qcm92aWRlczogY29tcGxlbWVudF9uYXRcbmZ1bmN0aW9uIGNvbXBsZW1lbnRfbmF0KG5hdCwgb2ZzLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0gKC0xID4+PiAwKSAtIChuYXQuZGF0YVtvZnMraV0gPj4+IDApO1xuICB9XG59XG5cbi8vIG9jYW1sIGZsaXBzIGNhcnJ5X2luXG4vL1Byb3ZpZGVzOiBkZWNyX25hdFxuZnVuY3Rpb24gZGVjcl9uYXQobmF0LCBvZnMsIGxlbiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IChjYXJyeV9pbiA9PSAxKSA/IDAgOiAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgeCA9IChuYXQuZGF0YVtvZnMraV0gPj4+MCkgLSBib3Jyb3c7XG4gICAgbmF0LmRhdGFbb2ZzK2ldID0geDtcbiAgICBpZiAoeCA+PSAwKSB7XG4gICAgICBib3Jyb3cgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvcnJvdyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAoYm9ycm93ID09IDEpID8gMCA6IDE7XG59XG5cbi8vIG9jYW1sIGZsaXBzIGNhcnJ5X2luXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IHN1Yl9uYXRcbi8vUmVxdWlyZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBzdWJfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIGNhcnJ5X2luKSB7XG4gIHZhciBib3Jyb3cgPSAoY2FycnlfaW4gPT0gMSkgPyAwIDogMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSAtIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgLSBib3Jyb3c7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvcnJvdyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWNyX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgKGJvcnJvdz09MSk/MDoxKTtcbn1cblxuLy8gbmF0MSArPSBuYXQyICogbmF0M1tvZnMzXVxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBtdWx0X2RpZ2l0X25hdFxuLy9SZXF1aXJlczogYWRkX25hdCwgbmF0X29mX2FycmF5XG5mdW5jdGlvbiBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBhID0gKG5hdDMuZGF0YVtvZnMzXSA+Pj4gMCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4yOyBpKyspIHtcbiAgICB2YXIgeDEgPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApICsgKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAqIChhICYgMHgwMDAwRkZGRikgKyBjYXJyeTtcbiAgICB2YXIgeDIgPSAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICogKGEgPj4+IDE2KTtcbiAgICBjYXJyeSA9IE1hdGguZmxvb3IoeDIvNjU1MzYpO1xuICAgIHZhciB4MyA9IHgxICsgKHgyICUgNjU1MzYpICogNjU1MzY7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSB4MztcbiAgICBjYXJyeSArPSBNYXRoLmZsb29yKHgzLzQyOTQ5NjcyOTYpO1xuICB9XG5cbiAgaWYobGVuMiA8IGxlbjEgJiYgY2FycnkpIHtcbiAgICByZXR1cm4gYWRkX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgbmF0X29mX2FycmF5KFtjYXJyeV0pLCAwLCAxLCAwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2Fycnk7XG4gIH1cbn1cblxuLy8gbmF0MSArPSBuYXQyICogbmF0M1xuLy8gbGVuMSA+PSBsZW4yICsgbGVuMy5cbi8vUHJvdmlkZXM6IG11bHRfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X2RpZ2l0X25hdFxuZnVuY3Rpb24gbXVsdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMywgbGVuMykge1xuICB2YXIgY2FycnkgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMzsgaSsrKSB7XG4gICAgY2FycnkgKz0gbXVsdF9kaWdpdF9uYXQobmF0MSwgb2ZzMStpLCBsZW4xLWksIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMraSk7XG4gIH1cbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG4vLyBuYXQxID0gMiAqIG5hdDEgKyBuYXQyICogbmF0MlxuLy8gbGVuMSA+PSAyICogbGVuMlxuLy9Qcm92aWRlczogc3F1YXJlX25hdFxuLy9SZXF1aXJlczogbXVsdF9uYXQsIGFkZF9uYXRcbmZ1bmN0aW9uIHNxdWFyZV9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICB2YXIgY2FycnkgPSAwO1xuICBjYXJyeSArPSBhZGRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDEsIG9mczEsIGxlbjEsIDApO1xuICBjYXJyeSArPSBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQyLCBvZnMyLCBsZW4yKTtcbiAgcmV0dXJuIGNhcnJ5O1xufVxuXG5cbi8vIDAgPD0gc2hpZnQgPCAzMlxuLy9Qcm92aWRlczogc2hpZnRfbGVmdF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X2xlZnRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIG5iaXRzKSB7XG4gIGlmKG5iaXRzID09IDApIHtcbiAgICBuYXQyLmRhdGFbb2ZzMl0gPSAwO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB3cmFwID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjE7IGkrKykge1xuICAgIHZhciBhID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKTtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IChhIDw8IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPj4+ICgzMiAtIG5iaXRzKTtcbiAgfVxuICBuYXQyLmRhdGFbb2ZzMl0gPSB3cmFwO1xuICByZXR1cm4gMDtcbn1cblxuLy8gQXNzdW1pbmcgYyA+IGEsIHJldHVybnMgW3F1b3RpZW50LCByZW1haW5kZXJdIG9mIChhPDwzMiArIGIpL2Ncbi8vUHJvdmlkZXM6IGRpdl9oZWxwZXJcbmZ1bmN0aW9uIGRpdl9oZWxwZXIoYSwgYiwgYykge1xuICB2YXIgeCA9IGEgKiA2NTUzNiArIChiPj4+MTYpO1xuICB2YXIgeSA9IE1hdGguZmxvb3IoeC9jKSAqIDY1NTM2O1xuICB2YXIgeiA9ICh4ICUgYykgKiA2NTUzNjtcbiAgdmFyIHcgPSB6ICsgKGIgJiAweDAwMDBGRkZGKTtcbiAgcmV0dXJuIFt5ICsgTWF0aC5mbG9vcih3L2MpLCB3ICUgY107XG59XG5cbi8vIG5hdDFbb2ZzMStsZW5dIDwgbmF0MltvZnMyXVxuLy9Qcm92aWRlczogZGl2X2RpZ2l0X25hdFxuLy9SZXF1aXJlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2RpZ2l0X25hdChuYXRxLCBvZnNxLCBuYXRyLCBvZnNyLCBuYXQxLCBvZnMxLCBsZW4sIG5hdDIsIG9mczIpIHtcbiAgdmFyIHJlbSA9IChuYXQxLmRhdGFbb2ZzMStsZW4tMV0gPj4+MCk7XG4gIC8vIG5hdHFbb2ZzcStsZW4tMV0gaXMgZ3VhcmFudGVlZCB0byBiZSB6ZXJvIChkdWUgdG8gdGhlIE1TRCByZXF1aXJlbWVudCksXG4gIC8vIGFuZCBzaG91bGQgbm90IGJlIHdyaXR0ZW4gdG8uXG4gIGZvcih2YXIgaSA9IGxlbi0yOyBpID49IDA7IGktLSkge1xuICAgIHZhciB4ID0gZGl2X2hlbHBlcihyZW0sIChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCksIChuYXQyLmRhdGFbb2ZzMl0gPj4+IDApKTtcbiAgICBuYXRxLmRhdGFbb2ZzcStpXSA9IHhbMF07XG4gICAgcmVtID0geFsxXTtcbiAgfVxuICBuYXRyLmRhdGFbb2Zzcl0gPSByZW07XG4gIHJldHVybiAwO1xufVxuXG4vLyBuYXQxW25hdDI6XSA6PSBuYXQxIC8gbmF0MlxuLy8gbmF0MVs6bmF0Ml0gOj0gbmF0MSAlIG5hdDJcbi8vIGxlbjEgPiBsZW4yLCBuYXQyW29mczIrbGVuMi0xXSA+IG5hdDFbb2ZzMStsZW4xLTFdXG4vL1Byb3ZpZGVzOiBkaXZfbmF0XG4vL1JlcXVpcmVzOiBkaXZfZGlnaXRfbmF0LCBkaXZfaGVscGVyLCBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQsIHNoaWZ0X2xlZnRfbmF0LCBzaGlmdF9yaWdodF9uYXQsIGNyZWF0ZV9uYXQsIHNldF90b196ZXJvX25hdCwgbXVsdF9kaWdpdF9uYXQsIHN1Yl9uYXQsIGNvbXBhcmVfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIGRpdl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICBpZihsZW4yID09IDEpIHtcbiAgICBkaXZfZGlnaXRfbmF0KG5hdDEsIG9mczErMSwgbmF0MSwgb2ZzMSwgbmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMik7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgcyA9IG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdChuYXQyLCBvZnMyK2xlbjItMSk7XG4gIHNoaWZ0X2xlZnRfbmF0KG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuXG4gIHZhciBkID0gKG5hdDIuZGF0YVtvZnMyK2xlbjItMV0gPj4+IDApICsgMTtcbiAgdmFyIGEgPSBjcmVhdGVfbmF0KGxlbjIrMSk7XG4gIGZvciAodmFyIGkgPSBsZW4xIC0gMTsgaSA+PSBsZW4yOyBpLS0pIHtcbiAgICAvLyBEZWNlbnQgbG93ZXIgYm91bmQgb24gcXVvXG4gICAgdmFyIHF1byA9IGQgPT0gNDI5NDk2NzI5NiA/IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgOiBkaXZfaGVscGVyKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCksIChuYXQxLmRhdGFbb2ZzMStpLTFdID4+PjApLCBkKVswXTtcbiAgICBzZXRfdG9femVyb19uYXQoYSwgMCwgbGVuMisxKTtcbiAgICBtdWx0X2RpZ2l0X25hdChhLCAwLCBsZW4yKzEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdF9vZl9hcnJheShbcXVvXSksIDApO1xuICAgIHN1Yl9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIrMSwgYSwgMCwgbGVuMisxLCAxKTtcblxuICAgIHdoaWxlIChuYXQxLmRhdGFbb2ZzMStpXSAhPSAwIHx8IGNvbXBhcmVfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yLCBuYXQyLCBvZnMyLCBsZW4yKSA+PSAwKSB7XG4gICAgICBxdW8gPSBxdW8gKyAxO1xuICAgICAgc3ViX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMisxLCBuYXQyLCBvZnMyLCBsZW4yLCAxKTtcbiAgICB9XG5cbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHF1bztcbiAgfVxuXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHNoaWZ0IHJlbWFpbmRlclxuICBzaGlmdF9yaWdodF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpOyAvLyByZXN0b3JlXG4gIHJldHVybiAwO1xufVxuXG5cbi8vIDAgPD0gc2hpZnQgPCAzMlxuLy9Qcm92aWRlczogc2hpZnRfcmlnaHRfbmF0XG5mdW5jdGlvbiBzaGlmdF9yaWdodF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYobmJpdHMgPT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IodmFyIGkgPSBsZW4xLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGEgPSBuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMDtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IChhID4+PiBuYml0cykgfCB3cmFwO1xuICAgIHdyYXAgPSBhIDw8ICgzMiAtIG5iaXRzKTtcbiAgfVxuICBuYXQyLmRhdGFbb2ZzMl0gPSB3cmFwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBpZihuYXQxLmRhdGFbb2ZzMV0gPiBuYXQyLmRhdGFbb2ZzMl0pIHJldHVybiAxO1xuICBpZihuYXQxLmRhdGFbb2ZzMV0gPCBuYXQyLmRhdGFbb2ZzMl0pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfbmF0XG4vL1JlcXVpcmVzOiBudW1fZGlnaXRzX25hdFxuZnVuY3Rpb24gY29tcGFyZV9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMikge1xuICB2YXIgYSA9IG51bV9kaWdpdHNfbmF0KG5hdDEsIG9mczEsIGxlbjEpO1xuICB2YXIgYiA9IG51bV9kaWdpdHNfbmF0KG5hdDIsIG9mczIsIGxlbjIpO1xuICBpZihhID4gYikgcmV0dXJuIDE7XG4gIGlmKGEgPCBiKSByZXR1cm4gLTE7XG4gIGZvcih2YXIgaSA9IGxlbjEgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmICgobmF0MS5kYXRhW29mczEraV0gPj4+IDApID4gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSkgcmV0dXJuIDE7XG4gICAgaWYgKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgPCAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApKSByZXR1cm4gLTE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNvbXBhcmVfbmF0X3JlYWxcbi8vUmVxdWlyZXM6IGNvbXBhcmVfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdF9yZWFsKG5hdDEsbmF0Mil7XG4gIHJldHVybiBjb21wYXJlX25hdChuYXQxLDAsbmF0MS5kYXRhLmxlbmd0aCxuYXQyLDAsbmF0Mi5kYXRhLmxlbmd0aCk7XG59XG5cbi8vUHJvdmlkZXM6IGxhbmRfZGlnaXRfbmF0XG5mdW5jdGlvbiBsYW5kX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSAmPSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBsb3JfZGlnaXRfbmF0XG5mdW5jdGlvbiBsb3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIHw9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGx4b3JfZGlnaXRfbmF0XG5mdW5jdGlvbiBseG9yX2RpZ2l0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIG5hdDEuZGF0YVtvZnMxXSBePSBuYXQyLmRhdGFbb2ZzMl07XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IHNlcmlhbGl6ZV9uYXRcbmZ1bmN0aW9uIHNlcmlhbGl6ZV9uYXQod3JpdGVyLCBuYXQsIHN6KXtcbiAgdmFyIGxlbiA9IG5hdC5kYXRhLmxlbmd0aDtcbiAgd3JpdGVyLndyaXRlKDMyLCBsZW4pO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgIHdyaXRlci53cml0ZSgzMiwgbmF0LmRhdGFbaV0pO1xuICB9XG4gIHN6WzBdID0gbGVuICogNDtcbiAgc3pbMV0gPSBsZW4gKiA4O1xufVxuXG4vL1Byb3ZpZGVzOiBkZXNlcmlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IE1sTmF0XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZV9uYXQocmVhZGVyLCBzeil7XG4gIHZhciBsZW4gPSByZWFkZXIucmVhZDMycygpO1xuICB2YXIgbmF0ID0gbmV3IE1sTmF0KGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgbmF0LmRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICB9XG4gIHN6WzBdID0gbGVuICogNDtcbiAgcmV0dXJuIG5hdDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBIdWdvIEhldXphcmRcblxuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVcbnZhciBjYW1sX2dyX3N0YXRlO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9nZXQoKSB7XG4gIGlmKGNhbWxfZ3Jfc3RhdGUpIHtcbiAgICByZXR1cm4gY2FtbF9ncl9zdGF0ZTtcbiAgfVxuICB0aHJvdyBbMCxjYW1sX25hbWVkX3ZhbHVlKFwiR3JhcGhpY3MuR3JhcGhpY19mYWlsdXJlXCIpLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiTm90IGluaXRpYWxpemVkXCIpXVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGUsY2FtbF9ncl9zdGF0ZV9pbml0XG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX3NldChjdHgpIHtcbiAgY2FtbF9ncl9zdGF0ZT1jdHg7XG4gIGNhbWxfZ3Jfc3RhdGVfaW5pdCgpXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX29wZW5fZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9ncmFwaChpbmZvKXtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIGluZm8gPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhpbmZvKTtcbiAgZnVuY3Rpb24gZ2V0KG5hbWUpe1xuICAgIHZhciByZXMgPSBpbmZvLm1hdGNoKFwiKF58LCkgKlwiK25hbWUrXCIgKj0gKihbYS16QS1aMC05X10rKSAqKCx8JClcIik7XG4gICAgaWYocmVzKSByZXR1cm4gcmVzWzJdO1xuICB9XG4gIHZhciBzcGVjcyA9IFtdO1xuICBpZighKGluZm89PVwiXCIpKSBzcGVjcy5wdXNoKGluZm8pO1xuICB2YXIgdGFyZ2V0ID0gZ2V0KFwidGFyZ2V0XCIpO1xuICBpZighdGFyZ2V0KSB0YXJnZXQ9XCJcIjtcbiAgdmFyIHN0YXR1cyA9IGdldChcInN0YXR1c1wiKTtcbiAgaWYoIXN0YXR1cykgc3BlY3MucHVzaChcInN0YXR1cz0xXCIpXG5cbiAgdmFyIHcgPSBnZXQoXCJ3aWR0aFwiKTtcbiAgdyA9IHc/cGFyc2VJbnQodyk6MjAwO1xuICBzcGVjcy5wdXNoKFwid2lkdGg9XCIrdyk7XG5cbiAgdmFyIGggPSBnZXQoXCJoZWlnaHRcIik7XG4gIGggPSBoP3BhcnNlSW50KGgpOjIwMDtcbiAgc3BlY3MucHVzaChcImhlaWdodD1cIitoKTtcblxuICB2YXIgd2luID0gZy5vcGVuKFwiYWJvdXQ6YmxhbmtcIix0YXJnZXQsc3BlY3Muam9pbihcIixcIikpO1xuICBpZighd2luKSB7Y2FtbF9mYWlsd2l0aChcIkdyYXBoaWNzLm9wZW5fZ3JhcGg6IGNhbm5vdCBvcGVuIHRoZSB3aW5kb3dcIil9XG4gIHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG4gIHZhciBjYW52YXMgPSBkb2MuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgY2FudmFzLndpZHRoID0gdztcbiAgY2FudmFzLmhlaWdodCA9IGg7XG4gIHZhciBjdHggPSBjYW1sX2dyX3N0YXRlX2NyZWF0ZShjYW52YXMsdyxoKTtcbiAgY3R4LnNldF90aXRsZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xuICAgIGRvYy50aXRsZSA9IHRpdGxlO1xuICB9O1xuICBjYW1sX2dyX3N0YXRlX3NldChjdHgpO1xuICB2YXIgYm9keSA9IGRvYy5ib2R5O1xuICBib2R5LnN0eWxlLm1hcmdpbiA9IFwiMHB4XCI7XG4gIGJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfaW5pdFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zZXRfY29sb3IsY2FtbF9ncl9tb3ZldG8sY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF9saW5lX3dpZHRoLGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZSxjYW1sX2dyX3NldF9mb250XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfaW5pdCgpe1xuICBjYW1sX2dyX21vdmV0byhjYW1sX2dyX3N0YXRlLngsY2FtbF9ncl9zdGF0ZS55KTtcbiAgY2FtbF9ncl9yZXNpemVfd2luZG93KGNhbWxfZ3Jfc3RhdGUud2lkdGgsY2FtbF9ncl9zdGF0ZS5oZWlnaHQpO1xuICBjYW1sX2dyX3NldF9saW5lX3dpZHRoKGNhbWxfZ3Jfc3RhdGUubGluZV93aWR0aCk7XG4gIGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZShjYW1sX2dyX3N0YXRlLnRleHRfc2l6ZSk7XG4gIGNhbWxfZ3Jfc2V0X2ZvbnQoY2FtbF9ncl9zdGF0ZS5mb250KTtcbiAgY2FtbF9ncl9zZXRfY29sb3IoY2FtbF9ncl9zdGF0ZS5jb2xvcik7XG4gIGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZShjYW1sX2dyX3N0YXRlLnRpdGxlKTtcbiAgLy9jYW1sX2dyX3Jlc2l6ZV93aW5kb3cgbWlnaHQgcmVzZXQgc29tZSBjYW52YXMnIHByb3BlcnRpZXNcbiAgY2FtbF9ncl9zdGF0ZS5jb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9jcmVhdGUoY2FudmFzLHcsaCl7XG4gIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIGNhbnZhcyA6IGNhbnZhcyxcbiAgICB4IDogMCxcbiAgICB5IDogMCxcbiAgICB3aWR0aCA6IHcsXG4gICAgaGVpZ2h0IDogaCxcbiAgICBsaW5lX3dpZHRoIDogMSxcbiAgICBmb250IDogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcImZpeGVkXCIpLFxuICAgIHRleHRfc2l6ZSA6IDI2LFxuICAgIGNvbG9yIDogMHgwMDAwMDAsXG4gICAgdGl0bGUgOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpXG4gIH07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZG9jX29mX3N0YXRlXG5mdW5jdGlvbiBjYW1sX2dyX2RvY19vZl9zdGF0ZShzdGF0ZSkge1xuICBpZihzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudClcbiAgICByZXR1cm4gc3RhdGUuY2FudmFzLm93bmVyRG9jdW1lbnQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2VfZ3JhcGhcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX2dyYXBoKCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jYW52YXMud2lkdGggPSAwO1xuICBzLmNhbnZhcy5oZWlnaHQgPSAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZShuYW1lKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLnRpdGxlID0gbmFtZTtcbiAgdmFyIGpzbmFtZSA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICBpZihzLnNldF90aXRsZSkgcy5zZXRfdGl0bGUoanNuYW1lKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVzaXplX3dpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfcmVzaXplX3dpbmRvdyh3LGgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KClcbiAgcy53aWR0aCA9IHc7XG4gIHMuaGVpZ2h0ID0gaDtcbiAgcy5jYW52YXMud2lkdGggPSB3O1xuICBzLmNhbnZhcy5oZWlnaHQgPSBoO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbGVhcl9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xlYXJfZ3JhcGgoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gIHMuY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAvLyAgcy5jb250ZXh0LnN0cm9rZVJlY3QgKDAuLCAwLiwgcy53aWR0aCwgcy5oZWlnaHQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zaXplX3hcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NpemVfeCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLndpZHRoO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaXplX3lcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3NpemVfeSgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmhlaWdodDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9jb2xvclxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2NvbG9yKGNvbG9yKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBmdW5jdGlvbiBjb252ZXJ0KG51bWJlcikge1xuICAgIHZhciBzdHIgPSAnJyArIG51bWJlci50b1N0cmluZygxNik7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCAyKSBzdHIgPSAnMCcgKyBzdHI7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICB2YXJcbiAgciA9IChjb2xvciA+PiAxNikgJiAweGZmLFxuICBnID0gKGNvbG9yID4+IDgpICAmIDB4ZmYsXG4gIGIgPSAoY29sb3IgPj4gMCkgICYgMHhmZjtcbiAgcy5jb2xvcj1jb2xvcjtcbiAgdmFyIGNfc3RyID0gJyMnICsgY29udmVydChyKSArIGNvbnZlcnQoZykgKyBjb252ZXJ0KGIpO1xuICBzLmNvbnRleHQuZmlsbFN0eWxlID0gICBjX3N0cjtcbiAgcy5jb250ZXh0LnN0cm9rZVN0eWxlID0gY19zdHI7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9wbG90XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9wbG90KHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltPXMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEoMSwxKTtcbiAgdmFyIGQgPSBpbS5kYXRhO1xuICB2YXIgY29sb3IgPSBzLmNvbG9yO1xuICBkWzBdID0gKGNvbG9yID4+IDE2KSAmIDB4ZmY7IC8vclxuICBkWzFdID0gKGNvbG9yID4+IDgpICAmIDB4ZmYsIC8vZ1xuICBkWzJdID0gKGNvbG9yID4+IDApICAmIDB4ZmY7IC8vYlxuICBkWzNdID0gMHhGRjsgLy9hXG4gIHMueD14O1xuICBzLnk9eTtcbiAgcy5jb250ZXh0LnB1dEltYWdlRGF0YShpbSx4LHMuaGVpZ2h0IC0geSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3BvaW50X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9wb2ludF9jb2xvcih4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBpbT1zLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKHgscy5oZWlnaHQgLSB5LDEsMSk7XG4gIHZhciBkID0gaW0uZGF0YTtcbiAgcmV0dXJuIChkWzBdIDw8IDE2KSArIChkWzFdIDw8IDgpICsgZFsyXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbW92ZXRvXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9tb3ZldG8oeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLng9eDtcbiAgcy55PXk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2N1cnJlbnRfeFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3VycmVudF94KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueFxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jdXJyZW50X3lcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2N1cnJlbnRfeSgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLnlcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbGluZXRvXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9saW5ldG8oeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHMuY29udGV4dC5tb3ZlVG8ocy54LHMuaGVpZ2h0IC0gcy55KTtcbiAgcy5jb250ZXh0LmxpbmVUbyh4LHMuaGVpZ2h0IC0geSk7XG4gIHMuY29udGV4dC5zdHJva2UoKTtcbiAgcy54PXg7XG4gIHMueT15O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19yZWN0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3JlY3QoeCx5LHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LnN0cm9rZVJlY3QoeCxzLmhlaWdodCAtIHksdywtaCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfYXJjX2F1eChjdHgsY3gsY3kscnkscngsYTEsYTIpe1xuICB3aGlsZShhMT5hMikgYTIrPTM2MDtcbiAgYTEgLz0gMTgwO1xuICBhMiAvPSAxODA7XG4gIHZhciByb3QgPSAwLHhQb3MseVBvcyx4UG9zX3ByZXYseVBvc19wcmV2O1xuICB2YXIgc3BhY2UgPSAyO1xuICB2YXIgbnVtID0gKCgoYTIgLSBhMSkgKiBNYXRoLlBJICogKChyeCtyeSkvMikpIC8gc3BhY2UpIHwgMDtcbiAgdmFyIGRlbHRhID0gKGEyIC0gYTEpICogTWF0aC5QSSAvIG51bTtcbiAgdmFyIGkgPSBhMSAqIE1hdGguUEk7XG4gIGZvciAodmFyIGo9MDtqPD1udW07aisrKXtcbiAgICB4UG9zID0gY3ggLSAocnggKiBNYXRoLnNpbihpKSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArIChyeSAqIE1hdGguY29zKGkpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHhQb3MgPSB4UG9zLnRvRml4ZWQoMik7XG4gICAgeVBvcyA9IGN5ICsgKHJ5ICogTWF0aC5jb3MoaSkpICogTWF0aC5zaW4ocm90ICogTWF0aC5QSSkgKyAocnggKiBNYXRoLnNpbihpKSkgKiBNYXRoLmNvcyhyb3QgKiBNYXRoLlBJKTtcbiAgICB5UG9zID0geVBvcy50b0ZpeGVkKDIpO1xuICAgIGlmIChqPT0wKSB7XG4gICAgICBjdHgubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgIH0gZWxzZSBpZiAoeFBvc19wcmV2IT14UG9zIHx8IHlQb3NfcHJldiE9eVBvcyl7XG4gICAgICBjdHgubGluZVRvKHhQb3MsIHlQb3MpO1xuICAgIH1cbiAgICB4UG9zX3ByZXY9eFBvcztcbiAgICB5UG9zX3ByZXY9eVBvcztcbiAgICBpLT0gZGVsdGE7Ly9jY3dcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfYXJjXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldCwgY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfYXJjKHgseSxyeCxyeSxhMSxhMil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjYW1sX2dyX2FyY19hdXgocy5jb250ZXh0LHgscy5oZWlnaHQgLSB5LHJ4LHJ5LGExLGEyKTtcbiAgcy5jb250ZXh0LnN0cm9rZSgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfbGluZV93aWR0aFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgodyl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5saW5lX3dpZHRoID0gdztcbiAgcy5jb250ZXh0LmxpbmVXaWR0aCA9IHdcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9yZWN0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX3JlY3QoeCx5LHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmZpbGxSZWN0KHgscy5oZWlnaHQgLSB5LHcsLWgpO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9wb2x5XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9maWxsX3BvbHkoYXIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcy5jb250ZXh0Lm1vdmVUbyhhclsxXVsxXSxzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgZm9yKHZhciBpID0gMjsgaSA8IGFyLmxlbmd0aDsgaSsrKVxuICAgIHMuY29udGV4dC5saW5lVG8oYXJbaV1bMV0scy5oZWlnaHQgLSBhcltpXVsyXSk7XG4gIHMuY29udGV4dC5saW5lVG8oYXJbMV1bMV0scy5oZWlnaHQgLSBhclsxXVsyXSk7XG4gIHMuY29udGV4dC5maWxsKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2ZpbGxfYXJjXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldCwgY2FtbF9ncl9hcmNfYXV4XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfYXJjKHgseSxyeCxyeSxhMSxhMil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjYW1sX2dyX2FyY19hdXgocy5jb250ZXh0LHgscy5oZWlnaHQgLSB5LHJ4LHJ5LGExLGEyKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfc3RyKHN0cil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIG0gPSBzLmNvbnRleHQubWVhc3VyZVRleHQoc3RyKTtcbiAgdmFyIGR4ID0gbS53aWR0aDtcbiAgcy5jb250ZXh0LmZpbGxUZXh0KHN0cixzLngscy5oZWlnaHQgLSBzLnkpO1xuICBzLnggKz0gZHggfCAwO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfZ3JfZHJhd19zdHJcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19jaGFyKGMpe1xuICBjYW1sX2dyX2RyYXdfc3RyKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHJpbmcoc3RyKXtcbiAgY2FtbF9ncl9kcmF3X3N0cihjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzdHIpKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2ZvbnRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfZm9udChmKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmZvbnQgPSBmO1xuICBzLmNvbnRleHQuZm9udCA9IHMudGV4dF9zaXplICsgXCJweCBcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMuZm9udCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF90ZXh0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfdGV4dF9zaXplKHNpemUpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMudGV4dF9zaXplID0gc2l6ZTtcbiAgcy5jb250ZXh0LmZvbnQgPSBzLnRleHRfc2l6ZSArIFwicHggXCIgKyBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzLmZvbnQpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl90ZXh0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl90ZXh0X3NpemUodHh0KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgdyA9IHMuY29udGV4dC5tZWFzdXJlVGV4dChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh0eHQpKS53aWR0aDtcbiAgcmV0dXJuIFswLHcscy50ZXh0X3NpemVdO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfbWFrZV9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfbWFrZV9pbWFnZShhcnIpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciBoID0gYXJyLmxlbmd0aCAtIDEgO1xuICB2YXIgdyA9IGFyclsxXS5sZW5ndGggLSAxO1xuICB2YXIgaW0gPSBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHcsaCk7XG4gIGZvcih2YXIgaT0wO2k8aDtpKyspe1xuICAgIGZvcih2YXIgaj0wO2o8dztqKyspe1xuICAgICAgdmFyIGMgPSBhcnJbaSsxXVtqKzFdO1xuICAgICAgdmFyIG8gPSBpKih3KjQpICsgKGogKiA0KTtcbiAgICAgIGlmKGMgPT0gLTEpIHtcbiAgICAgICAgaW0uZGF0YVtvICsgMF0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDJdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgM10gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW0uZGF0YVtvICsgMF0gPSBjID4+IDE2ICYgMHhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgMV0gPSBjID4+ICA4ICYgMHhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSBjID4+ICAwICYgMFhmZjtcbiAgICAgICAgaW0uZGF0YVtvICsgM10gPSAweGZmO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHVtcF9pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHVtcF9pbWFnZShpbSl7XG4gIHZhciBkYXRhID0gWzBdXG4gIGZvcih2YXIgaT0wOyBpPGltLmhlaWdodDtpKyspe1xuICAgIGRhdGFbaSsxXSA9IFswXVxuICAgIGZvcih2YXIgaj0wOyBqPGltLndpZHRoO2orKyl7XG4gICAgICB2YXIgbyA9IGkqKGltLndpZHRoKjQpICsgKGogKiA0KSxcbiAgICAgICAgICByID0gaW0uZGF0YVtvKzBdLFxuICAgICAgICAgIGcgPSBpbS5kYXRhW28rMV0sXG4gICAgICAgICAgYiA9IGltLmRhdGFbbysyXTtcbiAgICAgIGRhdGFbaSsxXVtqKzFdID0gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiXG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfaW1hZ2UoaW0seCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBpZighaW0uaW1hZ2UpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSBzLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzLmhlaWdodDtcbiAgICBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLnB1dEltYWdlRGF0YShpbSwwLDApO1xuICAgIHZhciBpbWFnZSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbWFnZSgpO1xuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHMuY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UseCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICAgICAgaW0uaW1hZ2UgPSBpbWFnZTtcbiAgICB9XG4gICAgaW1hZ2Uuc3JjID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgfSBlbHNlIHtcbiAgICBzLmNvbnRleHQuZHJhd0ltYWdlKGltLmltYWdlLHgscy5oZWlnaHQgLSBpbS5oZWlnaHQgLSB5KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3JlYXRlX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jcmVhdGVfaW1hZ2UoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh4LHkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9ibGl0X2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9ibGl0X2ltYWdlKGltLHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltMiA9IHMuY29udGV4dC5nZXRJbWFnZURhdGEoeCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHksaW0ud2lkdGgsaW0uaGVpZ2h0KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbTIuZGF0YS5sZW5ndGg7IGkrPTQpe1xuICAgIGltLmRhdGFbaV0gPSBpbTIuZGF0YVtpXTtcbiAgICBpbS5kYXRhW2krMV0gPSBpbTIuZGF0YVtpKzFdO1xuICAgIGltLmRhdGFbaSsyXSA9IGltMi5kYXRhW2krMl07XG4gICAgaW0uZGF0YVtpKzNdID0gaW0yLmRhdGFbaSszXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2lnaW9faGFuZGxlclxuZnVuY3Rpb24gY2FtbF9ncl9zaWdpb19oYW5kbGVyKCl7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpZ2lvX3NpZ25hbFxuZnVuY3Rpb24gY2FtbF9ncl9zaWdpb19zaWduYWwoKXtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2FpdF9ldmVudFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl93YWl0X2V2ZW50KF9ldmwpe1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl93YWl0X2V2ZW50IG5vdCBJbXBsZW1lbnRlZDogdXNlIEdyYXBoaWNzX2pzIGluc3RlYWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3luY2hyb25pemVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3luY2hyb25pemUgKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9zeW5jaHJvbml6ZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3JlbWVtYmVyX21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfcmVtZW1iZXJfbW9kZSAoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3JlbWVtYmVyX21vZGUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kaXNwbGF5X21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3JfZGlzcGxheV9tb2RlKCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9kaXNwbGF5X21vZGUgbm90IEltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3dpbmRvd19pZFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl93aW5kb3dfaWQoYSkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl93aW5kb3dfaWQgbm90IEltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX29wZW5fc3Vid2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX29wZW5fc3Vid2luZG93KGEsYixjLGQpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3cgbm90IEltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvd1xuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3coYSkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3cgbm90IEltcGxlbWVudGVkXCIpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9jb25zdGFudHNcbnZhciBjYW1sX21hcnNoYWxfY29uc3RhbnRzID0ge1xuICBQUkVGSVhfU01BTExfQkxPQ0s6ICAgICAgICAgMHg4MCxcbiAgUFJFRklYX1NNQUxMX0lOVDogICAgICAgICAgIDB4NDAsXG4gIFBSRUZJWF9TTUFMTF9TVFJJTkc6ICAgICAgICAweDIwLFxuICBDT0RFX0lOVDg6ICAgICAgICAgICAgICAgICAgMHgwMCxcbiAgQ09ERV9JTlQxNjogICAgICAgICAgICAgICAgIDB4MDEsXG4gIENPREVfSU5UMzI6ICAgICAgICAgICAgICAgICAweDAyLFxuICBDT0RFX0lOVDY0OiAgICAgICAgICAgICAgICAgMHgwMyxcbiAgQ09ERV9TSEFSRUQ4OiAgICAgICAgICAgICAgIDB4MDQsXG4gIENPREVfU0hBUkVEMTY6ICAgICAgICAgICAgICAweDA1LFxuICBDT0RFX1NIQVJFRDMyOiAgICAgICAgICAgICAgMHgwNixcbiAgQ09ERV9CTE9DSzMyOiAgICAgICAgICAgICAgIDB4MDgsXG4gIENPREVfQkxPQ0s2NDogICAgICAgICAgICAgICAweDEzLFxuICBDT0RFX1NUUklORzg6ICAgICAgICAgICAgICAgMHgwOSxcbiAgQ09ERV9TVFJJTkczMjogICAgICAgICAgICAgIDB4MEEsXG4gIENPREVfRE9VQkxFX0JJRzogICAgICAgICAgICAweDBCLFxuICBDT0RFX0RPVUJMRV9MSVRUTEU6ICAgICAgICAgMHgwQyxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0JJRzogICAgIDB4MEQsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9MSVRUTEU6ICAweDBFLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0JJRzogICAgMHgwRixcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6IDB4MDcsXG4gIENPREVfQ09ERVBPSU5URVI6ICAgICAgICAgICAweDEwLFxuICBDT0RFX0lORklYUE9JTlRFUjogICAgICAgICAgMHgxMSxcbiAgQ09ERV9DVVNUT006ICAgICAgICAgICAgICAgIDB4MTIsXG4gIENPREVfQ1VTVE9NX0xFTjogICAgICAgICAgICAweDE4LFxuICBDT0RFX0NVU1RPTV9GSVhFRDogICAgICAgICAgMHgxOVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sU3RyaW5nUmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBNbFN0cmluZ1JlYWRlciAocywgaSkgeyB0aGlzLnMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpOyB0aGlzLmkgPSBpOyB9XG5NbFN0cmluZ1JlYWRlci5wcm90b3R5cGUgPSB7XG4gIHJlYWQ4dTpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnMuY2hhckNvZGVBdCh0aGlzLmkrKyk7IH0sXG4gIHJlYWQ4czpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnMuY2hhckNvZGVBdCh0aGlzLmkrKykgPDwgMjQgPj4gMjQ7IH0sXG4gIHJlYWQxNnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKVxuICB9LFxuICByZWFkMTZzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCA+PiAxNikgfCBzLmNoYXJDb2RlQXQoaSArIDEpO1xuICB9LFxuICByZWFkMzJ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKSkgPj4+IDA7XG4gIH0sXG4gIHJlYWQzMnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMyk7XG4gIH0sXG4gIHJlYWRzdHI6ZnVuY3Rpb24gKGxlbikge1xuICAgIHZhciBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXModGhpcy5zLnN1YnN0cmluZyhpLCBpICsgbGVuKSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogQmlnU3RyaW5nUmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gQmlnU3RyaW5nUmVhZGVyIChicywgaSkgeyB0aGlzLnMgPSBiczsgdGhpcy5pID0gaTsgfVxuQmlnU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbWxfYmFfZ2V0XzEodGhpcy5zLHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbWxfYmFfZ2V0XzEodGhpcy5zLHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgOCkgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDI0ID4+IDE2KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpICAgICAgICAgKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcbiAgICAgIChjYW1sX2JhX2dldF8xKHMsaSsyKSA8PCA4KSAgfCBjYW1sX2JhX2dldF8xKHMsaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdmFyIGFyciA9IG5ldyBBcnJheShsZW4pXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKXtcbiAgICAgIGFycltqXSA9IGNhbWxfYmFfZ2V0XzEodGhpcy5zLCBpK2opO1xuICAgIH1cbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheShhcnIpO1xuICB9XG59XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKGEpIHtcbiAgcmV0dXJuIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoY2FtbF9pbnQ2NF9vZl9ieXRlcyAoYSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sU3RyaW5nUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fc3RyaW5nKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxTdHJpbmdSZWFkZXIgKHMsIHR5cGVvZiBvZnM9PVwibnVtYmVyXCI/b2ZzOm9mc1swXSk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAoY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocyksIHR5cGVvZiBvZnM9PVwibnVtYmVyXCI/b2ZzOm9mc1swXSk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gIHNpemVbMF0gPSA4O1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyAodCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9pbnQ2NF9tYXJzaGFsKHdyaXRlciwgdiwgc2l6ZXMpIHtcbiAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzICh2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHdyaXRlci53cml0ZSAoOCwgYltpXSk7XG4gIHNpemVzWzBdID0gODsgc2l6ZXNbMV0gPSA4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX3VubWFyc2hhbFxuZnVuY3Rpb24gY2FtbF9pbnQzMl91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgc2l6ZVswXSA9IDQ7XG4gIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwocmVhZGVyLCBzaXplKXtcbiAgc3dpdGNoIChyZWFkZXIucmVhZDh1ICgpKSB7XG4gIGNhc2UgMTpcbiAgICBzaXplWzBdID0gNDtcbiAgICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG4gIGNhc2UgMjpcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IG5hdGl2ZSBpbnRlZ2VyIHZhbHVlIHRvbyBsYXJnZVwiKTtcbiAgZGVmYXVsdDogY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG5hdGl2ZSBpbnRlZ2VyXCIpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF91bm1hcnNoYWwsIGNhbWxfaW50NjRfbWFyc2hhbCwgY2FtbF9pbnQ2NF9jb21wYXJlLCBjYW1sX2ludDY0X2hhc2hcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsLCBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfYmFfc2VyaWFsaXplLCBjYW1sX2JhX2Rlc2VyaWFsaXplLCBjYW1sX2JhX2NvbXBhcmUsIGNhbWxfYmFfaGFzaFxudmFyIGNhbWxfY3VzdG9tX29wcyA9XG4gICAge1wiX2pcIjoge1xuICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX2ludDY0X3VubWFyc2hhbCxcbiAgICAgIHNlcmlhbGl6ZSAgOiBjYW1sX2ludDY0X21hcnNoYWwsXG4gICAgICBmaXhlZF9sZW5ndGggOiA4LFxuICAgICAgY29tcGFyZSA6IGNhbWxfaW50NjRfY29tcGFyZSxcbiAgICAgIGhhc2ggOiBjYW1sX2ludDY0X2hhc2hcbiAgICB9LFxuICAgICBcIl9pXCI6IHtcbiAgICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50MzJfdW5tYXJzaGFsLFxuICAgICAgIGZpeGVkX2xlbmd0aCA6IDQsXG4gICAgIH0sXG4gICAgIFwiX25cIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9uYXRpdmVpbnRfdW5tYXJzaGFsLFxuICAgICAgIGZpeGVkX2xlbmd0aCA6IDQsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycmF5XCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnJheVwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9LFxuICAgICBcIl9iaWdhcnIwMlwiOntcbiAgICAgICBkZXNlcmlhbGl6ZSA6IChmdW5jdGlvbiAocmVhZGVyLCBzeikge3JldHVybiBjYW1sX2JhX2Rlc2VyaWFsaXplIChyZWFkZXIsc3osXCJfYmlnYXJyMDJcIil9KSxcbiAgICAgICBzZXJpYWxpemUgOiBjYW1sX2JhX3NlcmlhbGl6ZSxcbiAgICAgICBjb21wYXJlIDogY2FtbF9iYV9jb21wYXJlLFxuICAgICAgIGhhc2g6IGNhbWxfYmFfaGFzaCxcbiAgICAgfVxuICAgIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2Zsb2F0X29mX2J5dGVzLCBjYW1sX2N1c3RvbV9vcHNcblxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlcihyZWFkZXIsIG9mcykge1xuICB2YXIgX21hZ2ljID0gcmVhZGVyLnJlYWQzMnUgKClcbiAgdmFyIF9ibG9ja19sZW4gPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIG51bV9vYmplY3RzID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV8zMiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgX3NpemVfNjQgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gKG51bV9vYmplY3RzID4gMCk/W106bnVsbDtcbiAgdmFyIG9ial9jb3VudGVyID0gMDtcbiAgZnVuY3Rpb24gaW50ZXJuX3JlYyAoKSB7XG4gICAgdmFyIGNvZGUgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgIGlmIChjb2RlID49IDB4NDAgLypjc3QuUFJFRklYX1NNQUxMX0lOVCovKSB7XG4gICAgICBpZiAoY29kZSA+PSAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovKSB7XG4gICAgICAgIHZhciB0YWcgPSBjb2RlICYgMHhGO1xuICAgICAgICB2YXIgc2l6ZSA9IChjb2RlID4+IDQpICYgMHg3O1xuICAgICAgICB2YXIgdiA9IFt0YWddO1xuICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICBzdGFjay5wdXNoKHYsIHNpemUpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gKGNvZGUgJiAweDNGKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvZGUgPj0gMHgyMC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcgKi8pIHtcbiAgICAgICAgdmFyIGxlbiA9IGNvZGUgJiAweDFGO1xuICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKGNvZGUpIHtcbiAgICAgICAgY2FzZSAweDAwOiAvL2NzdC5DT0RFX0lOVDg6XG4gICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkOHMgKCk7XG4gICAgICAgIGNhc2UgMHgwMTogLy9jc3QuQ09ERV9JTlQxNjpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQxNnMgKCk7XG4gICAgICAgIGNhc2UgMHgwMjogLy9jc3QuQ09ERV9JTlQzMjpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQzMnMgKCk7XG4gICAgICAgIGNhc2UgMHgwMzogLy9jc3QuQ09ERV9JTlQ2NDpcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGludGVnZXIgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDQ6IC8vY3N0LkNPREVfU0hBUkVEODpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNTogLy9jc3QuQ09ERV9TSEFSRUQxNjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQxNnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDY6IC8vY3N0LkNPREVfU0hBUkVEMzI6XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA4OiAvL2NzdC5DT0RFX0JMT0NLMzI6XG4gICAgICAgICAgdmFyIGhlYWRlciA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgIHZhciB0YWcgPSBoZWFkZXIgJiAweEZGO1xuICAgICAgICAgIHZhciBzaXplID0gaGVhZGVyID4+IDEwO1xuICAgICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgICAgaWYgKHNpemUgPT0gMCkgcmV0dXJuIHY7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgxMzogLy9jc3QuQ09ERV9CTE9DSzY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGRhdGEgYmxvY2sgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDk6IC8vY3N0LkNPREVfU1RSSU5HODpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEE6IC8vY3N0LkNPREVfU1RSSU5HMzI6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQzogLy9jc3QuQ09ERV9ET1VCTEVfTElUVExFOlxuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgODtpKyspIHRbNyAtIGldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBCOiAvL2NzdC5DT0RFX0RPVUJMRV9CSUc6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFtpXSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgICAgICAgdmFyIHYgPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwRTogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbNyAtIGpdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBEOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MDc6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbNyAtIGpdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdltpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBGOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWTMyX0JJRzpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7aSA8PSBsZW47aSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2IFtpXSA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEwOiAvL2NzdC5DT0RFX0NPREVQT0lOVEVSOlxuICAgICAgICBjYXNlIDB4MTE6IC8vY3N0LkNPREVfSU5GSVhQT0lOVEVSOlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGNvZGUgcG9pbnRlclwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDEyOiAvL2NzdC5DT0RFX0NVU1RPTTpcbiAgICAgICAgY2FzZSAweDE4OiAvL2NzdC5DT0RFX0NVU1RPTV9MRU46XG4gICAgICAgIGNhc2UgMHgxOTogLy9jc3QuQ09ERV9DVVNUT01fRklYRUQ6XG4gICAgICAgICAgdmFyIGMsIHMgPSBcIlwiO1xuICAgICAgICAgIHdoaWxlICgoYyA9IHJlYWRlci5yZWFkOHUgKCkpICE9IDApIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSAoYyk7XG4gICAgICAgICAgdmFyIG9wcyA9IGNhbWxfY3VzdG9tX29wc1tzXTtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRfc2l6ZTtcbiAgICAgICAgICBpZighb3BzKVxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB1bmtub3duIGN1c3RvbSBibG9jayBpZGVudGlmaWVyXCIpO1xuICAgICAgICAgIHN3aXRjaChjb2RlKXtcbiAgICAgICAgICBjYXNlIDB4MTI6IC8vIGNzdC5DT0RFX0NVU1RPTSAoZGVwcmVjYXRlZClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxOTogLy8gY3N0LkNPREVfQ1VTVE9NX0ZJWEVEXG4gICAgICAgICAgICBpZighb3BzLmZpeGVkX2xlbmd0aClcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBleHBlY3RlZCBhIGZpeGVkLXNpemUgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IG9wcy5maXhlZF9sZW5ndGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDB4MTg6IC8vIGNzdC5DT0RFX0NVU1RPTV9MRU5cbiAgICAgICAgICAgIGV4cGVjdGVkX3NpemUgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgICAgICAgICAgIC8vIFNraXAgc2l6ZTY0XG4gICAgICAgICAgICByZWFkZXIucmVhZDMycygpOyByZWFkZXIucmVhZDMycygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvbGRfcG9zID0gcmVhZGVyLmk7XG4gICAgICAgICAgdmFyIHNpemUgPSBbMF07XG4gICAgICAgICAgdmFyIHYgPSBvcHMuZGVzZXJpYWxpemUocmVhZGVyLCBzaXplKTtcbiAgICAgICAgICBpZihleHBlY3RlZF9zaXplICE9IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBpZihleHBlY3RlZF9zaXplICE9IHNpemVbMF0pXG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW5jb3JyZWN0IGxlbmd0aCBvZiBzZXJpYWxpemVkIGN1c3RvbSBibG9ja1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbWVzc2FnZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgcmVzID0gaW50ZXJuX3JlYyAoKTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgc2l6ZSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGQgPSB2Lmxlbmd0aDtcbiAgICBpZiAoZCA8IHNpemUpIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgdltkXSA9IGludGVybl9yZWMgKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvZnMhPVwibnVtYmVyXCIpIG9mc1swXSA9IHJlYWRlci5pO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAocywgb2ZzKSB7XG4gIGZ1bmN0aW9uIGdldDMyKHMsaSkge1xuICAgIHJldHVybiAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkpIDw8IDI0KSB8XG4gICAgICAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMikgPDwgOCkgfFxuICAgICAgY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAzKTtcbiAgfVxuICBpZiAoZ2V0MzIocywgb2ZzKSAhPSAoMHg4NDk1QTZCRXwwKSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiTWFyc2hhbC5kYXRhX3NpemU6IGJhZCBvYmplY3RcIik7XG4gIHJldHVybiAoZ2V0MzIocywgb2ZzICsgNCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBNbE9iamVjdFRhYmxlXG52YXIgTWxPYmplY3RUYWJsZTtcbmlmICh0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QuV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgTWxPYmplY3RUYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIHBvbHlmaWxsICh1c2luZyBsaW5lYXIgc2VhcmNoKSAqL1xuICAgIGZ1bmN0aW9uIE5haXZlTG9va3VwKG9ianMpIHsgdGhpcy5vYmpzID0gb2JqczsgfVxuICAgIE5haXZlTG9va3VwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih2KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub2Jqcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5vYmpzW2ldID09PSB2KSByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9O1xuICAgIE5haXZlTG9va3VwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgaGVyZS4gW01sT2JqZWN0VGFibGUuc3RvcmVdIHdpbGwgcHVzaCB0byBbdGhpcy5vYmpzXSBkaXJlY3RseS5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIE1sT2JqZWN0VGFibGUoKSB7XG4gICAgICB0aGlzLm9ianMgPSBbXTsgdGhpcy5sb29rdXAgPSBuZXcgTmFpdmVMb29rdXAodGhpcy5vYmpzKTtcbiAgICB9O1xuICB9KCk7XG59XG5lbHNlIHtcbiAgTWxPYmplY3RUYWJsZSA9IGZ1bmN0aW9uIE1sT2JqZWN0VGFibGUoKSB7XG4gICAgdGhpcy5vYmpzID0gW107IHRoaXMubG9va3VwID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LldlYWtNYXAoKTtcbiAgfTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMubG9va3VwLnNldCh2LCB0aGlzLm9ianMubGVuZ3RoKTtcbiAgdGhpcy5vYmpzLnB1c2godik7XG59XG5cbk1sT2JqZWN0VGFibGUucHJvdG90eXBlLnJlY2FsbCA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIGkgPSB0aGlzLmxvb2t1cC5nZXQodik7XG4gIHJldHVybiAoaSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkIDogdGhpcy5vYmpzLmxlbmd0aCAtIGk7ICAgLyogaW5kZXggaXMgcmVsYXRpdmUgKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGVcbi8vVmVyc2lvbjogPj0gNC4wOFxudmFyIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlID0gZmFsc2VcblxuLy9Qcm92aWRlczogY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGVcbi8vVmVyc2lvbjogPCA0LjA4XG52YXIgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUgPSB0cnVlXG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlcywgY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBNbE9iamVjdFRhYmxlLCBjYW1sX2xpc3RfdG9fanNfYXJyYXksIGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCxjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG52YXIgY2FtbF9vdXRwdXRfdmFsID0gZnVuY3Rpb24gKCl7XG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7IHRoaXMuY2h1bmsgPSBbXTsgfVxuICBXcml0ZXIucHJvdG90eXBlID0ge1xuICAgIGNodW5rX2lkeDoyMCwgYmxvY2tfbGVuOjAsIG9ial9jb3VudGVyOjAsIHNpemVfMzI6MCwgc2l6ZV82NDowLFxuICAgIHdyaXRlOmZ1bmN0aW9uIChzaXplLCB2YWx1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfYXQ6ZnVuY3Rpb24gKHBvcywgc2l6ZSwgdmFsdWUpIHtcbiAgICAgIHZhciBwb3MgPSBwb3M7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1twb3MrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfY29kZTpmdW5jdGlvbiAoc2l6ZSwgY29kZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSBjb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IHNpemUgLSA4O2kgPj0gMDtpIC09IDgpXG4gICAgICAgIHRoaXMuY2h1bmtbdGhpcy5jaHVua19pZHgrK10gPSAodmFsdWUgPj4gaSkgJiAweEZGO1xuICAgIH0sXG4gICAgd3JpdGVfc2hhcmVkOmZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgIGlmIChvZmZzZXQgPCAoMSA8PCA4KSkgdGhpcy53cml0ZV9jb2RlKDgsIDB4MDQgLypjc3QuQ09ERV9TSEFSRUQ4Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIGlmIChvZmZzZXQgPCAoMSA8PCAxNikpIHRoaXMud3JpdGVfY29kZSgxNiwgMHgwNSAvKmNzdC5DT0RFX1NIQVJFRDE2Ki8sIG9mZnNldCk7XG4gICAgICBlbHNlIHRoaXMud3JpdGVfY29kZSgzMiwgMHgwNiAvKmNzdC5DT0RFX1NIQVJFRDMyKi8sIG9mZnNldCk7XG4gICAgfSxcbiAgICBwb3M6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jaHVua19pZHggfSxcbiAgICBmaW5hbGl6ZTpmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmJsb2NrX2xlbiA9IHRoaXMuY2h1bmtfaWR4IC0gMjA7XG4gICAgICB0aGlzLmNodW5rX2lkeCA9IDA7XG4gICAgICB0aGlzLndyaXRlICgzMiwgMHg4NDk1QTZCRSk7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5ibG9ja19sZW4pO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMub2JqX2NvdW50ZXIpO1xuICAgICAgdGhpcy53cml0ZSAoMzIsIHRoaXMuc2l6ZV8zMik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzY0KTtcbiAgICAgIHJldHVybiB0aGlzLmNodW5rO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKHYsIGZsYWdzKSB7XG4gICAgZmxhZ3MgPSBjYW1sX2xpc3RfdG9fanNfYXJyYXkoZmxhZ3MpO1xuXG4gICAgdmFyIG5vX3NoYXJpbmcgPSAoZmxhZ3MuaW5kZXhPZigwIC8qTWFyc2hhbC5Ob19zaGFyaW5nKi8pICE9PSAtMSksXG4gICAgICAgIGNsb3N1cmVzID0gIChmbGFncy5pbmRleE9mKDEgLypNYXJzaGFsLkNsb3N1cmVzKi8pICE9PSAtMSk7XG4gICAgICAgIC8qIE1hcnNoYWwuQ29tcGF0XzMyIGlzIHJlZHVuZGFudCBzaW5jZSBpbnRlZ2VycyBhcmUgMzItYml0IGFueXdheSAqL1xuXG4gICAgaWYgKGNsb3N1cmVzKVxuICAgICAgam9vX2dsb2JhbF9vYmplY3QuY29uc29sZS53YXJuKFwiaW4gY2FtbF9vdXRwdXRfdmFsOiBmbGFnIE1hcnNoYWwuQ2xvc3VyZXMgaXMgbm90IHN1cHBvcnRlZC5cIik7XG5cbiAgICB2YXIgd3JpdGVyID0gbmV3IFdyaXRlciAoKTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgaW50ZXJuX29ial90YWJsZSA9IG5vX3NoYXJpbmcgPyBudWxsIDogbmV3IE1sT2JqZWN0VGFibGUoKTtcblxuICAgIGZ1bmN0aW9uIG1lbW8odikge1xuICAgICAgaWYgKG5vX3NoYXJpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBleGlzdGluZ19vZmZzZXQgPSBpbnRlcm5fb2JqX3RhYmxlLnJlY2FsbCh2KTtcbiAgICAgIGlmIChleGlzdGluZ19vZmZzZXQpIHsgd3JpdGVyLndyaXRlX3NoYXJlZChleGlzdGluZ19vZmZzZXQpOyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgZWxzZSB7IGludGVybl9vYmpfdGFibGUuc3RvcmUodik7IHJldHVybiBmYWxzZTsgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVybl9yZWMgKHYpIHtcbiAgICAgIGlmICh2LmNhbWxfY3VzdG9tKSB7XG4gICAgICAgIGlmIChtZW1vKHYpKSByZXR1cm47XG4gICAgICAgIHZhciBuYW1lID0gdi5jYW1sX2N1c3RvbTtcbiAgICAgICAgdmFyIG9wcyA9IGNhbWxfY3VzdG9tX29wc1tuYW1lXTtcbiAgICAgICAgdmFyIHN6XzMyXzY0ID0gWzAsMF07XG4gICAgICAgIGlmKCFvcHMuc2VyaWFsaXplKVxuICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKEN1c3RvbSlcIik7XG4gICAgICAgIGlmKGNhbWxfbGVnYWN5X2N1c3RvbV9jb2RlKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDEyIC8qY3N0LkNPREVfQ1VTVE9NKi8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgbmFtZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgfSBlbHNlIGlmKG9wcy5maXhlZF9sZW5ndGggPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTggLypjc3QuQ09ERV9DVVNUT01fTEVOKi8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgbmFtZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgdmFyIGhlYWRlcl9wb3MgPSB3cml0ZXIucG9zICgpO1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wcy5zZXJpYWxpemUod3JpdGVyLCB2LCBzel8zMl82NCk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MsIDMyLCBzel8zMl82NFswXSk7XG4gICAgICAgICAgd3JpdGVyLndyaXRlX2F0KGhlYWRlcl9wb3MgKyA0LCAzMiwgMCk7IC8vIHplcm9cbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDgsIDMyLCBzel8zMl82NFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDE5IC8qY3N0LkNPREVfQ1VTVE9NX0ZJWEVEKi8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgbmFtZS5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGUoOCwgMCk7XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSB3cml0ZXIucG9zKCk7XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICBpZiAob3BzLmZpeGVkX2xlbmd0aCAhPSB3cml0ZXIucG9zKCkgLSBvbGRfcG9zKVxuICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogaW5jb3JyZWN0IGZpeGVkIHNpemVzIHNwZWNpZmllZCBieSBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDIgKyAoKHN6XzMyXzY0WzBdICsgMykgPj4gMik7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IDIgKyAoKHN6XzMyXzY0WzFdICsgNykgPj4gMyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgICAgaWYgKHZbMF0gPT0gMjUxKSB7XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKEFic3RyYWN0KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodi5sZW5ndGggPiAxICYmIG1lbW8odikpIHJldHVybjtcbiAgICAgICAgaWYgKHZbMF0gPCAxNiAmJiB2Lmxlbmd0aCAtIDEgPCA4KVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHg4MCAvKmNzdC5QUkVGSVhfU01BTExfQkxPQ0sqLyArIHZbMF0gKyAoKHYubGVuZ3RoIC0gMSk8PDQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDMyLCAweDA4IC8qY3N0LkNPREVfQkxPQ0szMiovLCAoKHYubGVuZ3RoLTEpIDw8IDEwKSB8IHZbMF0pO1xuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSB2Lmxlbmd0aDtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gdi5sZW5ndGg7XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEpIHN0YWNrLnB1c2ggKHYsIDEpO1xuICAgICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHYpKSB7XG4gICAgICAgIGlmKCEoY2FtbF9pc19tbF9ieXRlcyhjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpKSkpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBbQnl0ZXMudF0gY2Fubm90IHNhZmVseSBiZSBtYXJzaGFsZWQgd2l0aCBbLS1lbmFibGUgdXNlLWpzLXN0cmluZ11cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHYpO1xuICAgICAgICBpZiAobGVuIDwgMHgyMClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MjAgLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyovICsgbGVuKTtcbiAgICAgICAgZWxzZSBpZiAobGVuIDwgMHgxMDApXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDgsIDB4MDkvKmNzdC5DT0RFX1NUUklORzgqLywgbGVuKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICgzMiwgMHgwQSAvKmNzdC5DT0RFX1NUUklORzMyKi8sIGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBsZW47aSsrKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0KHYsaSkpO1xuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAxICsgKCgobGVuICsgNCkgLyA0KXwwKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMSArICgoKGxlbiArIDgpIC8gOCl8MCk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHYpKSB7XG4gICAgICAgIHZhciBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoOCwgMHgwOS8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDMyLCAweDBBIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxlbjtpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHYsaSkpO1xuICAgICAgICB3cml0ZXIuc2l6ZV8zMiArPSAxICsgKCgobGVuICsgNCkgLyA0KXwwKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMSArICgoKGxlbiArIDgpIC8gOCl8MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodiAhPSAodnwwKSl7XG4gICAgICAgICAgdmFyIHR5cGVfb2ZfdiA9IHR5cGVvZiB2O1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSWYgYSBmbG9hdCBoYXBwZW5zIHRvIGJlIGFuIGludGVnZXIgaXQgaXMgc2VyaWFsaXplZCBhcyBhbiBpbnRlZ2VyXG4gICAgICAgICAgLy8gKEpzX29mX29jYW1sIGNhbm5vdCB0ZWxsIHdoZXRoZXIgdGhlIHR5cGUgb2YgYW4gaW50ZWdlciBudW1iZXIgaXNcbiAgICAgICAgICAvLyBmbG9hdCBvciBpbnRlZ2VyLikgVGhpcyBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgY3Jhc2hlcyB3aGVuXG4gICAgICAgICAgLy8gdW5tYXJzaGFsbGluZyB1c2luZyB0aGUgc3RhbmRhcmQgcnVudGltZS4gSXQgc2VlbXMgYmV0dGVyIHRvXG4gICAgICAgICAgLy8gc3lzdGVtYXRpY2FsbHkgZmFpbCBvbiBtYXJzaGFsbGluZy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vICAgICAgICAgIGlmKHR5cGVfb2ZfdiAhPSBcIm51bWJlclwiKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChcIit0eXBlX29mX3YrXCIpXCIpO1xuICAgICAgICAgIC8vICAgICAgICAgIHZhciB0ID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQodikpO1xuICAgICAgICAgIC8vICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgwQiAvKmNzdC5DT0RFX0RPVUJMRV9CSUcqLyk7XG4gICAgICAgICAgLy8gICAgICAgICAgZm9yKHZhciBpID0gMDsgaTw4OyBpKyspe3dyaXRlci53cml0ZSg4LHRbaV0pfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPj0gMCAmJiB2IDwgMHg0MCkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMFg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8gKyB2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodiA+PSAtKDEgPDwgNykgJiYgdiA8ICgxIDw8IDcpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoOCwgMHgwMCAvKmNzdC5DT0RFX0lOVDgqLywgdik7XG4gICAgICAgICAgZWxzZSBpZiAodiA+PSAtKDEgPDwgMTUpICYmIHYgPCAoMSA8PCAxNSkpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgxNiwgMHgwMSAvKmNzdC5DT0RFX0lOVDE2Ki8sIHYpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDMyLCAweDAyIC8qY3N0LkNPREVfSU5UMzIqLywgdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZXh0ZXJuX3JlYyAodik7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBpID0gc3RhY2sucG9wICgpO1xuICAgICAgdmFyIHYgPSBzdGFjay5wb3AgKCk7XG4gICAgICBpZiAoaSArIDEgPCB2Lmxlbmd0aCkgc3RhY2sucHVzaCAodiwgaSArIDEpO1xuICAgICAgZXh0ZXJuX3JlYyAodltpXSk7XG4gICAgfVxuICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSB3cml0ZXIub2JqX2NvdW50ZXIgPSBpbnRlcm5fb2JqX3RhYmxlLm9ianMubGVuZ3RoO1xuICAgIHdyaXRlci5maW5hbGl6ZSgpO1xuICAgIHJldHVybiB3cml0ZXIuY2h1bms7XG4gIH1cbn0gKCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9hcnJheSAoY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfYnl0ZXNfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzICh2LCBmbGFncykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl9hcnJheSAoY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXJcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9mYWlsd2l0aCwgY2FtbF9ibGl0X2J5dGVzXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXIgKHMsIG9mcywgbGVuLCB2LCBmbGFncykge1xuICB2YXIgdCA9IGNhbWxfb3V0cHV0X3ZhbCAodiwgZmxhZ3MpO1xuICBpZiAodC5sZW5ndGggPiBsZW4pIGNhbWxfZmFpbHdpdGggKFwiTWFyc2hhbC50b19idWZmZXI6IGJ1ZmZlciBvdmVyZmxvd1wiKTtcbiAgY2FtbF9ibGl0X2J5dGVzKHQsIDAsIHMsIG9mcywgdC5sZW5ndGgpO1xuICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSW9cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY2xvc2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfc3lzX2Nsb3NlKGZkKSB7XG4gIGRlbGV0ZSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0ZF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9zdGRfb3V0cHV0KGNoYW5pZCxzKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBzdHIgPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpO1xuICB2YXIgc2xlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIpO1xuICBjaGFuLmZpbGUud3JpdGUoY2hhbi5vZmZzZXQsIHN0ciwgMCwgc2xlbik7XG4gIGNoYW4ub2Zmc2V0ICs9IHNsZW47XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19vcGVuXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nbG9iYWxfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9jcmVhdGVfYnl0ZXMsTWxGYWtlRmlsZVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyLCBqc19wcmludF9zdGRvdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RkX291dHB1dFxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW5faW50ZXJuYWwoaWR4LG91dHB1dCxmaWxlLGZsYWdzKSB7XG4gIGlmKGNhbWxfZ2xvYmFsX2RhdGEuZmRzID09PSB1bmRlZmluZWQpIGNhbWxfZ2xvYmFsX2RhdGEuZmRzID0gbmV3IEFycmF5KCk7XG4gIGZsYWdzPWZsYWdzP2ZsYWdzOnt9O1xuICB2YXIgaW5mbyA9IHt9O1xuICBpbmZvLmZpbGUgPSBmaWxlO1xuICBpbmZvLm9mZnNldCA9IGZsYWdzLmFwcGVuZD9maWxlLmxlbmd0aCgpOjA7XG4gIGluZm8uZmxhZ3MgPSBmbGFncztcbiAgaW5mby5vdXRwdXQgPSBvdXRwdXQ7XG4gIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2lkeF0gPSBpbmZvO1xuICBpZighY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeCB8fCBpZHggPiBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4KVxuICAgIGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHggPSBpZHg7XG4gIHJldHVybiBpZHg7XG59XG5mdW5jdGlvbiBjYW1sX3N5c19vcGVuIChuYW1lLCBmbGFncywgX3Blcm1zKSB7XG4gIHZhciBmID0ge307XG4gIHdoaWxlKGZsYWdzKXtcbiAgICBzd2l0Y2goZmxhZ3NbMV0pe1xuICAgIGNhc2UgMDogZi5yZG9ubHkgPSAxO2JyZWFrO1xuICAgIGNhc2UgMTogZi53cm9ubHkgPSAxO2JyZWFrO1xuICAgIGNhc2UgMjogZi5hcHBlbmQgPSAxO2JyZWFrO1xuICAgIGNhc2UgMzogZi5jcmVhdGUgPSAxO2JyZWFrO1xuICAgIGNhc2UgNDogZi50cnVuY2F0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA1OiBmLmV4Y2wgPSAxOyBicmVhaztcbiAgICBjYXNlIDY6IGYuYmluYXJ5ID0gMTticmVhaztcbiAgICBjYXNlIDc6IGYudGV4dCA9IDE7YnJlYWs7XG4gICAgY2FzZSA4OiBmLm5vbmJsb2NrID0gMTticmVhaztcbiAgICB9XG4gICAgZmxhZ3M9ZmxhZ3NbMl07XG4gIH1cbiAgaWYoZi5yZG9ubHkgJiYgZi53cm9ubHkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl9yZG9ubHkgYW5kIE9wZW5fd3Jvbmx5IGFyZSBub3QgY29tcGF0aWJsZVwiKTtcbiAgaWYoZi50ZXh0ICYmIGYuYmluYXJ5KVxuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LGYpO1xuICB2YXIgaWR4ID0gY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeD9jYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4OjA7XG4gIHJldHVybiBjYW1sX3N5c19vcGVuX2ludGVybmFsIChpZHgrMSxjYW1sX3N0ZF9vdXRwdXQsZmlsZSxmKTtcbn1cbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMCxjYW1sX3N0ZF9vdXRwdXQsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3RkaW5cbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMSxqc19wcmludF9zdGRvdXQsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3Rkb3V0XG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDIsanNfcHJpbnRfc3RkZXJyLCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZGVyclxuXG5cbi8vIG9jYW1sIENoYW5uZWxzXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lKCkge1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxzXG52YXIgY2FtbF9tbF9jaGFubmVscyA9IG5ldyBBcnJheSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dF9jaGFubmVsc19saXN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX291dF9jaGFubmVsc19saXN0ICgpIHtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGMgPSAwOyBjIDwgY2FtbF9tbF9jaGFubmVscy5sZW5ndGg7IGMrKyl7XG4gICAgaWYoY2FtbF9tbF9jaGFubmVsc1tjXSAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm9wZW5lZCAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm91dClcbiAgICAgIGw9WzAsY2FtbF9tbF9jaGFubmVsc1tjXS5mZCxsXTtcbiAgfVxuICByZXR1cm4gbDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQgKGZkKSB7XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICBpZihkYXRhLmZsYWdzLnJkb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyByZWFkb25seVwiKTtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpkYXRhLmZpbGUsXG4gICAgb2Zmc2V0OmRhdGEub2Zmc2V0LFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDp0cnVlLFxuICAgIGJ1ZmZlcjpcIlwiXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLGNhbWxfc3lzX29wZW4sY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIChmZCkgIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3Mud3Jvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHdyaXRlb25seVwiKTtcblxuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OiBmYWxzZSxcbiAgICByZWZpbGw6bnVsbFxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX2NoYW5uZWxfZGVzY3JpcHRvcihjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlKGNoYW5pZCxtb2RlKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF07XG4gIGRhdGEuZmxhZ3MudGV4dCA9ICFtb2RlXG4gIGRhdGEuZmxhZ3MuYmluYXJ5ID0gbW9kZVxuICByZXR1cm4gMDtcbn1cblxuLy9JbnB1dCBmcm9tIGluX2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9jbG9zZV9jaGFubmVsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLCBjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3N5c19jbG9zZVxuZnVuY3Rpb24gY2FtbF9tbF9jbG9zZV9jaGFubmVsIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgY2hhbi5vcGVuZWQgPSBmYWxzZTtcbiAgY2hhbi5maWxlLmNsb3NlKCk7XG4gIGNhbWxfc3lzX2Nsb3NlKGNoYW4uZmQpXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemUoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5maWxlLmxlbmd0aCgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCxjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZV82NChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNoYW4uZmlsZS5sZW5ndGggKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXQoY2hhbmlkLGYpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwoY2hhbmlkLGYpIHtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLnJlZmlsbCA9IGY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbikge1xuICB2YXIgc3RyID0gY2hhbi5yZWZpbGwoKTtcbiAgdmFyIHN0cl9sZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyKTtcbiAgaWYgKHN0cl9sZW4gPT0gMCkgY2hhbi5yZWZpbGwgPSBudWxsO1xuICBjaGFuLmZpbGUud3JpdGUoY2hhbi5maWxlLmxlbmd0aCgpLCBzdHIsIDAsIHN0cl9sZW4pO1xuICByZXR1cm4gc3RyX2xlbjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0IChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCA9PSBudWxsKSByZXR1cm47XG4gIGlmIChjaGFuLmZpbGUubGVuZ3RoKCkgIT0gY2hhbi5vZmZzZXQpIHJldHVybjtcbiAgY2FtbF9tbF9yZWZpbGxfaW5wdXQgKGNoYW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dCAoY2hhbmlkLCBzLCBpLCBsKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgbDIgPSBjaGFuLmZpbGUubGVuZ3RoKCkgLSBjaGFuLm9mZnNldDtcbiAgaWYgKGwyID09IDAgJiYgY2hhbi5yZWZpbGwgIT0gbnVsbCkgbDIgPSBjYW1sX21sX3JlZmlsbF9pbnB1dChjaGFuKTtcbiAgaWYgKGwyIDwgbCkgbCA9IGwyO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCwgcywgaSwgbCk7XG4gIGNoYW4ub2Zmc2V0ICs9IGw7XG4gIHJldHVybiBsO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG5cbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKDgpO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCw4KTtcblxuICAvLyBIZWFkZXIgaXMgMjAgYnl0ZXNcbiAgdmFyIGxlbiA9IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKGJ1ZiwgMCkgKyAyMDtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsbGVuKTtcblxuICB2YXIgb2Zmc2V0ID0gWzBdO1xuICB2YXIgcmVzID0gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKGJ1Ziwgb2Zmc2V0KTtcbiAgY2hhbi5vZmZzZXQgPSBjaGFuLm9mZnNldCArIG9mZnNldFswXTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9jaGFyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfY2hhciAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQoY2hhbmlkKTtcbiAgaWYgKGNoYW4ub2Zmc2V0ID49IGNoYW4uZmlsZS5sZW5ndGgoKSlcbiAgICBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciByZXMgPSBjaGFuLmZpbGUucmVhZF9vbmUoY2hhbi5vZmZzZXQpO1xuICBjaGFuLm9mZnNldCsrO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9tbF9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfaW50IChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBmaWxlID0gY2hhbi5maWxlO1xuICB3aGlsZSAoKGNoYW4ub2Zmc2V0ICsgMykgPj0gZmlsZS5sZW5ndGgoKSkge1xuICAgIHZhciBsID0gY2FtbF9tbF9yZWZpbGxfaW5wdXQoY2hhbik7XG4gICAgaWYgKGwgPT0gMCkgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB9XG4gIHZhciBvID0gY2hhbi5vZmZzZXQ7XG4gIHZhciByID0oZmlsZS5yZWFkX29uZShvICApIDw8IDI0KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobysxKSA8PCAxNilcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMikgPDwgOClcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMykpO1xuICBjaGFuLm9mZnNldCs9NDtcbiAgcmV0dXJuIHI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pblxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbihjaGFuaWQscG9zKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgY2hhbi5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW5fNjQoY2hhbmlkLHBvcyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGNoYW4ub2Zmc2V0ID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5cbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luKGNoYW5pZCkge3JldHVybiBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW5fNjQoY2hhbmlkKSB7cmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCl9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQoY2hhbmlkKTtcbiAgdmFyIHAgPSBjaGFuLm9mZnNldDtcbiAgdmFyIGxlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYocCA+PSBsZW4pIHsgcmV0dXJuIDA7fVxuICB3aGlsZSh0cnVlKSB7XG4gICAgaWYocCA+PSBsZW4pIHJldHVybiAtIChwIC0gY2hhbi5vZmZzZXQpO1xuICAgIGlmKGNoYW4uZmlsZS5yZWFkX29uZShwKSA9PSAxMCkgcmV0dXJuIHAgLSBjaGFuLm9mZnNldCArIDE7XG4gICAgcCsrO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZmx1c2hcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2ZsdXNoIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmKCEgY2hhbi5vcGVuZWQpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiQ2Fubm90IGZsdXNoIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIGlmKCFjaGFuLmJ1ZmZlciB8fCBjaGFuLmJ1ZmZlciA9PSBcIlwiKSByZXR1cm4gMDtcbiAgaWYoY2hhbi5mZFxuICAgICAmJiBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXVxuICAgICAmJiBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0O1xuICAgIHN3aXRjaChvdXRwdXQubGVuZ3RoKXtcbiAgICBjYXNlIDI6IG91dHB1dChjaGFuaWQsY2hhbi5idWZmZXIpO2JyZWFrO1xuICAgIGRlZmF1bHQ6IG91dHB1dChjaGFuLmJ1ZmZlcilcbiAgICB9O1xuICB9XG4gIGNoYW4uYnVmZmVyID0gXCJcIjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vb3V0cHV0IHRvIG91dF9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2ZsdXNoLGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3Qgb3V0cHV0IHRvIGEgY2xvc2VkIGNoYW5uZWxcIik7XG4gIHZhciBieXRlcztcbiAgaWYob2Zmc2V0ID09IDAgJiYgY2FtbF9tbF9ieXRlc19sZW5ndGgoYnVmZmVyKSA9PSBsZW4pXG4gICAgYnl0ZXMgPSBidWZmZXI7XG4gIGVsc2Uge1xuICAgIGJ5dGVzID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgICBjYW1sX2JsaXRfYnl0ZXMoYnVmZmVyLG9mZnNldCxieXRlcywwLGxlbik7XG4gIH1cbiAgdmFyIHN0cmluZyA9IGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ5dGVzKTtcbiAgdmFyIGpzc3RyaW5nID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzdHJpbmcpO1xuICB2YXIgaWQgPSBqc3N0cmluZy5sYXN0SW5kZXhPZihcIlxcblwiKTtcbiAgaWYoaWQgPCAwKVxuICAgIGNoYW4uYnVmZmVyKz1qc3N0cmluZztcbiAgZWxzZSB7XG4gICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nLnN1YnN0cigwLGlkKzEpO1xuICAgIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCk7XG4gICAgY2hhbi5idWZmZXIgKz0ganNzdHJpbmcuc3Vic3RyKGlkKzEpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXMsIGNhbWxfYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dChjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pe1xuICByZXR1cm4gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGJ1ZmZlciksb2Zmc2V0LGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9jaGFyIChjaGFuaWQsYykge1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsMSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nLCBjYW1sX21sX291dHB1dCxjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlIChjaGFuaWQsdixmbGFncykge1xuICB2YXIgcyA9IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyh2LCBmbGFncyk7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dChjaGFuaWQscG9zKXtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0ID0gcG9zO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9tbF9jaGFubmVscywgY2FtbF9tbF9mbHVzaFxuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX291dF82NChjaGFuaWQscG9zKXtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0ID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXQoY2hhbmlkKSB7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgcmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXRcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXRfNjQoY2hhbmlkKSB7XG4gIGNhbWxfbWxfZmx1c2goY2hhbmlkKTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQgKGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfaW50IChjaGFuaWQsaSkge1xuICB2YXIgYXJyID0gWyhpPj4yNCkgJiAweEZGLChpPj4xNikgJiAweEZGLChpPj44KSAmIDB4RkYsaSAmIDB4RkYgXTtcbiAgdmFyIHMgPSBjYW1sX3N0cmluZ19vZl9hcnJheShhcnIpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLDQpO1xuICByZXR1cm4gMFxufVxuIiwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWlub3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWlub3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX21ham9yKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19mdWxsX21ham9yXG5mdW5jdGlvbiBjYW1sX2djX2Z1bGxfbWFqb3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2NvbXBhY3Rpb25cbmZ1bmN0aW9uIGNhbWxfZ2NfY29tcGFjdGlvbigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY291bnRlcnNcbmZ1bmN0aW9uIGNhbWxfZ2NfY291bnRlcnMoKSB7IHJldHVybiBbMjU0LDAsMCwwXSB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX3F1aWNrX3N0YXRcbmZ1bmN0aW9uIGNhbWxfZ2NfcXVpY2tfc3RhdCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ2Nfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19zdGF0KCkge1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9nY19zZXRcbmZ1bmN0aW9uIGNhbWxfZ2Nfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX2dldFxuZnVuY3Rpb24gY2FtbF9nY19nZXQoKXtcbiAgcmV0dXJuIFswLDAsMCwwLDAsMCwwLDAsMF1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3NldFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3NldChfY29udHJvbCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWdpc3RlciBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWdpc3RlciAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVsZWFzZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9maW5hbF9yZWxlYXNlICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0YXJ0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc3RhcnQocmF0ZSxzdGFja19zaXplLHRyYWNrZXIpe1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZW1wcm9mX3N0b3BcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdG9wKHVuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZCwgQW5keSBSYXlcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbi8vXG4vLyBCaWdhcnJheS5cbi8vXG4vLyAtIGFsbCBiaWdhcnJheSB0eXBlcyBpbmNsdWRpbmcgSW50NjQgYW5kIENvbXBsZXguXG4vLyAtIGZvcnRyYW4gKyBjIGxheW91dHNcbi8vIC0gc3ViL3NsaWNlL3Jlc2hhcGVcbi8vIC0gcmV0YWluIGZhc3QgcGF0aCBmb3IgMWQgYXJyYXkgYWNjZXNzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaW5pdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYV9pbml0KCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplKGRpbXMpIHtcbiAgdmFyIG5fZGltcyA9IGRpbXMubGVuZ3RoO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbl9kaW1zOyBpKyspIHtcbiAgICBpZiAoZGltc1tpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBzaXplID0gc2l6ZSAqIGRpbXNbaV07XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCl7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSA3OiBjYXNlIDEwOiBjYXNlIDExOiByZXR1cm4gMjtcbiAgZGVmYXVsdDogcmV0dXJuIDE7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBzaXplKXtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIHZpZXc7XG4gIHN3aXRjaChraW5kKXtcbiAgY2FzZSAwOiAgdmlldyA9IGcuRmxvYXQzMkFycmF5OyBicmVhaztcbiAgY2FzZSAxOiAgdmlldyA9IGcuRmxvYXQ2NEFycmF5OyBicmVhaztcbiAgY2FzZSAyOiAgdmlldyA9IGcuSW50OEFycmF5OyBicmVhaztcbiAgY2FzZSAzOiAgdmlldyA9IGcuVWludDhBcnJheTsgYnJlYWs7XG4gIGNhc2UgNDogIHZpZXcgPSBnLkludDE2QXJyYXk7IGJyZWFrO1xuICBjYXNlIDU6ICB2aWV3ID0gZy5VaW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNjogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDc6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA4OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgOTogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDEwOiB2aWV3ID0gZy5GbG9hdDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDExOiB2aWV3ID0gZy5GbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDEyOiB2aWV3ID0gZy5VaW50OEFycmF5OyBicmVhaztcbiAgfVxuICBpZiAoIXZpZXcpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgdmFyIGRhdGEgPSBuZXcgdmlldyhzaXplICogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2N1c3RvbV9uYW1lXG4vL1ZlcnNpb246IDwgNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnJheVwiXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPj0gNC4xMVxudmFyIGNhbWxfYmFfY3VzdG9tX25hbWUgPSBcIl9iaWdhcnIwMlwiXG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpLCBjYW1sX2ludDY0X2hpMzIsIGNhbWxfaW50NjRfbG8zMlxuZnVuY3Rpb24gTWxfQmlnYXJyYXkgKGtpbmQsIGxheW91dCwgZGltcywgYnVmZmVyKSB7XG5cbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhID0gYnVmZmVyO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY2FtbF9jdXN0b20gPSBjYW1sX2JhX2N1c3RvbV9uYW1lO1xuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICB2YXIgb2ZzID0gMDtcbiAgaWYodHlwZW9mIGFyZyA9PT0gXCJudW1iZXJcIikgYXJnID0gW2FyZ107XG4gIGlmICghIChhcmcgaW5zdGFuY2VvZiBBcnJheSkpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ2FycmF5LmpzOiBpbnZhbGlkIG9mZnNldFwiKTtcbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYXJnLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5nZXQvc2V0OiBiYWQgbnVtYmVyIG9mIGRpbWVuc2lvbnNcIik7XG4gIGlmKHRoaXMubGF5b3V0ID09IDAgLyogY19sYXlvdXQgKi8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFyZ1tpXSA8IDAgfHwgYXJnW2ldID49IHRoaXMuZGltc1tpXSlcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyBhcmdbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmRpbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChhcmdbaV0gPCAxIHx8IGFyZ1tpXSA+IHRoaXMuZGltc1tpXSl7XG4gICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIG9mcyA9IChvZnMgKiB0aGlzLmRpbXNbaV0pICsgKGFyZ1tpXSAtIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2ZzO1xufVxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGwgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBoID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkobCxoKTtcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciByID0gdGhpcy5kYXRhW29mcyAqIDIgKyAwXTtcbiAgICB2YXIgaSA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMV07XG4gICAgcmV0dXJuIFsyNTQsIHIsIGldO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiB0aGlzLmRhdGFbb2ZzXVxuICB9XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IGNhbWxfaW50NjRfaGkzMih2KTtcbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMF0gPSB2WzFdO1xuICAgIHRoaXMuZGF0YVtvZnMgKiAyICsgMV0gPSB2WzJdO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gMFxufVxuXG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHYpIHtcbiAgc3dpdGNoKHRoaXMua2luZCl7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIHZhciBhID0gY2FtbF9pbnQ2NF9sbzMyKHYpO1xuICAgIHZhciBiID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGlmKGEgPT0gYil7XG4gICAgICB0aGlzLmRhdGEuZmlsbChhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpPHRoaXMuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZGF0YVtpXSA9IChpJTIgPT0gMCkgPyBhIDogYjtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IGNhc2UgMTE6XG4gICAgLy8gQ29tcGxleDMyLCBDb21wbGV4NjRcbiAgICB2YXIgaW0gPSB2WzFdO1xuICAgIHZhciByZSA9IHZbMl07XG4gICAgaWYoaW0gPT0gcmUpe1xuICAgICAgdGhpcy5kYXRhLmZpbGwoaW0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGltIDogcmU7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRoaXMuZGF0YS5maWxsKHYpO1xuICAgIGJyZWFrO1xuICB9XG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYiwgdG90YWwpIHtcbiAgaWYgKHRoaXMubGF5b3V0ICE9IGIubGF5b3V0IHx8IHRoaXMua2luZCAhPSBiLmtpbmQpIHtcbiAgICB2YXIgazEgPSB0aGlzLmtpbmQgfCAodGhpcy5sYXlvdXQgPDwgOCk7XG4gICAgdmFyIGsyID0gICAgYi5raW5kIHwgKGIubGF5b3V0IDw8IDgpO1xuICAgIHJldHVybiBrMiAtIGsxO1xuICB9XG4gIGlmICh0aGlzLmRpbXMubGVuZ3RoICE9IGIuZGltcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYi5kaW1zLmxlbmd0aCAtIHRoaXMuZGltcy5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKHRoaXMuZGltc1tpXSAhPSBiLmRpbXNbaV0pXG4gICAgICByZXR1cm4gKHRoaXMuZGltc1tpXSA8IGIuZGltc1tpXSkgPyAtMSA6IDE7XG4gIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICBjYXNlIDEwOlxuICBjYXNlIDExOlxuICAgIC8vIEZsb2F0c1xuICAgIHZhciB4LCB5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB4ID0gdGhpcy5kYXRhW2ldO1xuICAgICAgeSA9IGIuZGF0YVtpXTtcbiAgICAgIGlmICh4IDwgeSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHggPiB5KVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmICh4ICE9IHkpIHtcbiAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgaWYgKHggPT0geCkgcmV0dXJuIDE7XG4gICAgICAgIGlmICh5ID09IHkpIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzpcbiAgICAvLyBJbnQ2NFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSs9Mikge1xuICAgICAgLy8gQ2hlY2sgaGlnaGVzdCBiaXRzIGZpcnN0XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPCBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpKzFdID4gYi5kYXRhW2krMV0pXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApIDwgKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGlmICgodGhpcy5kYXRhW2ldID4+PiAwKSA+IChiLmRhdGFbaV0gPj4+IDApKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMjpcbiAgY2FzZSAzOlxuICBjYXNlIDQ6XG4gIGNhc2UgNTpcbiAgY2FzZSA2OlxuICBjYXNlIDg6XG4gIGNhc2UgOTpcbiAgY2FzZSAxMjpcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA8IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRoaXMuZGF0YVtpXSA+IGIuZGF0YVtpXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBNbF9CaWdhcnJheV9jXzFfMVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcbiAgdGhpcy5raW5kICAgPSBraW5kIDtcbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gIHRoaXMuZGltcyAgID0gZGltcztcbiAgdGhpcy5kYXRhICAgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZSA9IG5ldyBNbF9CaWdhcnJheSgpXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gKGFyZykge1xuICBpZih0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKXtcbiAgICBpZigoYXJnIGluc3RhbmNlb2YgQXJyYXkpICYmIGFyZy5sZW5ndGggPT0gMSlcbiAgICAgIGFyZyA9IGFyZ1swXTtcbiAgICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIk1sX0JpZ2FycmF5X2NfMV8xLm9mZnNldFwiKTtcbiAgfVxuICBpZiAoYXJnIDwgMCB8fCBhcmcgPj0gdGhpcy5kaW1zWzBdKVxuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFyZztcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZnMpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9mcyx2KSB7XG4gIHRoaXMuZGF0YVtvZnNdID0gdjtcbiAgcmV0dXJuIDBcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICB0aGlzLmRhdGEuZmlsbCh2KTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jb21wYXJlXG5mdW5jdGlvbiBjYW1sX2JhX2NvbXBhcmUoYSxiLHRvdGFsKXtcbiAgcmV0dXJuIGEuY29tcGFyZShiLHRvdGFsKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IE1sX0JpZ2FycmF5LCBNbF9CaWdhcnJheV9jXzFfMSwgY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKXtcbiAgdmFyIHNpemVfcGVyX2VsZW1lbnQgPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpO1xuICBpZihjYW1sX2JhX2dldF9zaXplKGRpbXMpICogc2l6ZV9wZXJfZWxlbWVudCAhPSBkYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImxlbmd0aCBkb2Vzbid0IG1hdGNoIGRpbXNcIik7XG4gIH1cbiAgaWYobGF5b3V0ID09IDAgJiYgLy8gY19sYXlvdXRcbiAgICAgZGltcy5sZW5ndGggPT0gMSAmJiAvLyBBcnJheTFcbiAgICAgc2l6ZV9wZXJfZWxlbWVudCA9PSAxKSAvLyAxLXRvLTEgbWFwcGluZ1xuICAgIHJldHVybiBuZXcgTWxfQmlnYXJyYXlfY18xXzEoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlKGtpbmQsIGxheW91dCwgZGltc19tbCkge1xuICB2YXIgZGltcyA9IGNhbWxfanNfZnJvbV9hcnJheShkaW1zX21sKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgY2FtbF9iYV9nZXRfc2l6ZShkaW1zKSk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGNhbWxfYmFfY2hhbmdlX2xheW91dChiYSwgbGF5b3V0KSB7XG4gIGlmKGJhLmxheW91dCA9PSBsYXlvdXQpIHJldHVybiBiYTtcbiAgdmFyIG5ld19kaW1zID0gW11cbiAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIG5ld19kaW1zW2ldID0gYmEuZGltc1tiYS5kaW1zLmxlbmd0aCAtIGkgLSAxXTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBsYXlvdXQsIG5ld19kaW1zLCBiYS5kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kXG5mdW5jdGlvbiBjYW1sX2JhX2tpbmQoYmEpIHtcbiAgcmV0dXJuIGJhLmtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbGF5b3V0XG5mdW5jdGlvbiBjYW1sX2JhX2xheW91dChiYSkge1xuICByZXR1cm4gYmEubGF5b3V0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX251bV9kaW1zXG5mdW5jdGlvbiBjYW1sX2JhX251bV9kaW1zKGJhKSB7XG4gIHJldHVybiBiYS5kaW1zLmxlbmd0aDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1cbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9kaW0oYmEsIGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gYmEuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZGltXCIpO1xuICByZXR1cm4gYmEuZGltc1tpXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMVxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzEoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMlxuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzIoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fM1xuLy9SZXF1aXJlczogY2FtbF9iYV9kaW1cbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzMoYmEpIHtcbiAgcmV0dXJuIGNhbWxfYmFfZGltKGJhLCAyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9nZW5lcmljKGJhLCBpKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKTtcbiAgcmV0dXJuIGJhLmdldChvZnMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDE2KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcyArIDEpO1xuICByZXR1cm4gKGIxIHwgKGIyIDw8IDgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9nZXQzMihiYSwgaTApIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gYmEuZ2V0KG9mcyswKTtcbiAgdmFyIGIyID0gYmEuZ2V0KG9mcysxKTtcbiAgdmFyIGIzID0gYmEuZ2V0KG9mcysyKTtcbiAgdmFyIGI0ID0gYmEuZ2V0KG9mcyszKTtcbiAgcmV0dXJuICggKGIxIDw8IDApICB8XG4gICAgICAgICAgIChiMiA8PCA4KSAgfFxuICAgICAgICAgICAoYjMgPDwgMTYpIHxcbiAgICAgICAgICAgKGI0IDw8IDI0KSApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDY0KGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICB2YXIgYjUgPSBiYS5nZXQob2ZzKzQpO1xuICB2YXIgYjYgPSBiYS5nZXQob2ZzKzUpO1xuICB2YXIgYjcgPSBiYS5nZXQob2ZzKzYpO1xuICB2YXIgYjggPSBiYS5nZXQob2ZzKzcpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbYjgsYjcsYjYsYjUsYjQsYjMsYjIsYjFdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMShiYSwgaTApIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoaTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMihiYSwgaTAsIGkxKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMV0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfM1xuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMyhiYSwgaTAsIGkxLCBpMikge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfZ2VuZXJpYyhiYSwgaSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGNhbWxfanNfZnJvbV9hcnJheShpKSksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDE2KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMSA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzEsICh2ID4+PiA4KSAmIDB4ZmYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQzMihiYSwgaTAsIHYpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChpMCk7XG4gIGlmKG9mcyArIDMgPj0gYmEuZGF0YS5sZW5ndGgpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYmEuc2V0KG9mcyswLCAgdiAgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzIsICh2ID4+PiAxNikgJiAweGZmKTtcbiAgYmEuc2V0KG9mcyszLCAodiA+Pj4gMjQpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDY0KGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgNyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgdiA9IGNhbWxfaW50NjRfdG9fYnl0ZXModik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpKyspIGJhLnNldChvZnMraSwgdls3LWldKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMShiYSwgaTAsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChpMCksIHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8yXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8yKGJhLCBpMCwgaTEsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTFdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8zXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8zKGJhLCBpMCwgaTEsIGkyLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoW2kwLGkxLGkyXSksIHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9maWxsXG5mdW5jdGlvbiBjYW1sX2JhX2ZpbGwoYmEsIHYpIHtcbiAgYmEuZmlsbCh2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2JsaXQoc3JjLCBkc3QpIHtcbiAgaWYgKGRzdC5kaW1zLmxlbmd0aCAhPSBzcmMuZGltcy5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRzdC5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIGlmIChkc3QuZGltc1tpXSAhPSBzcmMuZGltc1tpXSlcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgZHN0LmRhdGEuc2V0KHNyYy5kYXRhKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc3ViXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zdWIoYmEsIG9mcywgbGVuKSB7XG4gIHZhciBjaGFuZ2VkX2RpbTtcbiAgdmFyIG11bCA9IDE7XG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSAwO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGJhLmRpbXMubGVuZ3RoIC0gMSk7IGkrKylcbiAgICAgIG11bCA9IG11bCAqIGJhLmRpbXNbaV07XG4gICAgY2hhbmdlZF9kaW0gPSBiYS5kaW1zLmxlbmd0aCAtIDE7XG4gICAgb2ZzID0gb2ZzIC0gMTtcbiAgfVxuICBpZiAob2ZzIDwgMCB8fCBsZW4gPCAwIHx8IChvZnMgKyBsZW4pID4gYmEuZGltc1tjaGFuZ2VkX2RpbV0pe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnN1YjogYmFkIHN1Yi1hcnJheVwiKTtcbiAgfVxuICB2YXIgbmV3X2RpbXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgIG5ld19kaW1zW2ldID0gYmEuZGltc1tpXTtcbiAgbmV3X2RpbXNbY2hhbmdlZF9kaW1dID0gbGVuO1xuICBtdWwgKj0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBtdWwsIChvZnMgKyBsZW4pICogbXVsKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2xpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfc2xpY2UoYmEsIHZpbmQpIHtcbiAgdmluZCA9IGNhbWxfanNfZnJvbV9hcnJheSh2aW5kKTtcbiAgdmFyIG51bV9pbmRzID0gdmluZC5sZW5ndGg7XG4gIHZhciBpbmRleCA9IFtdO1xuICB2YXIgc3ViX2RpbXMgPSBbXTtcbiAgdmFyIG9mcztcblxuICBpZiAobnVtX2luZHMgPiBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zbGljZTogdG9vIG1hbnkgaW5kaWNlc1wiKTtcblxuICAvLyBDb21wdXRlIG9mZnNldCBhbmQgY2hlY2sgYm91bmRzXG4gIGlmIChiYS5sYXlvdXQgPT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2ldID0gdmluZFtpXTtcbiAgICBmb3IgKDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDA7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKG51bV9pbmRzKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzICsgaV0gPSB2aW5kW2ldO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGggLSBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSAxO1xuICAgIHN1Yl9kaW1zID0gYmEuZGltcy5zbGljZSgwLCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzKTtcbiAgfVxuICBvZnMgPSBiYS5vZmZzZXQoaW5kZXgpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoc3ViX2RpbXMpO1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoYmEua2luZCk7XG4gIHZhciBuZXdfZGF0YSA9IGJhLmRhdGEuc3ViYXJyYXkob2ZzICogc2l6ZV9wZXJfZWxlbWVudCwgKG9mcyArIHNpemUpICogc2l6ZV9wZXJfZWxlbWVudCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoYmEua2luZCwgYmEubGF5b3V0LCBzdWJfZGltcywgbmV3X2RhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3Jlc2hhcGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfYmFfZ2V0X3NpemVcbmZ1bmN0aW9uIGNhbWxfYmFfcmVzaGFwZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbmV3X2RpbSA9IFtdO1xuICB2YXIgbnVtX2RpbXMgPSB2aW5kLmxlbmd0aDtcblxuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpe1xuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgfVxuICB2YXIgbnVtX2VsdHMgPSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9kaW1zOyBpKyspIHtcbiAgICBuZXdfZGltW2ldID0gdmluZFtpXTtcbiAgICBpZiAobmV3X2RpbVtpXSA8IDApXG4gICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgbnVtX2VsdHMgPSBudW1fZWx0cyAqIG5ld19kaW1baV07XG4gIH1cblxuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoYmEuZGltcyk7XG4gIC8vIENoZWNrIHRoYXQgc2l6ZXMgYWdyZWVcbiAgaWYgKG51bV9lbHRzICE9IHNpemUpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogc2l6ZSBtaXNtYXRjaFwiKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIG5ld19kaW0sIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfYmFfc2VyaWFsaXplKHdyaXRlciwgYmEsIHN6KSB7XG4gIHdyaXRlci53cml0ZSgzMiwgYmEuZGltcy5sZW5ndGgpO1xuICB3cml0ZXIud3JpdGUoMzIsIChiYS5raW5kIHwgKGJhLmxheW91dCA8PCA4KSkpO1xuICBpZihiYS5jYW1sX2N1c3RvbSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZihiYS5kaW1zW2ldIDwgMHhmZmZmKVxuICAgICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRpbXNbaV0pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHdyaXRlci53cml0ZSgxNiwgMHhmZmZmKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCAwKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIGVsc2VcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgd3JpdGVyLndyaXRlKDMyLGJhLmRpbXNbaV0pXG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSg4LCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMTYsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHdyaXRlci53cml0ZSg4LDApO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGJhLmdldChpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0KGJhLmdldChpKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGIpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogLy8gRmxvYXQzMkFycmF5IChjb21wbGV4MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBqID0gYmEuZ2V0KGkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsxXSkpO1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoalsyXSkpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgIHZhciBjb21wbGV4ID0gYmEuZ2V0KGkpO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzFdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyhjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoY29tcGxleFsyXSkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHdyaXRlci53cml0ZSAoOCwgYltqXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHN6WzBdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA0O1xuICBzelsxXSA9ICg0ICsgYmEuZGltcy5sZW5ndGgpICogODtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kZXNlcmlhbGl6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzLCBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfYnVmZmVyXG5mdW5jdGlvbiBjYW1sX2JhX2Rlc2VyaWFsaXplKHJlYWRlciwgc3osIG5hbWUpe1xuICB2YXIgbnVtX2RpbXMgPSByZWFkZXIucmVhZDMycygpO1xuICBpZiAobnVtX2RpbXMgPCAwIHx8IG51bV9kaW1zID4gMTYpXG4gICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiB3cm9uZyBudW1iZXIgb2YgYmlnYXJyYXkgZGltZW5zaW9uc1wiKTtcbiAgdmFyIHRhZyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBraW5kID0gdGFnICYgMHhmZlxuICB2YXIgbGF5b3V0ID0gKHRhZyA+PiA4KSAmIDE7XG4gIHZhciBkaW1zID0gW11cbiAgaWYobmFtZSA9PSBcIl9iaWdhcnIwMlwiKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgICAgdmFyIHNpemVfZGltID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICAgIGlmKHNpemVfZGltID09IDB4ZmZmZil7XG4gICAgICAgIHZhciBzaXplX2RpbV9oaSA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIHZhciBzaXplX2RpbV9sbyA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgIGlmKHNpemVfZGltX2hpICE9IDApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBiaWdhcnJheSBkaW1lbnNpb24gb3ZlcmZsb3cgaW4gMzJiaXRcIik7XG4gICAgICAgIHNpemVfZGltID0gc2l6ZV9kaW1fbG87XG4gICAgICB9XG4gICAgICBkaW1zLnB1c2goc2l6ZV9kaW0pO1xuICAgIH1cbiAgZWxzZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykgZGltcy5wdXNoKHJlYWRlci5yZWFkMzJ1KCkpO1xuICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoZGltcyk7XG4gIHZhciBkYXRhID0gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpO1xuICB2YXIgYmEgPSBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoa2luZCwgbGF5b3V0LCBkaW1zLCBkYXRhKTtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQxNnUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNjogIC8vIEludDMyQXJyYXkgKGludDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDg6ICAvLyBJbnQzMkFycmF5IChpbnQpXG4gIGNhc2UgOTogIC8vIEludDMyQXJyYXkgKG5hdGl2ZWludClcbiAgICB2YXIgc2l4dHkgPSByZWFkZXIucmVhZDh1KCk7XG4gICAgaWYoc2l4dHkpIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogY2Fubm90IHJlYWQgYmlnYXJyYXkgd2l0aCA2NC1iaXQgT0NhbWwgaW50c1wiKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDMycygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OiAvLyAoaW50NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGludDY0ID0gY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KTtcbiAgICAgIGJhLnNldChpLGludDY0KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTogIC8vIEZsb2F0NjRBcnJheVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDA6ICAvLyBGbG9hdDMyQXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciBmID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksZik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyhyZWFkZXIucmVhZDMycygpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciByZSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgIHZhciBpbSA9IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyhjYW1sX2ludDY0X29mX2J5dGVzKHQpKTtcbiAgICAgIGJhLnNldChpLFsyNTQscmUsaW1dKTtcbiAgICB9XG4gICAgYnJlYWtcbiAgfVxuICBzelswXSA9ICg0ICsgbnVtX2RpbXMpICogNDtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL0RlcHJlY2F0ZWRcbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX2Zyb21cbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRhdGExLCBkYXRhMiwganN0eXAsIGtpbmQsIGxheW91dCwgZGltcyl7XG4gIGlmKGRhdGEyIHx8IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCkgPT0gMil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iYV9jcmVhdGVfZnJvbTogdXNlIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcIik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGExKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9oYXNoIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9oYXNoX21peF9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9oYXNoKGJhKXtcbiAgdmFyIG51bV9lbHRzID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgdmFyIGggPSAwO1xuICBzd2l0Y2goYmEua2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gIGNhc2UgMzogIC8vVWludDhBcnJheVxuICBjYXNlIDEyOiAvL1VpbnQ4QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDI1NikgbnVtX2VsdHMgPSAyNTY7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDQgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTQpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgOCkgfCAoYmEuZGF0YVtpKzJdIDw8IDE2KSB8IChiYS5kYXRhW2krM10gPDwgMjQpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIHcgPSAwO1xuICAgIHN3aXRjaCAobnVtX2VsdHMgJiAzKSB7XG4gICAgY2FzZSAzOiB3ICA9IGJhLmRhdGFbaSsyXSA8PCAxNjsgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlIDI6IHcgfD0gYmEuZGF0YVtpKzFdIDw8IDg7ICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMTogdyB8PSBiYS5kYXRhW2krMF07XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDQ6ICAvLyBJbnQxNkFycmF5XG4gIGNhc2UgNTogIC8vIFVpbnQxNkFycmF5XG4gICAgaWYobnVtX2VsdHMgPiAxMjgpIG51bV9lbHRzID0gMTI4O1xuICAgIHZhciB3ID0gMCwgaSA9MDtcbiAgICBmb3IoaSA9IDA7IGkgKyAyIDw9IGJhLmRhdGEubGVuZ3RoOyBpKz0yKXtcbiAgICAgIHcgPSBiYS5kYXRhW2krMF0gfCAoYmEuZGF0YVtpKzFdIDw8IDE2KTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLHcpO1xuICAgIH1cbiAgICBpZiAoKG51bV9lbHRzICYgMSkgIT0gMClcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDc6ICAvLyBJbnQzMkFycmF5IChpbnQ2NClcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBudW1fZWx0cyAqPSAyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBudW1fZWx0cyAqPTI7IC8qIGZhbGx0aHJvdWdoICovXG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGlmIChudW1fZWx0cyA+IDY0KSBudW1fZWx0cyA9IDY0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2VsdHM7IGkrKykgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgMTE6IC8vIEZsb2F0NjRBcnJheSAoY29tcGxleDY0KVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gMzIpIG51bV9lbHRzID0gMzI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV90b190eXBlZF9hcnJheSBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5KGJhKXtcbiAgcmV0dXJuIGJhLmRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheSh0YSl7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBraW5kO1xuICBpZiAodGEgaW5zdGFuY2VvZiBnLkZsb2F0MzJBcnJheSkga2luZCA9IDA7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5GbG9hdDY0QXJyYXkpIGtpbmQgPSAxO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuSW50OEFycmF5KSBraW5kID0gMjtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLlVpbnQ4QXJyYXkpIGtpbmQgPSAzO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuSW50MTZBcnJheSkga2luZCA9IDQ7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5VaW50MTZBcnJheSkga2luZCA9IDU7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQzMkFycmF5KSBraW5kID0gNjtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLlVpbnQzMkFycmF5KSBraW5kID0gNjtcbiAgZWxzZSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXk6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gIHJldHVybiBraW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSh0YSl7XG4gIHZhciBraW5kID0gY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5KHRhKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgbGlicmFyeVxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEpzbGliXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfcHVyZV9leHByIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX3B1cmVfZXhwciAoZikgeyByZXR1cm4gZigpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfc2V0IChtdXRhYmxlLCBjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3NldChvLGYsdikgeyBvW2ZdPXY7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2dldChvLGYpIHsgcmV0dXJuIG9bZl07IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZGVsZXRlIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZGVsZXRlKG8sZikgeyBkZWxldGUgb1tmXTsgcmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaW5zdGFuY2VvZiAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19pbnN0YW5jZW9mKG8sYykgeyByZXR1cm4gbyBpbnN0YW5jZW9mIGM7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc190eXBlb2YgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190eXBlb2YobykgeyByZXR1cm4gdHlwZW9mIG87IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19vbl9pZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19vbl9pZSAoKSB7XG4gIHZhciB1YSA9XG4gICAgICBqb29fZ2xvYmFsX29iamVjdC5uYXZpZ2F0b3I/am9vX2dsb2JhbF9vYmplY3QubmF2aWdhdG9yLnVzZXJBZ2VudDpcIlwiO1xuICByZXR1cm4gdWEuaW5kZXhPZihcIk1TSUVcIikgIT0gLTEgJiYgdWEuaW5kZXhPZihcIk9wZXJhXCIpICE9IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lc2NhcGUgY29uc3QgKGNvbnN0KVxudmFyIGNhbWxfanNfcmVnZXhwcyA9IHsgYW1wOi8mL2csIGx0Oi88L2csIHF1b3Q6L1xcXCIvZywgYWxsOi9bJjxcXFwiXS8gfTtcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lc2NhcGUgKHMpIHtcbiAgaWYgKCFjYW1sX2pzX3JlZ2V4cHMuYWxsLnRlc3QocykpIHJldHVybiBzO1xuICByZXR1cm4gcy5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5hbXAsIFwiJmFtcDtcIilcbiAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMubHQsIFwiJmx0O1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5xdW90LCBcIiZxdW90O1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VudGl0aWVzXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZW50aXRpZXMocykge1xuICB2YXIgZW50aXR5ID0gL14mIz9bMC05YS16QS1aXSs7JC9cbiAgaWYocy5tYXRjaChlbnRpdHkpKVxuICB7XG4gICAgdmFyIHN0ciwgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICB0ZW1wLmlubmVySFRNTD0gcztcbiAgICBzdHI9IHRlbXAudGV4dENvbnRlbnQgfHwgdGVtcC5pbm5lclRleHQ7XG4gICAgdGVtcD1udWxsO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgZWxzZSB7XG4gICAgY2FtbF9mYWlsd2l0aChcIkludmFsaWQgZW50aXR5IFwiICsgcyk7XG4gIH1cbn1cblxuLy8vLy8vLy8vLy8gRGVidWdnaW5nIGNvbnNvbGVcbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0X2NvbnNvbGUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0X2NvbnNvbGUgKCkge1xuICB2YXIgYyA9IGpvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGU/am9vX2dsb2JhbF9vYmplY3QuY29uc29sZTp7fTtcbiAgdmFyIG0gPSBbXCJsb2dcIiwgXCJkZWJ1Z1wiLCBcImluZm9cIiwgXCJ3YXJuXCIsIFwiZXJyb3JcIiwgXCJhc3NlcnRcIiwgXCJkaXJcIiwgXCJkaXJ4bWxcIixcbiAgICAgICAgICAgXCJ0cmFjZVwiLCBcImdyb3VwXCIsIFwiZ3JvdXBDb2xsYXBzZWRcIiwgXCJncm91cEVuZFwiLCBcInRpbWVcIiwgXCJ0aW1lRW5kXCJdO1xuICBmdW5jdGlvbiBmICgpIHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykgaWYgKCFjW21baV1dKSBjW21baV1dPWY7XG4gIHJldHVybiBjO1xufVxuXG4vL1Byb3ZpZGVzOmNhbWxfdHJhbXBvbGluZVxuZnVuY3Rpb24gY2FtbF90cmFtcG9saW5lKHJlcykge1xuICB2YXIgYyA9IDE7XG4gIHdoaWxlKHJlcyAmJiByZXMuam9vX3RyYW1wKXtcbiAgICByZXMgPSByZXMuam9vX3RyYW1wLmFwcGx5KG51bGwsIHJlcy5qb29fYXJncyk7XG4gICAgYysrO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lX3JldHVyblxuZnVuY3Rpb24gY2FtbF90cmFtcG9saW5lX3JldHVybihmLGFyZ3MpIHtcbiAgcmV0dXJuIHtqb29fdHJhbXA6Zixqb29fYXJnczphcmdzfTtcbn1cblxuLy9Qcm92aWRlczoganNfcHJpbnRfc3Rkb3V0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24ganNfcHJpbnRfc3Rkb3V0KHMpIHtcbiAgdmFyIHMgPSBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZG91dC53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAgJiYgdi5sb2cgJiYgdi5sb2cocyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGpzX3ByaW50X3N0ZGVyciAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGpzX3ByaW50X3N0ZGVycihzKSB7XG4gIHZhciBzID0gY2FtbF91dGYxNl9vZl91dGY4KHMpO1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZiAoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5zdGRvdXQgJiYgZy5wcm9jZXNzLnN0ZG91dC53cml0ZSkge1xuICAgIGcucHJvY2Vzcy5zdGRlcnIud3JpdGUocylcbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgb3V0cHV0IHRoZSBsYXN0IFxcbiBpZiBwcmVzZW50XG4gICAgLy8gYXMgY29uc29sZSBsb2dnaW5nIGRpc3BsYXkgYSBuZXdsaW5lIGF0IHRoZSBlbmRcbiAgICBpZihzLmNoYXJDb2RlQXQocy5sZW5ndGggLSAxKSA9PSAxMClcbiAgICAgIHMgPSBzLnN1YnN0cigwLHMubGVuZ3RoIC0gMSApO1xuICAgIHZhciB2ID0gZy5jb25zb2xlO1xuICAgIHYgJiYgdi5lcnJvciAmJiB2LmVycm9yKHMpO1xuICB9XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9pc19qc1xuZnVuY3Rpb24gY2FtbF9pc19qcygpIHtcbiAgcmV0dXJuIDE7XG59XG5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dyYXBfZXhjZXB0aW9uIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcsY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50XG5mdW5jdGlvbiBjYW1sX3dyYXBfZXhjZXB0aW9uKGUpIHtcbiAgaWYoZSBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gZTtcbiAgLy9TdGFja19vdmVyZmxvdzogY2hyb21lLCBzYWZhcmlcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuUmFuZ2VFcnJvclxuICAgICAmJiBlIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuUmFuZ2VFcnJvclxuICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC9tYXhpbXVtIGNhbGwgc3RhY2svaSkpXG4gICAgcmV0dXJuIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93KTtcbiAgLy9TdGFja19vdmVyZmxvdzogZmlyZWZveFxuICBpZihqb29fZ2xvYmFsX29iamVjdC5JbnRlcm5hbEVycm9yXG4gICAgICYmIGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5JbnRlcm5hbEVycm9yXG4gICAgICYmIGUubWVzc2FnZVxuICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL3RvbyBtdWNoIHJlY3Vyc2lvbi9pKSlcbiAgICByZXR1cm4gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3cpO1xuICAvL1dyYXAgRXJyb3IgaW4gSnMuRXJyb3IgZXhjZXB0aW9uXG4gIGlmKGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5FcnJvciAmJiBjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSlcbiAgICByZXR1cm4gWzAsY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIiksZV07XG4gIC8vZmFsbGJhY2s6IHdyYXBwZWQgaW4gRmFpbHVyZVxuICByZXR1cm4gWzAsY2FtbF9nbG9iYWxfZGF0YS5GYWlsdXJlLGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChTdHJpbmcoZSkpXTtcbn1cblxuLy8gRXhwZXJpbWVudGFsXG4vL1Byb3ZpZGVzOiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2UoZXhuLCBmb3JjZSkge1xuICAvL25ldmVyIHJlcmFpc2UgZm9yIGNvbnN0YW50IGV4blxuICBpZighZXhuLmpzX2Vycm9yIHx8IGZvcmNlIHx8IGV4blswXSA9PSAyNDgpIGV4bi5qc19lcnJvciA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5FcnJvcihcIkpzIGV4Y2VwdGlvbiBjb250YWluaW5nIGJhY2t0cmFjZVwiKTtcbiAgcmV0dXJuIGV4bjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZihleG4uanNfZXJyb3IpIHsgcmV0dXJuIGV4bi5qc19lcnJvcjsgfVxuICByZXR1cm4gbnVsbDtcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBwYXJzaW5nLmMgODk4MyAyMDA4LTA4LTA2IDA5OjM4OjI1WiB4bGVyb3kgJCAqL1xuXG4vKiBUaGUgUERBIGF1dG9tYXRvbiBmb3IgcGFyc2VycyBnZW5lcmF0ZWQgYnkgY2FtbHlhY2MgKi9cblxuLyogVGhlIHB1c2hkb3duIGF1dG9tYXRhICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2xleF9hcnJheVxuZnVuY3Rpb24gY2FtbF9wYXJzZV9lbmdpbmUodGFibGVzLCBlbnYsIGNtZCwgYXJnKVxue1xuICB2YXIgRVJSQ09ERSA9IDI1NjtcblxuICAvL3ZhciBTVEFSVCA9IDA7XG4gIC8vdmFyIFRPS0VOX1JFQUQgPSAxO1xuICAvL3ZhciBTVEFDS1NfR1JPV05fMSA9IDI7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8yID0gMztcbiAgLy92YXIgU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEID0gNDtcbiAgLy92YXIgRVJST1JfREVURUNURUQgPSA1O1xuICB2YXIgbG9vcCA9IDY7XG4gIHZhciB0ZXN0c2hpZnQgPSA3O1xuICB2YXIgc2hpZnQgPSA4O1xuICB2YXIgc2hpZnRfcmVjb3ZlciA9IDk7XG4gIHZhciByZWR1Y2UgPSAxMDtcblxuICB2YXIgUkVBRF9UT0tFTiA9IDA7XG4gIHZhciBSQUlTRV9QQVJTRV9FUlJPUiA9IDE7XG4gIHZhciBHUk9XX1NUQUNLU18xID0gMjtcbiAgdmFyIEdST1dfU1RBQ0tTXzIgPSAzO1xuICB2YXIgQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04gPSA0O1xuICB2YXIgQ0FMTF9FUlJPUl9GVU5DVElPTiA9IDU7XG5cbiAgdmFyIGVudl9zX3N0YWNrID0gMTtcbiAgdmFyIGVudl92X3N0YWNrID0gMjtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0X3N0YWNrID0gMztcbiAgdmFyIGVudl9zeW1iX2VuZF9zdGFjayA9IDQ7XG4gIHZhciBlbnZfc3RhY2tzaXplID0gNTtcbiAgdmFyIGVudl9zdGFja2Jhc2UgPSA2O1xuICB2YXIgZW52X2N1cnJfY2hhciA9IDc7XG4gIHZhciBlbnZfbHZhbCA9IDg7XG4gIHZhciBlbnZfc3ltYl9zdGFydCA9IDk7XG4gIHZhciBlbnZfc3ltYl9lbmQgPSAxMDtcbiAgdmFyIGVudl9hc3AgPSAxMTtcbiAgdmFyIGVudl9ydWxlX2xlbiA9IDEyO1xuICB2YXIgZW52X3J1bGVfbnVtYmVyID0gMTM7XG4gIHZhciBlbnZfc3AgPSAxNDtcbiAgdmFyIGVudl9zdGF0ZSA9IDE1O1xuICB2YXIgZW52X2VycmZsYWcgPSAxNjtcblxuICAvLyB2YXIgX3RibF9hY3Rpb25zID0gMTtcbiAgdmFyIHRibF90cmFuc2xfY29uc3QgPSAyO1xuICB2YXIgdGJsX3RyYW5zbF9ibG9jayA9IDM7XG4gIHZhciB0YmxfbGhzID0gNDtcbiAgdmFyIHRibF9sZW4gPSA1O1xuICB2YXIgdGJsX2RlZnJlZCA9IDY7XG4gIHZhciB0YmxfZGdvdG8gPSA3O1xuICB2YXIgdGJsX3NpbmRleCA9IDg7XG4gIHZhciB0YmxfcmluZGV4ID0gOTtcbiAgdmFyIHRibF9naW5kZXggPSAxMDtcbiAgdmFyIHRibF90YWJsZXNpemUgPSAxMTtcbiAgdmFyIHRibF90YWJsZSA9IDEyO1xuICB2YXIgdGJsX2NoZWNrID0gMTM7XG4gIC8vIHZhciBfdGJsX2Vycm9yX2Z1bmN0aW9uID0gMTQ7XG4gIC8vIHZhciBfdGJsX25hbWVzX2NvbnN0ID0gMTU7XG4gIC8vIHZhciBfdGJsX25hbWVzX2Jsb2NrID0gMTY7XG5cbiAgaWYgKCF0YWJsZXMuZGdvdG8pIHtcbiAgICB0YWJsZXMuZGVmcmVkID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGVmcmVkXSk7XG4gICAgdGFibGVzLnNpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3NpbmRleF0pO1xuICAgIHRhYmxlcy5jaGVjayAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9jaGVja10pO1xuICAgIHRhYmxlcy5yaW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9yaW5kZXhdKTtcbiAgICB0YWJsZXMudGFibGUgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfdGFibGVdKTtcbiAgICB0YWJsZXMubGVuICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGVuXSk7XG4gICAgdGFibGVzLmxocyAgICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2xoc10pO1xuICAgIHRhYmxlcy5naW5kZXggPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9naW5kZXhdKTtcbiAgICB0YWJsZXMuZGdvdG8gID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfZGdvdG9dKTtcbiAgfVxuXG4gIHZhciByZXMgPSAwLCBuLCBuMSwgbjIsIHN0YXRlMTtcblxuICAvLyBSRVNUT1JFXG4gIHZhciBzcCA9IGVudltlbnZfc3BdO1xuICB2YXIgc3RhdGUgPSBlbnZbZW52X3N0YXRlXTtcbiAgdmFyIGVycmZsYWcgPSBlbnZbZW52X2VycmZsYWddO1xuXG4gIGV4aXQ6Zm9yICg7Oykge1xuICAgIHN3aXRjaChjbWQpIHtcbiAgICBjYXNlIDA6Ly9TVEFSVDpcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGVycmZsYWcgPSAwO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDY6Ly9sb29wOlxuICAgICAgbiA9IHRhYmxlcy5kZWZyZWRbc3RhdGVdO1xuICAgICAgaWYgKG4gIT0gMCkgeyBjbWQgPSByZWR1Y2U7IGJyZWFrOyB9XG4gICAgICBpZiAoZW52W2Vudl9jdXJyX2NoYXJdID49IDApIHsgY21kID0gdGVzdHNoaWZ0OyBicmVhazsgfVxuICAgICAgcmVzID0gUkVBRF9UT0tFTjtcbiAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgbGV4ZXIgYW5kIHVwZGF0ZXMgKi9cbiAgICAgIC8qIHN5bWJfc3RhcnQgYW5kIHN5bWJfZW5kICovXG4gICAgY2FzZSAxOi8vVE9LRU5fUkVBRDpcbiAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSB0YWJsZXNbdGJsX3RyYW5zbF9ibG9ja11bYXJnWzBdICsgMV07XG4gICAgICAgIGVudltlbnZfbHZhbF0gPSBhcmdbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSB0YWJsZXNbdGJsX3RyYW5zbF9jb25zdF1bYXJnICsgMV07XG4gICAgICAgIGVudltlbnZfbHZhbF0gPSAwO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIDc6Ly90ZXN0c2hpZnQ6XG4gICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgY21kID0gc2hpZnQ7IGJyZWFrO1xuICAgICAgfVxuICAgICAgbjEgPSB0YWJsZXMucmluZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIG4gPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgICBjbWQgPSByZWR1Y2U7IGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGVycmZsYWcgPD0gMCkge1xuICAgICAgICByZXMgPSBDQUxMX0VSUk9SX0ZVTkNUSU9OO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgZXJyb3IgZnVuY3Rpb24gKi9cbiAgICBjYXNlIDU6Ly9FUlJPUl9ERVRFQ1RFRDpcbiAgICAgIGlmIChlcnJmbGFnIDwgMykge1xuICAgICAgICBlcnJmbGFnID0gMztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3AgKyAxXTtcbiAgICAgICAgICBuMSA9IHRhYmxlcy5zaW5kZXhbc3RhdGUxXTtcbiAgICAgICAgICBuMiA9IG4xICsgRVJSQ09ERTtcbiAgICAgICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IEVSUkNPREUpIHtcbiAgICAgICAgICAgIGNtZCA9IHNoaWZ0X3JlY292ZXI7IGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3AgPD0gZW52W2Vudl9zdGFja2Jhc2VdKSByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgICAgIHNwLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZW52W2Vudl9jdXJyX2NoYXJdID09IDApIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgODovL3NoaWZ0OlxuICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICBpZiAoZXJyZmxhZyA+IDApIGVycmZsYWctLTtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgOTovL3NoaWZ0X3JlY292ZXI6XG4gICAgICBzdGF0ZSA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICBzcCsrO1xuICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICByZXMgPSBHUk9XX1NUQUNLU18xO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAvKiBUaGUgTUwgY29kZSByZXNpemVzIHRoZSBzdGFja3MgKi9cbiAgICBjYXNlIDI6Ly9TVEFDS1NfR1JPV05fMTpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9sdmFsXTtcbiAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9zdGFydF07XG4gICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF07XG4gICAgICBjbWQgPSBsb29wO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDEwOi8vcmVkdWNlOlxuICAgICAgdmFyIG0gPSB0YWJsZXMubGVuW25dO1xuICAgICAgZW52W2Vudl9hc3BdID0gc3A7XG4gICAgICBlbnZbZW52X3J1bGVfbnVtYmVyXSA9IG47XG4gICAgICBlbnZbZW52X3J1bGVfbGVuXSA9IG07XG4gICAgICBzcCA9IHNwIC0gbSArIDE7XG4gICAgICBtID0gdGFibGVzLmxoc1tuXTtcbiAgICAgIHN0YXRlMSA9IGVudltlbnZfc19zdGFja11bc3BdO1xuICAgICAgbjEgPSB0YWJsZXMuZ2luZGV4W21dO1xuICAgICAgbjIgPSBuMSArIHN0YXRlMTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBzdGF0ZTEpXG4gICAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMuZGdvdG9bbV07XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzI7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMzovL1NUQUNLU19HUk9XTl8yOlxuICAgICAgcmVzID0gQ09NUFVURV9TRU1BTlRJQ19BQ1RJT047XG4gICAgICBicmVhayBleGl0O1xuICAgICAgLyogVGhlIE1MIGNvZGUgY2FsbHMgdGhlIHNlbWFudGljIGFjdGlvbiAqL1xuICAgIGNhc2UgNDovL1NFTUFOVElDX0FDVElPTl9DT01QVVRFRDpcbiAgICAgIGVudltlbnZfc19zdGFja11bc3AgKyAxXSA9IHN0YXRlO1xuICAgICAgZW52W2Vudl92X3N0YWNrXVtzcCArIDFdID0gYXJnO1xuICAgICAgdmFyIGFzcCA9IGVudltlbnZfYXNwXTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIGlmIChzcCA+IGFzcCkge1xuICAgICAgICAvKiBUaGlzIGlzIGFuIGVwc2lsb24gcHJvZHVjdGlvbi4gVGFrZSBzeW1iX3N0YXJ0IGVxdWFsIHRvIHN5bWJfZW5kLiAqL1xuICAgICAgICBlbnZbZW52X3N5bWJfc3RhcnRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVthc3AgKyAxXTtcbiAgICAgIH1cbiAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgLyogU2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvLyBTQVZFXG4gIGVudltlbnZfc3BdID0gc3A7XG4gIGVudltlbnZfc3RhdGVdID0gc3RhdGU7XG4gIGVudltlbnZfZXJyZmxhZ10gPSBlcnJmbGFnO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9wYXJzZXJfdHJhY2UgY29uc3Rcbi8vRHVtbXkgZnVuY3Rpb24hXG5mdW5jdGlvbiBjYW1sX3NldF9wYXJzZXJfdHJhY2UoKSB7IHJldHVybiAwOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWI6IGNvZGUgc3BlY2lmaWMgdG8gSnNfb2Zfb2NhbWxcblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Jvb2woeCkgeyByZXR1cm4gISF4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2Jvb2wgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19ib29sKHgpIHsgcmV0dXJuICt4OyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fZmxvYXQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190b19mbG9hdCh4KSB7IHJldHVybiB4OyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9hcnJheSBtdXRhYmxlIChzaGFsbG93KVxuZnVuY3Rpb24gY2FtbF9qc19mcm9tX2FycmF5KGEpIHtcbiAgcmV0dXJuIGEuc2xpY2UoMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3RvX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2FycmF5KGEpIHtcbiAgdmFyIGxlbiA9IGEubGVuZ3RoO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGJbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGxlbjtpKyspIGJbaSsxXSA9IGFbaV07XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X29mX2pzX2FycmF5KGEpe1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgaT1hLmxlbmd0aCAtIDE7IGk+PTA7IGktLSl7XG4gICAgdmFyIGUgPSBhW2ldO1xuICAgIGwgPSBbMCxlLGxdO1xuICB9XG4gIHJldHVybiBsXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF90b19qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3RfdG9fanNfYXJyYXkobCl7XG4gIHZhciBhID0gW107XG4gIGZvcig7IGwgIT09IDA7IGwgPSBsWzJdKSB7XG4gICAgYS5wdXNoKGxbMV0pO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3ZhciBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfdmFyKHgpIHtcbiAgdmFyIHggPSBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyh4KTtcbiAgLy9DaGVja3MgdGhhdCB4IGhhcyB0aGUgZm9ybSBpZGVudFsuaWRlbnRdKlxuICBpZigheC5tYXRjaCgvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKihcXC5bYS16QS1aXyRdW2EtekEtWl8kMC05XSopKiQvKSl7XG4gICAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9qc192YXI6IFxcXCJcIiArIHggKyBcIlxcXCIgaXMgbm90IGEgdmFsaWQgSmF2YVNjcmlwdCB2YXJpYWJsZS4gY29udGludWluZyAuLlwiKTtcbiAgICAvL2pvb19nbG9iYWxfb2JqZWN0LmNvbnNvbGUuZXJyb3IoXCJKcy5VbnNhZmUuZXZhbF9zdHJpbmdcIilcbiAgfVxuICByZXR1cm4gZXZhbCh4KTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfY2FsbCAoY29uc3QsIG11dGFibGUsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfY2FsbChmLCBvLCBhcmdzKSB7IHJldHVybiBmLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnVuX2NhbGwgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2Z1bl9jYWxsKGYsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBmKCk7XG4gIGNhc2UgMjogcmV0dXJuIGYgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBmIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIHJldHVybiBmLmFwcGx5KG51bGwsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX21ldGhfY2FsbCAobXV0YWJsZSwgY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX21ldGhfY2FsbChvLCBmLCBhcmdzKSB7XG4gIHJldHVybiBvW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGYpXS5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19uZXcgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX25ldyhjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIGNhc2UgODogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfb2pzX25ld19hcnIgKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX29qc19uZXdfYXJyKGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDA6IHJldHVybiBuZXcgYztcbiAgY2FzZSAxOiByZXR1cm4gbmV3IGMgKGFbMF0pO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGEpOyB9XG4gIEYucHJvdG90eXBlID0gYy5wcm90b3R5cGU7XG4gIHJldHVybiBuZXcgRjtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKGxlbiA+IDApe1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgW3VuZGVmaW5lZF0pO1xuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbYXJnc10pO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKG4gPT0gYXJpdHkgJiYgZi5sZW5ndGggPT0gYXJpdHkpIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbiArIDEpO1xuICAgIGFyZ3NbMF0gPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaSsxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLGFyZ3MpO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZixbdGhpcyxhcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3N0cmljdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkgKyAxKTtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJndW1lbnRzLmxlbmd0aCwgYXJpdHkpXG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZShmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpOyB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2VxdWFscyBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2VxdWFscyAoeCwgeSkgeyByZXR1cm4gKyh4ID09IHkpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXZhbF9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfZXZhbF9zdHJpbmcgKHMpIHtyZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cHIgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19leHByKHMpIHtcbiAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cXG5cIik7XG4gIHJldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcHVyZV9qc19leHByIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcHVyZV9qc19leHByIChzKXtcbiAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9wdXJlX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19vYmplY3QgKG9iamVjdF9saXRlcmFsKVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNfb2JqZWN0IChhKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gYVtpXTtcbiAgICBvW2NhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHBbMV0pXSA9IHBbMl07XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9qc19leHBvcnRfdmFyXG5mdW5jdGlvbiBjYW1sX2pzX2V4cG9ydF92YXIgKCl7XG4gIGlmKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHNcbiAgZWxzZVxuICAgIHJldHVybiBqb29fZ2xvYmFsX29iamVjdDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9XZWFrZGVmXG5mdW5jdGlvbiBjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZSh1bml0KXtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYodHlwZW9mIGcuWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLlhNTEh0dHBSZXF1ZXN0IH0gY2F0Y2ggKGUpIHsgfTtcbiAgfVxuICBpZih0eXBlb2YgZy5hY3RpdmVYT2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5hY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuYWN0aXZlWE9iamVjdChcIk1zeG1sMy5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLmFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICB9XG4gIGNhbWxfZmFpbHdpdGgoXCJDYW5ub3QgY3JlYXRlIGEgWE1MSHR0cFJlcXVlc3RcIik7XG59XG4iLCIvL1Byb3ZpZGVzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gdW5peF9nZXR0aW1lb2ZkYXkgKCkge1xuICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAvIDEwMDA7XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfdGltZVxuLy9SZXF1aXJlczogdW5peF9nZXR0aW1lb2ZkYXlcbmZ1bmN0aW9uIHVuaXhfdGltZSAoKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHVuaXhfZ2V0dGltZW9mZGF5ICgpKTtcbn1cblxuLy9Qcm92aWRlczogdW5peF9nbXRpbWVcbmZ1bmN0aW9uIHVuaXhfZ210aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKSkpLmdldFRpbWUoKTtcbiAgdmFyIGRveSA9IE1hdGguZmxvb3IoKGRfbnVtIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0VVRDU2Vjb25kcygpLCBkLmdldFVUQ01pbnV0ZXMoKSwgZC5nZXRVVENIb3VycygpLFxuICAgICAgICAgIGQuZ2V0VVRDRGF0ZSgpLCBkLmdldFVUQ01vbnRoKCksIGQuZ2V0VVRDRnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgZC5nZXRVVENEYXkoKSwgZG95LFxuICAgICAgICAgIGZhbHNlIHwgMCAvKiBmb3IgVVRDIGRheWxpZ2h0IHNhdmluZ3MgdGltZSBpcyBmYWxzZSAqLylcbn1cblxuLy9Qcm92aWRlczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIHVuaXhfbG9jYWx0aW1lICh0KSB7XG4gIHZhciBkID0gbmV3IERhdGUgKHQgKiAxMDAwKTtcbiAgdmFyIGRfbnVtID0gZC5nZXRUaW1lKCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSAobmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICB2YXIgamFuID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgdmFyIGp1bCA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XG4gIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KGphbi5nZXRUaW1lem9uZU9mZnNldCgpLCBqdWwuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gIHJldHVybiBCTE9DSygwLCBkLmdldFNlY29uZHMoKSwgZC5nZXRNaW51dGVzKCksIGQuZ2V0SG91cnMoKSxcbiAgICAgICAgICBkLmdldERhdGUoKSwgZC5nZXRNb250aCgpLCBkLmdldEZ1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgIGQuZ2V0RGF5KCksIGRveSxcbiAgICAgICAgICAoZC5nZXRUaW1lem9uZU9mZnNldCgpIDwgc3RkVGltZXpvbmVPZmZzZXQpIHwgMCAvKiBkYXlsaWdodCBzYXZpbmdzIHRpbWUgIGZpZWxkLiAqLylcbn1cblxuLy9Qcm92aWRlczogdW5peF9ta3RpbWVcbi8vUmVxdWlyZXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiB1bml4X21rdGltZSh0bSl7XG4gIHZhciBkID0gKG5ldyBEYXRlKHRtWzZdKzE5MDAsdG1bNV0sdG1bNF0sdG1bM10sdG1bMl0sdG1bMV0pKS5nZXRUaW1lKCk7XG4gIHZhciB0ID0gTWF0aC5mbG9vcihkIC8gMTAwMCk7XG4gIHZhciB0bTIgPSB1bml4X2xvY2FsdGltZSh0KTtcbiAgcmV0dXJuIEJMT0NLKDAsdCx0bTIpO1xufVxuXG4vL1Byb3ZpZGVzOiB3aW5fc3RhcnR1cCBjb25zdFxuZnVuY3Rpb24gd2luX3N0YXJ0dXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiB3aW5fY2xlYW51cCBjb25zdFxuZnVuY3Rpb24gd2luX2NsZWFudXAoKSB7fVxuXG4vL1Byb3ZpZGVzOiB3aW5faGFuZGxlX2ZkIGNvbnN0XG5mdW5jdGlvbiB3aW5faGFuZGxlX2ZkKHgpIHtyZXR1cm4geDt9XG5cbi8vUHJvdmlkZXM6IHVuaXhfaXNhdHR5IFxuLy9SZXF1aXJlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIHVuaXhfaXNhdHR5KGZpbGVEZXNjcmlwdG9yKSB7XG4gIGlmKGZzX25vZGVfc3VwcG9ydGVkKCkpIHtcbiAgICB2YXIgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG4gICAgcmV0dXJuIHR0eS5pc2F0dHkoZmlsZURlc2NyaXB0b3IpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfaW50IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZywgY2FtbF9zdHJfcmVwZWF0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9pbnQoZm10LCBpKSB7XG4gIGlmIChjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCkgPT0gXCIlZFwiKSByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhcIlwiK2kpO1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChpIDwgMCkgeyBpZiAoZi5zaWduZWRjb252KSB7IGYuc2lnbiA9IC0xOyBpID0gLWk7IH0gZWxzZSBpID4+Pj0gMDsgfVxuICB2YXIgcyA9IGkudG9TdHJpbmcoZi5iYXNlKTtcbiAgaWYgKGYucHJlYyA+PSAwKSB7XG4gICAgZi5maWxsZXIgPSAnICc7XG4gICAgdmFyIG4gPSBmLnByZWMgLSBzLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIHMgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBzO1xuICB9XG4gIHJldHVybiBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nKGYsIHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKSB7XG4gIHZhciBpID0gMCwgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLCBiYXNlID0gMTAsIHNpZ24gPSAxO1xuICBpZiAobGVuID4gMCkge1xuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpKSB7XG4gICAgY2FzZSA0NTogaSsrOyBzaWduID0gLTE7IGJyZWFrO1xuICAgIGNhc2UgNDM6IGkrKzsgc2lnbiA9IDE7IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaSArIDEgPCBsZW4gJiYgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSA9PSA0OClcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpKSB7XG4gICAgY2FzZSAxMjA6IGNhc2UgODg6IGJhc2UgPSAxNjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExMTogY2FzZSA3OTogYmFzZSA9ICA4OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgIDk4OiBjYXNlIDY2OiBiYXNlID0gIDI7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAxMTc6IGNhc2UgODU6IGkgKz0gMjsgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gW2ksIHNpZ24sIGJhc2VdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2RpZ2l0XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2RpZ2l0KGMpIHtcbiAgaWYgKGMgPj0gNDggJiYgYyA8PSA1NykgIHJldHVybiBjIC0gNDg7XG4gIGlmIChjID49IDY1ICYmIGMgPD0gOTApICByZXR1cm4gYyAtIDU1O1xuICBpZiAoYyA+PSA5NyAmJiBjIDw9IDEyMikgcmV0dXJuIGMgLSA4NztcbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfcGFyc2VfZGlnaXQsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfaW50X29mX3N0cmluZyAocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgdGhyZXNob2xkID0gLTEgPj4+IDA7XG4gIHZhciBjID0gKGkgPCBsZW4pP2NhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk6MDtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGQ7XG4gIGZvciAoaSsrO2k8bGVuO2krKykge1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICByZXMgPSBiYXNlICogcmVzICsgZDtcbiAgICBpZiAocmVzID4gdGhyZXNob2xkKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAvLyBGb3IgYmFzZSBkaWZmZXJlbnQgZnJvbSAxMCwgd2UgZXhwZWN0IGFuIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLFxuICAvLyBoZW5jZSBhbnkgdmFsdWUgb2YgJ3JlcycgKGxlc3MgdGhhbiAndGhyZXNob2xkJykgaXMgYWNjZXB0YWJsZS5cbiAgLy8gQnV0IHdlIGhhdmUgdG8gY29udmVydCB0aGUgcmVzdWx0IGJhY2sgdG8gYSBzaWduZWQgaW50ZWdlci5cbiAgcmVzID0gc2lnbiAqIHJlcztcbiAgaWYgKChiYXNlID09IDEwKSAmJiAoKHJlcyB8IDApICE9IHJlcykpXG4gICAgLyogU2lnbmVkIHJlcHJlc2VudGF0aW9uIGV4cGVjdGVkLCBhbGxvdyAtMl4obmJpdHMtMSkgdG8gMl4obmJpdHMtMSkgLSAxICovXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHJldHVybiByZXMgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX211bCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tdWwoYSxiKXtcbiAgcmV0dXJuIE1hdGguaW11bChhLGIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RpdlxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9kaXYoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiAoeC95KXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9tb2QoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiB4JXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnN3YXAxNlxuZnVuY3Rpb24gY2FtbF9ic3dhcDE2KHgpIHtcbiAgcmV0dXJuICgoKCh4ICYgMHgwMEZGKSA8PCA4KSB8XG4gICAgICAgICAgICgoeCAmIDB4RkYwMCkgPj4gOCkpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfYnN3YXBcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYnN3YXAoeCkge1xuICByZXR1cm4gKCgoeCAmIDB4MDAwMDAwRkYpIDw8IDI0KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMDAwRkYwMCkgPDwgOCkgfFxuICAgICAgICAgICgoeCAmIDB4MDBGRjAwMDApID4+PiA4KSB8XG4gICAgICAgICAgKCh4ICYgMHhGRjAwMDAwMCkgPj4+IDI0KSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Jzd2FwXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X2Jzd2FwKHgpIHtcbiAgdmFyIHkgPSBjYW1sX2ludDY0X3RvX2J5dGVzKHgpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhbeVs3XSwgeVs2XSwgeVs1XSwgeVs0XSwgeVszXSwgeVsyXSwgeVsxXSwgeVswXV0pO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBIYXNodGJsXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF91bml2X3BhcmFtIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaGFzaF91bml2X3BhcmFtIChjb3VudCwgbGltaXQsIG9iaikge1xuICB2YXIgaGFzaF9hY2N1ID0gMDtcbiAgZnVuY3Rpb24gaGFzaF9hdXggKG9iaikge1xuICAgIGxpbWl0IC0tO1xuICAgIGlmIChjb3VudCA8IDAgfHwgbGltaXQgPCAwKSByZXR1cm47XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5ICYmIG9ialswXSA9PT0gKG9ialswXXwwKSkge1xuICAgICAgc3dpdGNoIChvYmpbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9ialsyXSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIGxpbWl0Kys7IGhhc2hfYXV4KG9iaik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIG9ialswXSkgfCAwO1xuICAgICAgICBmb3IgKHZhciBpID0gb2JqLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIGhhc2hfYXV4IChvYmpbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyhvYmopKSB7XG4gICAgICBjb3VudCAtLTtcbiAgICAgIHN3aXRjaCAob2JqLnQgJiA2KSB7XG4gICAgICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMob2JqKTtcbiAgICAgIGNhc2UgMDogLyogQllURVMgKi9cbiAgICAgICAgZm9yICh2YXIgYiA9IG9iai5jLCBsID0gY2FtbF9tbF9ieXRlc19sZW5ndGgob2JqKSwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOiAvKiBBUlJBWSAqL1xuICAgICAgICBmb3IgKHZhciBhID0gb2JqLmMsIGwgPSBjYW1sX21sX2J5dGVzX2xlbmd0aChvYmopLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBhW2ldKSB8IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyhvYmopKSB7XG4gICAgICAgIHZhciBqc2J5dGVzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhvYmopO1xuICAgICAgICBmb3IgKHZhciBiID0ganNieXRlcywgbCA9IGpzYnl0ZXMubGVuZ3RoLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZm9yICh2YXIgYiA9IG9iaiwgbCA9IG9iai5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSAob2JqfDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBjb3VudCAtLTtcbiAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9iaikgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSArb2JqKSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgY291bnQtLTtcbiAgICAgIHZhciBwID0gY2FtbF9pbnQ2NF90b19ieXRlcyAoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IChvYmopKTtcbiAgICAgIGZvciAodmFyIGkgPSA3OyBpID49IDA7IGktLSkgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgcFtpXSkgfCAwO1xuICAgIH0gZWxzZSBpZihvYmogJiYgb2JqLmNhbWxfY3VzdG9tKSB7XG4gICAgICBpZihjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKSB7XG4gICAgICAgIHZhciBoID0gY2FtbF9jdXN0b21fb3BzW29iai5jYW1sX2N1c3RvbV0uaGFzaChvYmopIHwgMDtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgaCkgfCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNoX2F1eCAob2JqKTtcbiAgcmV0dXJuIGhhc2hfYWNjdSAmIDB4M0ZGRkZGRkY7XG59XG5cbi8vZnVuY3Rpb24gUk9UTDMyKHgsbikgeyByZXR1cm4gKCh4IDw8IG4pIHwgKHggPj4+ICgzMi1uKSkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50KGgsZCkge1xuICBkID0gY2FtbF9tdWwoZCwgMHhjYzllMmQ1MXwwKTtcbiAgZCA9ICgoZCA8PCAxNSkgfCAoZCA+Pj4gKDMyLTE1KSkpOyAvLyBST1RMMzIoZCwgMTUpO1xuICBkID0gY2FtbF9tdWwoZCwgMHgxYjg3MzU5Myk7XG4gIGggXj0gZDtcbiAgaCA9ICgoaCA8PCAxMykgfCAoaCA+Pj4gKDMyLTEzKSkpOyAgIC8vUk9UTDMyKGgsIDEzKTtcbiAgcmV0dXJuICgoKGggKyAoaCA8PCAyKSl8MCkgKyAoMHhlNjU0NmI2NHwwKSl8MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9maW5hbFxuLy9SZXF1aXJlczogY2FtbF9tdWxcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfZmluYWwoaCkge1xuICBoIF49IGggPj4+IDE2O1xuICBoID0gY2FtbF9tdWwgKGgsIDB4ODVlYmNhNmJ8MCk7XG4gIGggXj0gaCA+Pj4gMTM7XG4gIGggPSBjYW1sX211bCAoaCwgMHhjMmIyYWUzNXwwKTtcbiAgaCBePSBoID4+PiAxNjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9oYXNoX21peF9pbnQ2NFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9mbG9hdCAoaCwgdjApIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfaW50NjQoaCwgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0ICh2MCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbG8zMiwgY2FtbF9pbnQ2NF9oaTMyXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludDY0IChoLCB2KSB7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2xvMzIodikpO1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgY2FtbF9pbnQ2NF9oaTMyKHYpKTtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gcy5jaGFyQ29kZUF0KGkpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCA4KVxuICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMikgPDwgMTYpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSszKSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHMuY2hhckNvZGVBdChpKzIpIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gcy5jaGFyQ29kZUF0KGkrMSkgPDwgODtcbiAgY2FzZSAxOlxuICAgIHcgfD0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlc19hcnIoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHNbaV1cbiAgICAgIHwgKHNbaSsxXSA8PCA4KVxuICAgICAgfCAoc1tpKzJdIDw8IDE2KVxuICAgICAgfCAoc1tpKzNdIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gc1tpKzJdIDw8IDE2O1xuICBjYXNlIDI6IHcgfD0gc1tpKzFdIDw8IDg7XG4gIGNhc2UgMTogdyB8PSBzW2ldO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgZGVmYXVsdDpcbiAgfVxuICBoIF49IGxlbjtcbiAgcmV0dXJuIGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYnl0ZXMoaCwgdikge1xuICBzd2l0Y2ggKHYudCAmIDYpIHtcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzICh2KTtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCwgdi5jKTtcbiAgICBicmVhaztcbiAgY2FzZSAyOiAvKiBBUlJBWSAqL1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLCB2LmMpO1xuICB9XG4gIHJldHVybiBoXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsIHYpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHYpKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2ggbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0LCBjYW1sX2hhc2hfbWl4X3N0cmluZywgY2FtbF9oYXNoX21peF9ieXRlcywgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaGFzaCAoY291bnQsIGxpbWl0LCBzZWVkLCBvYmopIHtcbiAgdmFyIHF1ZXVlLCByZCwgd3IsIHN6LCBudW0sIGgsIHYsIGksIGxlbjtcbiAgc3ogPSBsaW1pdDtcbiAgaWYgKHN6IDwgMCB8fCBzeiA+IDI1Nikgc3ogPSAyNTY7XG4gIG51bSA9IGNvdW50O1xuICBoID0gc2VlZDtcbiAgcXVldWUgPSBbb2JqXTsgcmQgPSAwOyB3ciA9IDE7XG4gIHdoaWxlIChyZCA8IHdyICYmIG51bSA+IDApIHtcbiAgICB2ID0gcXVldWVbcmQrK107XG4gICAgaWYgKHYgJiYgdi5jYW1sX2N1c3RvbSl7XG4gICAgICBpZihjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0gJiYgY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dLmhhc2gpIHtcbiAgICAgICAgdmFyIGhoID0gY2FtbF9jdXN0b21fb3BzW3YuY2FtbF9jdXN0b21dLmhhc2godik7XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludCAoaCwgaGgpO1xuICAgICAgICBudW0gLS07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgc3dpdGNoICh2WzBdKSB7XG4gICAgICBjYXNlIDI0ODpcbiAgICAgICAgLy8gT2JqZWN0XG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2WzJdKTtcbiAgICAgICAgbnVtLS07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgcXVldWVbLS1yZF0gPSB2WzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB0YWcgPSAoKHYubGVuZ3RoIC0gMSkgPDwgMTApIHwgdlswXTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHRhZyk7XG4gICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAod3IgPj0gc3opIGJyZWFrO1xuICAgICAgICAgIHF1ZXVlW3dyKytdID0gdltpXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2J5dGVzKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X3N0cmluZyhoLHYpXG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gKHZ8MCkpIHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2K3YrMSk7XG4gICAgICBudW0tLTtcbiAgICB9IGVsc2UgaWYgKHYgPT09ICt2KSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfZmxvYXQoaCx2KTtcbiAgICAgIG51bS0tO1xuICAgIH1cbiAgfVxuICBoID0gY2FtbF9oYXNoX21peF9maW5hbChoKTtcbiAgcmV0dXJuIGggJiAweDNGRkZGRkZGO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbF90YWdcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX2lzX21sX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsX3RhZyhhKXtcbiAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyhhKSkgcmV0dXJuIDI1MjsgLy8gc3RyaW5nX3RhZ1xuICBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyhhKSkgcmV0dXJuIDEyNTI7IC8vIG9jYW1sIHN0cmluZyAoaWYgZGlmZmVyZW50IGZyb20gYnl0ZXMpXG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBBcnJheSAmJiBhWzBdID09PSAoYVswXT4+PjApICYmIGFbMF0gPD0gMjU1KSB7XG4gICAgLy8gTG9vayBsaWtlIGFuIG9jYW1sIGJsb2NrXG4gICAgdmFyIHRhZyA9IGFbMF0gfCAwO1xuICAgIC8vIGlnbm9yZSBkb3VibGVfYXJyYXlfdGFnIGJlY2F1c2Ugd2UgY2Fubm90IGFjY3VyYXRlbHkgc2V0XG4gICAgLy8gdGhpcyB0YWcgd2hlbiB3ZSBjcmVhdGUgYW4gYXJyYXkgb2YgZmxvYXQuXG4gICAgcmV0dXJuICh0YWcgPT0gMjU0KT8wOnRhZ1xuICB9XG4gIGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBTdHJpbmcpIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiKSByZXR1cm4gMTI1MjA7IC8vIGphdmFzY3JpcHQgc3RyaW5nLCBsaWtlIHN0cmluZ190YWcgKDI1MilcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIE51bWJlcikgcmV0dXJuIDEwMDA7IC8vIGludF90YWcgKHdlIHVzZSBpdCBmb3IgYWxsIG51bWJlcnMpXG4gIGVsc2UgaWYgKGEgJiYgYS5jYW1sX2N1c3RvbSkgcmV0dXJuIDEyNTU7IC8vIGxpa2UgY3VzdG9tX3RhZyAoMjU1KVxuICBlbHNlIGlmIChhICYmIGEuY29tcGFyZSkgcmV0dXJuIDEyNTY7IC8vIGxpa2UgY3VzdG9tX3RhZyAoMjU1KVxuICBlbHNlIGlmICh0eXBlb2YgYSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiAxMjQ3OyAvLyBsaWtlIGNsb3N1cmVfdGFnICgyNDcpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3ltYm9sXCIpIHJldHVybiAxMjUxO1xuICByZXR1cm4gMTAwMTsgLy9vdXRfb2ZfaGVhcF90YWdcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tXG4vL1JlcXVpcmVzOiBjYW1sX2N1c3RvbV9vcHNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShhKXtcbiAgcmV0dXJuIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbYS5jYW1sX2N1c3RvbV0uY29tcGFyZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfbnVtYmVyX2N1c3RvbShudW0sIGN1c3RvbSwgc3dhcCwgdG90YWwpIHtcbiAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oY3VzdG9tKTtcbiAgaWYoY29tcCkge1xuICAgIHZhciB4ID0gKHN3YXAgPiAwKT9jb21wKGN1c3RvbSxudW0sdG90YWwpOmNvbXAobnVtLGN1c3RvbSx0b3RhbCk7XG4gICAgaWYodG90YWwgJiYgeCAhPSB4KSByZXR1cm4gc3dhcDsgLy8gdG90YWwgJiYgbmFuXG4gICAgaWYoK3ggIT0gK3gpIHJldHVybiAreDsgLy8gbmFuXG4gICAgaWYoKHggfCAwKSAhPSAwKSByZXR1cm4gKHggfCAwKTsgLy8gIW5hblxuICB9XG4gIHJldHVybiBzd2FwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWwgKGNvbnN0LCBjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ludF9jb21wYXJlLCBjYW1sX3N0cmluZ19jb21wYXJlLCBjYW1sX2J5dGVzX2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tLCBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NvbXBhcmVfdmFsIChhLCBiLCB0b3RhbCkge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgZm9yKDs7KSB7XG4gICAgaWYgKCEodG90YWwgJiYgYSA9PT0gYikpIHtcbiAgICAgIHZhciB0YWdfYSA9IGNhbWxfY29tcGFyZV92YWxfdGFnKGEpO1xuICAgICAgLy8gZm9yd2FyZF90YWcgP1xuICAgICAgaWYodGFnX2EgPT0gMjUwKSB7IGEgPSBhWzFdOyBjb250aW51ZSB9XG5cbiAgICAgIHZhciB0YWdfYiA9IGNhbWxfY29tcGFyZV92YWxfdGFnKGIpO1xuICAgICAgLy8gZm9yd2FyZF90YWcgP1xuICAgICAgaWYodGFnX2IgPT0gMjUwKSB7IGIgPSBiWzFdOyBjb250aW51ZSB9XG5cbiAgICAgIC8vIHRhZ3MgYXJlIGRpZmZlcmVudFxuICAgICAgaWYodGFnX2EgIT09IHRhZ19iKSB7XG4gICAgICAgIGlmKHRhZ19hID09IDEwMDApIHtcbiAgICAgICAgICBpZih0YWdfYiA9PSAxMjU1KSB7IC8vaW1tZWRpYXRlIGNhbiBjb21wYXJlIGFnYWluc3QgY3VzdG9tXG4gICAgICAgICAgICByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKGEsIGIsIC0xLCB0b3RhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmKHRhZ19iID09IDEwMDApIHtcbiAgICAgICAgICBpZih0YWdfYSA9PSAxMjU1KSB7IC8vaW1tZWRpYXRlIGNhbiBjb21wYXJlIGFnYWluc3QgY3VzdG9tXG4gICAgICAgICAgICByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKGIsIGEsIDEsIHRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRhZ19hIDwgdGFnX2IpPy0xOjE7XG4gICAgICB9XG4gICAgICBzd2l0Y2godGFnX2Epe1xuICAgICAgICAvLyAyNDY6IExhenlfdGFnIGhhbmRsZWQgYmVsbG93XG4gICAgICBjYXNlIDI0NzogLy8gQ2xvc3VyZV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNDg6IC8vIE9iamVjdFxuICAgICAgICB2YXIgeCA9IGNhbWxfaW50X2NvbXBhcmUoYVsyXSwgYlsyXSk7XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ5OiAvLyBJbmZpeFxuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI1MDogLy8gRm9yd2FyZCB0YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBhYm92ZVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IEZvcndhcmRfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MTogLy9BYnN0cmFjdFxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogYWJzdHJhY3QgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTI6IC8vIE9DYW1sIGJ5dGVzXG4gICAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgICAgdmFyIHggPSBjYW1sX2J5dGVzX2NvbXBhcmUoYSwgYik7XG4gICAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTM6IC8vIERvdWJsZV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IERvdWJsZV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjU0OiAvLyBEb3VibGVfYXJyYXlfdGFnXG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW4sIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBEb3VibGVfYXJyYXlfdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjU1OiAvLyBDdXN0b21fdGFnXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgQ3VzdG9tX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjQ3OiAvLyBGdW5jdGlvblxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1NTogLy8gQ3VzdG9tXG4gICAgICAgIHZhciBjb21wID0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGEpO1xuICAgICAgICBpZihjb21wICE9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShiKSl7XG4gICAgICAgICAgcmV0dXJuIChhLmNhbWxfY3VzdG9tPGIuY2FtbF9jdXN0b20pPy0xOjE7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIWNvbXApXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogYWJzdHJhY3QgdmFsdWVcIik7XG4gICAgICAgIHZhciB4ID0gY29tcChhLGIsdG90YWwpO1xuICAgICAgICBpZih4ICE9IHgpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCBVTk9SREVSRURcbiAgICAgICAgICByZXR1cm4gdG90YWw/LTE6eDtcbiAgICAgICAgfVxuICAgICAgICBpZih4ICE9PSAoeHwwKSl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIHJldHVybiB2YWx1ZVxuICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICB9XG4gICAgICAgIGlmICh4ICE9IDApIHJldHVybiAoeCB8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1NjogLy8gY29tcGFyZSBmdW5jdGlvblxuICAgICAgICB2YXIgeCA9IGEuY29tcGFyZShiLHRvdGFsKTtcbiAgICAgICAgaWYoeCAhPSB4KSB7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIFVOT1JERVJFRFxuICAgICAgICAgIHJldHVybiB0b3RhbD8tMTp4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHggIT09ICh4fDApKXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDAwOiAvLyBOdW1iZXJcbiAgICAgICAgYSA9ICthO1xuICAgICAgICBiID0gK2I7XG4gICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICBpZiAoYSAhPSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICBpZiAoYSA9PSBhKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYiA9PSBiKSByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwMDE6IC8vIFRoZSByZXN0XG4gICAgICAgIC8vIEhlcmUgd2UgY2FuIGJlIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAgIC8vIDEuIEphdmFTY3JpcHQgcHJpbWl0aXZlIHR5cGVzXG4gICAgICAgIC8vIDIuIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gcHJpbWl0aXZlIHR5cGVzXG4gICAgICAgIC8vIDMuIEphdmFTY3JpcHQgb2JqZWN0IHRoYW4gY2Fubm90IGJlIGNvZXJjZWQgdG8gcHJpbWl0aXZlIHR5cGVzXG4gICAgICAgIC8vXG4gICAgICAgIC8vICgzKSB3aWxsIHJhaXNlIGEgW1R5cGVFcnJvcl1cbiAgICAgICAgLy8gKDIpIHdpbGwgY29lcmNlIHRvIHByaW1pdGl2ZSB0eXBlcyB1c2luZyBbdmFsdWVPZl0gb3IgW3RvU3RyaW5nXVxuICAgICAgICAvLyAoMikgYW5kICgzKSwgYWZ0ZXIgZXZlbnR1YWwgY29lcmNpb25cbiAgICAgICAgLy8gLSBpZiBhIGFuZCBiIGFyZSBzdHJpbmdzLCBhcHBseSBsZXhpY29ncmFwaGljIGNvbXBhcmlzb25cbiAgICAgICAgLy8gLSBpZiBhIG9yIGIgYXJlIG5vdCBzdHJpbmdzLCBjb252ZXJ0IGEgYW5kIGIgdG8gbnVtYmVyXG4gICAgICAgIC8vICAgYW5kIGFwcGx5IHN0YW5kYXJkIGNvbXBhcmlzb25cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRXhjZXB0aW9uOiBgIT1gIHdpbGwgbm90IGNvZXJjZS9jb252ZXJ0IGlmIGJvdGggYSBhbmQgYiBhcmUgb2JqZWN0c1xuICAgICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgIT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgaWYgKGEgPT0gYSkgcmV0dXJuIDE7XG4gICAgICAgICAgaWYgKGIgPT0gYikgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUxOiAvLyBKYXZhU2NyaXB0IFN5bWJvbCwgbm8gb3JkZXJpbmcuXG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjUyOiAvLyBvY2FtbCBzdHJpbmdzXG4gICAgICAgIHZhciBhID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhhKTtcbiAgICAgICAgdmFyIGIgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGIpO1xuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgICBpZihhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTIwOiAvLyBqYXZhc2NyaXB0IHN0cmluZ3NcbiAgICAgICAgdmFyIGEgPSBhLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBiID0gYi50b1N0cmluZygpO1xuICAgICAgICBpZihhICE9PSBiKSB7XG4gICAgICAgICAgaWYoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgICAgICBpZihhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0NjogLy8gTGF6eV90YWdcbiAgICAgIGNhc2UgMjU0OiAvLyBEb3VibGVfYXJyYXlcbiAgICAgIGRlZmF1bHQ6IC8vIEJsb2NrIHdpdGggb3RoZXIgdGFnXG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIChhLmxlbmd0aCA8IGIubGVuZ3RoKT8tMToxO1xuICAgICAgICBpZiAoYS5sZW5ndGggPiAxKSBzdGFjay5wdXNoKGEsIGIsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YWNrLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcbiAgICB2YXIgaSA9IHN0YWNrLnBvcCgpO1xuICAgIGIgPSBzdGFjay5wb3AoKTtcbiAgICBhID0gc3RhY2sucG9wKCk7XG4gICAgaWYgKGkgKyAxIDwgYS5sZW5ndGgpIHN0YWNrLnB1c2goYSwgYiwgaSArIDEpO1xuICAgIGEgPSBhW2ldO1xuICAgIGIgPSBiW2ldO1xuICB9XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZSAoYSwgYikgeyByZXR1cm4gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdHJ1ZSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaW50X2NvbXBhcmUgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9pbnRfY29tcGFyZSAoYSwgYikge1xuICBpZiAoYSA8IGIpIHJldHVybiAoLTEpOyBpZiAoYSA9PSBiKSByZXR1cm4gMDsgcmV0dXJuIDE7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpID09IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbm90ZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpICE9IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dyZWF0ZXJlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPj0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcnRoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ncmVhdGVydGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPiAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9sZXNzZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzZXF1YWwgKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpIDw9IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3N0aGFuIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfbGVzc3RoYW4gKHgsIHkpIHsgcmV0dXJuICsoY2FtbF9jb21wYXJlX3ZhbCh4LHksZmFsc2UpIDwgMCk7IH1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfQ2FtbGludGVybmFsTW9kX2luaXRfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3dpdGhfYXJnLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX0NhbWxpbnRlcm5hbE1vZF9pbml0X21vZChsb2Msc2hhcGUpIHtcbiAgZnVuY3Rpb24gdW5kZWZfbW9kdWxlIChfeCkge1xuICAgIGNhbWxfcmFpc2Vfd2l0aF9hcmcoY2FtbF9nbG9iYWxfZGF0YS5VbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSwgbG9jKTtcbiAgfVxuICBmdW5jdGlvbiBsb29wIChzaGFwZSxzdHJ1Y3QsaWR4KXtcbiAgICBpZih0eXBlb2Ygc2hhcGUgPT09IFwibnVtYmVyXCIpXG4gICAgICBzd2l0Y2goc2hhcGUpe1xuICAgICAgY2FzZSAwOi8vZnVuY3Rpb25cbiAgICAgICAgc3RydWN0W2lkeF09e2Z1bjp1bmRlZl9tb2R1bGV9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTovL2xhenlcbiAgICAgICAgc3RydWN0W2lkeF09WzI0NiwgdW5kZWZfbW9kdWxlXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0Oi8vY2FzZSAyOi8vY2xhc3NcbiAgICAgICAgc3RydWN0W2lkeF09W107XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgc3dpdGNoKHNoYXBlWzBdKXtcbiAgICAgIGNhc2UgMDovL21vZHVsZVxuICAgICAgICBzdHJ1Y3RbaWR4XSA9IFswXTtcbiAgICAgICAgZm9yKHZhciBpPTE7aTxzaGFwZVsxXS5sZW5ndGg7aSsrKVxuICAgICAgICAgIGxvb3Aoc2hhcGVbMV1baV0sc3RydWN0W2lkeF0saSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDovL2Nhc2UgMTovL1ZhbHVlXG4gICAgICAgIHN0cnVjdFtpZHhdID0gc2hhcGVbMV07XG4gICAgICB9XG4gIH1cbiAgdmFyIHJlcyA9IFtdO1xuICBsb29wKHNoYXBlLHJlcywwKTtcbiAgcmV0dXJuIHJlc1swXVxufVxuLy9Qcm92aWRlczogY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZFxuLy9SZXF1aXJlczogY2FtbF91cGRhdGVfZHVtbXlcbmZ1bmN0aW9uIGNhbWxfQ2FtbGludGVybmFsTW9kX3VwZGF0ZV9tb2Qoc2hhcGUscmVhbCx4KSB7XG4gIGlmKHR5cGVvZiBzaGFwZSA9PT0gXCJudW1iZXJcIilcbiAgICBzd2l0Y2goc2hhcGUpe1xuICAgIGNhc2UgMDovL2Z1bmN0aW9uXG4gICAgY2FzZSAxOi8vbGF6eVxuICAgIGNhc2UgMjovL2NsYXNzXG4gICAgZGVmYXVsdDpcbiAgICAgIGNhbWxfdXBkYXRlX2R1bW15KHJlYWwseCk7XG4gICAgfVxuICBlbHNlXG4gICAgc3dpdGNoKHNoYXBlWzBdKXtcbiAgICBjYXNlIDA6Ly9tb2R1bGVcbiAgICAgIGZvcih2YXIgaT0xO2k8c2hhcGVbMV0ubGVuZ3RoO2krKylcbiAgICAgICAgY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZChzaGFwZVsxXVtpXSxyZWFsW2ldLHhbaV0pO1xuICAgICAgYnJlYWs7XG4gICAgICAvL2Nhc2UgMTovL1ZhbHVlXG4gICAgZGVmYXVsdDpcbiAgICB9O1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF91cGRhdGVfZHVtbXlcbmZ1bmN0aW9uIGNhbWxfdXBkYXRlX2R1bW15ICh4LCB5KSB7XG4gIGlmKCB0eXBlb2YgeT09PVwiZnVuY3Rpb25cIiApIHsgeC5mdW4gPSB5OyByZXR1cm4gMDsgfVxuICBpZiggeS5mdW4gKSB7IHguZnVuID0geS5mdW47IHJldHVybiAwOyB9XG4gIHZhciBpID0geS5sZW5ndGg7IHdoaWxlIChpLS0pIHhbaV0gPSB5W2ldOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfaXNfYmxvY2sgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfaXNfYmxvY2sgKHgpIHsgcmV0dXJuICsoeCBpbnN0YW5jZW9mIEFycmF5KTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9ieXRlcywgY2FtbF9pc19tbF9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfb2JqX3RhZyAoeCkge1xuICBpZiAoKHggaW5zdGFuY2VvZiBBcnJheSkgJiYgeFswXSA9PSAoeFswXSA+Pj4gMCkpXG4gICAgcmV0dXJuIHhbMF1cbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh4KSlcbiAgICByZXR1cm4gMjUyXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKHgpKVxuICAgIHJldHVybiAyNTJcbiAgZWxzZSBpZiAoKHggaW5zdGFuY2VvZiBGdW5jdGlvbikgfHwgdHlwZW9mIHggPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiAyNDdcbiAgZWxzZSBpZiAoeCAmJiB4LmNhbWxfY3VzdG9tKVxuICAgIHJldHVybiAyNTVcbiAgZWxzZVxuICAgIHJldHVybiAxMDAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF90YWcgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3RhZyAoeCwgdGFnKSB7IHhbMF0gPSB0YWc7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX29ial9ibG9jayBjb25zdCAoY29uc3QsY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9ibG9jayAodGFnLCBzaXplKSB7XG4gIHZhciBvID0gbmV3IEFycmF5KHNpemUrMSk7XG4gIG9bMF09dGFnO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzaXplOyBpKyspIG9baV0gPSAwO1xuICByZXR1cm4gbztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfd2l0aF90YWdcbmZ1bmN0aW9uIGNhbWxfb2JqX3dpdGhfdGFnKHRhZyx4KSB7XG4gIHZhciBsID0geC5sZW5ndGg7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gdGFnO1xuICBmb3IodmFyIGkgPSAxOyBpIDwgbDsgaSsrICkgYVtpXSA9IHhbaV07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9kdXAgbXV0YWJsZSAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9kdXAgKHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RydW5jYXRlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9vYmpfdHJ1bmNhdGUgKHgsIHMpIHtcbiAgaWYgKHM8PTAgfHwgcyArIDEgPiB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiT2JqLnRydW5jYXRlXCIpO1xuICBpZiAoeC5sZW5ndGggIT0gcyArIDEpIHgubGVuZ3RoID0gcyArIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9tYWtlX2ZvcndhcmRcbmZ1bmN0aW9uIGNhbWxfb2JqX21ha2VfZm9yd2FyZCAoYix2KSB7XG4gIGJbMF09MjUwO1xuICBiWzFdPXY7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9sYXp5X21ha2VfZm9yd2FyZCAodikgeyByZXR1cm4gWzI1MCwgdl07IH1cblxuLy8vLy8vLy8vLy8vLyBDYW1saW50ZXJuYWxPT1xuLy9Qcm92aWRlczogY2FtbF9nZXRfcHVibGljX21ldGhvZCBjb25zdFxudmFyIGNhbWxfbWV0aG9kX2NhY2hlID0gW107XG5mdW5jdGlvbiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIChvYmosIHRhZywgY2FjaGVpZCkge1xuICB2YXIgbWV0aHMgPSBvYmpbMV07XG4gIHZhciBvZnMgPSBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXTtcbiAgaWYgKG9mcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhcnJheSBpcyBub3Qgc3BhcnNlXG4gICAgZm9yICh2YXIgaSA9IGNhbWxfbWV0aG9kX2NhY2hlLmxlbmd0aDsgaSA8IGNhY2hlaWQ7IGkrKylcbiAgICAgIGNhbWxfbWV0aG9kX2NhY2hlW2ldID0gMDtcbiAgfSBlbHNlIGlmIChtZXRoc1tvZnNdID09PSB0YWcpIHtcbiAgICByZXR1cm4gbWV0aHNbb2ZzIC0gMV07XG4gIH1cbiAgdmFyIGxpID0gMywgaGkgPSBtZXRoc1sxXSAqIDIgKyAxLCBtaTtcbiAgd2hpbGUgKGxpIDwgaGkpIHtcbiAgICBtaSA9ICgobGkraGkpID4+IDEpIHwgMTtcbiAgICBpZiAodGFnIDwgbWV0aHNbbWkrMV0pIGhpID0gbWktMjtcbiAgICBlbHNlIGxpID0gbWk7XG4gIH1cbiAgY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF0gPSBsaSArIDE7XG4gIC8qIHJldHVybiAwIGlmIHRhZyBpcyBub3QgdGhlcmUgKi9cbiAgcmV0dXJuICh0YWcgPT0gbWV0aHNbbGkrMV0gPyBtZXRoc1tsaV0gOiAwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vb19sYXN0X2lkXG52YXIgY2FtbF9vb19sYXN0X2lkID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9zZXRfb29faWRcbi8vUmVxdWlyZXM6IGNhbWxfb29fbGFzdF9pZFxuZnVuY3Rpb24gY2FtbF9zZXRfb29faWQgKGIpIHtcbiAgYlsyXT1jYW1sX29vX2xhc3RfaWQrKztcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZnJlc2hfb29faWRcbi8vUmVxdWlyZXM6IGNhbWxfb29fbGFzdF9pZFxuZnVuY3Rpb24gY2FtbF9mcmVzaF9vb19pZCgpIHtcbiAgcmV0dXJuIGNhbWxfb29fbGFzdF9pZCsrO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9yYXdfZmllbGRcbmZ1bmN0aW9uIGNhbWxfb2JqX3Jhd19maWVsZChvLGkpIHsgcmV0dXJuIG9baSsxXSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF9yYXdfZmllbGRcbmZ1bmN0aW9uIGNhbWxfb2JqX3NldF9yYXdfZmllbGQobyxpLHYpIHsgcmV0dXJuIG9baSsxXSA9IHYgfVxuIiwiLy8vLy8vLy8vIEJJR1NUUklOR1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nKGgsIGJzKSB7XG4gIHJldHVybiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLGJzLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyIG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIoYnMpIHtcbiAgcmV0dXJuIGJzLmRhdGEuYnVmZmVyXG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b190eXBlZF9hcnJheSBtdXRhYmxlXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fdHlwZWRfYXJyYXkoYnMpIHtcbiAgcmV0dXJuIGJzLmRhdGFcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlciBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIoYWIpIHtcbiAgdmFyIHRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYWIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKDEyLCAwLCBbdGEubGVuZ3RoXSwgdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlXG5mdW5jdGlvbiBiaWdzdHJpbmdfb2ZfdHlwZWRfYXJyYXkoYmEpIHtcbiAgdmFyIHRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYmEuYnVmZmVyLCBiYS5ieXRlT2Zmc2V0LCBiYS5sZW5ndGggKiBiYS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX21lbWNtcFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfbWVtY21wKHMxLCBwb3MxLCBzMiwgcG9zMiwgbGVuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBhID0gY2FtbF9iYV9nZXRfMShzMSxwb3MxICsgaSk7XG4gICAgdmFyIGIgPSBjYW1sX2JhX2dldF8xKHMyLHBvczIgKyBpKTtcbiAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEoYmExLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKG9mczEgKyBsZW4gPiBiYTEuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc3ViYXJyYXkob2ZzMSxvZnMxK2xlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxwb3MyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKHBvczEgKyBsZW4gPiBjYW1sX21sX3N0cmluZ19sZW5ndGgoc3RyMSkpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYob2ZzMiArIGxlbiA+IGJhMi5kYXRhLmxlbmd0aCkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBjYW1sX2FycmF5X29mX3N0cmluZyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9hcnJheV9vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYnl0ZXNfdG9fYmEoc3RyMSwgcG9zMSwgYmEyLCBwb3MyLCBsZW4pe1xuICBpZigxMiAhPSBiYTIua2luZClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMiA9IGJhMi5vZmZzZXQocG9zMik7XG4gIGlmKHBvczEgKyBsZW4gPiBjYW1sX21sX2J5dGVzX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMoc3RyMSkuc2xpY2UocG9zMSxwb3MxICsgbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLG9mczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXMoYmExLCBwb3MxLCBieXRlczIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMS5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMxID0gYmExLm9mZnNldChwb3MxKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKHBvczIgKyBsZW4gPiBjYW1sX21sX2J5dGVzX2xlbmd0aChieXRlczIpKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gYmExLmRhdGEuc2xpY2Uob2ZzMSwgb2ZzMStsZW4pO1xuICBjYW1sX2JsaXRfYnl0ZXMoY2FtbF9ieXRlc19vZl9hcnJheShzbGljZSksIDAsIGJ5dGVzMiwgcG9zMiwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXMgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9iYWNrdHJhY2Vfc3RhdHVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVjb3JkX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3QgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZV9zbG90OiBpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVzdG9yZV9yYXdfYmFja3RyYWNlKGV4biwgYnQpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrICgpIHsgcmV0dXJuIFswXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90KCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCIpO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IGxleGluZy5jIDYwNDUgMjAwNC0wMS0wMSAxNjo0Mjo0M1ogZG9saWdleiAkICovXG5cbi8qIFRoZSB0YWJsZS1kcml2ZW4gYXV0b21hdG9uIGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXguICovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9hcnJheShzKSB7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpO1xuICB2YXIgbCA9IHMubGVuZ3RoIC8gMjtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgIGFbaV0gPSAocy5jaGFyQ29kZUF0KDIgKiBpKSB8IChzLmNoYXJDb2RlQXQoMiAqIGkgKyAxKSA8PCA4KSkgPDwgMTYgPj4gMTY7XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5LCBjYW1sX2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuXG4gIGlmICghdGJsLmxleF9kZWZhdWx0KSB7XG4gICAgdGJsLmxleF9iYXNlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV0pO1xuICAgIHRibC5sZXhfYmFja3RyayA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtdKTtcbiAgICB0YmwubGV4X2NoZWNrID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9jaGVja10pO1xuICAgIHRibC5sZXhfdHJhbnMgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zXSk7XG4gICAgdGJsLmxleF9kZWZhdWx0ID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF0pO1xuICB9XG5cbiAgdmFyIGMsIHN0YXRlID0gc3RhcnRfc3RhdGU7XG5cbiAgdmFyIGJ1ZmZlciA9IGNhbWxfYXJyYXlfb2ZfYnl0ZXMobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHJldHVybiAtYmFzZS0xO1xuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogTmV3IGxleGVyIGVuZ2luZSwgd2l0aCBtZW1vcnkgb2YgcG9zaXRpb25zICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX25ld19sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9hcnJheV9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9sZXhfcnVuX21lbShzLCBpLCBtZW0sIGN1cnJfcG9zKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm47XG4gICAgdmFyIHNyYyA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChzcmMgPT0gMHhmZilcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBjdXJyX3BvcztcbiAgICBlbHNlXG4gICAgICBtZW0gW2RzdCArIDFdID0gbWVtIFtzcmMgKyAxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fdGFnKHMsIGksIG1lbSkge1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRzdCA9IHMuY2hhckNvZGVBdChpKTsgaSsrO1xuICAgIGlmIChkc3QgPT0gMHhmZikgcmV0dXJuIDtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IC0xO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbmV3X2xleF9lbmdpbmUodGJsLCBzdGFydF9zdGF0ZSwgbGV4YnVmKSB7XG4gIHZhciBsZXhfYnVmZmVyID0gMjtcbiAgdmFyIGxleF9idWZmZXJfbGVuID0gMztcbiAgdmFyIGxleF9zdGFydF9wb3MgPSA1O1xuICB2YXIgbGV4X2N1cnJfcG9zID0gNjtcbiAgdmFyIGxleF9sYXN0X3BvcyA9IDc7XG4gIHZhciBsZXhfbGFzdF9hY3Rpb24gPSA4O1xuICB2YXIgbGV4X2VvZl9yZWFjaGVkID0gOTtcbiAgdmFyIGxleF9tZW0gPSAxMDtcbiAgdmFyIGxleF9iYXNlID0gMTtcbiAgdmFyIGxleF9iYWNrdHJrID0gMjtcbiAgdmFyIGxleF9kZWZhdWx0ID0gMztcbiAgdmFyIGxleF90cmFucyA9IDQ7XG4gIHZhciBsZXhfY2hlY2sgPSA1O1xuICB2YXIgbGV4X2Jhc2VfY29kZSA9IDY7XG4gIHZhciBsZXhfYmFja3Rya19jb2RlID0gNztcbiAgdmFyIGxleF9kZWZhdWx0X2NvZGUgPSA4O1xuICB2YXIgbGV4X3RyYW5zX2NvZGUgPSA5O1xuICB2YXIgbGV4X2NoZWNrX2NvZGUgPSAxMDtcbiAgdmFyIGxleF9jb2RlID0gMTE7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHRfY29kZSkge1xuICAgIHRibC5sZXhfYmFzZV9jb2RlID0gICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFzZV9jb2RlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrX2NvZGUgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrX2NvZGVdKTtcbiAgICB0YmwubGV4X2NoZWNrX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrX2NvZGVdKTtcbiAgICB0YmwubGV4X3RyYW5zX2NvZGUgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X3RyYW5zX2NvZGVdKTtcbiAgICB0YmwubGV4X2RlZmF1bHRfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRfY29kZV0pO1xuICB9XG4gIGlmICh0YmwubGV4X2NvZGUgPT0gbnVsbCkgdGJsLmxleF9jb2RlID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyh0YmxbbGV4X2NvZGVdKTtcblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFzZV9jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICByZXR1cm4gLWJhc2UtMTtcbiAgICB9XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFja3Rya19jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIHZhciBwc3RhdGUgPSBzdGF0ZSA7XG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBJZiBzb21lIHRyYW5zaXRpb24sIGdldCBhbmQgcGVyZm9ybSBtZW1vcnkgbW92ZXMgKi9cbiAgICAgIHZhciBiYXNlX2NvZGUgPSB0YmwubGV4X2Jhc2VfY29kZVtwc3RhdGVdLCBwY19vZmY7XG4gICAgICBpZiAodGJsLmxleF9jaGVja19jb2RlW2Jhc2VfY29kZSArIGNdID09IHBzdGF0ZSlcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF90cmFuc19jb2RlW2Jhc2VfY29kZSArIGNdO1xuICAgICAgZWxzZVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X2RlZmF1bHRfY29kZVtwc3RhdGVdO1xuICAgICAgaWYgKHBjX29mZiA+IDApXG4gICAgICAgIGNhbWxfbGV4X3J1bl9tZW1cbiAgICAgICh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dLCBsZXhidWZbbGV4X2N1cnJfcG9zXSk7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICovXG4gICAgICBpZiAoYyA9PSAyNTYpIGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID0gMDtcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gQXJyYXlcblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zdWIgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9zdWIgKGEsIGksIGxlbikge1xuICB2YXIgYTIgPSBuZXcgQXJyYXkobGVuKzEpO1xuICBhMlswXT0wO1xuICBmb3IodmFyIGkyID0gMSwgaTE9IGkrMTsgaTIgPD0gbGVuOyBpMisrLGkxKysgKXtcbiAgICBhMltpMl09YVtpMV07XG4gIH1cbiAgcmV0dXJuIGEyO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2FwcGVuZCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2FwcGVuZChhMSwgYTIpIHtcbiAgdmFyIGwxID0gYTEubGVuZ3RoLCBsMiA9IGEyLmxlbmd0aDtcbiAgdmFyIGwgPSBsMStsMi0xXG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gMDtcbiAgdmFyIGkgPSAxLGogPSAxO1xuICBmb3IoO2k8bDE7aSsrKSBhW2ldPWExW2ldO1xuICBmb3IoO2k8bDtpKyssaisrKSBhW2ldPWEyW2pdO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9jb25jYXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9jb25jYXQobCkge1xuICB2YXIgYSA9IFswXTtcbiAgd2hpbGUgKGwgIT09IDApIHtcbiAgICB2YXIgYiA9IGxbMV07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiLmxlbmd0aDsgaSsrKSBhLnB1c2goYltpXSk7XG4gICAgbCA9IGxbMl07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfYmxpdChhMSwgaTEsIGEyLCBpMiwgbGVuKSB7XG4gIGlmIChpMiA8PSBpMSkge1xuICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGxlbjsgaisrKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBqID0gbGVuOyBqID49IDE7IGotLSkgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH07XG4gIHJldHVybiAwO1xufVxuXG4vLy8vLy8vLy8vLy8vIFBlcnZhc2l2ZVxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfc2V0IChhcnJheSwgaW5kZXgsIG5ld3ZhbCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGFycmF5W2luZGV4KzFdPW5ld3ZhbDsgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfZ2V0IChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKChpbmRleCA8IDApIHx8IChpbmRleCA+PSBhcnJheS5sZW5ndGggLSAxKSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXlbaW5kZXgrMV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfZmlsbFxuZnVuY3Rpb24gY2FtbF9hcnJheV9maWxsKGFycmF5LCBvZnMsIGxlbiwgdil7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgYXJyYXlbb2ZzK2krMV0gPSB2O1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NoZWNrX2JvdW5kIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2NoZWNrX2JvdW5kIChhcnJheSwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID4+PiAwID49IGFycmF5Lmxlbmd0aCAtIDEpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfdmVjdCBjb25zdCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9tYWtlX3ZlY3QgKGxlbiwgaW5pdCkge1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IGluaXQ7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21ha2VfZmxvYXRfdmVjdCBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfZmxvYXRfdmVjdChsZW4pe1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gMDtcbiAgcmV0dXJuIGJcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRhcnJheV9jcmVhdGUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9mbG9hdGFycmF5X2NyZWF0ZShsZW4pe1xuICBpZiAobGVuIDwgMCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgbGVuID0gbGVuICsgMSB8IDA7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbik7XG4gIGJbMF09MjU0O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gMDtcbiAgcmV0dXJuIGJcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLyBXZWFrIEFQSSwgYnV0IHdpdGhvdXQgdGhlIHdlYWsgc2VtYW50aWNzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1ZlcnNpb246IDwgNC4wM1xudmFyIGNhbWxfZXBoZV9rZXlfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAzXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG52YXIgY2FtbF9lcGhlX2RhdGFfb2Zmc2V0ID0gMlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3dlYWtfY3JlYXRlIChuKSB7XG4gIGlmIChuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuY3JlYXRlXCIpO1xuICB2YXIgeCA9IFsyNTEsXCJjYW1sX2VwaGVfbGlzdF9oZWFkXCJdO1xuICB4Lmxlbmd0aCA9IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgbjtcbiAgcmV0dXJuIHg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19zZXQoeCwgaSwgdikge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuc2V0XCIpO1xuICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB2O1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXQoeCwgaSkge1xuICBpZihpIDwgMCB8fCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkgPj0geC5sZW5ndGgpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2tleVwiKTtcbiAgcmV0dXJuICh4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSBdPT09dW5kZWZpbmVkKT8wOnhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19nZXRfY29weVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldCxjYW1sX2VwaGVfa2V5X29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19nZXRfY29weSh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfY29weVwiKTtcbiAgdmFyIHkgPSBjYW1sX3dlYWtfZ2V0KHgsIGkpO1xuICBpZiAoeSA9PT0gMCkgcmV0dXJuIHk7XG4gIHZhciB6ID0geVsxXTtcbiAgaWYgKHogaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeildO1xuICByZXR1cm4geTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NoZWNrIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfY2hlY2soeCwgaSkge1xuICBpZih4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0hPT11bmRlZmluZWQgJiYgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldICE9PTApXG4gICAgcmV0dXJuIDE7XG4gIGVsc2VcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgLy8gbWludXMgb25lIGJlY2F1c2UgY2FtbF9hcnJheV9ibGl0IHdvcmtzIG9uIG9jYW1sIGFycmF5XG4gIGNhbWxfYXJyYXlfYmxpdChhMSwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMSAtIDEsXG4gICAgICAgICAgICAgICAgICBhMiwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMiAtIDEsXG4gICAgICAgICAgICAgICAgICBsZW4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NyZWF0ZVxudmFyIGNhbWxfZXBoZV9jcmVhdGUgPSBjYW1sX3dlYWtfY3JlYXRlXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2JsaXRcbnZhciBjYW1sX2VwaGVfYmxpdF9rZXkgPSBjYW1sX3dlYWtfYmxpdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldFxudmFyIGNhbWxfZXBoZV9nZXRfa2V5ID0gY2FtbF93ZWFrX2dldFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbnZhciBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5ID0gY2FtbF93ZWFrX2dldF9jb3B5XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jaGVja1xudmFyIGNhbWxfZXBoZV9jaGVja19rZXkgPSBjYW1sX3dlYWtfY2hlY2tcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHYpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgWzAsIHZdKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgMClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9ibGl0X2RhdGEoc3JjLCBkc3Qpe1xuICBkc3RbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHNyY1tjYW1sX2VwaGVfZGF0YV9vZmZzZXRdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwXG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5KHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IGRhdGE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9kYXRhKHgsIGRhdGEpe1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSB1bmRlZmluZWQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiAxO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfY2hhblxuLy9SZXF1aXJlczogY2FtbF9tZDVfc3RyaW5nLCBjYW1sX3N0cmluZ19vZl9hcnJheSxjYW1sX21sX2NoYW5uZWxzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlLCBjYW1sX2NyZWF0ZV9ieXRlcywgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWQ1X2NoYW4oY2hhbmlkLGxlbil7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgY2hhbl9sZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKGxlbjwwKSBsZW4gPSBjaGFuX2xlbiAtIGNoYW4ub2Zmc2V0O1xuICBpZihjaGFuLm9mZnNldCArIGxlbiA+IGNoYW5fbGVuKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuICByZXR1cm4gY2FtbF9tZDVfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2J5dGVzKGJ1ZiksMCxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX21kNV9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfc3RyaW5nKHMsIG9mcywgbGVuKSB7XG4gIHJldHVybiBjYW1sX21kNV9ieXRlcyhjYW1sX2J5dGVzX29mX3N0cmluZyhzKSxvZnMsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG52YXIgY2FtbF9tZDVfYnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGFkZCAoeCwgeSkgeyByZXR1cm4gKHggKyB5KSB8IDA7IH1cbiAgZnVuY3Rpb24geHgocSxhLGIseCxzLHQpIHtcbiAgICBhID0gYWRkKGFkZChhLCBxKSwgYWRkKHgsIHQpKTtcbiAgICByZXR1cm4gYWRkKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gZmYoYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2coYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gaGgoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTsgfVxuICBmdW5jdGlvbiBpaShhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7IH1cblxuICBmdW5jdGlvbiBtZDUoYnVmZmVyLCBsZW5ndGgpIHtcbiAgICB2YXIgaSA9IGxlbmd0aDtcbiAgICBidWZmZXJbaSA+PiAyXSB8PSAweDgwIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgZm9yIChpID0gKGkgJiB+MHgzKSArIDg7KGkgJiAweDNGKSA8IDYwIDtpICs9IDQpXG4gICAgICBidWZmZXJbKGkgPj4gMikgLSAxXSA9IDA7XG4gICAgYnVmZmVyWyhpID4+IDIpIC0xXSA9IGxlbmd0aCA8PCAzO1xuICAgIGJ1ZmZlcltpID4+IDJdID0gKGxlbmd0aCA+PiAyOSkgJiAweDFGRkZGRkZGO1xuXG4gICAgdmFyIHcgPSBbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3Nl07XG5cbiAgICBmb3IoaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICB2YXIgYSA9IHdbMF0sIGIgPSB3WzFdLCBjID0gd1syXSwgZCA9IHdbM107XG5cbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgMF0sIDcsIDB4RDc2QUE0NzgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAxXSwgMTIsIDB4RThDN0I3NTYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyAyXSwgMTcsIDB4MjQyMDcwREIpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAzXSwgMjIsIDB4QzFCRENFRUUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNywgMHhGNTdDMEZBRik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDVdLCAxMiwgMHg0Nzg3QzYyQSk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNywgMHhBODMwNDYxMyk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDddLCAyMiwgMHhGRDQ2OTUwMSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDhdLCA3LCAweDY5ODA5OEQ4KTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgOV0sIDEyLCAweDhCNDRGN0FGKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE3LCAweEZGRkY1QkIxKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsxMV0sIDIyLCAweDg5NUNEN0JFKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDcsIDB4NkI5MDExMjIpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEzXSwgMTIsIDB4RkQ5ODcxOTMpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE0XSwgMTcsIDB4QTY3OTQzOEUpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE1XSwgMjIsIDB4NDlCNDA4MjEpO1xuXG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDFdLCA1LCAweEY2MUUyNTYyKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgNl0sIDksIDB4QzA0MEIzNDApO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTQsIDB4MjY1RTVBNTEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAwXSwgMjAsIDB4RTlCNkM3QUEpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA1XSwgNSwgMHhENjJGMTA1RCk7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTBdLCA5LCAweDAyNDQxNDUzKTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE0LCAweEQ4QTFFNjgxKTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgNF0sIDIwLCAweEU3RDNGQkM4KTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDUsIDB4MjFFMUNERTYpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE0XSwgOSwgMHhDMzM3MDdENik7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNCwgMHhGNEQ1MEQ4Nyk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDhdLCAyMCwgMHg0NTVBMTRFRCk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA1LCAweEE5RTNFOTA1KTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgMl0sIDksIDB4RkNFRkEzRjgpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTQsIDB4Njc2RjAyRDkpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEyXSwgMjAsIDB4OEQyQTRDOEEpO1xuXG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA0LCAweEZGRkEzOTQyKTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgOF0sIDExLCAweDg3NzFGNjgxKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxMV0sIDE2LCAweDZEOUQ2MTIyKTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsxNF0sIDIzLCAweEZERTUzODBDKTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDQsIDB4QTRCRUVBNDQpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA0XSwgMTEsIDB4NEJERUNGQTkpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTYsIDB4RjZCQjRCNjApO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEwXSwgMjMsIDB4QkVCRkJDNzApO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEzXSwgNCwgMHgyODlCN0VDNik7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDBdLCAxMSwgMHhFQUExMjdGQSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNiwgMHhENEVGMzA4NSk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krIDZdLCAyMywgMHgwNDg4MUQwNSk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDldLCA0LCAweEQ5RDREMDM5KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsxMl0sIDExLCAweEU2REI5OUU1KTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE2LCAweDFGQTI3Q0Y4KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgMl0sIDIzLCAweEM0QUM1NjY1KTtcblxuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNiwgMHhGNDI5MjI0NCk7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krIDddLCAxMCwgMHg0MzJBRkY5Nyk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNSwgMHhBQjk0MjNBNyk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDVdLCAyMSwgMHhGQzkzQTAzOSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krMTJdLCA2LCAweDY1NUI1OUMzKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgM10sIDEwLCAweDhGMENDQzkyKTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE1LCAweEZGRUZGNDdEKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgMV0sIDIxLCAweDg1ODQ1REQxKTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDYsIDB4NkZBODdFNEYpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE1XSwgMTAsIDB4RkUyQ0U2RTApO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA2XSwgMTUsIDB4QTMwMTQzMTQpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEzXSwgMjEsIDB4NEUwODExQTEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNiwgMHhGNzUzN0U4Mik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTFdLCAxMCwgMHhCRDNBRjIzNSk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNSwgMHgyQUQ3RDJCQik7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDldLCAyMSwgMHhFQjg2RDM5MSk7XG5cbiAgICAgIHdbMF0gPSBhZGQoYSwgd1swXSk7XG4gICAgICB3WzFdID0gYWRkKGIsIHdbMV0pO1xuICAgICAgd1syXSA9IGFkZChjLCB3WzJdKTtcbiAgICAgIHdbM10gPSBhZGQoZCwgd1szXSk7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoMTYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICAgIHRbaSAqIDQgKyBqXSA9ICh3W2ldID4+ICg4ICogaikpICYgMHhGRjtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAocywgb2ZzLCBsZW4pIHtcbiAgICAvLyBGSVg6IG1heWJlIHdlIHNob3VsZCBwZXJmb3JtIHRoZSBjb21wdXRhdGlvbiBieSBjaHVuayBvZiA2NCBieXRlc1xuICAgIC8vIGFzIGluIGh0dHA6Ly93d3cubXllcnNkYWlseS5vcmcvam9zZXBoL2phdmFzY3JpcHQvbWQ1LmpzXG4gICAgdmFyIGJ1ZiA9IFtdO1xuICAgIHN3aXRjaCAocy50ICYgNikge1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICAgIGNhc2UgMDogLyogQllURVMgKi9cbiAgICAgIHZhciBiID0gcy5jO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPVxuICAgICAgICAgIGIuY2hhckNvZGVBdChqKSB8IChiLmNoYXJDb2RlQXQoaisxKSA8PCA4KSB8XG4gICAgICAgICAgKGIuY2hhckNvZGVBdChqKzIpIDw8IDE2KSB8IChiLmNoYXJDb2RlQXQoaiszKSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYi5jaGFyQ29kZUF0KGkgKyBvZnMpIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgICB2YXIgYSA9IHMuYztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICAgIHZhciBqID0gaSArIG9mcztcbiAgICAgICAgYnVmW2k+PjJdID0gYVtqXSB8IChhW2orMV0gPDwgOCkgfCAoYVtqKzJdIDw8IDE2KSB8IChhW2orM10gPDwgMjQpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYnVmW2k+PjJdIHw9IGFbaSArIG9mc10gPDwgKDggKiAoaSAmIDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KG1kNShidWYsIGxlbikpO1xuICB9XG59ICgpO1xuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDIwIC0gSHVnbyBIZXV6YXJkXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgLSBTaGFjaGFyIEl0emhha3lcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9vY2FtbC9vY2FtbC9ibG9iLzQuMDcvb3RoZXJsaWJzL3N0ci9zdHJzdHVicy5jXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vanNjb3EvanNjb3EvYmxvYi92OC4xMS9jb3EtanMvanNfc3R1Yi9zdHIuanNcblxuLy9Qcm92aWRlczogcmVfbWF0Y2hcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfanNfZnJvbV9hcnJheSwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2dldFxuXG52YXIgcmVfbWF0Y2ggPSBmdW5jdGlvbigpe1xuICB2YXIgcmVfd29yZF9sZXR0ZXJzID0gW1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4MDAtMHgxRjogbm9uZSAqL1xuICAgIDB4MDAsIDB4MDAsIDB4RkYsIDB4MDMsICAgICAgIC8qIDB4MjAtMHgzRjogZGlnaXRzIDAtOSAqL1xuICAgIDB4RkUsIDB4RkYsIDB4RkYsIDB4ODcsICAgICAgIC8qIDB4NDAtMHg1RjogQSB0byBaLCBfICovXG4gICAgMHhGRSwgMHhGRiwgMHhGRiwgMHgwNywgICAgICAgLyogMHg2MC0weDdGOiBhIHRvIHogKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweDgwLTB4OUY6IG5vbmUgKi9cbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAgICAgICAvKiAweEEwLTB4QkY6IG5vbmUgKi9cbiAgICAweEZGLCAweEZGLCAweDdGLCAweEZGLCAgICAgICAvKiAweEMwLTB4REY6IExhdGluLTEgYWNjZW50ZWQgdXBwZXJjYXNlICovXG4gICAgMHhGRiwgMHhGRiwgMHg3RiwgMHhGRiAgICAgICAgLyogMHhFMC0weEZGOiBMYXRpbi0xIGFjY2VudGVkIGxvd2VyY2FzZSAqL1xuICBdO1xuXG4gIHZhciBvcGNvZGVzID0ge1xuICAgIENIQVI6IDAsIENIQVJOT1JNOiAxLCBTVFJJTkc6IDIsIFNUUklOR05PUk06IDMsIENIQVJDTEFTUzogNCxcbiAgICBCT0w6IDUsIEVPTDogNiwgV09SREJPVU5EQVJZOiA3LFxuICAgIEJFR0dST1VQOiA4LCBFTkRHUk9VUDogOSwgUkVGR1JPVVA6IDEwLFxuICAgIEFDQ0VQVDogMTEsXG4gICAgU0lNUExFT1BUOiAxMiwgU0lNUExFU1RBUjogMTMsIFNJTVBMRVBMVVM6IDE0LFxuICAgIEdPVE86IDE1LCBQVVNIQkFDSzogMTYsIFNFVE1BUks6IDE3LFxuICAgIENIRUNLUFJPR1JFU1M6IDE4XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfd29yZF9sZXR0ZXIoYykge1xuICAgIHJldHVybiAocmVfd29yZF9sZXR0ZXJzWyAgKGMgPj4gMyldID4+IChjICYgNykpICYgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluX2JpdHNldChzLGkpIHtcbiAgICByZXR1cm4gKGNhbWxfc3RyaW5nX2dldChzLChpID4+IDMpKSA+PiAoaSAmIDcpKSAmIDE7XG4gIH1cblxuICBmdW5jdGlvbiByZV9tYXRjaF9pbXBsKHJlLCBzLCBwb3MsIHBhcnRpYWwpIHtcblxuICAgIHZhciBwcm9nICAgICAgICAgID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzFdKSxcbiAgICAgICAgY3Bvb2wgICAgICAgICA9IGNhbWxfanNfZnJvbV9hcnJheShyZVsyXSksXG4gICAgICAgIG5vcm10YWJsZSAgICAgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHJlWzNdKSxcbiAgICAgICAgbnVtZ3JvdXBzICAgICA9IHJlWzRdIHwgMCxcbiAgICAgICAgbnVtcmVnaXN0ZXJzICA9IHJlWzVdIHwgMCxcbiAgICAgICAgc3RhcnRjaGFycyAgICA9IHJlWzZdIHwgMDtcblxuICAgIHZhciBzID0gY2FtbF9hcnJheV9vZl9zdHJpbmcocyk7XG5cbiAgICB2YXIgcGMgPSAwLFxuICAgICAgICBxdWl0ID0gZmFsc2UsXG4gICAgICAgIHN0YWNrID0gW10sXG4gICAgICAgIGdyb3VwcyA9IG5ldyBBcnJheShudW1ncm91cHMpLFxuICAgICAgICByZV9yZWdpc3RlciA9IG5ldyBBcnJheShudW1yZWdpc3RlcnMpO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyl7XG4gICAgICBncm91cHNbaV0gPSB7c3RhcnQ6IC0xLCBlbmQ6LTF9XG4gICAgfVxuICAgIGdyb3Vwc1swXS5zdGFydCA9IHBvcztcblxuICAgIHZhciBiYWNrdHJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHZhciBpdGVtID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGlmIChpdGVtLnVuZG8pIHtcbiAgICAgICAgICBpdGVtLnVuZG8ub2JqW2l0ZW0udW5kby5wcm9wXSA9IGl0ZW0udW5kby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGl0ZW0ucG9zKSB7XG4gICAgICAgICAgcGMgPSBpdGVtLnBvcy5wYztcbiAgICAgICAgICBwb3MgPSBpdGVtLnBvcy50eHQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWl0ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHB1c2ggPSBmdW5jdGlvbihpdGVtKSB7IHN0YWNrLnB1c2goaXRlbSk7IH07XG5cbiAgICB2YXIgYWNjZXB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZ3JvdXBzWzBdLmVuZCA9IHBvcztcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoMSArIGdyb3Vwcy5sZW5ndGgqMik7XG4gICAgICByZXN1bHRbMF0gPSAwOyAvLyB0YWdcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZyA9IGdyb3Vwc1tpXTtcbiAgICAgICAgaWYoZy5zdGFydCA8IDAgfHwgZy5lbmQgPCAwKSB7XG4gICAgICAgICAgZy5zdGFydCA9IGcuZW5kID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0WzIqaSArIDEgXSA9IGcuc3RhcnQ7XG4gICAgICAgIHJlc3VsdFsyKmkgKyAxICsgMSBdID0gZy5lbmQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH07XG5cbiAgICB2YXIgcHJlZml4X21hdGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYocGFydGlhbCkgcmV0dXJuIGFjY2VwdCAoKTtcbiAgICAgIGVsc2UgYmFja3RyYWNrICgpO1xuICAgIH1cblxuICAgIC8qIE1haW4gREZBIGludGVycHJldGVyIGxvb3AgKi9cbiAgICB3aGlsZSAoIXF1aXQpIHtcbiAgICAgIHZhciBvcCA9IHByb2dbcGNdICYgMHhmZixcbiAgICAgICAgICBzYXJnID0gcHJvZ1twY10gPj4gOCxcbiAgICAgICAgICB1YXJnID0gc2FyZyAmIDB4ZmYsXG4gICAgICAgICAgYyA9IHNbcG9zXSxcbiAgICAgICAgICBncm91cDtcblxuICAgICAgcGMrKztcblxuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVI6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGMgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSTk9STTpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IHVhcmcpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TVFJJTkc6XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAoYyA9PT0gYXJnLmNoYXJDb2RlQXQoaSkpXG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgZWxzZSB7IGJhY2t0cmFjaygpOyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNUUklOR05PUk06XG4gICAgICAgIGZvciAodmFyIGFyZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoY3Bvb2xbdWFyZ10pLCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgICBpZiAobm9ybXRhYmxlLmNoYXJDb2RlQXQoYykgPT09IGFyZy5jaGFyQ29kZUF0KGkpKVxuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIGVsc2UgeyBiYWNrdHJhY2soKTsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEFSQ0xBU1M6XG4gICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQk9MOlxuICAgICAgICBpZihwb3MgPiAwICYmIHNbcG9zIC0gMV0gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkVPTDpcbiAgICAgICAgaWYocG9zIDwgcy5sZW5ndGggJiYgc1twb3NdICE9IDEwIC8qIFxcbiAqLykge2JhY2t0cmFjaygpfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5XT1JEQk9VTkRBUlk6XG4gICAgICAgIGlmKHBvcyA9PSAwKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbMF0pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3MgPT09IHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1twb3MgLSAxXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSAhPSBpc193b3JkX2xldHRlcihzW3Bvc10pKSBicmVhaztcbiAgICAgICAgICBiYWNrdHJhY2sgKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQkVHR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOmdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGdyb3VwLnN0YXJ0fX0pO1xuICAgICAgICBncm91cC5zdGFydCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU5ER1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBwdXNoKHt1bmRvOiB7b2JqOiBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6J2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuZW5kfX0pO1xuICAgICAgICBncm91cC5lbmQgPSBwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlJFRkdST1VQOlxuICAgICAgICBncm91cCA9IGdyb3Vwc1t1YXJnXTtcbiAgICAgICAgaWYoZ3JvdXAuc3RhcnQgPCAwIHx8IGdyb3VwLmVuZCA8IDApIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICBmb3IgKHZhciBpID0gZ3JvdXAuc3RhcnQ7IGkgPCBncm91cC5lbmQ7IGkrKyl7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmKHNbaV0gIT0gc1twb3NdKSB7YmFja3RyYWNrICgpOyBicmVha31cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVPUFQ6XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSBwb3MrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0lNUExFU1RBUjpcbiAgICAgICAgd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpXG4gICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVQTFVTOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChpbl9iaXRzZXQoY3Bvb2xbdWFyZ10sIGMpKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgYyA9IHNbKytwb3NdO1xuICAgICAgICAgIH0gd2hpbGUgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkFDQ0VQVDpcbiAgICAgICAgcmV0dXJuIGFjY2VwdCgpO1xuICAgICAgY2FzZSBvcGNvZGVzLkdPVE86XG4gICAgICAgIHBjID0gcGMgKyBzYXJnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5QVVNIQkFDSzpcbiAgICAgICAgcHVzaCh7cG9zOiB7cGM6IHBjICsgc2FyZywgdHh0OiBwb3N9fSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNFVE1BUks6XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6cmVfcmVnaXN0ZXIsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOiB1YXJnLFxuICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlX3JlZ2lzdGVyW3VhcmddfX0pO1xuICAgICAgICByZV9yZWdpc3Rlclt1YXJnXSA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hFQ0tQUk9HUkVTUzpcbiAgICAgICAgaWYgKHJlX3JlZ2lzdGVyW3VhcmddID09PSBwb3MpIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZWNvZGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHJlX21hdGNoX2ltcGw7XG59KCk7XG5cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2ZvcndhcmRcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc2VhcmNoX2ZvcndhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2ZvcndhcmRcIilcbiAgd2hpbGUgKHBvcyA8PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIHtcbiAgICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gICAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgICBwb3MrKztcbiAgfVxuXG4gIHJldHVybiBbMF07ICAvKiBbfHxdIDogaW50IGFycmF5ICovXG59XG5cbi8vUHJvdmlkZXM6IHJlX3NlYXJjaF9iYWNrd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfYmFja3dhcmQocmUsIHMsIHBvcykge1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc2VhcmNoX2JhY2t3YXJkXCIpXG4gIHdoaWxlIChwb3MgPj0gMCkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcy0tO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuXG4vL1Byb3ZpZGVzOiByZV9zdHJpbmdfbWF0Y2hcbi8vUmVxdWlyZXM6IHJlX21hdGNoLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gcmVfc3RyaW5nX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnN0cmluZ19tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMCk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcGFydGlhbF9tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9wYXJ0aWFsX21hdGNoKHJlLHMscG9zKXtcbiAgaWYocG9zIDwgMCB8fCBwb3MgPiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyLnBhcnRpYWxfbWF0Y2hcIilcbiAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDEpO1xuICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICBlbHNlIHJldHVybiBbMF07XG59XG5cbi8vUHJvdmlkZXM6IHJlX3JlcGxhY2VtZW50X3RleHRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vLyBleHRlcm5hbCByZV9yZXBsYWNlbWVudF90ZXh0OiBzdHJpbmcgLT4gaW50IGFycmF5IC0+IHN0cmluZyAtPiBzdHJpbmdcbmZ1bmN0aW9uIHJlX3JlcGxhY2VtZW50X3RleHQocmVwbCxncm91cHMsb3JpZykge1xuICB2YXIgcmVwbCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVwbCk7XG4gIHZhciBsZW4gPSByZXBsLmxlbmd0aDtcbiAgdmFyIG9yaWcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9yaWcpO1xuICB2YXIgcmVzID0gXCJcIjsgLy9yZXN1bHRcbiAgdmFyIG4gPSAwOyAvLyBjdXJyZW50IHBvc2l0aW9uXG4gIHZhciBjdXI7IC8vY3VycmVudCBjaGFyXG4gIHZhciBzdGFydCwgZW5kLCBjO1xuICB3aGlsZShuIDwgbGVuKXtcbiAgICBjdXIgPSByZXBsLmNoYXJBdChuKyspO1xuICAgIGlmKGN1ciAhPSAnXFxcXCcpe1xuICAgICAgcmVzICs9IGN1cjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZihuID09IGxlbikgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiBpbGxlZ2FsIGJhY2tzbGFzaCBzZXF1ZW5jZVwiKTtcbiAgICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgICBzd2l0Y2goY3VyKXtcbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICByZXMgKz0gY3VyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzAnOiBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzpcbiAgICAgIGNhc2UgJzUnOiBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgICAgYyA9ICtjdXI7XG4gICAgICAgIGlmIChjKjIgPj0gZ3JvdXBzLmxlbmd0aCAtIDEgKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiICk7XG4gICAgICAgIHN0YXJ0ID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLGMqMik7XG4gICAgICAgIGVuZCA9IGNhbWxfYXJyYXlfZ2V0KGdyb3VwcywgYyoyICsxKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IC0xKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJTdHIucmVwbGFjZTogcmVmZXJlbmNlIHRvIHVubWF0Y2hlZCBncm91cFwiKTtcbiAgICAgICAgcmVzKz1vcmlnLnNsaWNlKHN0YXJ0LGVuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzICs9ICgnXFxcXCcgICsgY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocmVzKTsgfVxuIiwiLy9UaGUgZm9sbG93aW5nIGFyZSBkZWZpbmVkIGluIENzdHJ1Y3Rcbi8vVGhlcmUgYXJlIGp1c3QgcHJvdmlkZWQgaGVyZSBmb3IgY29tcGF0aWJpbGl0eSByZWFzb25zXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9XZWFrZGVmXG52YXIgY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmcgPSBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBEYW5pZWwgQy4gQnVlbnpsaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5cbmxldCBlcnJfbm9fcHJlZCA9IFwiVSswMDAwIGhhcyBubyBwcmVkZWNlc3NvclwiXG5sZXQgZXJyX25vX3N1Y2MgPSBcIlUrMTBGRkZGIGhhcyBubyBzdWNjZXNzb3JcIlxubGV0IGVycl9ub3Rfc3YgaSA9IGZvcm1hdF9pbnQgXCIlWFwiIGkgXiBcIiBpcyBub3QgYW4gVW5pY29kZSBzY2FsYXIgdmFsdWVcIlxubGV0IGVycl9ub3RfbGF0aW4xIHUgPSBcIlUrXCIgXiBmb3JtYXRfaW50IFwiJTA0WFwiIHUgXiBcIiBpcyBub3QgYSBsYXRpbjEgY2hhcmFjdGVyXCJcblxudHlwZSB0ID0gaW50XG5cbmxldCBtaW4gPSAweDAwMDBcbmxldCBtYXggPSAweDEwRkZGRlxubGV0IGxvX2JvdW5kID0gMHhEN0ZGXG5sZXQgaGlfYm91bmQgPSAweEUwMDBcblxubGV0IGJvbSA9IDB4RkVGRlxubGV0IHJlcCA9IDB4RkZGRFxuXG5sZXQgc3VjYyB1ID1cbiAgaWYgdSA9IGxvX2JvdW5kIHRoZW4gaGlfYm91bmQgZWxzZVxuICBpZiB1ID0gbWF4IHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3N1Y2MgZWxzZVxuICB1ICsgMVxuXG5sZXQgcHJlZCB1ID1cbiAgaWYgdSA9IGhpX2JvdW5kIHRoZW4gbG9fYm91bmQgZWxzZVxuICBpZiB1ID0gbWluIHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3ByZWQgZWxzZVxuICB1IC0gMVxuXG5sZXQgaXNfdmFsaWQgaSA9IChtaW4gPD0gaSAmJiBpIDw9IGxvX2JvdW5kKSB8fCAoaGlfYm91bmQgPD0gaSAmJiBpIDw9IG1heClcbmxldCBvZl9pbnQgaSA9IGlmIGlzX3ZhbGlkIGkgdGhlbiBpIGVsc2UgaW52YWxpZF9hcmcgKGVycl9ub3Rfc3YgaSlcbmV4dGVybmFsIHVuc2FmZV9vZl9pbnQgOiBpbnQgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHRvX2ludCA6IHQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfY2hhciB1ID0gdSA8IDI1NlxubGV0IG9mX2NoYXIgYyA9IENoYXIuY29kZSBjXG5sZXQgdG9fY2hhciB1ID1cbiAgaWYgdSA+IDI1NSB0aGVuIGludmFsaWRfYXJnIChlcnJfbm90X2xhdGluMSB1KSBlbHNlXG4gIENoYXIudW5zYWZlX2NociB1XG5cbmxldCB1bnNhZmVfdG9fY2hhciA9IENoYXIudW5zYWZlX2NoclxuXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5sZXQgaGFzaCA9IHRvX2ludFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDY0XTogNjQtYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDY0IC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF90b19mbG9hdFwiIFwiY2FtbF9pbnQ2NF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyIDogaW50MzIgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnQzMlwiXG5leHRlcm5hbCB0b19pbnQzMiA6IGludDY0IC0+IGludDMyID0gXCIlaW50NjRfdG9faW50MzJcIlxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfbmF0aXZlaW50XCJcbmV4dGVybmFsIHRvX25hdGl2ZWludCA6IGludDY0IC0+IG5hdGl2ZWludCA9IFwiJWludDY0X3RvX25hdGl2ZWludFwiXG5cbmxldCB6ZXJvID0gMExcbmxldCBvbmUgPSAxTFxubGV0IG1pbnVzX29uZSA9IC0xTFxubGV0IHN1Y2MgbiA9IGFkZCBuIDFMXG5sZXQgcHJlZCBuID0gc3ViIG4gMUxcbmxldCBhYnMgbiA9IGlmIG4gPj0gMEwgdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBtaW5faW50ID0gMHg4MDAwMDAwMDAwMDAwMDAwTFxubGV0IG1heF9pbnQgPSAweDdGRkZGRkZGRkZGRkZGRkZMXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFMKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgZnVuIG4gLT5cbiAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgU29tZSAodG9faW50IG4pXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0ID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5cblxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbnR5cGUgdCA9IGludDY0XG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldCB1bnNpZ25lZF9jb21wYXJlIG4gbSA9XG4gIGNvbXBhcmUgKHN1YiBuIG1pbl9pbnQpIChzdWIgbSBtaW5faW50KVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4ICopXG5cbnR5cGUgcG9zaXRpb24gPSB7XG4gIHBvc19mbmFtZSA6IHN0cmluZztcbiAgcG9zX2xudW0gOiBpbnQ7XG4gIHBvc19ib2wgOiBpbnQ7XG4gIHBvc19jbnVtIDogaW50O1xufVxuXG5sZXQgZHVtbXlfcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDA7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IC0xO1xufVxuXG50eXBlIGxleGJ1ZiA9XG4gIHsgcmVmaWxsX2J1ZmYgOiBsZXhidWYgLT4gdW5pdDtcbiAgICBtdXRhYmxlIGxleF9idWZmZXIgOiBieXRlcztcbiAgICBtdXRhYmxlIGxleF9idWZmZXJfbGVuIDogaW50O1xuICAgIG11dGFibGUgbGV4X2Fic19wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2N1cnJfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfYWN0aW9uIDogaW50O1xuICAgIG11dGFibGUgbGV4X2VvZl9yZWFjaGVkIDogYm9vbDtcbiAgICBtdXRhYmxlIGxleF9tZW0gOiBpbnQgYXJyYXk7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcCA6IHBvc2l0aW9uO1xuICAgIG11dGFibGUgbGV4X2N1cnJfcCA6IHBvc2l0aW9uO1xuICB9XG5cbnR5cGUgbGV4X3RhYmxlcyA9XG4gIHsgbGV4X2Jhc2U6IHN0cmluZztcbiAgICBsZXhfYmFja3Ryazogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0OiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrOiBzdHJpbmc7XG4gICAgbGV4X2Jhc2VfY29kZSA6IHN0cmluZztcbiAgICBsZXhfYmFja3Rya19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0X2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NvZGU6IHN0cmluZzt9XG5cbmV4dGVybmFsIGNfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludCA9IFwiY2FtbF9sZXhfZW5naW5lXCJcbmV4dGVybmFsIGNfbmV3X2VuZ2luZSA6IGxleF90YWJsZXMgLT4gaW50IC0+IGxleGJ1ZiAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9uZXdfbGV4X2VuZ2luZVwiXG5cbmxldCBlbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IG5ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX25ld19lbmdpbmUgdGJsIHN0YXRlIGJ1ZiBpblxuICBpZiByZXN1bHQgPj0gMCAmJiBidWYubGV4X2N1cnJfcCAhPSBkdW1teV9wb3MgdGhlbiBiZWdpblxuICAgIGJ1Zi5sZXhfc3RhcnRfcCA8LSBidWYubGV4X2N1cnJfcDtcbiAgICBidWYubGV4X2N1cnJfcCA8LSB7YnVmLmxleF9jdXJyX3BcbiAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBwb3NfY251bSA9IGJ1Zi5sZXhfYWJzX3BvcyArIGJ1Zi5sZXhfY3Vycl9wb3N9O1xuICBlbmQ7XG4gIHJlc3VsdFxuXG5cbmxldCBsZXhfcmVmaWxsIHJlYWRfZnVuIGF1eF9idWZmZXIgbGV4YnVmID1cbiAgbGV0IHJlYWQgPVxuICAgIHJlYWRfZnVuIGF1eF9idWZmZXIgKEJ5dGVzLmxlbmd0aCBhdXhfYnVmZmVyKSBpblxuICBsZXQgbiA9XG4gICAgaWYgcmVhZCA+IDBcbiAgICB0aGVuIHJlYWRcbiAgICBlbHNlIChsZXhidWYubGV4X2VvZl9yZWFjaGVkIDwtIHRydWU7IDApIGluXG4gICgqIEN1cnJlbnQgc3RhdGUgb2YgdGhlIGJ1ZmZlcjpcbiAgICAgICAgPC0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tPlxuICAgICAgICB8ICBqdW5rIHwgICAgICB2YWxpZCBkYXRhICAgICB8ICAganVuayAgICB8XG4gICAgICAgIF4gICAgICAgXiAgICAgICAgICAgICAgICAgICAgIF4gICAgICAgICAgIF5cbiAgICAgICAgMCAgICBzdGFydF9wb3MgICAgICAgICAgICAgYnVmZmVyX2VuZCAgICBCeXRlcy5sZW5ndGggYnVmZmVyXG4gICopXG4gIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG4gPiBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXIgdGhlbiBiZWdpblxuICAgICgqIFRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyICopXG4gICAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgKyBuXG4gICAgICAgPD0gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyXG4gICAgdGhlbiBiZWdpblxuICAgICAgKCogQnV0IHRoZXJlIGlzIGVub3VnaCBzcGFjZSBpZiB3ZSByZWNsYWltIHRoZSBqdW5rIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgIG9mIHRoZSBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIGxleGJ1Zi5sZXhfYnVmZmVyIDBcbiAgICAgICAgICAgICAgICAgIChsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcylcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgKCogV2UgbXVzdCBncm93IHRoZSBidWZmZXIuICBEb3VibGluZyBpdHMgc2l6ZSB3aWxsIHByb3ZpZGUgZW5vdWdoXG4gICAgICAgICBzcGFjZSBzaW5jZSBuIDw9IFN0cmluZy5sZW5ndGggYXV4X2J1ZmZlciA8PSBTdHJpbmcubGVuZ3RoIGJ1ZmZlci5cbiAgICAgICAgIFdhdGNoIG91dCBmb3Igc3RyaW5nIGxlbmd0aCBvdmVyZmxvdywgdGhvdWdoLiAqKVxuICAgICAgbGV0IG5ld2xlbiA9XG4gICAgICAgIG1pbiAoMiAqIEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlcikgU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGluXG4gICAgICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcyArIG4gPiBuZXdsZW5cbiAgICAgIHRoZW4gZmFpbHdpdGggXCJMZXhpbmcubGV4X3JlZmlsbDogY2Fubm90IGdyb3cgYnVmZmVyXCI7XG4gICAgICBsZXQgbmV3YnVmID0gQnl0ZXMuY3JlYXRlIG5ld2xlbiBpblxuICAgICAgKCogQ29weSB0aGUgdmFsaWQgZGF0YSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXcgYnVmZmVyICopXG4gICAgICBCeXRlcy5ibGl0IGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICBuZXdidWYgMFxuICAgICAgICAgICAgICAgICAgKGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zKTtcbiAgICAgIGxleGJ1Zi5sZXhfYnVmZmVyIDwtIG5ld2J1ZlxuICAgIGVuZDtcbiAgICAoKiBSZWFsbG9jYXRpb24gb3Igbm90LCB3ZSBoYXZlIHNoaWZ0ZWQgdGhlIGRhdGEgbGVmdCBieVxuICAgICAgIHN0YXJ0X3BvcyBjaGFyYWN0ZXJzOyB1cGRhdGUgdGhlIHBvc2l0aW9ucyAqKVxuICAgIGxldCBzID0gbGV4YnVmLmxleF9zdGFydF9wb3MgaW5cbiAgICBsZXhidWYubGV4X2Fic19wb3MgPC0gbGV4YnVmLmxleF9hYnNfcG9zICsgcztcbiAgICBsZXhidWYubGV4X2N1cnJfcG9zIDwtIGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIDwtIDA7XG4gICAgbGV4YnVmLmxleF9sYXN0X3BvcyA8LSBsZXhidWYubGV4X2xhc3RfcG9zIC0gcztcbiAgICBsZXhidWYubGV4X2J1ZmZlcl9sZW4gPC0gbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gcyA7XG4gICAgbGV0IHQgPSBsZXhidWYubGV4X21lbSBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC0xIGRvXG4gICAgICBsZXQgdiA9IHQuKGkpIGluXG4gICAgICBpZiB2ID49IDAgdGhlblxuICAgICAgICB0LihpKSA8LSB2LXNcbiAgICBkb25lXG4gIGVuZDtcbiAgKCogVGhlcmUgaXMgbm93IGVub3VnaCBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgKilcbiAgQnl0ZXMuYmxpdCBhdXhfYnVmZmVyIDAgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9idWZmZXJfbGVuIG47XG4gIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gKyBuXG5cbmxldCB6ZXJvX3BvcyA9IHtcbiAgcG9zX2ZuYW1lID0gXCJcIjtcbiAgcG9zX2xudW0gPSAxO1xuICBwb3NfYm9sID0gMDtcbiAgcG9zX2NudW0gPSAwO1xufVxuXG5sZXQgZnJvbV9mdW5jdGlvbiA/KHdpdGhfcG9zaXRpb25zID0gdHJ1ZSkgZiA9XG4gIHsgcmVmaWxsX2J1ZmYgPSBsZXhfcmVmaWxsIGYgKEJ5dGVzLmNyZWF0ZSA1MTIpO1xuICAgIGxleF9idWZmZXIgPSBCeXRlcy5jcmVhdGUgMTAyNDtcbiAgICBsZXhfYnVmZmVyX2xlbiA9IDA7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IGZhbHNlO1xuICAgIGxleF9zdGFydF9wID0gaWYgd2l0aF9wb3NpdGlvbnMgdGhlbiB6ZXJvX3BvcyBlbHNlIGR1bW15X3BvcztcbiAgICBsZXhfY3Vycl9wID0gaWYgd2l0aF9wb3NpdGlvbnMgdGhlbiB6ZXJvX3BvcyBlbHNlIGR1bW15X3BvcztcbiAgfVxuXG5sZXQgZnJvbV9jaGFubmVsID93aXRoX3Bvc2l0aW9ucyBpYyA9XG4gIGZyb21fZnVuY3Rpb24gP3dpdGhfcG9zaXRpb25zIChmdW4gYnVmIG4gLT4gaW5wdXQgaWMgYnVmIDAgbilcblxubGV0IGZyb21fc3RyaW5nID8od2l0aF9wb3NpdGlvbnMgPSB0cnVlKSBzID1cbiAgeyByZWZpbGxfYnVmZiA9IChmdW4gbGV4YnVmIC0+IGxleGJ1Zi5sZXhfZW9mX3JlYWNoZWQgPC0gdHJ1ZSk7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLm9mX3N0cmluZyBzOyAoKiBoYXZlIHRvIG1ha2UgYSBjb3B5IGZvciBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHVuc2FmZS1zdHJpbmcgbW9kZSAqKVxuICAgIGxleF9idWZmZXJfbGVuID0gU3RyaW5nLmxlbmd0aCBzO1xuICAgIGxleF9hYnNfcG9zID0gMDtcbiAgICBsZXhfc3RhcnRfcG9zID0gMDtcbiAgICBsZXhfY3Vycl9wb3MgPSAwO1xuICAgIGxleF9sYXN0X3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfYWN0aW9uID0gMDtcbiAgICBsZXhfbWVtID0gW3x8XTtcbiAgICBsZXhfZW9mX3JlYWNoZWQgPSB0cnVlO1xuICAgIGxleF9zdGFydF9wID0gaWYgd2l0aF9wb3NpdGlvbnMgdGhlbiB6ZXJvX3BvcyBlbHNlIGR1bW15X3BvcztcbiAgICBsZXhfY3Vycl9wID0gaWYgd2l0aF9wb3NpdGlvbnMgdGhlbiB6ZXJvX3BvcyBlbHNlIGR1bW15X3BvcztcbiAgfVxuXG5sZXQgc2V0X3Bvc2l0aW9uIGxleGJ1ZiBwb3NpdGlvbiA9XG4gIGxleGJ1Zi5sZXhfY3Vycl9wICA8LSB7cG9zaXRpb24gd2l0aCBwb3NfZm5hbWUgPSBsZXhidWYubGV4X2N1cnJfcC5wb3NfZm5hbWV9O1xuICBsZXhidWYubGV4X2Fic19wb3MgPC0gcG9zaXRpb24ucG9zX2NudW1cblxubGV0IHNldF9maWxlbmFtZSBsZXhidWYgZm5hbWUgPVxuICBsZXhidWYubGV4X2N1cnJfcCA8LSB7bGV4YnVmLmxleF9jdXJyX3Agd2l0aCBwb3NfZm5hbWUgPSBmbmFtZX1cblxubGV0IHdpdGhfcG9zaXRpb25zIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3Bvc1xuXG5sZXQgbGV4ZW1lIGxleGJ1ZiA9XG4gIGxldCBsZW4gPSBsZXhidWYubGV4X2N1cnJfcG9zIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3BvcyBsZW5cblxubGV0IHN1Yl9sZXhlbWUgbGV4YnVmIGkxIGkyID1cbiAgbGV0IGxlbiA9IGkyLWkxIGluXG4gIEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuXG5cbmxldCBzdWJfbGV4ZW1lX29wdCBsZXhidWYgaTEgaTIgPVxuICBpZiBpMSA+PSAwIHRoZW4gYmVnaW5cbiAgICBsZXQgbGVuID0gaTItaTEgaW5cbiAgICBTb21lIChCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGkxIGxlbilcbiAgZW5kIGVsc2UgYmVnaW5cbiAgICBOb25lXG4gIGVuZFxuXG5sZXQgc3ViX2xleGVtZV9jaGFyIGxleGJ1ZiBpID0gQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGlcblxubGV0IHN1Yl9sZXhlbWVfY2hhcl9vcHQgbGV4YnVmIGkgPVxuICBpZiBpID49IDAgdGhlblxuICAgIFNvbWUgKEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciBpKVxuICBlbHNlXG4gICAgTm9uZVxuXG5cbmxldCBsZXhlbWVfY2hhciBsZXhidWYgaSA9XG4gIEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciAobGV4YnVmLmxleF9zdGFydF9wb3MgKyBpKVxuXG5sZXQgbGV4ZW1lX3N0YXJ0IGxleGJ1ZiA9IGxleGJ1Zi5sZXhfc3RhcnRfcC5wb3NfY251bVxubGV0IGxleGVtZV9lbmQgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3AucG9zX2NudW1cblxubGV0IGxleGVtZV9zdGFydF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfc3RhcnRfcFxubGV0IGxleGVtZV9lbmRfcCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcFxuXG5sZXQgbmV3X2xpbmUgbGV4YnVmID1cbiAgbGV0IGxjcCA9IGxleGJ1Zi5sZXhfY3Vycl9wIGluXG4gIGlmIGxjcCAhPSBkdW1teV9wb3MgdGhlblxuICAgIGxleGJ1Zi5sZXhfY3Vycl9wIDwtXG4gICAgICB7IGxjcCB3aXRoXG4gICAgICAgIHBvc19sbnVtID0gbGNwLnBvc19sbnVtICsgMTtcbiAgICAgICAgcG9zX2JvbCA9IGxjcC5wb3NfY251bTtcbiAgICAgIH1cblxuXG5cbigqIERpc2NhcmQgZGF0YSBsZWZ0IGluIGxleGVyIGJ1ZmZlci4gKilcblxubGV0IGZsdXNoX2lucHV0IGxiID1cbiAgbGIubGV4X2N1cnJfcG9zIDwtIDA7XG4gIGxiLmxleF9hYnNfcG9zIDwtIDA7XG4gIGxldCBsY3AgPSBsYi5sZXhfY3Vycl9wIGluXG4gIGlmIGxjcCAhPSBkdW1teV9wb3MgdGhlblxuICAgIGxiLmxleF9jdXJyX3AgPC0ge3plcm9fcG9zIHdpdGggcG9zX2ZuYW1lID0gbGNwLnBvc19mbmFtZX07XG4gIGxiLmxleF9idWZmZXJfbGVuIDwtIDA7XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgQmVub2l0IFZhdWdvbiwgRU5TVEEgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICgqIFRvb2xzIHRvIG1hbmlwdWxhdGUgc2Nhbm5pbmcgc2V0IG9mIGNoYXJzIChzZWUgJVsuLi5dKSAqKVxuXG50eXBlIG11dGFibGVfY2hhcl9zZXQgPSBieXRlc1xuXG4oKiBDcmVhdGUgYSBmcmVzaCwgZW1wdHksIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgY3JlYXRlX2NoYXJfc2V0ICgpID0gQnl0ZXMubWFrZSAzMiAnXFwwMDAnXG5cbigqIEFkZCBhIGNoYXIgaW4gYSBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIEJ5dGVzLnNldCBjaGFyX3NldCBzdHJfaW5kXG4gICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoQnl0ZXMuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxvciBtYXNrKSlcblxubGV0IGZyZWV6ZV9jaGFyX3NldCBjaGFyX3NldCA9XG4gIEJ5dGVzLnRvX3N0cmluZyBjaGFyX3NldFxuXG4oKiBDb21wdXRlIHRoZSBjb21wbGVtZW50IG9mIGEgY2hhciBzZXQuICopXG5sZXQgcmV2X2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgbGV0IGNoYXJfc2V0JyA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICBmb3IgaSA9IDAgdG8gMzEgZG9cbiAgICBCeXRlcy5zZXQgY2hhcl9zZXQnIGlcbiAgICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgaSkgbHhvciAweEZGKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgY2hhcl9zZXQnXG5cbigqIFJldHVybiB0cnVlIGlmIGEgYGMnIGlzIGluIGBjaGFyX3NldCcuICopXG5sZXQgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICAoaW50X29mX2NoYXIgKFN0cmluZy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbGFuZCBtYXNrKSA8PiAwXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAoKiBJZ25vcmVkIHBhcmFtIGNvbnZlcnNpb24gKilcblxuKCogR0FEVCB1c2VkIHRvIGFic3RyYWN0IGFuIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVyLiAqKVxuKCogU2VlIHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdC4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmIgPSBQYXJhbV9mb3JtYXRfRUJCIDpcbiAgICAoJ3ggLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhcmFtX2Zvcm1hdF9lYmJcblxuKCogQ29tcHV0ZSBhIHBhZGRpbmcgYXNzb2NpYXRlZCB0byBhIHBhZF9vcHRpb24gKHNlZSBcIiVfNDJkXCIpLiAqKVxubGV0IHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3BhZGRpbmdcbiAgfCBTb21lIHdpZHRoIC0+IExpdF9wYWRkaW5nIChSaWdodCwgd2lkdGgpXG5cbigqIENvbXB1dGUgYSBwcmVjaXNpb24gYXNzb2NpYXRlZCB0byBhIHByZWNfb3B0aW9uIChzZWUgXCIlXy40MmZcIikuICopXG5sZXQgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCA9IG1hdGNoIHByZWNfb3B0IHdpdGhcbiAgfCBOb25lIC0+IE5vX3ByZWNpc2lvblxuICB8IFNvbWUgbmRlYyAtPiBMaXRfcHJlY2lzaW9uIG5kZWNcblxuKCogVHVybiBhbiBpZ25vcmVkIHBhcmFtIGludG8gaXRzIGVxdWl2YWxlbnQgbm90LWlnbm9yZWQgZm9ybWF0IG5vZGUuICopXG4oKiBVc2VkIGZvciBmb3JtYXQgcHJldHR5LXByaW50aW5nIGFuZCBTY2FuZi4gKilcbmxldCBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT4gKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhcmFtX2Zvcm1hdF9lYmIgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDaGFyIGZtdClcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfY2hhciBmbXQpXG4gIHwgSWdub3JlZF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFN0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX3N0cmluZyAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2ludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoSW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50MzIgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQzMiAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKE5hdGl2ZWludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDY0IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50NjQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9mbG9hdCAocGFkX29wdCwgcHJlY19vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZsb2F0ICgoRmxvYXRfZmxhZ18sIEZsb2F0X2YpLFxuICAgICAgICAgICAgICBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfYm9vbCBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQm9vbCAocGFkX29mX3BhZF9vcHQgcGFkX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX3JlYWRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFJlYWRlciBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX25leHRfY2hhciBmbXQpXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGVzICopXG5cbnR5cGUgKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuID1cbiAgfCBBY2Nfb3Blbl90YWcgb2YgKCdiLCAnYykgYWNjXG4gIHwgQWNjX29wZW5fYm94IG9mICgnYiwgJ2MpIGFjY1xuXG4oKiBSZXZlcnNlZCBsaXN0IG9mIHByaW50aW5nIGF0b21zLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHByaW50ZiBhcmd1bWVudHMuICopXG5hbmQgKCdiLCAnYykgYWNjID1cbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgb2YgKCdiLCAnYykgYWNjICogZm9ybWF0dGluZ19saXRcbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW5cbiAgICAgICgqIFNwZWNpYWwgZm10dGluZyAoYm94KSAqKVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIExpdGVyYWwgc3RyaW5nICopXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogTGl0ZXJhbCBjaGFyICopXG4gIHwgQWNjX2RhdGFfc3RyaW5nICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogR2VuZXJhdGVkIHN0cmluZyAqKVxuICB8IEFjY19kYXRhX2NoYXIgICAgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIEdlbmVyYXRlZCBjaGFyICopXG4gIHwgQWNjX2RlbGF5ICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAqICgnYiAtPiAnYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIERlbGF5ZWQgcHJpbnRpbmcgKCVhLCAldCkgKilcbiAgfCBBY2NfZmx1c2ggICAgICAgICAgb2YgKCdiLCAnYykgYWNjICAgICAgICAgICAgICAoKiBGbHVzaCAqKVxuICB8IEFjY19pbnZhbGlkX2FyZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmdcbiAgICAgICgqIFJhaXNlIEludmFsaWRfYXJndW1lbnQgbXNnICopXG4gIHwgRW5kX29mX2FjY1xuXG4oKiBMaXN0IG9mIGhldGVyb2dlbmVvdXMgdmFsdWVzLiAqKVxuKCogVXNlZCB0byBhY2N1bXVsYXRlIHNjYW5mIGNhbGxiYWNrIGFyZ3VtZW50cy4gKilcbnR5cGUgKCdhLCAnYikgaGV0ZXJfbGlzdCA9XG4gIHwgQ29ucyA6ICdjICogKCdhLCAnYikgaGV0ZXJfbGlzdCAtPiAoJ2MgLT4gJ2EsICdiKSBoZXRlcl9saXN0XG4gIHwgTmlsIDogKCdiLCAnYikgaGV0ZXJfbGlzdFxuXG4oKiBFeGlzdGVudGlhbCBCbGFjayBCb3hlcy4gKilcbigqIFVzZWQgdG8gYWJzdHJhY3Qgc29tZSBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlcnMuICopXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZGRpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9IFBhZGRpbmdfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdHR5LiAqKVxuKCogU2VlIHRoZSB0eXBlX3BhZHByZWMgZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9IFBhZHByZWNfZm10dHlfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3opIHByZWNpc2lvbiAqICgneiwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkZGluZ19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmIgPSBQYWRkaW5nX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHBhZGRpbmcgKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3ByZWNpc2lvbl9mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYiA9IFByZWNpc2lvbl9mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYiA9IFBhZHByZWNfZm10X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdwIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgncCwgJ2IsICdjLCAnZSwgJ2YpIHBhZHByZWNfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCB0aGUgJ2EgYW5kICdkIHBhcmFtZXRlcnMgb2YgYW4gZm10LiAqKVxuKCogT3V0cHV0IHR5cGUgb2YgdGhlIGZvcm1hdCBwYXJzaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmIgPSBGbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ2IsICdjLCAnZSwgJ2YpIGZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfZm9ybWF0X2dlbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgPSBGbXRfZm10dHlfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdCAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXR0eSAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiID0gRm10dHlfZm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXR0eSAqXG4gICAgICgneCwgJ2IsICdjLCAneSwgJ2UsICdmKSBmbXRfZm10dHlfZWJiIC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9mbXRfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBmbXR0eSB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgZm9ybWF0IHR5cGVzLiAqKVxudHlwZSBmbXR0eV9lYmIgPSBGbXR0eV9FQkIgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT4gZm10dHlfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwYWRkaW5nIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwYWRkaW5ncy4gKilcbnR5cGUgcGFkZGluZ19lYmIgPSBQYWRkaW5nX0VCQiA6ICgnYSwgJ2IpIHBhZGRpbmcgLT4gcGFkZGluZ19lYmJcblxuKCogQWJzdHJhY3QgYWxsIHByZWNpc2lvbiB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcHJlY2lzaW9ucy4gKilcbnR5cGUgcHJlY2lzaW9uX2ViYiA9IFByZWNpc2lvbl9FQkIgOiAoJ2EsICdiKSBwcmVjaXNpb24gLT4gcHJlY2lzaW9uX2ViYlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnN0YW50cyAqKVxuXG4oKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgZmxvYXQgcHJpbnRpbmcuICopXG5sZXQgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24gZmNvbnYgPVxuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HIHwgRmxvYXRfaCB8IEZsb2F0X0hcbiAgfCBGbG9hdF9DRiAtPiAtNlxuICAoKiBGb3IgJWggJUggYW5kICUjRiBmb3JtYXRzLCBhIG5lZ2F0aXZlIHByZWNpc2lvbiBtZWFucyBcImFzIG1hbnkgZGlnaXRzIGFzXG4gICAgIG5lY2Vzc2FyeVwiLiAgRm9yIHRoZSBvdGhlciBGUCBmb3JtYXRzLCB3ZSB0YWtlIHRoZSBhYnNvbHV0ZSB2YWx1ZVxuICAgICBvZiB0aGUgcHJlY2lzaW9uLCBoZW5jZSA2IGRpZ2l0cyBieSBkZWZhdWx0LiAqKVxuICB8IEZsb2F0X0YgLT4gMTJcbiAgKCogRGVmYXVsdCBwcmVjaXNpb24gZm9yIE9DYW1sIGZsb2F0IHByaW50aW5nICglRikuICopXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRXh0ZXJuYWxzICopXG5cbmV4dGVybmFsIGZvcm1hdF9mbG9hdDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfaW50MzI6IHN0cmluZyAtPiBpbnQzMiAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50MzJfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9uYXRpdmVpbnQ6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDY0OiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5leHRlcm5hbCBoZXhzdHJpbmdfb2ZfZmxvYXQ6IGZsb2F0IC0+IGludCAtPiBjaGFyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXRcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgKCogVG9vbHMgdG8gcHJldHR5LXByaW50IGZvcm1hdHMgKilcblxuKCogVHlwZSBvZiBleHRlbnNpYmxlIGNoYXJhY3RlciBidWZmZXJzLiAqKVxudHlwZSBidWZmZXIgPSB7XG4gIG11dGFibGUgaW5kIDogaW50O1xuICBtdXRhYmxlIGJ5dGVzIDogYnl0ZXM7XG59XG5cbigqIENyZWF0ZSBhIGZyZXNoIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY3JlYXRlIGluaXRfc2l6ZSA9IHsgaW5kID0gMDsgYnl0ZXMgPSBCeXRlcy5jcmVhdGUgaW5pdF9zaXplIH1cblxuKCogQ2hlY2sgc2l6ZSBvZiB0aGUgYnVmZmVyIGFuZCBncm93IGl0IGlmIG5lZWRlZC4gKilcbmxldCBidWZmZXJfY2hlY2tfc2l6ZSBidWYgb3ZlcmhlYWQgPVxuICBsZXQgbGVuID0gQnl0ZXMubGVuZ3RoIGJ1Zi5ieXRlcyBpblxuICBsZXQgbWluX2xlbiA9IGJ1Zi5pbmQgKyBvdmVyaGVhZCBpblxuICBpZiBtaW5fbGVuID4gbGVuIHRoZW4gKFxuICAgIGxldCBuZXdfbGVuID0gbWF4IChsZW4gKiAyKSBtaW5fbGVuIGluXG4gICAgbGV0IG5ld19zdHIgPSBCeXRlcy5jcmVhdGUgbmV3X2xlbiBpblxuICAgIEJ5dGVzLmJsaXQgYnVmLmJ5dGVzIDAgbmV3X3N0ciAwIGxlbjtcbiAgICBidWYuYnl0ZXMgPC0gbmV3X3N0cjtcbiAgKVxuXG4oKiBBZGQgdGhlIGNoYXJhY3RlciBgYycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX2NoYXIgYnVmIGMgPVxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgMTtcbiAgQnl0ZXMuc2V0IGJ1Zi5ieXRlcyBidWYuaW5kIGM7XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIDFcblxuKCogQWRkIHRoZSBzdHJpbmcgYHMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHMgPVxuICBsZXQgc3RyX2xlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBidWZmZXJfY2hlY2tfc2l6ZSBidWYgc3RyX2xlbjtcbiAgU3RyaW5nLmJsaXQgcyAwIGJ1Zi5ieXRlcyBidWYuaW5kIHN0cl9sZW47XG4gIGJ1Zi5pbmQgPC0gYnVmLmluZCArIHN0cl9sZW5cblxuKCogR2V0IHRoZSBjb250ZW50IG9mIHRoZSBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NvbnRlbnRzIGJ1ZiA9XG4gIEJ5dGVzLnN1Yl9zdHJpbmcgYnVmLmJ5dGVzIDAgYnVmLmluZFxuXG4oKioqKVxuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgY29udmVyc2lvbiB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfaWNvbnYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X2QgfCBJbnRfcGQgfCBJbnRfc2QgfCBJbnRfQ2QgLT4gJ2QnIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2lcbiAgfCBJbnRfQ2kgLT4gJ2knIHwgSW50X3ggfCBJbnRfQ3ggLT4gJ3gnIHwgSW50X1ggfCBJbnRfQ1ggLT4gJ1gnIHwgSW50X29cbiAgfCBJbnRfQ28gLT4gJ28nIHwgSW50X3UgfCBJbnRfQ3UgLT4gJ3UnXG5cbigqIENvbnZlcnQgYSBmbG9hdCBjb252ZXJzaW9uIHRvIGNoYXIuICopXG4oKiBgY0YnIHdpbGwgYmUgJ0YnIGZvciBkaXNwbGF5aW5nIGZvcm1hdCBhbmQgJ2cnIHRvIGNhbGwgbGliYyBwcmludGYgKilcbmxldCBjaGFyX29mX2Zjb252ID8oY0Y9J0YnKSBmY29udiA9IG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZiAtPiAnZicgfCBGbG9hdF9lIC0+ICdlJ1xuICB8IEZsb2F0X0UgLT4gJ0UnIHwgRmxvYXRfZyAtPiAnZydcbiAgfCBGbG9hdF9HIC0+ICdHJyB8IEZsb2F0X0YgLT4gY0ZcbiAgfCBGbG9hdF9oIC0+ICdoJyB8IEZsb2F0X0ggLT4gJ0gnXG4gIHwgRmxvYXRfQ0YgLT4gJ0YnXG5cblxuKCogQ29udmVydCBhIHNjYW5uaW5nIGNvdW50ZXIgdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2NvdW50ZXIgY291bnRlciA9IG1hdGNoIGNvdW50ZXIgd2l0aFxuICB8IExpbmVfY291bnRlciAgLT4gJ2wnXG4gIHwgQ2hhcl9jb3VudGVyICAtPiAnbidcbiAgfCBUb2tlbl9jb3VudGVyIC0+ICdOJ1xuXG4oKioqKVxuXG4oKiBQcmludCBhIGNoYXJfc2V0IGluIGEgYnVmZmVyIHdpdGggdGhlIE9DYW1sIGZvcm1hdCBsZXhpY2FsIGNvbnZlbnRpb24uICopXG5sZXQgYnByaW50X2NoYXJfc2V0IGJ1ZiBjaGFyX3NldCA9XG4gIGxldCByZWMgcHJpbnRfc3RhcnQgc2V0ID1cbiAgICBsZXQgaXNfYWxvbmUgYyA9XG4gICAgICBsZXQgYmVmb3JlLCBhZnRlciA9IENoYXIuKGNociAoY29kZSBjIC0gMSksIGNociAoY29kZSBjICsgMSkpIGluXG4gICAgICBpc19pbl9jaGFyX3NldCBzZXQgY1xuICAgICAgJiYgbm90IChpc19pbl9jaGFyX3NldCBzZXQgYmVmb3JlICYmIGlzX2luX2NoYXJfc2V0IHNldCBhZnRlcikgaW5cbiAgICBpZiBpc19hbG9uZSAnXScgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICddJztcbiAgICBwcmludF9vdXQgc2V0IDE7XG4gICAgaWYgaXNfYWxvbmUgJy0nIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLSc7XG4gIGFuZCBwcmludF9vdXQgc2V0IGkgPVxuICAgIGlmIGkgPCAyNTYgdGhlblxuICAgICAgaWYgaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBpKSB0aGVuIHByaW50X2ZpcnN0IHNldCBpXG4gICAgICBlbHNlIHByaW50X291dCBzZXQgKGkgKyAxKVxuICBhbmQgcHJpbnRfZmlyc3Qgc2V0IGkgPVxuICAgIG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgIHwgJ1xcMjU1JyAtPiBwcmludF9jaGFyIGJ1ZiAyNTU7XG4gICAgfCAnXScgfCAnLScgLT4gcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgIHwgXyAtPiBwcmludF9zZWNvbmQgc2V0IChpICsgMSk7XG4gIGFuZCBwcmludF9zZWNvbmQgc2V0IGkgPVxuICAgIGlmIGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaSkgdGhlblxuICAgICAgbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgICB8ICdcXDI1NScgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgMjU0O1xuICAgICAgICBwcmludF9jaGFyIGJ1ZiAyNTU7XG4gICAgICB8ICddJyB8ICctJyB3aGVuIG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCAoaSArIDEpKSkgLT5cbiAgICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgICAgcHJpbnRfb3V0IHNldCAoaSArIDEpO1xuICAgICAgfCBfIHdoZW4gbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IChpICsgMSkpKSAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgICBwcmludF9jaGFyIGJ1ZiBpO1xuICAgICAgICBwcmludF9vdXQgc2V0IChpICsgMik7XG4gICAgICB8IF8gLT5cbiAgICAgICAgcHJpbnRfaW4gc2V0IChpIC0gMSkgKGkgKyAyKTtcbiAgICBlbHNlIChcbiAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgKVxuICBhbmQgcHJpbnRfaW4gc2V0IGkgaiA9XG4gICAgaWYgaiA9IDI1NiB8fCBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgaikpIHRoZW4gKFxuICAgICAgcHJpbnRfY2hhciBidWYgaTtcbiAgICAgIHByaW50X2NoYXIgYnVmIChpbnRfb2ZfY2hhciAnLScpO1xuICAgICAgcHJpbnRfY2hhciBidWYgKGogLSAxKTtcbiAgICAgIGlmIGogPCAyNTYgdGhlbiBwcmludF9vdXQgc2V0IChqICsgMSk7XG4gICAgKSBlbHNlXG4gICAgICBwcmludF9pbiBzZXQgaSAoaiArIDEpO1xuICBhbmQgcHJpbnRfY2hhciBidWYgaSA9IG1hdGNoIGNoYXJfb2ZfaW50IGkgd2l0aFxuICAgIHwgJyUnIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgICB8ICdAJyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQCc7XG4gICAgfCBjICAgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBpblxuICBidWZmZXJfYWRkX2NoYXIgYnVmICdbJztcbiAgcHJpbnRfc3RhcnQgKFxuICAgIGlmIGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0ICdcXDAwMCdcbiAgICB0aGVuICggYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXic7IHJldl9jaGFyX3NldCBjaGFyX3NldCApXG4gICAgZWxzZSBjaGFyX3NldFxuICApO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmICddJ1xuXG4oKioqKVxuXG4oKiBQcmludCBhIHBhZHR5IGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcGFkdHkgYnVmIHBhZHR5ID0gbWF0Y2ggcGFkdHkgd2l0aFxuICB8IExlZnQgIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJy0nXG4gIHwgUmlnaHQgLT4gKClcbiAgfCBaZXJvcyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcwJ1xuXG4oKiBQcmludCB0aGUgJ18nIG9mIGFuIGlnbm9yZWQgZmxhZyBpZiBuZWVkZWQuICopXG5sZXQgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWcgPVxuICBpZiBpZ25fZmxhZyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ18nXG5cbigqKiopXG5cbmxldCBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIHdpZHRoIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyB3aWR0aClcblxuKCoqKilcblxuKCogUHJpbnQgcGFkZGluZyBpbiBhIGJ1ZmZlciB3aXRoIHRoZSBmb3JtYXQtbGlrZSBzeW50YXguICopXG5sZXQgYnByaW50X3BhZGRpbmcgOiB0eXBlIGEgYiAuIGJ1ZmZlciAtPiAoYSwgYikgcGFkZGluZyAtPiB1bml0ID1cbmZ1biBidWYgcGFkIC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAtPiAoKVxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgbikgLT5cbiAgICBicHJpbnRfcGFkdHkgYnVmIHBhZHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBuKTtcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSAtPlxuICAgIGJwcmludF9wYWR0eSBidWYgcGFkdHk7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKidcblxuKCogUHJpbnQgcHJlY2lzaW9uIGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcHJlY2lzaW9uIDogdHlwZSBhIGIgLiBidWZmZXIgLT4gKGEsIGIpIHByZWNpc2lvbiAtPiB1bml0ID1cbiAgZnVuIGJ1ZiBwcmVjIC0+IG1hdGNoIHByZWMgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiAtPiAoKVxuICB8IExpdF9wcmVjaXNpb24gbiAtPlxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy4nO1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBuKTtcbiAgfCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiLipcIlxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnLCAnICcgb3IgJyMnIGFzc29jaWF0ZWQgdG8gYW4gaW50IGNvbnZlcnNpb24uICopXG5sZXQgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9wZCB8IEludF9waSAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcrJ1xuICB8IEludF9zZCB8IEludF9zaSAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEludF9DeCB8IEludF9DWCB8IEludF9DbyB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnIydcbiAgfCBJbnRfZCB8IEludF9pIHwgSW50X3ggfCBJbnRfWCB8IEludF9vIHwgSW50X3UgLT4gKClcblxuKCogUHJpbnQgYW4gY29tcGxldGUgaW50IGZvcm1hdCBpbiBhIGJ1ZmZlciAoZXg6IFwiJTMuKmRcIikuICopXG5sZXQgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqIFByaW50IGEgY29tcGxldGUgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjIGMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKioqKVxuXG4oKiBQcmludCB0aGUgb3B0aW9uYWwgJysnLCAnICcgYW5kL29yICcjJyBhc3NvY2lhdGVkIHRvIGEgZmxvYXQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnYgPVxuICBiZWdpbiBtYXRjaCBmc3QgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ZsYWdfcCAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcrJ1xuICB8IEZsb2F0X2ZsYWdfcyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcgJ1xuICB8IEZsb2F0X2ZsYWdfIC0+ICgpIGVuZDtcbiAgbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9DRiAtPiBidWZmZXJfYWRkX2NoYXIgYnVmICcjJ1xuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HXG4gIHwgRmxvYXRfRiB8IEZsb2F0X2ggfCBGbG9hdF9IIC0+ICgpXG5cbigqIFByaW50IGEgY29tcGxldGUgZmxvYXQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlKyouM2ZcIikuICopXG5sZXQgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9mY29udiBmY29udilcblxuKCogQ29tcHV0ZSB0aGUgbGl0ZXJhbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBGb3JtYXR0aW5nX2xpdC4gKilcbigqIFVzZWQgYnkgUHJpbnRmIGFuZCBTY2FuZiB3aGVyZSBmb3JtYXR0aW5nIGlzIG5vdCBpbnRlcnByZXRlZC4gKilcbmxldCBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQgPSBtYXRjaCBmb3JtYXR0aW5nX2xpdCB3aXRoXG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgLT4gXCJAXVwiXG4gIHwgQ2xvc2VfdGFnICAgICAgICAgICAgLT4gXCJAfVwiXG4gIHwgQnJlYWsgKHN0ciwgXywgXykgICAgLT4gc3RyXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgLT4gXCJAP1wiXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgLT4gXCJAXFxuXCJcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAtPiBcIkAuXCJcbiAgfCBNYWdpY19zaXplIChzdHIsIF8pICAtPiBzdHJcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAtPiBcIkBAXCJcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAtPiBcIkAlXCJcbiAgfCBTY2FuX2luZGljIGMgLT4gXCJAXCIgXiAoU3RyaW5nLm1ha2UgMSBjKVxuXG4oKioqKVxuXG4oKiBQcmludCBhIGxpdGVyYWwgY2hhciBpbiBhIGJ1ZmZlciwgZXNjYXBlICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyID0gbWF0Y2ggY2hyIHdpdGhcbiAgfCAnJScgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSVcIlxuICB8IF8gLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjaHJcblxuKCogUHJpbnQgYSBsaXRlcmFsIHN0cmluZyBpbiBhIGJ1ZmZlciwgZXNjYXBlIGFsbCAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyID1cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc3RyIC0gMSBkb1xuICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIHN0ci5baV1cbiAgZG9uZVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgcHJldHR5LXByaW50aW5nICopXG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IHR5cGUgKGFuIGZtdHR5KSBpbiBhIGJ1ZmZlci4gKilcbmxldCByZWMgYnByaW50X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCAuXG4gICAgYnVmZmVyIC0+IChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gdW5pdCA9XG5mdW4gYnVmIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlY1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFN0cmluZ190eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVzXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWlcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQzMl90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVuaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGbG9hdF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlZlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEJvb2xfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVCXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWFcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBUaGV0YV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIldFwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFueV90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiU/XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgUmVhZGVyX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlX3JcIjtcbiAgICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHksIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXtcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJX1cIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5LCBfLCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUoXCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEVuZF9vZl9mbXR0eSAtPiAoKVxuXG4oKioqKVxuXG5sZXQgcmVjIGludF9vZl9jdXN0b21fYXJpdHkgOiB0eXBlIGEgYiBjIC5cbiAgKGEsIGIsIGMpIGN1c3RvbV9hcml0eSAtPiBpbnQgPVxuICBmdW5jdGlvblxuICB8IEN1c3RvbV96ZXJvIC0+IDBcbiAgfCBDdXN0b21fc3VjYyB4IC0+IDEgKyBpbnRfb2ZfY3VzdG9tX2FyaXR5IHhcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2ZtdCBidWYgZm10ID1cbiAgbGV0IHJlYyBmbXRpdGVyIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGJvb2wgLT4gdW5pdCA9XG4gIGZ1biBmbXQgaWduX2ZsYWcgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnUyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdsJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnTCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0InO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYSc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3QnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgZm9yIF9pID0gMSB0byBpbnRfb2ZfY3VzdG9tX2FyaXR5IGFyaXR5IGRvXG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnPyc7XG4gICAgICBkb25lO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgUmVhZGVyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3InOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlIVwiO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNocjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAneyc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnfSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJygnO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyknO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHdpZHRoX29wdDsgYnByaW50X2NoYXJfc2V0IGJ1ZiBjaGFyX3NldDtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2NvdW50ZXIgY291bnRlcik7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIFwiMGNcIjsgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgICBmbXRpdGVyIGZtdCcgdHJ1ZTtcblxuICAgIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCk7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGZtdGluZ19nZW4gd2l0aFxuICAgICAgfCBPcGVuX3RhZyAoRm9ybWF0IChfLCBzdHIpKSAtPlxuICAgICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCJAe1wiOyBidWZmZXJfYWRkX3N0cmluZyBidWYgc3RyXG4gICAgICB8IE9wZW5fYm94IChGb3JtYXQgKF8sIHN0cikpIC0+XG4gICAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIkBbXCI7IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzdHJcbiAgICAgIGVuZDtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRW5kX29mX2Zvcm1hdCAtPiAoKVxuXG4gIGluIGZtdGl0ZXIgZm10IGZhbHNlXG5cbigqKiopXG5cbigqIENvbnZlcnQgYSBmb3JtYXQgdG8gc3RyaW5nLiAqKVxubGV0IHN0cmluZ19vZl9mbXQgZm10ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdCBidWYgZm10O1xuICBidWZmZXJfY29udGVudHMgYnVmXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIFR5cGUgZXh0cmFjdGlvbiAqKVxuXG50eXBlIChfLCBfKSBlcSA9IFJlZmwgOiAoJ2EsICdhKSBlcVxuXG4oKiBJbnZhcmlhbnQ6IHRoaXMgZnVuY3Rpb24gaXMgdGhlIGlkZW50aXR5IG9uIHZhbHVlcy5cblxuICAgSW4gcGFydGljdWxhciwgaWYgKHR5MSwgdHkyKSBoYXZlIGVxdWFsIHZhbHVlcywgdGhlblxuICAgKHRyYW5zIChzeW1tIHR5MSkgdHkyKSByZXNwZWN0cyB0aGUgJ3RyYW5zJyBwcmVjb25kaXRpb24uICopXG5sZXQgcmVjIHN5bW0gOiB0eXBlIGExIGIxIGMxIGQxIGUxIGYxIGEyIGIyIGMyIGQyIGUyIGYyIC5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10dHlfcmVsXG49IGZ1bmN0aW9uXG4gIHwgQ2hhcl90eSByZXN0IC0+IENoYXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnRfdHkgcmVzdCAtPiBJbnRfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQzMl90eSByZXN0IC0+IEludDMyX3R5IChzeW1tIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPiBJbnQ2NF90eSAoc3ltbSByZXN0KVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IE5hdGl2ZWludF90eSAoc3ltbSByZXN0KVxuICB8IEZsb2F0X3R5IHJlc3QgLT4gRmxvYXRfdHkgKHN5bW0gcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT4gQm9vbF90eSAoc3ltbSByZXN0KVxuICB8IFN0cmluZ190eSByZXN0IC0+IFN0cmluZ190eSAoc3ltbSByZXN0KVxuICB8IFRoZXRhX3R5IHJlc3QgLT4gVGhldGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbHBoYV90eSByZXN0IC0+IEFscGhhX3R5IChzeW1tIHJlc3QpXG4gIHwgQW55X3R5IHJlc3QgLT4gQW55X3R5IChzeW1tIHJlc3QpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT4gUmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPiBJZ25vcmVkX3JlYWRlcl90eSAoc3ltbSByZXN0KVxuICB8IEZvcm1hdF9hcmdfdHkgKHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MiwgdHkxLCBzeW1tIHJlc3QpXG4gIHwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuXG5sZXQgcmVjIGZtdHR5X3JlbF9kZXQgOiB0eXBlIGExIGIgYyBkMSBlMSBmMSBhMiBkMiBlMiBmMiAuXG4gIChhMSwgYiwgYywgZDEsIGUxLCBmMSxcbiAgIGEyLCBiLCBjLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWwgLT5cbiAgICAoKGYxLCBmMikgZXEgLT4gKGExLCBhMikgZXEpXG4gICogKChhMSwgYTIpIGVxIC0+IChmMSwgZjIpIGVxKVxuICAqICgoZTEsIGUyKSBlcSAtPiAoZDEsIGQyKSBlcSlcbiAgKiAoKGQxLCBkMikgZXEgLT4gKGUxLCBlMikgZXEpXG49IGZ1bmN0aW9uXG4gIHwgRW5kX29mX2ZtdHR5IC0+XG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpXG4gIHwgQ2hhcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFN0cmluZ190eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGbG9hdF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEJvb2xfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcblxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbnlfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGRlIFJlZmwgaW4gUmVmbClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IEZvcm1hdF9hcmdfdHkgKF90eSwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGxldCBhZywgZ2EsIGRqLCBqZCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIGxldCBSZWZsID0gYWcgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBnYSBSZWZsIGluIGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBlZCBSZWZsIGluIGxldCBSZWZsID0gZGogUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBqZCBSZWZsIGluIGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuXG4oKiBQcmVjb25kaXRpb246IHdlIGFzc3VtZSB0aGF0IHRoZSB0d28gZm10dHlfcmVsIGFyZ3VtZW50cyBoYXZlIGVxdWFsXG4gICB2YWx1ZXMgKGF0IHBvc3NpYmx5IGRpc3RpbmN0IHR5cGVzKTsgdGhpcyBpbnZhcmlhbnQgY29tZXMgZnJvbSB0aGUgd2F5XG4gICBmbXR0eV9yZWwgd2l0bmVzc2VzIGFyZSBwcm9kdWNlZCBieSB0aGUgdHlwZS1jaGVja2VyXG5cbiAgIFRoZSBjb2RlIGJlbG93IHVzZXMgKGFzc2VydCBmYWxzZSkgd2hlbiB0aGlzIGFzc3VtcHRpb24gaXMgYnJva2VuLiBUaGVcbiAgIGNvZGUgcGF0dGVybiBpcyB0aGUgZm9sbG93aW5nOlxuXG4gICAgIHwgRm9vIHgsIEZvbyB5IC0+XG4gICAgICAgKCogY2FzZSB3aGVyZSBpbmRlZWQgYm90aCB2YWx1ZXNcbiAgICAgICAgICBzdGFydCB3aXRoIGNvbnN0cnVjdG9yIEZvbyAqKVxuICAgICB8IEZvbyBfLCBfXG4gICAgIHwgXywgRm9vIF8gLT5cbiAgICAgICAoKiBkaWZmZXJlbnQgaGVhZCBjb25zdHJ1Y3RvcnM6IGJyb2tlbiBwcmVjb25kaXRpb24gKilcbiAgICAgICBhc3NlcnQgZmFsc2VcbiopXG5hbmQgdHJhbnMgOiB0eXBlXG4gIGExIGIxIGMxIGQxIGUxIGYxXG4gIGEyIGIyIGMyIGQyIGUyIGYyXG4gIGEzIGIzIGMzIGQzIGUzIGYzXG4uXG4gICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbi0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLFxuICAgIGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5X3JlbFxuLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG49IGZ1biB0eTEgdHkyIC0+IG1hdGNoIHR5MSwgdHkyIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QxLCBDaGFyX3R5IHJlc3QyIC0+IENoYXJfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IFN0cmluZ190eSByZXN0MSwgU3RyaW5nX3R5IHJlc3QyIC0+IFN0cmluZ190eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQm9vbF90eSByZXN0MSwgQm9vbF90eSByZXN0MiAtPiBCb29sX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnRfdHkgcmVzdDEsIEludF90eSByZXN0MiAtPiBJbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludDMyX3R5IHJlc3QxLCBJbnQzMl90eSByZXN0MiAtPiBJbnQzMl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50NjRfdHkgcmVzdDEsIEludDY0X3R5IHJlc3QyIC0+IEludDY0X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdDEsIE5hdGl2ZWludF90eSByZXN0MiAtPiBOYXRpdmVpbnRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZsb2F0X3R5IHJlc3QxLCBGbG9hdF90eSByZXN0MiAtPiBGbG9hdF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG5cbiAgfCBBbHBoYV90eSByZXN0MSwgQWxwaGFfdHkgcmVzdDIgLT4gQWxwaGFfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFscGhhX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgQWxwaGFfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFRoZXRhX3R5IHJlc3QxLCBUaGV0YV90eSByZXN0MiAtPiBUaGV0YV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgVGhldGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBUaGV0YV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgQW55X3R5IHJlc3QxLCBBbnlfdHkgcmVzdDIgLT4gQW55X3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBBbnlfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbnlfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IFJlYWRlcl90eSByZXN0MSwgUmVhZGVyX3R5IHJlc3QyIC0+IFJlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgUmVhZGVyX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgUmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MSwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdDIgLT5cbiAgICBJZ25vcmVkX3JlYWRlcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBJZ25vcmVkX3JlYWRlcl90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X2FyZ190eSAodHkxLCByZXN0MSksIEZvcm1hdF9hcmdfdHkgKHR5MiwgcmVzdDIpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHJhbnMgdHkxIHR5MiwgdHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRm9ybWF0X2FyZ190eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9hcmdfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxMSwgdHkxMiwgcmVzdDEpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyMSwgdHkyMiwgcmVzdDIpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxMikgdHkyMSBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHR5IGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTIyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfc3Vic3RfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBGb3JtYXRfc3Vic3RfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IEVuZF9vZl9mbXR0eSwgRW5kX29mX2ZtdHR5IC0+IEVuZF9vZl9mbXR0eVxuICB8IEVuZF9vZl9mbXR0eSwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBFbmRfb2ZfZm10dHkgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCByZWMgZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmb3JtYXR0aW5nX2dlbiAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdCwgXykpIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogRXh0cmFjdCB0aGUgdHlwZSByZXByZXNlbnRhdGlvbiAoYW4gZm10dHkpIG9mIGEgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2ZtdCA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcblxuICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnRfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoSW50MzJfdHkgdHlfcmVzdCkgaW5cbiAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCBwcmVjX3R5XG4gIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKE5hdGl2ZWludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQ2NF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChGbG9hdF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcblxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IENhbWxfY2hhciByZXN0ICAgICAgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEJvb2wgKHBhZCwgcmVzdCkgICAgICAgICAgIC0+XG4gICAgICBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IHBhZCAoQm9vbF90eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IEFscGhhIHJlc3QgICAgICAgICAgICAgICAgIC0+IEFscGhhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAtPiBUaGV0YV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgICAgLT4gZm10dHlfb2ZfY3VzdG9tIGFyaXR5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBSZWFkZXIgcmVzdCAgICAgICAgICAgICAgICAtPiBSZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRm9ybWF0X2FyZyAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgdHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eSwgdHksIGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRmx1c2ggcmVzdCAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPiBTdHJpbmdfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+IEludF90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgLT4gZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2xpdCAoXywgcmVzdCkgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAgLT5cbiAgICBjb25jYXRfZm10dHkgKGZtdHR5X29mX2Zvcm1hdHRpbmdfZ2VuIGZtdGluZ19nZW4pIChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgIC0+IEVuZF9vZl9mbXR0eVxuXG5hbmQgZm10dHlfb2ZfY3VzdG9tIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAoeSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGFyaXR5IGZtdHR5IC0+IG1hdGNoIGFyaXR5IHdpdGhcbiAgfCBDdXN0b21femVybyAtPiBmbXR0eVxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+IEFueV90eSAoZm10dHlfb2ZfY3VzdG9tIGFyaXR5IGZtdHR5KVxuXG4oKiBFeHRyYWN0IHRoZSBmbXR0eSBvZiBhbiBpZ25vcmVkIHBhcmFtZXRlciBmb2xsb3dlZCBieSB0aGUgcmVzdCBvZlxuICAgdGhlIGZvcm1hdC4gKilcbmFuZCBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDMyIChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zsb2F0IChfLCBfKSAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoXywgZm10dHkpIC0+IGNvbmNhdF9mbXR0eSBmbXR0eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3JlYWRlciAgICAgICAgICAgICAgICAgIC0+IElnbm9yZWRfcmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcGFkZGluZyBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpzXCIpLiAqKVxuYW5kIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcGFkZGluZyBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcGFkZGluZyBfIC0+IEludF90eSBmbXR0eVxuXG4oKiBBZGQgYW4gSW50X3R5IG5vZGUgaWYgcHJlY2lzaW9uIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlLipmXCIpLiopXG5hbmQgZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoeCwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuICBmdW4gcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjIHdpdGhcbiAgICB8IE5vX3ByZWNpc2lvbiAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3ByZWNpc2lvbiBfIC0+IGZtdHR5XG4gICAgfCBBcmdfcHJlY2lzaW9uICAgLT4gSW50X3R5IGZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGluZyAqKVxuXG4oKiBFeGNlcHRpb24gcmFpc2VkIHdoZW4gYSBmb3JtYXQgZG9lcyBub3QgbWF0Y2ggYSBnaXZlbiBmb3JtYXQgdHlwZS4gKilcbmV4Y2VwdGlvbiBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBwYWRkaW5nLiAqKVxuKCogVGFrZSBhbiBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgdGhlIGludGVnZXIgc2hvdWxkIGJlIGtlcHQgYXMgYXJndW1lbnQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZGRpbmcgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkZGluZ19mbXR0eV9lYmIgPVxuZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQsIGZtdHR5IHdpdGhcbiAgfCBOb19wYWRkaW5nLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChOb19wYWRkaW5nLCBmbXR0eSlcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBfIC0+IFBhZGRpbmdfZm10dHlfRUJCIChMaXRfcGFkZGluZyAocGFkdHksdyksZm10dHkpXG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEludF90eSByZXN0IC0+IFBhZGRpbmdfZm10dHlfRUJCIChBcmdfcGFkZGluZyBwYWR0eSxyZXN0KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBDb252ZXJ0IGEgKHVwYWRkaW5nLCB1cHJlY2lzaW9uKSB0byBhIChwYWRkaW5nLCBwcmVjaXNpb24pLiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiBuZWVkZWQuICopXG4oKiBSYWlzZSBUeXBlX21pc21hdGNoIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCB0eXBlX3BhZHByZWMgOiB0eXBlIGEgYiBjIGQgZSBmIHggeSB6IC5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHopIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFkcHJlY19mbXR0eV9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMsIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBOb19wcmVjaXNpb24sIHJlc3QpXG4gIHwgTGl0X3ByZWNpc2lvbiBwLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIExpdF9wcmVjaXNpb24gcCwgcmVzdClcbiAgfCBBcmdfcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBJbnRfdHkgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBBcmdfcHJlY2lzaW9uLCByZXN0KVxuICB8IF8sIFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFR5cGUgYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogSWYgdHlwaW5nIHN1Y2NlZWQsIGdlbmVyYXRlIGEgY29weSBvZiB0aGUgZm9ybWF0IHdpdGggdGhlIHNhbWVcbiAgICB0eXBlIHBhcmFtZXRlcnMgYXMgdGhlIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgcmVjIHR5cGVfZm9ybWF0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IHdpdGhcbiAgfCBGbXRfZm10dHlfRUJCIChmbXQnLCBFbmRfb2ZfZm10dHkpIC0+IGZtdCdcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0X2dlbiA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIGZtdCwgZm10dHkgd2l0aFxuICB8IENoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBDYW1sX2NoYXIgZm10X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDYW1sX2NoYXIgZm10JywgZm10dHknKVxuICB8IFN0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChTdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBDYW1sX3N0cmluZyAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChDYW1sX3N0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDMyX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQ2NF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEZsb2F0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBCb29sIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBCb29sX3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChCb29sIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgRmx1c2ggZm10X3Jlc3QsIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRmx1c2ggZm10JywgZm10dHknKVxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZ19saXRlcmFsIChzdHIsIGZtdCcpLCBmbXR0eScpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChDaGFyX2xpdGVyYWwgKGNociwgZm10JyksIGZtdHR5JylcblxuICB8IEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1Yl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eScsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1Yl9mbXR0eTEsIF9zdWJfZm10dHkyLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5MSkgdGhlblxuICAgICAgcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9XG4gICAgICB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgKGVyYXNlX3JlbCBmbXR0eV9yZXN0KVxuICAgIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkxLCBmbXQnKSwgZm10dHknKVxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgQWxwaGEgZm10X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQWxwaGEgZm10JywgZm10dHknKVxuICB8IFRoZXRhIGZtdF9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFRoZXRhIGZtdCcsIGZtdHR5JylcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZ19nZW4sIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfZm9ybWF0dGluZ19nZW4gZm9ybWF0dGluZ19nZW4gZm10X3Jlc3QgZm10dHlfcmVzdFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBSZWFkZXIgZm10X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFJlYWRlciBmbXQnLCBmbXR0eScpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10X3Jlc3QpLCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQnKSwgZm10dHknKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10JyksIGZtdHR5JylcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtIGlnbiByZXN0IGZtdHR5X3Jlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QgLT4gRm10X2ZtdHR5X0VCQiAoRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdClcblxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYTEgYTMgYjEgYjMgYzEgYzMgZDEgZDMgZTEgZTIgZTMgZjEgZjIgZjMgLlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmb3JtYXR0aW5nX2dlbiAtPlxuICAgIChmMSwgYjEsIGMxLCBlMSwgZTIsIGYyKSBmbXQgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHkgLT5cbiAgICAoYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10X2ZtdHR5X2ViYiA9XG5mdW4gZm9ybWF0dGluZ19nZW4gZm10MCBmbXR0eTAgLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcbiAgfCBPcGVuX2JveCAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG5cbigqIFR5cGUgYW4gSWdub3JlZF9wYXJhbSBub2RlIGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW0gOiB0eXBlIHAgcSB4IHkgeiB0IHUgdiBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIHksIHosIHQsIHEsIHApIGlnbm9yZWQgLT5cbiAgICAocCwgeSwgeiwgcSwgdSwgdikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGlnbiBmbXQgZm10dHkgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3N0cmluZyBfICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludCBfICAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDMyIF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX25hdGl2ZWludCBfICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2ludDY0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zsb2F0IF8gICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICBhcyBpZ24nIC0+IHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgaWduJyBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIChJZ25vcmVkX2Zvcm1hdF9hcmcgKHBhZF9vcHQsIHN1Yl9mbXR0eSkpIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eScsIEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eSBmbXQgZm10dHkgaW5cbiAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10JyksXG4gICAgICAgICAgICAgICAgICAgZm10dHknKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+IChcbiAgICBtYXRjaCBmbXR0eSB3aXRoXG4gICAgfCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9yZWFkZXIsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSA6IHR5cGUgYTEgYTIgYjEgYjIgYzEgYzIgZDEgZDIgZTEgZTIgZjEgZjIgLlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZDIsIGEyKSBpZ25vcmVkIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdCAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eSAtPlxuICAgIChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBpZ24gZm10IGZtdHR5IC0+XG4gIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSBpblxuICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChpZ24sIGZtdCcpLCBmbXR0eScpXG5cbigqIFR5cGluZyBvZiB0aGUgY29tcGxleCBjYXNlOiBcIiVfKC4uLiUpXCIuICopXG5hbmQgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gOiB0eXBlIHcgeCB5IHogcCBzIHQgdSBhIGIgYyBkIGUgZiAuXG4gICAgKHcsIHgsIHksIHosIHMsIHApIGZtdHR5IC0+XG4gICAgKHAsIHgsIHksIHMsIHQsIHUpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlfZm10X2ViYiA9XG5mdW4gc3ViX2ZtdHR5IGZtdCBmbXR0eSAtPiBtYXRjaCBzdWJfZm10dHksIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFN0cmluZ190eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQzMl90eSBzdWJfZm10dHlfcmVzdCwgSW50MzJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCwgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKE5hdGl2ZWludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDY0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBGbG9hdF90eSBzdWJfZm10dHlfcmVzdCwgRmxvYXRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QsIEJvb2xfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQm9vbF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIEFscGhhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBUaGV0YV90eSBzdWJfZm10dHlfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFJlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHksIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViMl9mbXR0eSA8PiBGbXR0eV9FQkIgc3ViMl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIHN1Yl9mbXR0eV9yZXN0JyksIGZtdCcpXG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5LCAgc3ViMl9mbXR0eSwgIHN1Yl9mbXR0eV9yZXN0KSxcbiAgICBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICAoKiBUT0RPIGRlZmluZSBGbXR0eV9yZWxfRUJCIHRvIHJlbW92ZSB0aG9zZSBlcmFzZV9yZWwgKilcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIxX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMl9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBzdWJfZm10dHknID0gdHJhbnMgKHN5bW0gc3ViMV9mbXR0eScpIHN1YjJfZm10dHknIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgc3ViX2ZtdHR5JyBpblxuICAgIGxldCBSZWZsID0gZjIgUmVmbCBpblxuICAgIGxldCBSZWZsID0gZjQgUmVmbCBpblxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIChlcmFzZV9yZWwgc3ViX2ZtdHR5X3Jlc3QpIGZtdCBmbXR0eV9yZXN0XG4gICAgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHknLCBzdWIyX2ZtdHR5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bW0gc3ViX2ZtdHR5X3Jlc3QnKSxcbiAgICAgICAgICAgICAgICAgICBmbXQnKVxuICB8IEVuZF9vZl9mbXR0eSwgZm10dHkgLT5cbiAgICBGbXR0eV9mbXRfRUJCIChFbmRfb2ZfZm10dHksIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIFRoaXMgaW1wbGVtZW50YXRpb24gb2YgYHJlY2FzdGAgaXMgYSBiaXQgZGlzYXBwb2ludGluZy4gVGhlXG4gICBpbnZhcmlhbnQgcHJvdmlkZWQgYnkgdGhlIHR5cGUgYXJlIHZlcnkgc3Ryb25nOiB0aGUgaW5wdXQgZm9ybWF0J3NcbiAgIHR5cGUgaXMgaW4gcmVsYXRpb24gdG8gdGhlIG91dHB1dCB0eXBlJ3MgYXMgd2l0bmVzc2VkIGJ5IHRoZVxuICAgZm10dHlfcmVsIGFyZ3VtZW50LiBPbmUgd291bGQgYXQgZmlyc3QgZXhwZWN0IHRoaXMgZnVuY3Rpb24gdG8gYmVcbiAgIHRvdGFsLCBhbmQgaW1wbGVtZW50YWJsZSBieSBleGhhdXN0aXZlIHBhdHRlcm4gbWF0Y2hpbmcuIEluc3RlYWQsXG4gICB3ZSByZXVzZSB0aGUgaGlnaGx5IHBhcnRpYWwgYW5kIG11Y2ggbGVzcyB3ZWxsLWRlZmluZWQgZnVuY3Rpb25cbiAgIGB0eXBlX2Zvcm1hdGAgdGhhdCBoYXMgbG9zdCBhbGwga25vd2xlZGdlIG9mIHRoZSBjb3JyZXNwb25kZW5jZVxuICAgYmV0d2VlbiB0aGUgYXJndW1lbnQncyB0eXBlcy5cblxuICAgQmVzaWRlcyB0aGUgZmFjdCB0aGF0IHRoaXMgZnVuY3Rpb24gcmV1c2VzIGEgbG90IG9mIHRoZVxuICAgYHR5cGVfZm9ybWF0YCBsb2dpYyAoZWcuOiBzZWVpbmcgSW50X3R5IGluIHRoZSBmbXR0eSBwYXJhbWV0ZXIgZG9lc1xuICAgbm90IGxldCB5b3UgbWF0Y2ggb24gSW50IG9ubHksIGFzIHlvdSBtYXkgaW4gZmFjdCBoYXZlIEZsb2F0XG4gICAoQXJnX3BhZGRpbmcsIC4uLikgKFwiJS4qZFwiKSBiZWdpbm5pbmcgd2l0aCBhbiBJbnRfdHkpLCBpdCBpcyBhbHNvXG4gICBhIHBhcnRpYWwgZnVuY3Rpb24sIGJlY2F1c2UgdGhlIHR5cGluZyBpbmZvcm1hdGlvbiBpbiBhIGZvcm1hdCBpc1xuICAgbm90IHF1aXRlIGVub3VnaCB0byByZWNvbnN0cnVjdCBpdCB1bmFtYmlndW91c2x5LiBGb3IgZXhhbXBsZSwgdGhlXG4gICBmb3JtYXQgdHlwZXMgb2YgXCIlZCVfclwiIGFuZCBcIiVfciVkXCIgaGF2ZSB0aGUgc2FtZSBmb3JtYXQ2XG4gICBwYXJhbWV0ZXJzLCBidXQgdGhleSBhcmUgbm90IGF0IGFsbCBleGNoYW5nZWFibGUsIGFuZCBwdXR0aW5nIG9uZVxuICAgaW4gcGxhY2Ugb2YgdGhlIG90aGVyIG11c3QgcmVzdWx0IGluIGEgZHluYW1pYyBmYWlsdXJlLlxuXG4gICBHaXZlbiB0aGF0OlxuICAgLSB3ZSdkIGhhdmUgdG8gZHVwbGljYXRlIGEgbG90IG9mIG5vbi10cml2aWFsIHR5cGluZyBsb2dpYyBmcm9tIHR5cGVfZm9ybWF0XG4gICAtIHRoaXMgd291bGRuJ3QgZXZlbiBlbGltaW5hdGUgKGFsbCkgdGhlIGR5bmFtaWMgZmFpbHVyZXNcbiAgIHdlIGRlY2lkZWQgdG8ganVzdCByZXVzZSB0eXBlX2Zvcm1hdCBkaXJlY3RseSBmb3Igbm93LlxuKilcbmxldCByZWNhc3QgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRcbj0gZnVuIGZtdCBmbXR0eSAtPlxuICB0eXBlX2Zvcm1hdCBmbXQgKGVyYXNlX3JlbCAoc3ltbSBmbXR0eSkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFByaW50aW5nIHRvb2xzICopXG5cbigqIEFkZCBwYWRkaW5nIHNwYWNlcyBhcm91bmQgYSBzdHJpbmcuICopXG5sZXQgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggc3RyID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCB3aWR0aCwgcGFkdHkgPVxuICAgIGFicyB3aWR0aCxcbiAgICAoKiB3aGlsZSBsaXRlcmFsIHBhZGRpbmcgd2lkdGhzIGFyZSBhbHdheXMgbm9uLW5lZ2F0aXZlLFxuICAgICAgIGR5bmFtaWNhbGx5LXNldCB3aWR0aHMgKEFyZ19wYWRkaW5nLCBlZy4gJSpkKSBtYXkgYmUgbmVnYXRpdmU7XG4gICAgICAgd2UgaW50ZXJwcmV0IHRob3NlIGFzIHNwZWNpZnlpbmcgYSBwYWRkaW5nLXRvLXRoZS1sZWZ0OyB0aGlzXG4gICAgICAgbWVhbnMgdGhhdCAnMCcgbWF5IGdldCBkcm9wcGVkIGV2ZW4gaWYgaXQgd2FzIGV4cGxpY2l0bHkgc2V0LFxuICAgICAgIGJ1dDpcbiAgICAgICAtIHRoaXMgaXMgd2hhdCB0aGUgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRvZXMsIGFuZFxuICAgICAgICAgd2UgcHJlc2VydmUgY29tcGF0aWJpbGl0eSBpZiBwb3NzaWJsZVxuICAgICAgIC0gd2UgY291bGQgb25seSBzaWduYWwgdGhpcyBpc3N1ZSBieSBmYWlsaW5nIGF0IHJ1bnRpbWUsXG4gICAgICAgICB3aGljaCBpcyBub3QgdmVyeSBuaWNlLi4uICopXG4gICAgaWYgd2lkdGggPCAwIHRoZW4gTGVmdCBlbHNlIHBhZHR5IGluXG4gIGlmIHdpZHRoIDw9IGxlbiB0aGVuIHN0ciBlbHNlXG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2Ugd2lkdGggKGlmIHBhZHR5ID0gWmVyb3MgdGhlbiAnMCcgZWxzZSAnICcpIGluXG4gICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgIHwgTGVmdCAgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzIDAgbGVuXG4gICAgfCBSaWdodCAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMCAmJiAoc3RyLlswXSA9ICcrJyB8fCBzdHIuWzBdID0gJy0nIHx8IHN0ci5bMF0gPSAnICcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDAgc3RyLlswXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAod2lkdGggLSBsZW4gKyAxKSAobGVuIC0gMSlcbiAgICB8IFplcm9zIHdoZW4gbGVuID4gMSAmJiBzdHIuWzBdID0gJzAnICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAod2lkdGggLSBsZW4gKyAyKSAobGVuIC0gMilcbiAgICB8IFplcm9zIC0+XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHdpZHRoIC0gbGVuKSBsZW5cbiAgICBlbmQ7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQWRkICcwJyBwYWRkaW5nIHRvIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NCBzdHJpbmcgcmVwcmVzZW50YXRpb24uICopXG5sZXQgZml4X2ludF9wcmVjaXNpb24gcHJlYyBzdHIgPVxuICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBtYXRjaCBzdHIuWzBdIHdpdGhcbiAgfCAoJysnIHwgJy0nIHwgJyAnKSBhcyBjIHdoZW4gcHJlYyArIDEgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDEpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMCBjO1xuICAgIFN0cmluZy5ibGl0IHN0ciAxIHJlcyAocHJlYyAtIGxlbiArIDIpIChsZW4gLSAxKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyB3aGVuIHByZWMgKyAyID4gbGVuICYmIGxlbiA+IDEgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSAocHJlYyArIDIpICcwJyBpblxuICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgIFN0cmluZy5ibGl0IHN0ciAyIHJlcyAocHJlYyAtIGxlbiArIDQpIChsZW4gLSAyKTtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyB3aGVuIHByZWMgPiBsZW4gLT5cbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSBwcmVjICcwJyBpblxuICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAocHJlYyAtIGxlbikgbGVuO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgXyAtPlxuICAgIHN0clxuXG4oKiBFc2NhcGUgYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpbmcgY29udmVudGlvbi4gKilcbmxldCBzdHJpbmdfdG9fY2FtbF9zdHJpbmcgc3RyID1cbiAgbGV0IHN0ciA9IFN0cmluZy5lc2NhcGVkIHN0ciBpblxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIGxldCByZXMgPSBCeXRlcy5tYWtlIChsICsgMikgJ1xcXCInIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2ludC9pbnQzMi9uYXRpdmVpbnQvaW50NjQgZmlyc3QgYXJndW1lbnRcbiAgIGZyb20gYW4gaW50X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2ljb252ID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVkXCIgfCBJbnRfcGQgLT4gXCIlK2RcIiB8IEludF9zZCAtPiBcIiUgZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlaVwiIHwgSW50X3BpIC0+IFwiJStpXCIgfCBJbnRfc2kgLT4gXCIlIGlcIlxuICB8IEludF94IC0+IFwiJXhcIiB8IEludF9DeCAtPiBcIiUjeFwiXG4gIHwgSW50X1ggLT4gXCIlWFwiIHwgSW50X0NYIC0+IFwiJSNYXCJcbiAgfCBJbnRfbyAtPiBcIiVvXCIgfCBJbnRfQ28gLT4gXCIlI29cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJXVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252TCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlTGRcIiB8IEludF9wZCAtPiBcIiUrTGRcIiB8IEludF9zZCAtPiBcIiUgTGRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJUxpXCIgfCBJbnRfcGkgLT4gXCIlK0xpXCIgfCBJbnRfc2kgLT4gXCIlIExpXCJcbiAgfCBJbnRfeCAtPiBcIiVMeFwiIHwgSW50X0N4IC0+IFwiJSNMeFwiXG4gIHwgSW50X1ggLT4gXCIlTFhcIiB8IEludF9DWCAtPiBcIiUjTFhcIlxuICB8IEludF9vIC0+IFwiJUxvXCIgfCBJbnRfQ28gLT4gXCIlI0xvXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVMdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZsID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVsZFwiIHwgSW50X3BkIC0+IFwiJStsZFwiIHwgSW50X3NkIC0+IFwiJSBsZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlbGlcIiB8IEludF9waSAtPiBcIiUrbGlcIiB8IEludF9zaSAtPiBcIiUgbGlcIlxuICB8IEludF94IC0+IFwiJWx4XCIgfCBJbnRfQ3ggLT4gXCIlI2x4XCJcbiAgfCBJbnRfWCAtPiBcIiVsWFwiIHwgSW50X0NYIC0+IFwiJSNsWFwiXG4gIHwgSW50X28gLT4gXCIlbG9cIiB8IEludF9DbyAtPiBcIiUjbG9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJWx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udm4gPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJW5kXCIgfCBJbnRfcGQgLT4gXCIlK25kXCIgfCBJbnRfc2QgLT4gXCIlIG5kXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVuaVwiIHwgSW50X3BpIC0+IFwiJStuaVwiIHwgSW50X3NpIC0+IFwiJSBuaVwiXG4gIHwgSW50X3ggLT4gXCIlbnhcIiB8IEludF9DeCAtPiBcIiUjbnhcIlxuICB8IEludF9YIC0+IFwiJW5YXCIgfCBJbnRfQ1ggLT4gXCIlI25YXCJcbiAgfCBJbnRfbyAtPiBcIiVub1wiIHwgSW50X0NvIC0+IFwiJSNub1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlbnVcIlxuXG4oKiBHZW5lcmF0ZSB0aGUgZm9ybWF0X2Zsb2F0IGZpcnN0IGFyZ3VtZW50IGZyb20gYSBmbG9hdF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjID1cbiAgICBsZXQgcHJlYyA9IGFicyBwcmVjIGluXG4gICAgbGV0IHN5bWIgPSBjaGFyX29mX2Zjb252IH5jRjonZycgZmNvbnYgaW5cbiAgICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICAgIGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udjtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcuJztcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgKEludC50b19zdHJpbmcgcHJlYyk7XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBzeW1iO1xuICAgIGJ1ZmZlcl9jb250ZW50cyBidWZcblxubGV0IHRyYW5zZm9ybV9pbnRfYWx0IGljb252IHMgPVxuICBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1IC0+XG4gICAgbGV0IGRpZ2l0cyA9XG4gICAgICBsZXQgbiA9IHJlZiAwIGluXG4gICAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgICB8ICcwJy4uJzknIC0+IGluY3IgblxuICAgICAgICB8IF8gLT4gKClcbiAgICAgIGRvbmU7XG4gICAgICAhblxuICAgIGluXG4gICAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCBzICsgKGRpZ2l0cyAtIDEpIC8gMykgaW5cbiAgICBsZXQgcG9zID0gcmVmIDAgaW5cbiAgICBsZXQgcHV0IGMgPSBCeXRlcy5zZXQgYnVmICFwb3MgYzsgaW5jciBwb3MgaW5cbiAgICBsZXQgbGVmdCA9IHJlZiAoKGRpZ2l0cyAtIDEpIG1vZCAzICsgMSkgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgJzAnLi4nOScgYXMgYyAtPlxuICAgICAgICAgIGlmICFsZWZ0ID0gMCB0aGVuIChwdXQgJ18nOyBsZWZ0IDo9IDMpOyBkZWNyIGxlZnQ7IHB1dCBjXG4gICAgICB8IGMgLT4gcHV0IGNcbiAgICBkb25lO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYnVmXG4gIHwgXyAtPiBzXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gYSBjb252ZXJzaW9uLiAqKVxubGV0IGNvbnZlcnRfaW50IGljb252IG4gPVxuICB0cmFuc2Zvcm1faW50X2FsdCBpY29udiAoZm9ybWF0X2ludCAoZm9ybWF0X29mX2ljb252IGljb252KSBuKVxubGV0IGNvbnZlcnRfaW50MzIgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50MzIgKGZvcm1hdF9vZl9pY29udmwgaWNvbnYpIG4pXG5sZXQgY29udmVydF9uYXRpdmVpbnQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfbmF0aXZlaW50IChmb3JtYXRfb2ZfaWNvbnZuIGljb252KSBuKVxubGV0IGNvbnZlcnRfaW50NjQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50NjQgKGZvcm1hdF9vZl9pY29udkwgaWNvbnYpIG4pXG5cbigqIENvbnZlcnQgYSBmbG9hdCB0byBzdHJpbmcuICopXG4oKiBGaXggc3BlY2lhbCBjYXNlIG9mIFwiT0NhbWwgZmxvYXQgZm9ybWF0XCIuICopXG5sZXQgY29udmVydF9mbG9hdCBmY29udiBwcmVjIHggPVxuICBsZXQgaGV4ICgpID1cbiAgICBsZXQgc2lnbiA9XG4gICAgICBtYXRjaCBmc3QgZmNvbnYgd2l0aFxuICAgICAgfCBGbG9hdF9mbGFnX3AgLT4gJysnXG4gICAgICB8IEZsb2F0X2ZsYWdfcyAtPiAnICdcbiAgICAgIHwgXyAtPiAnLScgaW5cbiAgICBoZXhzdHJpbmdfb2ZfZmxvYXQgeCBwcmVjIHNpZ24gaW5cbiAgbGV0IGFkZF9kb3RfaWZfbmVlZGVkIHN0ciA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IHJlYyBpc192YWxpZCBpID1cbiAgICAgIGlmIGkgPSBsZW4gdGhlbiBmYWxzZSBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICB8ICcuJyB8ICdlJyB8ICdFJyAtPiB0cnVlXG4gICAgICAgIHwgXyAtPiBpc192YWxpZCAoaSArIDEpIGluXG4gICAgaWYgaXNfdmFsaWQgMCB0aGVuIHN0ciBlbHNlIHN0ciBeIFwiLlwiIGluXG4gIGxldCBjYW1sX3NwZWNpYWxfdmFsIHN0ciA9IG1hdGNoIGNsYXNzaWZ5X2Zsb2F0IHggd2l0aFxuICAgIHwgRlBfbm9ybWFsIHwgRlBfc3Vibm9ybWFsIHwgRlBfemVybyAtPiBzdHJcbiAgICB8IEZQX2luZmluaXRlIC0+IGlmIHggPCAwLjAgdGhlbiBcIm5lZ19pbmZpbml0eVwiIGVsc2UgXCJpbmZpbml0eVwiXG4gICAgfCBGUF9uYW4gLT4gXCJuYW5cIiBpblxuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X2ggLT4gaGV4ICgpXG4gIHwgRmxvYXRfSCAtPiBTdHJpbmcudXBwZXJjYXNlX2FzY2lpIChoZXggKCkpXG4gIHwgRmxvYXRfQ0YgLT4gY2FtbF9zcGVjaWFsX3ZhbCAoaGV4ICgpKVxuICB8IEZsb2F0X0YgLT5cbiAgICBsZXQgc3RyID0gZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeCBpblxuICAgIGNhbWxfc3BlY2lhbF92YWwgKGFkZF9kb3RfaWZfbmVlZGVkIHN0cilcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRyAtPlxuICAgIGZvcm1hdF9mbG9hdCAoZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMpIHhcblxuKCogQ29udmVydCBhIGNoYXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpY2FsIGNvbnZlbnRpb24uICopXG5sZXQgZm9ybWF0X2NhbWxfY2hhciBjID1cbiAgbGV0IHN0ciA9IENoYXIuZXNjYXBlZCBjIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKGwgKyAyKSAnXFwnJyBpblxuICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgcmVzIDEgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQ29udmVydCBhIGZvcm1hdCB0eXBlIHRvIHN0cmluZyAqKVxubGV0IHN0cmluZ19vZl9mbXR0eSBmbXR0eSA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXR0eSBidWYgZm10dHk7XG4gIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgcHJpbnRpbmcgZnVuY3Rpb24gKilcblxuKCogTWFrZSBhIGdlbmVyaWMgcHJpbnRpbmcgZnVuY3Rpb24uICopXG4oKiBVc2VkIHRvIGdlbmVyYXRlIFByaW50ZiBhbmQgRm9ybWF0IHByaW50aW5nIGZ1bmN0aW9ucy4gKilcbigqIFBhcmFtZXRlcnM6XG4gICAgIGs6IGEgY29udGludWF0aW9uIGZpbmFsbHkgYXBwbGllZCB0byB0aGUgb3V0cHV0IHN0cmVhbSBhbmQgdGhlIGFjY3VtdWxhdG9yLlxuICAgICBvOiB0aGUgb3V0cHV0IHN0cmVhbSAoc2VlIGssICVhIGFuZCAldCkuXG4gICAgIGFjYzogcmV2IGxpc3Qgb2YgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1c2gsIGZvcm1hdHRpbmcsIC4uLikuXG4gICAgIGZtdDogdGhlIGZvcm1hdC4gKilcbmxldCByZWMgbWFrZV9wcmludGYgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9jaGFyIChhY2MsIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgcmVzdFxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZvcm1hdF9jYW1sX2NoYXIgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIChmdW4gc3RyIC0+IHN0cilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCBzdHJpbmdfdG9fY2FtbF9zdHJpbmdcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludCBpY29udlxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQzMiBpY29udlxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfbmF0aXZlaW50IGljb252XG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDY0IGljb252XG4gIHwgRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9mbG9hdF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGZjb252XG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIGFjYyByZXN0IHBhZCBzdHJpbmdfb2ZfYm9vbFxuICB8IEFscGhhIHJlc3QgLT5cbiAgICBmdW4gZiB4IC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kZWxheSAoYWNjLCBmdW4gbyAtPiBmIG8geCkpIHJlc3RcbiAgfCBUaGV0YSByZXN0IC0+XG4gICAgZnVuIGYgLT4gbWFrZV9wcmludGYgayAoQWNjX2RlbGF5IChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBtYWtlX2N1c3RvbSBrIGFjYyByZXN0IGFyaXR5IChmICgpKVxuICB8IFJlYWRlciBfIC0+XG4gICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAqKVxuICAgICgqIEluZGVlZCwgc2luY2UgcHJpbnRmIGFuZCBjby4gdGFrZSBhIGZvcm1hdDQgYXMgYXJndW1lbnQsIHRoZSAnZCBhbmQgJ2VcbiAgICAgICB0eXBlIHBhcmFtZXRlcnMgb2YgZm10IGFyZSBvYnZpb3VzbHkgZXF1YWxzLiBUaGUgUmVhZGVyIGlzIHRoZVxuICAgICAgIG9ubHkgY29uc3RydWN0b3Igd2hpY2ggdG91Y2ggJ2QgYW5kICdlIHR5cGUgcGFyYW1ldGVycyBvZiB0aGUgZm9ybWF0XG4gICAgICAgdHlwZSwgaXQgYWRkcyBhbiAoLT4pIHRvIHRoZSAnZCBwYXJhbWV0ZXJzLiBDb25zZXF1ZW50bHksIGEgZm9ybWF0NFxuICAgICAgIGNhbm5vdCBjb250YWluIGEgUmVhZGVyIG5vZGUsIGV4Y2VwdCBpbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvXG4gICAgICAgYW4gJXsuLi4lfS4gSXQncyBub3QgYSBwcm9ibGVtIGJlY2F1c2UgbWFrZV9wcmludGYgZG8gbm90IGNhbGxcbiAgICAgICBpdHNlbGYgcmVjdXJzaXZlbHkgb24gdGhlIHN1Yi1mb3JtYXQgYXNzb2NpYXRlZCB0byAley4uLiV9LiAqKVxuICAgIGFzc2VydCBmYWxzZVxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfZmx1c2ggYWNjKSByZXN0XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19zdHJpbmdfbGl0ZXJhbCAoYWNjLCBzdHIpKSByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2NoYXJfbGl0ZXJhbCAoYWNjLCBjaHIpKSByZXN0XG5cbiAgfCBGb3JtYXRfYXJnIChfLCBzdWJfZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gc3RyaW5nX29mX2ZtdHR5IHN1Yl9mbXR0eSBpblxuICAgIChmdW4gc3RyIC0+XG4gICAgICBpZ25vcmUgc3RyO1xuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHR5KSkgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPiBtYWtlX3ByaW50ZiBrIGFjY1xuICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgIGxldCBuZXdfYWNjID0gQWNjX2ludmFsaWRfYXJnIChhY2MsIFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlW1wiKSBpblxuICAgIGZ1biBfIC0+IG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAoKiBUaGlzIGNhc2Ugc2hvdWxkIGJlIHJlZnVzZWQgZm9yIFByaW50Zi4gKilcbiAgICAoKiBBY2NlcHRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gKilcbiAgICAoKiBJbnRlcnByZXQgJWwsICVuIGFuZCAlTCBhcyAldS4gKilcbiAgICBmdW4gbiAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2ludCBcIiV1XCIgbikgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIG1ha2VfaWdub3JlZF9wYXJhbSBrIGFjYyBpZ24gcmVzdFxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX2Zvcm1hdHRpbmdfbGl0IChhY2MsIGZtdGluZ19saXQpKSByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga2FjYyA9XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fdGFnIGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXQnXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBsZXQgaycga2FjYyA9XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fYm94IGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXQnXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgayBhY2NcblxuKCogRGVsYXkgdGhlIGVycm9yIChJbnZhbGlkX2FyZ3VtZW50IFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlX1wiKS4gKilcbigqIEdlbmVyYXRlIGZ1bmN0aW9ucyB0byB0YWtlIHJlbWFpbmluZyBhcmd1bWVudHMgKGFmdGVyIHRoZSBcIiVfXCIpLiAqKVxuYW5kIG1ha2VfaWdub3JlZF9wYXJhbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGlnbiBmbXQgLT4gbWF0Y2ggaWduIHdpdGhcbiAgfCBJZ25vcmVkX2NoYXIgICAgICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfc3RyaW5nIF8gICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX25hdGl2ZWludCAoXywgXykgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Jvb2wgXyAgICAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIGZtdHR5IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyICAgICAgICAgICAgICAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG5cblxuKCogU3BlY2lhbCBjYXNlIG9mIHByaW50ZiBcIiVfKFwiLiAqKVxuYW5kIG1ha2VfZnJvbV9mbXR0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGZtdHR5IC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludDMyX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEZsb2F0X3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIGFjYyByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQW55X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgUmVhZGVyX3R5IF8gICAgICAgICAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgXyAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgRm9ybWF0X2FyZ190eSAoXywgcmVzdCkgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIEluc2VydCBhbiBBY2NfaW52YWxpZF9hcmcgaW4gdGhlIGFjY3VtdWxhdG9yIGFuZCBjb250aW51ZSB0byBnZW5lcmF0ZVxuICAgY2xvc3VyZXMgdG8gZ2V0IHRoZSByZW1haW5pbmcgYXJndW1lbnRzLiAqKVxuYW5kIG1ha2VfaW52YWxpZF9hcmcgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIGFjYyBmbXQgLT5cbiAgbWFrZV9wcmludGYgayAoQWNjX2ludmFsaWRfYXJnIChhY2MsIFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlX1wiKSkgZm10XG5cbigqIEZpeCBwYWRkaW5nLCB0YWtlIGl0IGFzIGFuIGV4dHJhIGludGVnZXIgYXJndW1lbnQgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfcGFkZGluZyA6IHR5cGUgeCB6IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB6IC0+IGEpIHBhZGRpbmcgLT4gKHogLT4gc3RyaW5nKSAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgdHJhbnMgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIHRyYW5zIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3aWR0aCkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgd2lkdGggKHRyYW5zIHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5IC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG5cbigqIEZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gZm9yIGludCwgaW50MzIsIG5hdGl2ZWludCBvciBpbnQ2NC4gKilcbigqIFRha2Ugb25lIG9yIHR3byBleHRyYSBpbnRlZ2VyIGFyZ3VtZW50cyBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSB6IGEgYiBjIGQgZSBmIC5cbiAgICAoKGIsIGMpIGFjYyAtPiBmKSAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPiAoaW50X2NvbnYgLT4geiAtPiBzdHJpbmcpIC0+XG4gICAgaW50X2NvbnYgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHByZWMgdHJhbnMgaWNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IHRyYW5zIGljb252IHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcblxuKCogQ29udmVydCBhIGZsb2F0LCBmaXggcGFkZGluZyBhbmQgcHJlY2lzaW9uIGlmIG5lZWRlZC4gKilcbigqIFRha2UgdGhlIGZsb2F0IGFyZ3VtZW50IGFuZCBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIGZsb2F0IC0+IGEpIHByZWNpc2lvbiAtPiBmbG9hdF9jb252IC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCBwcmVjIGZjb252IC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IChkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udikgeCBpblxuICAgICAgbGV0IHN0cicgPSBmaXhfcGFkZGluZyBwYWR0eSB3IHN0ciBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG5hbmQgbWFrZV9jdXN0b20gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHggLT4geSA9XG4gIGZ1biBrIGFjYyByZXN0IGFyaXR5IGYgLT4gbWF0Y2ggYXJpdHkgd2l0aFxuICB8IEN1c3RvbV96ZXJvIC0+IG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBmKSkgcmVzdFxuICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgZnVuIHggLT5cbiAgICAgIG1ha2VfY3VzdG9tIGsgYWNjIHJlc3QgYXJpdHkgKGYgeClcblxubGV0IGNvbnN0IHggXyA9IHhcblxubGV0IHJlYyBtYWtlX2lwcmludGYgOiB0eXBlIGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT4gc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiBhID1cbiAgZnVuIGsgbyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFN0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQ2FtbF9zdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBJbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDMyIChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBGbG9hdCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgQm9vbCAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX2N1c3RvbV9hcml0eSBrIG8gcmVzdCBhcml0eVxuICAgIHwgUmVhZGVyIF8gLT5cbiAgICAgICAgKCogVGhpcyBjYXNlIGlzIGltcG9zc2libGUsIGJ5IHR5cGluZyBvZiBmb3JtYXRzLiAgU2VlIHRoZVxuICAgICAgICAgICBub3RlIGluIHRoZSBjb3JyZXNwb25kaW5nIGNhc2UgZm9yIG1ha2VfcHJpbnRmLiAqKVxuICAgICAgICBhc3NlcnQgZmFsc2VcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0X2FyZyAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgICAgIGZ1biAoRm9ybWF0IChmbXQsIF8pKSAtPlxuICAgICAgICAgIG1ha2VfaXByaW50ZiBrIG9cbiAgICAgICAgICAgIChjb25jYXRfZm10IChyZWNhc3QgZm10IGZtdHR5KSByZXN0KVxuICAgIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaWdub3JlZF9wYXJhbSAoZnVuIF8gLT4gayBvKSAoRW5kX29mX2FjYykgaWduIHJlc3RcbiAgICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgKGZ1biBrb2MgLT4gbWFrZV9pcHJpbnRmIGsga29jIHJlc3QpIG8gZm10J1xuICAgIHwgRW5kX29mX2Zvcm1hdCAtPlxuICAgICAgICBrIG9cbmFuZCBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiA6XG4gIHR5cGUgeCB5IHogYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPiBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPiB4ID1cbiAgZnVuIGsgbyBmbXQgcGFkIHByZWMgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgICAsIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTm9fcGFkZGluZyAgICwgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKSlcbmFuZCBmbl9vZl9jdXN0b21fYXJpdHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+XG4gIHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiB5ID1cbiAgZnVuIGsgbyBmbXQgLT4gZnVuY3Rpb25cbiAgICB8IEN1c3RvbV96ZXJvIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gZm10XG4gICAgfCBDdXN0b21fc3VjYyBhcml0eSAtPlxuICAgICAgICBjb25zdCAoZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyBmbXQgYXJpdHkpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIENvbnRpbnVhdGlvbnMgZm9yIG1ha2VfcHJpbnRmICopXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgbyBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBcIkB7XCI7IG91dHB1dF9hY2MgbyBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBcIkBbXCI7IG91dHB1dF9hY2MgbyBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9zdHJpbmcgbyBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IG91dHB1dF9jaGFyIG8gY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgZiBvXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmbHVzaCBvXG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgbyBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBidWZwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBidWZwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBidWZwdXRfYWNjIGIgcDsgZiBiXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBidWZwdXRfYWNjIGIgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKiBSZWN1cnNpdmVseSBvdXRwdXQgYW4gXCJhY2N1bXVsYXRvclwiIGNvbnRhaW5pbmcgYSByZXZlcnNlZCBsaXN0IG9mXG4gICBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzLCAuLi4pIGluIGEgYnVmZmVyLiAqKVxuKCogRGlmZmVyIGZyb20gYnVmcHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgJWEgYW5kICV0LiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgc3RycHV0X2FjYyBiIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAe1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQFtcIjsgc3RycHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBzXG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfY2hhciBiIGNcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgKGYgKCkpXG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgYiBwO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBzdHJwdXRfYWNjIGIgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBFcnJvciBtYW5hZ2VtZW50ICopXG5cbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgcHJldHR5LXByaW50ZWQgZXJyb3IgbWVzc2FnZS4gKilcbmxldCBmYWlsd2l0aF9tZXNzYWdlIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMjU2IGluXG4gIGxldCBrIGFjYyA9IHN0cnB1dF9hY2MgYnVmIGFjYzsgZmFpbHdpdGggKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsgRW5kX29mX2FjYyBmbXRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXR0aW5nIHRvb2xzICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYW4gb3BlbiBibG9jayBkZXNjcmlwdGlvbiAoaW5kZW50LCBibG9ja190eXBlKSAqKVxubGV0IG9wZW5fYm94X29mX3N0cmluZyBzdHIgPVxuICBpZiBzdHIgPSBcIlwiIHRoZW4gKDAsIFBwX2JveCkgZWxzZVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCBpbnZhbGlkX2JveCAoKSA9IGZhaWx3aXRoX21lc3NhZ2UgXCJpbnZhbGlkIGJveCBkZXNjcmlwdGlvbiAlU1wiIHN0ciBpblxuICAgIGxldCByZWMgcGFyc2Vfc3BhY2VzIGkgPVxuICAgICAgaWYgaSA9IGxlbiB0aGVuIGkgZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgICAgfCAnICcgfCAnXFx0JyAtPiBwYXJzZV9zcGFjZXMgKGkgKyAxKVxuICAgICAgICB8IF8gLT4gaVxuICAgIGFuZCBwYXJzZV9sd29yZCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnYScgLi4gJ3onIC0+IHBhcnNlX2x3b3JkIGkgKGogKyAxKVxuICAgICAgICB8IF8gLT4galxuICAgIGFuZCBwYXJzZV9pbnQgaSBqID1cbiAgICAgIGlmIGogPSBsZW4gdGhlbiBqIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltqXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBwYXJzZV9pbnQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqIGluXG4gICAgbGV0IHdzdGFydCA9IHBhcnNlX3NwYWNlcyAwIGluXG4gICAgbGV0IHdlbmQgPSBwYXJzZV9sd29yZCB3c3RhcnQgd3N0YXJ0IGluXG4gICAgbGV0IGJveF9uYW1lID0gU3RyaW5nLnN1YiBzdHIgd3N0YXJ0ICh3ZW5kIC0gd3N0YXJ0KSBpblxuICAgIGxldCBuc3RhcnQgPSBwYXJzZV9zcGFjZXMgd2VuZCBpblxuICAgIGxldCBuZW5kID0gcGFyc2VfaW50IG5zdGFydCBuc3RhcnQgaW5cbiAgICBsZXQgaW5kZW50ID1cbiAgICAgIGlmIG5zdGFydCA9IG5lbmQgdGhlbiAwIGVsc2VcbiAgICAgICAgdHJ5IGludF9vZl9zdHJpbmcgKFN0cmluZy5zdWIgc3RyIG5zdGFydCAobmVuZCAtIG5zdGFydCkpXG4gICAgICAgIHdpdGggRmFpbHVyZSBfIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgbGV0IGV4cF9lbmQgPSBwYXJzZV9zcGFjZXMgbmVuZCBpblxuICAgIGlmIGV4cF9lbmQgPD4gbGVuIHRoZW4gaW52YWxpZF9ib3ggKCk7XG4gICAgbGV0IGJveF90eXBlID0gbWF0Y2ggYm94X25hbWUgd2l0aFxuICAgICAgfCBcIlwiIHwgXCJiXCIgLT4gUHBfYm94XG4gICAgICB8IFwiaFwiICAgICAgLT4gUHBfaGJveFxuICAgICAgfCBcInZcIiAgICAgIC0+IFBwX3Zib3hcbiAgICAgIHwgXCJodlwiICAgICAtPiBQcF9odmJveFxuICAgICAgfCBcImhvdlwiICAgIC0+IFBwX2hvdmJveFxuICAgICAgfCBfICAgICAgICAtPiBpbnZhbGlkX2JveCAoKSBpblxuICAgIChpbmRlbnQsIGJveF90eXBlKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFBhcnNpbmcgdG9vbHMgKilcblxuKCogQ3JlYXRlIGEgcGFkZGluZ19mbXRfZWJiIGZyb20gYSBwYWRkaW5nIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgOiB0eXBlIHggeSAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgICAgKF8sIF8sIF8sIF8sIF8pIHBhZGRpbmdfZm10X2ViYiA9XG5mdW4gcGFkIGZtdCAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIGZtdClcbiAgfCBMaXRfcGFkZGluZyAocywgdykgLT4gUGFkZGluZ19mbXRfRUJCIChMaXRfcGFkZGluZyAocywgdyksIGZtdClcbiAgfCBBcmdfcGFkZGluZyBzICAgICAgLT4gUGFkZGluZ19mbXRfRUJCIChBcmdfcGFkZGluZyBzLCBmbXQpXG5cbigqIENyZWF0ZSBhIHByZWNpc2lvbl9mbXRfZWJiIGZyb20gYSBwcmVjaXNpb24gYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcHJlY2lzaW9uIHRvIGRpc2pvaW4gdGhlIHR5cGUgcGFyYW1ldGVycyBvZiBhcmd1bWVudCBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgOiB0eXBlIHggeSAuXG4gICAgKHgsIHkpIHByZWNpc2lvbiAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcHJlY2lzaW9uX2ZtdF9lYmIgPVxuZnVuIHByZWMgZm10IC0+IG1hdGNoIHByZWMgd2l0aFxuICB8IE5vX3ByZWNpc2lvbiAgICAtPiBQcmVjaXNpb25fZm10X0VCQiAoTm9fcHJlY2lzaW9uLCBmbXQpXG4gIHwgTGl0X3ByZWNpc2lvbiBwIC0+IFByZWNpc2lvbl9mbXRfRUJCIChMaXRfcHJlY2lzaW9uIHAsIGZtdClcbiAgfCBBcmdfcHJlY2lzaW9uICAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKEFyZ19wcmVjaXNpb24sIGZtdClcblxuKCogQ3JlYXRlIGEgcGFkcHJlY19mbXRfZWJiIGZyb20gYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwYWRkaW5nIGFuZCB0aGUgcHJlY2lzaW9uIHRvIGRpc2pvaW4gdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50c1xuICAgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZHByZWNfZm10X2ViYiA6IHR5cGUgeCB5IHogdCAuXG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHosIHQpIHByZWNpc2lvbiAtPlxuICAgIChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAoXywgXywgXywgXywgXykgcGFkcHJlY19mbXRfZWJiID1cbmZ1biBwYWQgcHJlYyBmbXQgLT5cbiAgbGV0IFByZWNpc2lvbl9mbXRfRUJCIChwcmVjLCBmbXQnKSA9IG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgcHJlYyBmbXQgaW5cbiAgbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nICAgICAgICAgLT4gUGFkcHJlY19mbXRfRUJCIChOb19wYWRkaW5nLCBwcmVjLCBmbXQnKVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRwcmVjX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgcHJlYywgZm10JylcbiAgfCBBcmdfcGFkZGluZyBzICAgICAgLT4gUGFkcHJlY19mbXRfRUJCIChBcmdfcGFkZGluZyBzLCBwcmVjLCBmbXQnKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgcGFyc2luZyAqKVxuXG4oKiBQYXJzZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBmb3JtYXQgYW5kIGNyZWF0ZSBhIGZtdF9lYmIuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gaW4gY2FzZSBvZiBpbnZhbGlkIGZvcm1hdC4gKilcbmxldCBmbXRfZWJiX29mX3N0cmluZyA/bGVnYWN5X2JlaGF2aW9yIHN0ciA9XG4gICgqIFBhcmFtZXRlcnMgbmFtaW5nIGNvbnZlbnRpb246ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGxpdF9zdGFydDogc3RhcnQgb2YgdGhlIGxpdGVyYWwgc2VxdWVuY2UuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3RyX2luZDogY3VycmVudCBpbmRleCBpbiB0aGUgc3RyaW5nLiAgICAgICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBlbmRfaW5kOiBlbmQgb2YgdGhlIGN1cnJlbnQgKHN1Yi0pZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHBjdF9pbmQ6IGluZGV4IG9mIHRoZSAnJScgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAqKVxuICAoKiAgIC0gemVybzogIGlzIHRoZSAnMCcgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBtaW51czogaXMgdGhlICctJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHBsdXM6ICBpcyB0aGUgJysnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaGFzaDogIGlzIHRoZSAnIycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBzcGFjZTogaXMgdGhlICcgJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIGlnbjogICBpcyB0aGUgJ18nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGFkOiBwYWRkaW5nIG9mIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBwcmVjOiBwcmVjaXNpb24gb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHN5bWI6IGNoYXIgcmVwcmVzZW50aW5nIHRoZSBjb252ZXJzaW9uICgnYycsICdzJywgJ2QnLCAuLi4pLiAqKVxuICAoKiAgIC0gY2hhcl9zZXQ6IHNldCBvZiBjaGFyYWN0ZXJzIGFzIGJpdG1hcCAoc2VlIHNjYW5mICVbLi4uXSkuICAgICopXG5cbiAgbGV0IGxlZ2FjeV9iZWhhdmlvciA9IG1hdGNoIGxlZ2FjeV9iZWhhdmlvciB3aXRoXG4gICAgfCBTb21lIGZsYWcgLT4gZmxhZ1xuICAgIHwgTm9uZSAtPiB0cnVlXG4gICgqICBXaGVuIHRoaXMgZmxhZyBpcyBlbmFibGVkLCB0aGUgZm9ybWF0IHBhcnNlciB0cmllcyB0byBiZWhhdmUgYXNcbiAgICAgIHRoZSA8NC4wMiBpbXBsZW1lbnRhdGlvbnMsIGluIHBhcnRpY3VsYXIgaXQgaWdub3JlcyBtb3N0IGJlbmluZVxuICAgICAgbm9uc2Vuc2ljYWwgZm9ybWF0LiBXaGVuIHRoZSBmbGFnIGlzIGRpc2FibGVkLCBpdCB3aWxsIHJlamVjdCBhbnlcbiAgICAgIGZvcm1hdCB0aGF0IGlzIG5vdCBhY2NlcHRlZCBieSB0aGUgc3BlY2lmaWNhdGlvbi5cblxuICAgICAgQSB0eXBpY2FsIGV4YW1wbGUgd291bGQgYmUgXCIlKyBkXCI6IHNwZWNpZnlpbmcgYm90aCAnKycgKGlmIHRoZVxuICAgICAgbnVtYmVyIGlzIHBvc2l0aXZlLCBwYWQgd2l0aCBhICcrJyB0byBnZXQgdGhlIHNhbWUgd2lkdGggYXNcbiAgICAgIG5lZ2F0aXZlIG51bWJlcnMpIGFuZCAnICcgKGlmIHRoZSBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoXG4gICAgICBhIHNwYWNlKSBkb2VzIG5vdCBtYWtlIHNlbnNlLCBidXQgdGhlIGxlZ2FjeSAoPCA0LjAyKVxuICAgICAgaW1wbGVtZW50YXRpb24gd2FzIGhhcHB5IHRvIGp1c3QgaWdub3JlIHRoZSBzcGFjZS5cbiAgKilcbiAgaW5cblxuICAoKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhIGZyaWVuZGx5IGVycm9yIG1lc3NhZ2UuICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIHN0cl9pbmQgbXNnID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlc1wiXG4gICAgICBzdHIgc3RyX2luZCBtc2dcbiAgaW5cblxuICAoKiBVc2VkIHdoZW4gdGhlIGVuZCBvZiB0aGUgZm9ybWF0IChvciB0aGUgY3VycmVudCBzdWItZm9ybWF0KSB3YXMgZW5jb3VudGVyZWRcbiAgICAgIHVuZXhwZWN0ZWRseS4gKilcbiAgbGV0IHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kID1cbiAgICBpbnZhbGlkX2Zvcm1hdF9tZXNzYWdlIGVuZF9pbmRcbiAgICAgIFwidW5leHBlY3RlZCBlbmQgb2YgZm9ybWF0XCJcbiAgaW5cblxuICAoKiBVc2VkIGZvciAlMGM6IG5vIG90aGVyIHdpZHRocyBhcmUgaW1wbGVtZW50ZWQgKilcbiAgbGV0IGludmFsaWRfbm9ubnVsbF9jaGFyX3dpZHRoIHN0cl9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZFxuICAgICAgXCJub24temVybyB3aWR0aHMgYXJlIHVuc3VwcG9ydGVkIGZvciAlYyBjb252ZXJzaW9uc1wiXG4gIGluXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiBvcHRpb24gZGVwZW5kZW5jeVxuICAgICBwcm9ibGVtLiAqKVxuICBsZXQgaW52YWxpZF9mb3JtYXRfd2l0aG91dCBzdHJfaW5kIGMgcyA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJyVjJyB3aXRob3V0ICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIGMgc1xuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBhbiB1bmV4cGVjdGVkXG4gICAgIGNoYXJhY3Rlci4gKilcbiAgbGV0IGV4cGVjdGVkX2NoYXJhY3RlciBzdHJfaW5kIGV4cGVjdGVkIHJlYWQgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgJXMgZXhwZWN0ZWQsIHJlYWQgJUNcIlxuICAgICAgc3RyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZFxuICBpblxuXG4gICgqIFBhcnNlIHRoZSBzdHJpbmcgZnJvbSBiZWdfaW5kIChpbmNsdWRlZCkgdG8gZW5kX2luZCAoZXhjbHVkZWQpLiAqKVxuICBsZXQgcmVjIHBhcnNlIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGJlZ19pbmQgZW5kX2luZCAtPiBwYXJzZV9saXRlcmFsIGJlZ19pbmQgYmVnX2luZCBlbmRfaW5kXG5cbiAgKCogUmVhZCBsaXRlcmFsIGNoYXJhY3RlcnMgdXAgdG8gJyUnIG9yICdAJyBzcGVjaWFsIGNoYXJhY3RlcnMuICopXG4gIGFuZCBwYXJzZV9saXRlcmFsIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBsaXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBFbmRfb2ZfZm9ybWF0IGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZV9mb3JtYXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2FmdGVyX2F0IChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBhZGRfbGl0ZXJhbCBsaXRfc3RhcnQgc3RyX2luZCBmbXRfcmVzdFxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX2xpdGVyYWwgbGl0X3N0YXJ0IChzdHJfaW5kICsgMSkgZW5kX2luZFxuXG4gICgqIFBhcnNlIGEgZm9ybWF0IGFmdGVyICclJyAqKVxuICBhbmQgcGFyc2VfZm9ybWF0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgZW5kX2luZCAtPiBwYXJzZV9pZ24gcGN0X2luZCAocGN0X2luZCArIDEpIGVuZF9pbmRcblxuICBhbmQgcGFyc2VfaWduIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdfJyAtPiBwYXJzZV9mbGFncyBwY3RfaW5kIChzdHJfaW5kKzEpIGVuZF9pbmQgdHJ1ZVxuICAgICAgfCBfIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGZhbHNlXG5cbiAgYW5kIHBhcnNlX2ZsYWdzIDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiXG4gID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIGlnbiAtPlxuICAgIGxldCB6ZXJvID0gcmVmIGZhbHNlIGFuZCBtaW51cyA9IHJlZiBmYWxzZVxuICAgIGFuZCBwbHVzID0gcmVmIGZhbHNlIGFuZCBzcGFjZSA9IHJlZiBmYWxzZVxuICAgIGFuZCBoYXNoID0gcmVmIGZhbHNlIGluXG4gICAgbGV0IHNldF9mbGFnIHN0cl9pbmQgZmxhZyA9XG4gICAgICAoKiBpbiBsZWdhY3kgbW9kZSwgZHVwbGljYXRlIGZsYWdzIGFyZSBhY2NlcHRlZCAqKVxuICAgICAgaWYgIWZsYWcgJiYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBkdXBsaWNhdGUgZmxhZyAlQ1wiXG4gICAgICAgICAgc3RyIHN0cl9pbmQgc3RyLltzdHJfaW5kXTtcbiAgICAgIGZsYWcgOj0gdHJ1ZTtcbiAgICBpblxuICAgIGxldCByZWMgcmVhZF9mbGFncyBzdHJfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzAnIC0+IHNldF9mbGFnIHN0cl9pbmQgemVybzsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnLScgLT4gc2V0X2ZsYWcgc3RyX2luZCBtaW51czsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcrJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHBsdXM7ICByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyMnIC0+IHNldF9mbGFnIHN0cl9pbmQgaGFzaDsgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICcgJyAtPiBzZXRfZmxhZyBzdHJfaW5kIHNwYWNlOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgXyAtPlxuICAgICAgICBwYXJzZV9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kXG4gICAgICAgICAgIXplcm8gIW1pbnVzICFwbHVzICFoYXNoICFzcGFjZSBpZ25cbiAgICAgIGVuZFxuICAgIGluXG4gICAgcmVhZF9mbGFncyBzdHJfaW5kXG5cbiAgKCogVHJ5IHRvIHJlYWQgYSBkaWdpdGFsIG9yIGEgJyonIHBhZGRpbmcuICopXG4gIGFuZCBwYXJzZV9wYWRkaW5nIDogdHlwZSBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgemVybyBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBsZXQgcGFkdHkgPSBtYXRjaCB6ZXJvLCBtaW51cyB3aXRoXG4gICAgICB8IGZhbHNlLCBmYWxzZSAtPiBSaWdodFxuICAgICAgfCBmYWxzZSwgdHJ1ZSAgLT4gTGVmdFxuICAgICAgfCAgdHJ1ZSwgZmFsc2UgLT4gWmVyb3NcbiAgICAgIHwgIHRydWUsIHRydWUgIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIExlZnRcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJy0nIFwiMFwiIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICBsZXQgbmV3X2luZCwgd2lkdGggPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIG5ld19pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIChMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSlcbiAgICB8ICcqJyAtPlxuICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIChBcmdfcGFkZGluZyBwYWR0eSlcbiAgICB8IF8gLT5cbiAgICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICAgIHwgTGVmdCAgLT5cbiAgICAgICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICctJyBcInBhZGRpbmdcIjtcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgfCBaZXJvcyAtPlxuICAgICAgICAgKCogYSAnMCcgcGFkZGluZyBpbmRpY2F0aW9uIG5vdCBmb2xsb3dlZCBieSBhbnl0aGluZyBzaG91bGRcbiAgICAgICAgICAgYmUgaW50ZXJwcmV0ZWQgYXMgYSBSaWdodCBwYWRkaW5nIG9mIHdpZHRoIDAuIFRoaXMgaXMgdXNlZFxuICAgICAgICAgICBieSBzY2FubmluZyBjb252ZXJzaW9ucyAlMHMgYW5kICUwYyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICAoTGl0X3BhZGRpbmcgKFJpZ2h0LCAwKSlcbiAgICAgIHwgUmlnaHQgLT5cbiAgICAgICAgcGFyc2VfYWZ0ZXJfcGFkZGluZyBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgICAgTm9fcGFkZGluZ1xuICAgICAgZW5kXG5cbiAgKCogSXMgcHJlY2lzaW9uIGRlZmluZWQ/ICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wYWRkaW5nIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJy4nIC0+XG4gICAgICBwYXJzZV9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWRcbiAgICB8IHN5bWIgLT5cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgTm9fcHJlY2lzaW9uIHBhZCBzeW1iXG5cbiAgKCogUmVhZCB0aGUgZGlnaXRhbCBvciAnKicgcHJlY2lzaW9uLiAqKVxuICBhbmQgcGFyc2VfcHJlY2lzaW9uIDogdHlwZSB4IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT5cbiAgICAgICAgKHgsIF8pIHBhZGRpbmcgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9saXRlcmFsIG1pbnVzIHN0cl9pbmQgPVxuICAgICAgbGV0IG5ld19pbmQsIHByZWMgPSBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMCBpblxuICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgcGFkIChMaXRfcHJlY2lzaW9uIHByZWMpIGluXG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZFxuICAgIHwgKCcrJyB8ICctJykgYXMgc3ltYiB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPlxuICAgICAgKCogTGVnYWN5IG1vZGUgd291bGQgYWNjZXB0IGFuZCBpZ25vcmUgJysnIG9yICctJyBiZWZvcmUgdGhlXG4gICAgICAgICBpbnRlZ2VyIGRlc2NyaWJpbmcgdGhlIGRlc2lyZWQgcHJlY2lzaW9uOyBub3RlIHRoYXQgdGhpc1xuICAgICAgICAgY2Fubm90IGhhcHBlbiBmb3IgcGFkZGluZyB3aWR0aCwgYXMgJysnIGFuZCAnLScgYWxyZWFkeSBoYXZlXG4gICAgICAgICBhIHNlbWFudGljcyB0aGVyZS5cblxuICAgICAgICAgVGhhdCBzYWlkLCB0aGUgaWRlYSAoc3VwcG9ydGVkIGJ5IHRoaXMgdHdlYWspIHRoYXQgd2lkdGggYW5kXG4gICAgICAgICBwcmVjaXNpb24gbGl0ZXJhbHMgYXJlIFwiaW50ZWdlciBsaXRlcmFsc1wiIGluIHRoZSBPQ2FtbCBzZW5zZSBpc1xuICAgICAgICAgc3RpbGwgYmxhdGFudGx5IHdyb25nLCBhcyAxMjNfNDU2IG9yIDB4RkYgYXJlIHJlamVjdGVkLiAqKVxuICAgICAgcGFyc2VfbGl0ZXJhbCAobWludXMgfHwgc3ltYiA9ICctJykgKHN0cl9pbmQgKyAxKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlXG4gICAgICAgIGlnbiBwYWQgQXJnX3ByZWNpc2lvblxuICAgIHwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogbm90ZSB0aGF0IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkaWQgbm90IGlnbm9yZSAnLicgd2l0aG91dFxuICAgICAgICAgICBhIG51bWJlciAoYXMgaXQgZG9lcyBmb3IgcGFkZGluZyBpbmRpY2F0aW9ucyksIGJ1dFxuICAgICAgICAgICBpbnRlcnByZXRzIGl0IGFzICcuMCcgKilcbiAgICAgICAgcGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gMClcbiAgICAgIGVsc2VcbiAgICAgICAgaW52YWxpZF9mb3JtYXRfd2l0aG91dCAoc3RyX2luZCAtIDEpICcuJyBcInByZWNpc2lvblwiXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIGNvbnZlcnNpb24uICopXG4gIGFuZCBwYXJzZV9hZnRlcl9wcmVjaXNpb24gOiB0eXBlIHggeSB6IHQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYXJzZV9jb252ICh0eXBlIHUpICh0eXBlIHYpIChwYWRwcmVjIDogKHUsIHYpIHBhZGRpbmcpID1cbiAgICAgIHBhcnNlX2NvbnZlcnNpb24gcGN0X2luZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWRcbiAgICAgICAgcHJlYyBwYWRwcmVjIHN0ci5bc3RyX2luZF0gaW5cbiAgICAoKiBpbiBsZWdhY3kgbW9kZSwgc29tZSBmb3JtYXRzICglcyBhbmQgJVMpIGFjY2VwdCBhIHdlaXJkIG1peCBvZlxuICAgICAgIHBhZGRpbmcgYW5kIHByZWNpc2lvbiwgd2hpY2ggaXMgbWVyZ2VkIGFzIGEgc2luZ2xlIHBhZGRpbmdcbiAgICAgICBpbmZvcm1hdGlvbi4gRm9yIGV4YW1wbGUsIGluICUuMTBzIHRoZSBwcmVjaXNpb24gaXMgaW1wbGljaXRseVxuICAgICAgIHVuZGVyc3Rvb2QgYXMgcGFkZGluZyAlMTBzLCBidXQgdGhlIGxlZnQtcGFkZGluZyBjb21wb25lbnQgbWF5XG4gICAgICAgYmUgc3BlY2lmaWVkIGVpdGhlciBhcyBhIGxlZnQgcGFkZGluZyBvciBhIG5lZ2F0aXZlIHByZWNpc2lvbjpcbiAgICAgICAlLS4zcyBhbmQgJS4tM3MgYXJlIGVxdWl2YWxlbnQgdG8gJS0zcyAqKVxuICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgfCBOb19wYWRkaW5nIC0+IChcbiAgICAgIG1hdGNoIG1pbnVzLCBwcmVjIHdpdGhcbiAgICAgICAgfCBfLCBOb19wcmVjaXNpb24gLT4gcGFyc2VfY29udiBOb19wYWRkaW5nXG4gICAgICAgIHwgZmFsc2UsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoUmlnaHQsIG4pKVxuICAgICAgICB8IHRydWUsIExpdF9wcmVjaXNpb24gbiAtPiBwYXJzZV9jb252IChMaXRfcGFkZGluZyAoTGVmdCwgbikpXG4gICAgICAgIHwgZmFsc2UsIEFyZ19wcmVjaXNpb24gLT4gcGFyc2VfY29udiAoQXJnX3BhZGRpbmcgUmlnaHQpXG4gICAgICAgIHwgdHJ1ZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBMZWZ0KVxuICAgIClcbiAgICB8IHBhZCAtPiBwYXJzZV9jb252IHBhZFxuXG4gICgqIENhc2UgYW5hbHlzaXMgb24gY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2NvbnZlcnNpb24gOiB0eXBlIHggeSB6IHQgdSB2IGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+ICh4LCB5KSBwYWRkaW5nIC0+XG4gICAgICAgICh6LCB0KSBwcmVjaXNpb24gLT4gKHUsIHYpIHBhZGRpbmcgLT4gY2hhciAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCBwcmVjIHBhZHByZWMgc3ltYiAtPlxuICAgICgqIEZsYWdzIHVzZWQgdG8gY2hlY2sgb3B0aW9uIHVzYWdlcy9jb21wYXRpYmlsaXRpZXMuICopXG4gICAgbGV0IHBsdXNfdXNlZCAgPSByZWYgZmFsc2UgYW5kIGhhc2hfdXNlZCA9IHJlZiBmYWxzZVxuICAgIGFuZCBzcGFjZV91c2VkID0gcmVmIGZhbHNlIGFuZCBpZ25fdXNlZCAgID0gcmVmIGZhbHNlXG4gICAgYW5kIHBhZF91c2VkICAgPSByZWYgZmFsc2UgYW5kIHByZWNfdXNlZCAgPSByZWYgZmFsc2UgaW5cblxuICAgICgqIEFjY2VzcyB0byBvcHRpb25zLCB1cGRhdGUgZmxhZ3MuICopXG4gICAgbGV0IGdldF9wbHVzICAgICgpID0gcGx1c191c2VkICA6PSB0cnVlOyBwbHVzXG4gICAgYW5kIGdldF9oYXNoICAgKCkgPSBoYXNoX3VzZWQgOj0gdHJ1ZTsgaGFzaFxuICAgIGFuZCBnZXRfc3BhY2UgICAoKSA9IHNwYWNlX3VzZWQgOj0gdHJ1ZTsgc3BhY2VcbiAgICBhbmQgZ2V0X2lnbiAgICAgKCkgPSBpZ25fdXNlZCAgIDo9IHRydWU7IGlnblxuICAgIGFuZCBnZXRfcGFkICAgICAoKSA9IHBhZF91c2VkICAgOj0gdHJ1ZTsgcGFkXG4gICAgYW5kIGdldF9wcmVjICAgICgpID0gcHJlY191c2VkICA6PSB0cnVlOyBwcmVjXG4gICAgYW5kIGdldF9wYWRwcmVjICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRwcmVjIGluXG5cbiAgICBsZXQgZ2V0X2ludF9wYWQgKCkgOiAoeCx5KSBwYWRkaW5nID1cbiAgICAgICgqICU1LjNkIGlzIGFjY2VwdGVkIGFuZCBtZWFuaW5nZnVsOiBwYWQgdG8gbGVuZ3RoIDUgd2l0aFxuICAgICAgICAgc3BhY2VzLCBidXQgZmlyc3QgcGFkIHdpdGggemVyb3MgdXB0byBsZW5ndGggMyAoMC1wYWRkaW5nXG4gICAgICAgICBpcyB0aGUgaW50ZXJwcmV0YXRpb24gb2YgXCJwcmVjaXNpb25cIiBmb3IgaW50ZWdlciBmb3JtYXRzKS5cblxuICAgICAgICAgJTA1LjNkIGlzIHJlZHVuZGFudDogcGFkIHRvIGxlbmd0aCA1ICp3aXRoIHplcm9zKiwgYnV0XG4gICAgICAgICBmaXJzdCBwYWQgd2l0aCB6ZXJvcy4uLiBUbyBhZGQgaW5zdWx0IHRvIHRoZSBpbmp1cnksIHRoZVxuICAgICAgICAgbGVnYWN5IGltcGxlbWVudGF0aW9uIGlnbm9yZXMgdGhlIDAtcGFkZGluZyBpbmRpY2F0aW9uIGFuZFxuICAgICAgICAgZG9lcyB0aGUgNSBwYWRkaW5nIHdpdGggc3BhY2VzIGluc3RlYWQuIFdlIHJldXNlIHRoaXNcbiAgICAgICAgIGludGVycHJldGF0aW9uIGZvciBjb21wYXRpYmlsaXR5LCBidXQgc3RhdGljYWxseSByZWplY3QgdGhpc1xuICAgICAgICAgZm9ybWF0IHdoZW4gdGhlIGxlZ2FjeSBtb2RlIGlzIGRpc2FibGVkLCB0byBwcm90ZWN0IHN0cmljdFxuICAgICAgICAgdXNlcnMgZnJvbSB0aGlzIGNvcm5lciBjYXNlLiAqKVxuICAgICAgIG1hdGNoIGdldF9wYWQgKCksIGdldF9wcmVjICgpIHdpdGhcbiAgICAgICAgIHwgcGFkLCBOb19wcmVjaXNpb24gLT4gcGFkXG4gICAgICAgICB8IE5vX3BhZGRpbmcsIF8gICAgIC0+IE5vX3BhZGRpbmdcbiAgICAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCBuKSwgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIG4pXG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IEFyZ19wYWRkaW5nIFplcm9zLCBfIC0+XG4gICAgICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcwJyBcInByZWNpc2lvblwiXG4gICAgICAgICB8IExpdF9wYWRkaW5nIF8gYXMgcGFkLCBfIC0+IHBhZFxuICAgICAgICAgfCBBcmdfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWQgaW5cblxuICAgICgqIENoZWNrIHRoYXQgcGFkdHkgPD4gWmVyb3MuICopXG4gICAgbGV0IGNoZWNrX25vXzAgc3ltYiAodHlwZSBhIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgOiAoYSxiKSBwYWRkaW5nID1cbiAgICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gcGFkXG4gICAgICB8IExpdF9wYWRkaW5nICgoTGVmdCB8IFJpZ2h0KSwgXykgLT4gcGFkXG4gICAgICB8IEFyZ19wYWRkaW5nIChMZWZ0IHwgUmlnaHQpIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgICB8IEFyZ19wYWRkaW5nIFplcm9zIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIEFyZ19wYWRkaW5nIFJpZ2h0XG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCIwXCJcbiAgICBpblxuXG4gICAgKCogR2V0IHBhZGRpbmcgYXMgYSBwYWRfb3B0aW9uIChzZWUgXCIlX1wiLCBcIiV7XCIsIFwiJShcIiBhbmQgXCIlW1wiKS5cbiAgICAgICAobm8gbmVlZCBmb3IgbGVnYWN5IG1vZGUgdHdlYWtpbmcsIHRob3NlIHdlcmUgcmVqZWN0ZWQgYnkgdGhlXG4gICAgICAgbGVnYWN5IHBhcnNlciBhcyB3ZWxsKSAqKVxuICAgIGxldCBvcHRfb2ZfcGFkIGMgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9IG1hdGNoIHBhZCB3aXRoXG4gICAgICB8IE5vX3BhZGRpbmcgLT4gTm9uZVxuICAgICAgfCBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKSAtPiBTb21lIHdpZHRoXG4gICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicwJ1wiXG4gICAgICB8IExpdF9wYWRkaW5nIChMZWZ0LCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gU29tZSB3aWR0aFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBjIFwiJy0nXCJcbiAgICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIicqJ1wiXG4gICAgaW5cbiAgICBsZXQgZ2V0X3BhZF9vcHQgYyA9IG9wdF9vZl9wYWQgYyAoZ2V0X3BhZCAoKSkgaW5cbiAgICBsZXQgZ2V0X3BhZHByZWNfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWRwcmVjICgpKSBpblxuXG4gICAgKCogR2V0IHByZWNpc2lvbiBhcyBhIHByZWNfb3B0aW9uIChzZWUgXCIlX2ZcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgZ2V0X3ByZWNfb3B0ICgpID0gbWF0Y2ggZ2V0X3ByZWMgKCkgd2l0aFxuICAgICAgfCBOb19wcmVjaXNpb24gICAgICAgLT4gTm9uZVxuICAgICAgfCBMaXRfcHJlY2lzaW9uIG5kZWMgLT4gU29tZSBuZGVjXG4gICAgICB8IEFyZ19wcmVjaXNpb24gICAgICAtPiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJyonXCJcbiAgICBpblxuXG4gICAgbGV0IGZtdF9yZXN1bHQgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICcsJyAtPlxuICAgICAgcGFyc2Ugc3RyX2luZCBlbmRfaW5kXG4gICAgfCAnYycgLT5cbiAgICAgIGxldCBjaGFyX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICVjICopXG4gICAgICAgIGlmIGdldF9pZ24gKClcbiAgICAgICAgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChDaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBzY2FuX2Zvcm1hdCBmbXRfcmVzdCA9ICgqICUwYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9zY2FuX25leHRfY2hhciwgZm10X3Jlc3QpKVxuICAgICAgICBlbHNlIEZtdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdF9yZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBiZWdpbiBtYXRjaCBnZXRfcGFkX29wdCAnYycgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gY2hhcl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIDAgLT4gc2Nhbl9mb3JtYXQgZm10X3Jlc3RcbiAgICAgICAgfCBTb21lIF9uIC0+XG4gICAgICAgICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3JcbiAgICAgICAgICAgdGhlbiBpbnZhbGlkX25vbm51bGxfY2hhcl93aWR0aCBzdHJfaW5kXG4gICAgICAgICAgIGVsc2UgKCogbGVnYWN5IGlnbm9yZXMgJWMgd2lkdGhzICopIGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICBlbmRcbiAgICB8ICdDJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX2NhbWxfY2hhcixmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKENhbWxfY2hhciBmbXRfcmVzdClcbiAgICB8ICdzJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKFN0cmluZyAocGFkJywgZm10X3Jlc3QnKSlcbiAgICB8ICdTJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9jYW1sX3N0cmluZyAoZ2V0X3BhZHByZWNfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkZGluZ19mbXRfRUJCIChwYWQnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZGRpbmdfZm10X2ViYiBwYWQgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT5cbiAgICAgIGxldCBpY29udiA9IGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIChnZXRfcGx1cyAoKSkgKGdldF9oYXNoICgpKVxuICAgICAgICAoZ2V0X3NwYWNlICgpKSBzeW1iIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdOJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gVG9rZW5fY291bnRlciBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIGNvdW50ZXIgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCkpXG4gICAgfCAnbCcgfCAnbicgfCAnTCcgd2hlbiBzdHJfaW5kPWVuZF9pbmQgfHwgbm90IChpc19pbnRfYmFzZSBzdHIuW3N0cl9pbmRdKSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGxldCBjb3VudGVyID0gY291bnRlcl9vZl9jaGFyIHN5bWIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQzMiAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDMyIChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnbicgLT5cbiAgICAgIGxldCBpY29udiA9XG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCAoc3RyX2luZCArIDEpIChnZXRfcGx1cyAoKSlcbiAgICAgICAgICAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX25hdGl2ZWludCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ0wnIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgICAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9pbnQ2NCAoaWNvbnYsIGdldF9wYWRfb3B0ICdfJykgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9pbnRfcGFkICgpKSAoZ2V0X3ByZWMgKCkpIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEludDY0IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnZicgfCAnZScgfCAnRScgfCAnZycgfCAnRycgfCAnRicgfCAnaCcgfCAnSCcgLT5cbiAgICAgIGxldCBmY29udiA9XG4gICAgICAgIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmRcbiAgICAgICAgICAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSkgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZmxvYXQgKGdldF9wYWRfb3B0ICdfJywgZ2V0X3ByZWNfb3B0ICgpKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2InIHwgJ0InIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Jvb2wgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEJvb2wgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnYScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChBbHBoYSBmbXRfcmVzdClcbiAgICB8ICd0JyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKFRoZXRhIGZtdF9yZXN0KVxuICAgIHwgJ3InIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKFJlYWRlciBmbXRfcmVzdClcbiAgICB8ICchJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZsdXNoIGZtdF9yZXN0KVxuICAgIHwgKCclJyB8ICdAJykgYXMgYyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoYywgZm10X3Jlc3QpKVxuICAgIHwgJ3snIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnfScgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ3snLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICcoJyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJyknIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnKCcsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJ1snIC0+XG4gICAgICBsZXQgbmV4dF9pbmQsIGNoYXJfc2V0ID0gcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ18nLCBjaGFyX3NldCkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnWycsIGNoYXJfc2V0LCBmbXRfcmVzdCkpXG4gICAgfCAnLScgfCAnKycgfCAnIycgfCAnICcgfCAnXycgLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGZsYWcgJUMgaXMgb25seSBhbGxvd2VkIGFmdGVyIHRoZSAnJSUnLCBiZWZvcmUgcGFkZGluZyBhbmQgcHJlY2lzaW9uXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgc3ltYlxuICAgIHwgXyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgaW52YWxpZCBjb252ZXJzaW9uIFxcXCIlJSVjXFxcIlwiIHN0ciAoc3RyX2luZCAtIDEpIHN5bWJcbiAgICBpblxuICAgICgqIENoZWNrIGZvciB1bnVzZWQgb3B0aW9ucywgYW5kIHJlamVjdCB0aGVtIGFzIGluY29tcGF0aWJsZS5cblxuICAgICAgIFN1Y2ggY2hlY2tzIG5lZWQgdG8gYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsIGFzIHRoZSBsZWdhY3lcbiAgICAgICBwYXJzZXIgc2lsZW50bHkgaWdub3JlZCBpbmNvbXBhdGlibGUgZmxhZ3MuICopXG4gICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuIGJlZ2luXG4gICAgaWYgbm90ICFwbHVzX3VzZWQgJiYgcGx1cyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiO1xuICAgIGlmIG5vdCAhaGFzaF91c2VkICYmIGhhc2ggdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIjtcbiAgICBpZiBub3QgIXNwYWNlX3VzZWQgJiYgc3BhY2UgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIjtcbiAgICBpZiBub3QgIXBhZF91c2VkICAmJiBQYWRkaW5nX0VCQiBwYWQgPD4gUGFkZGluZ19FQkIgTm9fcGFkZGluZyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcImBwYWRkaW5nJ1wiO1xuICAgIGlmIG5vdCAhcHJlY191c2VkICYmIFByZWNpc2lvbl9FQkIgcHJlYyA8PiBQcmVjaXNpb25fRUJCIE5vX3ByZWNpc2lvbiB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgKGlmIGlnbiB0aGVuICdfJyBlbHNlIHN5bWIpXG4gICAgICAgIFwiYHByZWNpc2lvbidcIjtcbiAgICBpZiBpZ24gJiYgcGx1cyB0aGVuIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKydcIjtcbiAgICBlbmQ7XG4gICAgKCogdGhpcyBsYXN0IHRlc3QgbXVzdCBub3QgYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsXG4gICAgICAgYXMgaWdub3JpbmcgaXQgd291bGQgdHlwaWNhbGx5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0eXBpbmdcbiAgICAgICB0aGFuIHdoYXQgdGhlIGxlZ2FjeSBwYXJzZXIgdXNlZCAqKVxuICAgIGlmIG5vdCAhaWduX3VzZWQgJiYgaWduIHRoZW5cbiAgICAgIGJlZ2luIG1hdGNoIHN5bWIgd2l0aFxuICAgICAgICAoKiBhcmd1bWVudC1sZXNzIGZvcm1hdHMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIGluIGxlZ2FjeSBtb2RlICopXG4gICAgICAgIHwgKCdAJyB8ICclJyB8ICchJyB8ICcsJykgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gKClcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInXydcIlxuICAgICAgZW5kO1xuICAgIGZtdF9yZXN1bHRcblxuICAoKiBQYXJzZSBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIChhZnRlciAnQCcpLiAqKVxuICBhbmQgcGFyc2VfYWZ0ZXJfYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKCdAJywgRW5kX29mX2Zvcm1hdCkpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICdbJyAtPlxuICAgICAgICBwYXJzZV90YWcgZmFsc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICddJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfYm94LCBmbXRfcmVzdCkpXG4gICAgICB8ICd7JyAtPlxuICAgICAgICBwYXJzZV90YWcgdHJ1ZSAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJ30nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChDbG9zZV90YWcsIGZtdF9yZXN0KSlcbiAgICAgIHwgJywnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJALFwiLCAwLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEJyZWFrIChcIkAgXCIsIDEsIDApLCBmbXRfcmVzdCkpXG4gICAgICB8ICc7JyAtPlxuICAgICAgICBwYXJzZV9nb29kX2JyZWFrIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnPycgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZGbHVzaCwgZm10X3Jlc3QpKVxuICAgICAgfCAnXFxuJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRm9yY2VfbmV3bGluZSwgZm10X3Jlc3QpKVxuICAgICAgfCAnLicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZsdXNoX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIHBhcnNlX21hZ2ljX3NpemUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICdAJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoRXNjYXBlZF9hdCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgd2hlbiBzdHJfaW5kICsgMSA8IGVuZF9pbmQgJiYgc3RyLltzdHJfaW5kICsgMV0gPSAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfcGVyY2VudCwgZm10X3Jlc3QpKVxuICAgICAgfCAnJScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIGZtdF9yZXN0KSlcbiAgICAgIHwgYyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyBjLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDxuYW1lPiBhZnRlciBcIkB7XCIgb3IgXCJAW1wiLiAqKVxuICBhbmQgcGFyc2VfdGFnIDogdHlwZSBlIGYgLiBib29sIC0+IGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gaXNfb3Blbl90YWcgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgdHJ5XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnPCcgLT5cbiAgICAgICAgbGV0IGluZCA9IFN0cmluZy5pbmRleF9mcm9tIHN0ciAoc3RyX2luZCArIDEpICc+JyBpblxuICAgICAgICBpZiBpbmQgPj0gZW5kX2luZCB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciBzdHJfaW5kIChpbmQgLSBzdHJfaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCAoaW5kICsgMSkgaW5cbiAgICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKHN1Yl9mbXQsIHN1Yl9zdHIpIGluXG4gICAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgICBpZiBpc19vcGVuX3RhZyB0aGVuIE9wZW5fdGFnIHN1Yl9mb3JtYXQgZWxzZSBPcGVuX2JveCBzdWJfZm9ybWF0IGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG4gICAgICB8IF8gLT5cbiAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoRW5kX29mX2Zvcm1hdCwgXCJcIikgaW5cbiAgICAgIGxldCBmb3JtYXR0aW5nID1cbiAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmcsIGZtdF9yZXN0KSlcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPHdpZHRoIG9mZnNldD4gYWZ0ZXIgXCJAO1wiLiAqKVxuICBhbmQgcGFyc2VfZ29vZF9icmVhayA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBsZXQgbmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0ID1cbiAgICAgIHRyeVxuICAgICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB8fCBzdHIuW3N0cl9pbmRdIDw+ICc8JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgbGV0IHN0cl9pbmRfMSA9IHBhcnNlX3NwYWNlcyAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXzFdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IChcbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCB3aWR0aCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8xIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8zXSB3aXRoXG4gICAgICAgICAgICAgIHwgJz4nIC0+XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF8zLXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzMgKyAxLCBCcmVhayAocywgd2lkdGgsIDApXG4gICAgICAgICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgICAgICAgIGxldCBzdHJfaW5kXzQsIG9mZnNldCA9IHBhcnNlX2ludGVnZXIgc3RyX2luZF8zIGVuZF9pbmQgaW5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF81ID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfNCBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgaWYgc3RyLltzdHJfaW5kXzVdIDw+ICc+JyB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IFN0cmluZy5zdWIgc3RyIChzdHJfaW5kLTIpIChzdHJfaW5kXzUtc3RyX2luZCszKSBpblxuICAgICAgICAgICAgICAgIHN0cl9pbmRfNSArIDEsIEJyZWFrIChzLCB3aWR0aCwgb2Zmc2V0KVxuICAgICAgICAgICAgICB8IF8gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIClcbiAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgd2l0aCBOb3RfZm91bmQgfCBGYWlsdXJlIF8gLT5cbiAgICAgICAgc3RyX2luZCwgQnJlYWsgKFwiQDtcIiwgMSwgMClcbiAgICBpblxuICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgbmV4dF9pbmQgZW5kX2luZCBpblxuICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIHRoZSBzaXplIGluIGEgPG4+LiAqKVxuICBhbmQgcGFyc2VfbWFnaWNfc2l6ZSA6IHR5cGUgZSBmIC4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBtYXRjaFxuICAgICAgdHJ5XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPlxuICAgICAgICAgIGxldCBzdHJfaW5kXzIsIHNpemUgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMyA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzIgZW5kX2luZCBpblxuICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF8zXSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZCAtIDIpIChzdHJfaW5kXzMgLSBzdHJfaW5kICsgMykgaW5cbiAgICAgICAgICBTb21lIChzdHJfaW5kXzMgKyAxLCBNYWdpY19zaXplIChzLCBzaXplKSlcbiAgICAgICAgfCBfIC0+IE5vbmVcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIE5vbmVcbiAgICB3aXRoXG4gICAgfCBTb21lIChuZXh0X2luZCwgZm9ybWF0dGluZ19saXQpIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChmb3JtYXR0aW5nX2xpdCwgZm10X3Jlc3QpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChTY2FuX2luZGljICc8JywgZm10X3Jlc3QpKVxuXG4gICgqIFBhcnNlIGFuZCBjb25zdHJ1Y3QgYSBjaGFyIHNldC4gKilcbiAgYW5kIHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcblxuICAgIGxldCBjaGFyX3NldCA9IGNyZWF0ZV9jaGFyX3NldCAoKSBpblxuICAgIGxldCBhZGRfY2hhciBjID1cbiAgICAgIGFkZF9pbl9jaGFyX3NldCBjaGFyX3NldCBjO1xuICAgIGluXG4gICAgbGV0IGFkZF9yYW5nZSBjIGMnID1cbiAgICAgIGZvciBpID0gaW50X29mX2NoYXIgYyB0byBpbnRfb2ZfY2hhciBjJyBkb1xuICAgICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgKGNoYXJfb2ZfaW50IGkpO1xuICAgICAgZG9uZTtcbiAgICBpblxuXG4gICAgbGV0IGZhaWxfc2luZ2xlX3BlcmNlbnQgc3RyX2luZCA9XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6ICclJScgYWxvbmUgaXMgbm90IGFjY2VwdGVkIGluIGNoYXJhY3RlciBzZXRzLCBcXFxuICAgICAgICAgdXNlICUlJSUgaW5zdGVhZCBhdCBwb3NpdGlvbiAlZC5cIiBzdHIgc3RyX2luZFxuICAgIGluXG5cbiAgICAoKiBQYXJzZSB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgY2hhciBzZXQuICopXG4gICAgbGV0IHJlYyBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGxldCBjID0gc3RyLltzdHJfaW5kXSBpblxuICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICAgKCogUGFyc2UgdGhlIGNvbnRlbnQgb2YgYSBjaGFyIHNldCB1bnRpbCB0aGUgZmlyc3QgJ10nLiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9jb250ZW50IHN0cl9pbmQgZW5kX2luZCA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgYWRkX2NoYXIgJy0nO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjIC0+XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFRlc3QgZm9yIHJhbmdlIGluIGNoYXIgc2V0LiAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICctJyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyB3aGVuIGMgPSAnJScgLT5cbiAgICAgICAgYWRkX2NoYXIgYyc7XG4gICAgICAgIHBhcnNlX2NoYXJfc2V0X2NvbnRlbnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGlmIGMgPSAnJScgdGhlbiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQ7XG4gICAgICAgICgqIG5vdGUgdGhhdCAnQCcgYWxvbmUgaXMgYWNjZXB0ZWQsIGFzIGRvbmUgYnkgdGhlIGxlZ2FjeVxuICAgICAgICAgICBpbXBsZW1lbnRhdGlvbjsgdGhlIGRvY3VtZW50YXRpb24gc3BlY2lmaWNhbGx5IHJlcXVpcmVzICVAXG4gICAgICAgICAgIHNvIHdlIGNvdWxkIHdhcm4gb24gdGhhdCAqKVxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjJ1xuXG4gICAgKCogTWFuYWdlIHJhbmdlIGluIGNoYXIgc2V0IChleGNlcHQgaWYgdGhlICctJyB0aGUgbGFzdCBjaGFyIGJlZm9yZSAnXScpICopXG4gICAgYW5kIHBhcnNlX2NoYXJfc2V0X2FmdGVyX21pbnVzIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ10nIC0+XG4gICAgICAgIGFkZF9jaGFyIGM7XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICAgICAgfCAoJyUnIHwgJ0AnKSBhcyBjJyAtPlxuICAgICAgICAgICAgYWRkX3JhbmdlIGMgYyc7XG4gICAgICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMikgZW5kX2luZFxuICAgICAgICAgIHwgXyAtPiBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmRcbiAgICAgICAgZW5kXG4gICAgICB8IGMnIC0+XG4gICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgIGluXG4gICAgbGV0IHN0cl9pbmQsIHJldmVyc2UgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgICB8ICdeJyAtPiBzdHJfaW5kICsgMSwgdHJ1ZVxuICAgICAgICB8IF8gLT4gc3RyX2luZCwgZmFsc2UgaW5cbiAgICBsZXQgbmV4dF9pbmQgPSBwYXJzZV9jaGFyX3NldF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICBsZXQgY2hhcl9zZXQgPSBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgaW5cbiAgICBuZXh0X2luZCwgKGlmIHJldmVyc2UgdGhlbiByZXZfY2hhcl9zZXQgY2hhcl9zZXQgZWxzZSBjaGFyX3NldClcblxuICAoKiBDb25zdW1lIGFsbCBuZXh0IHNwYWNlcywgcmFpc2UgYW4gRmFpbHVyZSBpZiBlbmRfaW5kIGlzIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9zcGFjZXMgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGlmIHN0ci5bc3RyX2luZF0gPSAnICcgdGhlbiBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGVsc2Ugc3RyX2luZFxuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlIGlmIGVuZF9pbmQgaXNcbiAgICAgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCBhY2MgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gYWNjICogMTAgKyAoaW50X29mX2NoYXIgYyAtIGludF9vZl9jaGFyICcwJykgaW5cbiAgICAgIGlmIG5ld19hY2MgPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlblxuICAgICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogaW50ZWdlciAlZCBpcyBncmVhdGVyIHRoYW4gdGhlIGxpbWl0ICVkXCJcbiAgICAgICAgICBzdHIgbmV3X2FjYyBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICAgIGVsc2VcbiAgICAgICAgcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG5ld19hY2NcbiAgICB8IF8gLT4gc3RyX2luZCwgYWNjXG5cbiAgKCogUmVhZCBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgZnJvbSB0aGUgc3RyaW5nLCByYWlzZSBhIEZhaWx1cmVcbiAgICAgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2VfaW50ZWdlciBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwXG4gICAgfCAnLScgLT4gKFxuICAgICAgaWYgc3RyX2luZCArIDEgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmQgKyAxXSB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgICAgbGV0IG5leHRfaW5kLCBuID0gcGFyc2VfcG9zaXRpdmUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIDAgaW5cbiAgICAgICAgbmV4dF9pbmQsIC1uXG4gICAgICB8IGMgLT5cbiAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJkaWdpdFwiIGNcbiAgICApXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIEFkZCBhIGxpdGVyYWwgdG8gYSBmb3JtYXQgZnJvbSBhIGxpdGVyYWwgY2hhcmFjdGVyIHN1Yi1zZXF1ZW5jZS4gKilcbiAgYW5kIGFkZF9saXRlcmFsIDogdHlwZSBhIGQgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gKGEsIF8sIF8sIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gbGl0X3N0YXJ0IHN0cl9pbmQgZm10IC0+IG1hdGNoIHN0cl9pbmQgLSBsaXRfc3RhcnQgd2l0aFxuICAgIHwgMCAgICAtPiBGbXRfRUJCIGZtdFxuICAgIHwgMSAgICAtPiBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKHN0ci5bbGl0X3N0YXJ0XSwgZm10KSlcbiAgICB8IHNpemUgLT4gRm10X0VCQiAoU3RyaW5nX2xpdGVyYWwgKFN0cmluZy5zdWIgc3RyIGxpdF9zdGFydCBzaXplLCBmbXQpKVxuXG4gICgqIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXRcbiAgICAgKGkuZS4gdGhlIGNvcnJlc3BvbmRpbmcgXCIlfVwiIG9yIFwiJSlcIikgKilcbiAgYW5kIHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCBjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuXG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IHVuY2xvc2VkIHN1Yi1mb3JtYXQsIFxcXG4gICAgICAgICBleHBlY3RlZCBcXFwiJSUlY1xcXCIgYXQgY2hhcmFjdGVyIG51bWJlciAlZFwiIHN0ciBjIGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnJScgLT5cbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgaWYgc3RyLltzdHJfaW5kICsgMV0gPSBjIHRoZW4gKCogRW5kIG9mIGZvcm1hdCBmb3VuZCAqKSBzdHJfaW5kIGVsc2VcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICB8ICdfJyAtPlxuICAgICAgICAgICgqIFNlYXJjaCBmb3IgXCIlXyhcIiBvciBcIiVfe1wiLiAqKVxuICAgICAgICAgIGlmIHN0cl9pbmQgKyAyID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDJdIHdpdGhcbiAgICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJ30nIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgICAgfCBfIC0+IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMykgZW5kX2luZCBjXG4gICAgICAgICAgZW5kXG4gICAgICAgIHwgJ3snIC0+XG4gICAgICAgICAgKCogJXsuLi4lfSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJygnIC0+XG4gICAgICAgICAgKCogJSguLi4lKSBzdWItZm9ybWF0IGZvdW5kLiAqKVxuICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAyKSBlbmRfaW5kICcpJyBpblxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdWJfZW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIHwgJ30nIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICUoLi4uJX0uICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJyknXCIgJ30nXG4gICAgICAgIHwgJyknIC0+XG4gICAgICAgICAgKCogRXJyb3I6ICV7Li4uJSkuICopXG4gICAgICAgICAgZXhwZWN0ZWRfY2hhcmFjdGVyIChzdHJfaW5kICsgMSkgXCJjaGFyYWN0ZXIgJ30nXCIgJyknXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCBjXG4gICAgICAgIGVuZFxuICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDEpIGVuZF9pbmQgY1xuXG4gICgqIENoZWNrIGlmIHN5bWIgaXMgYSB2YWxpZCBpbnQgY29udmVyc2lvbiBhZnRlciBcIiVsXCIsIFwiJW5cIiBvciBcIiVMXCIgKilcbiAgYW5kIGlzX2ludF9iYXNlIHN5bWIgPSBtYXRjaCBzeW1iIHdpdGhcbiAgICB8ICdkJyB8ICdpJyB8ICd4JyB8ICdYJyB8ICdvJyB8ICd1JyAtPiB0cnVlXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgKCogQ29udmVydCBhIGNoYXIgKGwsIG4gb3IgTCkgdG8gaXRzIGFzc29jaWF0ZWQgY291bnRlci4gKilcbiAgYW5kIGNvdW50ZXJfb2ZfY2hhciBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnbCcgLT4gTGluZV9jb3VudGVyICB8ICduJyAtPiBDaGFyX2NvdW50ZXJcbiAgICB8ICdMJyAtPiBUb2tlbl9jb3VudGVyIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzeW1iKSB0byBpdHMgYXNzb2NpYXRlZCBpbnRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBtYXRjaCBwbHVzLCBoYXNoLCBzcGFjZSwgc3ltYiB3aXRoXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnZCcgLT4gSW50X2QgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2knIC0+IEludF9pXG4gICAgfCBmYWxzZSwgZmFsc2UsICB0cnVlLCAnZCcgLT4gSW50X3NkIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2knIC0+IEludF9zaVxuICAgIHwgIHRydWUsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9wZCB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfcGlcbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd4JyAtPiBJbnRfeCAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnWCcgLT4gSW50X1hcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd4JyAtPiBJbnRfQ3ggfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnWCcgLT4gSW50X0NYXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAnbycgLT4gSW50X29cbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdvJyAtPiBJbnRfQ29cbiAgICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICd1JyAtPiBJbnRfdVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2QnIC0+IEludF9DZFxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ2knIC0+IEludF9DaVxuICAgIHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ3UnIC0+IEludF9DdVxuICAgIHwgXywgdHJ1ZSwgXywgJ3gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DeFxuICAgIHwgXywgdHJ1ZSwgXywgJ1gnIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9DWFxuICAgIHwgXywgdHJ1ZSwgXywgJ28nIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+IEludF9Db1xuICAgIHwgXywgdHJ1ZSwgXywgKCdkJyB8ICdpJyB8ICd1JykgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIlxuICAgIHwgdHJ1ZSwgXywgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgdHJ1ZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCJcbiAgICB8IHRydWUsIF8sIGZhbHNlLCBfICAgIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgZmFsc2UgaGFzaCBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJysnXCJcbiAgICB8IGZhbHNlLCBfLCBmYWxzZSwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBDb252ZXJ0IChwbHVzLCBzcGFjZSwgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgZmxvYXRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBoYXNoIHNwYWNlIHN5bWIgPVxuICAgIGxldCBmbGFnID0gbWF0Y2ggcGx1cywgc3BhY2Ugd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfXG4gICAgfCBmYWxzZSwgIHRydWUgLT4gRmxvYXRfZmxhZ19zXG4gICAgfCAgdHJ1ZSwgZmFsc2UgLT4gRmxvYXRfZmxhZ19wXG4gICAgfCAgdHJ1ZSwgIHRydWUgLT5cbiAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBGbG9hdF9mbGFnX3BcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiIGluXG4gICAgbGV0IGtpbmQgPSBtYXRjaCBoYXNoLCBzeW1iIHdpdGhcbiAgICB8IF8sICdmJyAtPiBGbG9hdF9mXG4gICAgfCBfLCAnZScgLT4gRmxvYXRfZVxuICAgIHwgXywgJ0UnIC0+IEZsb2F0X0VcbiAgICB8IF8sICdnJyAtPiBGbG9hdF9nXG4gICAgfCBfLCAnRycgLT4gRmxvYXRfR1xuICAgIHwgXywgJ2gnIC0+IEZsb2F0X2hcbiAgICB8IF8sICdIJyAtPiBGbG9hdF9IXG4gICAgfCBmYWxzZSwgJ0YnIC0+IEZsb2F0X0ZcbiAgICB8IHRydWUsICdGJyAtPiBGbG9hdF9DRlxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgaW5cbiAgICBmbGFnLCBraW5kXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGluY29tcGF0aWJsZSBvcHRpb25zLiopXG4gIGFuZCBpbmNvbXBhdGlibGVfZmxhZyA6IHR5cGUgYSAuIGludCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmcgLT4gYSA9XG4gICAgZnVuIHBjdF9pbmQgc3RyX2luZCBzeW1iIG9wdGlvbiAtPlxuICAgICAgbGV0IHN1YmZtdCA9IFN0cmluZy5zdWIgc3RyIHBjdF9pbmQgKHN0cl9pbmQgLSBwY3RfaW5kKSBpblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgJXMgaXMgaW5jb21wYXRpYmxlIHdpdGggJyVjJyBpbiBzdWItZm9ybWF0ICVTXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgb3B0aW9uIHN5bWIgc3ViZm10XG5cbiAgaW4gcGFyc2UgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAoKiBHdWFyZGVkIHN0cmluZyB0byBmb3JtYXQgY29udmVyc2lvbnMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHN0ciBmbXR0eSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgZm10dHksIHN0cilcbiAgd2l0aCBUeXBlX21pc21hdGNoIC0+XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgXCJiYWQgaW5wdXQ6IGZvcm1hdCB0eXBlIG1pc21hdGNoIGJldHdlZW4gJVMgYW5kICVTXCJcbiAgICAgIHN0ciAoc3RyaW5nX29mX2ZtdHR5IGZtdHR5KVxuXG4oKiBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgZm9ybWF0IGNvbXBhdGlibGUgd2l0aCBhbiBvdGhlciBmb3JtYXQuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgKEZvcm1hdCAoZm10Jywgc3RyJykpID1cbiAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgc3RyIGluXG4gIHRyeSBGb3JtYXQgKHR5cGVfZm9ybWF0IGZtdCAoZm10dHlfb2ZfZm10IGZtdCcpLCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiIHN0ciBzdHInXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gUHJpbnRmXG5cbnR5cGUgdCA9IGV4biA9IC4uXG5cbmxldCBwcmludGVycyA9IEF0b21pYy5tYWtlIFtdXG5cbmxldCBsb2NmbXQgPSBmb3JtYXRfb2Zfc3RyaW5nIFwiRmlsZSBcXFwiJXNcXFwiLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkOiAlc1wiXG5cbmxldCBmaWVsZCB4IGkgPVxuICBsZXQgZiA9IE9iai5maWVsZCB4IGkgaW5cbiAgaWYgbm90IChPYmouaXNfYmxvY2sgZikgdGhlblxuICAgIHNwcmludGYgXCIlZFwiIChPYmoubWFnaWMgZiA6IGludCkgICAgICAgICAgICgqIGNhbiBhbHNvIGJlIGEgY2hhciAqKVxuICBlbHNlIGlmIE9iai50YWcgZiA9IE9iai5zdHJpbmdfdGFnIHRoZW5cbiAgICBzcHJpbnRmIFwiJVNcIiAoT2JqLm1hZ2ljIGYgOiBzdHJpbmcpXG4gIGVsc2UgaWYgT2JqLnRhZyBmID0gT2JqLmRvdWJsZV90YWcgdGhlblxuICAgIHN0cmluZ19vZl9mbG9hdCAoT2JqLm1hZ2ljIGYgOiBmbG9hdClcbiAgZWxzZVxuICAgIFwiX1wiXG5cbmxldCByZWMgb3RoZXJfZmllbGRzIHggaSA9XG4gIGlmIGkgPj0gT2JqLnNpemUgeCB0aGVuIFwiXCJcbiAgZWxzZSBzcHJpbnRmIFwiLCAlcyVzXCIgKGZpZWxkIHggaSkgKG90aGVyX2ZpZWxkcyB4IChpKzEpKVxuXG5sZXQgZmllbGRzIHggPVxuICBtYXRjaCBPYmouc2l6ZSB4IHdpdGhcbiAgfCAwIC0+IFwiXCJcbiAgfCAxIC0+IFwiXCJcbiAgfCAyIC0+IHNwcmludGYgXCIoJXMpXCIgKGZpZWxkIHggMSlcbiAgfCBfIC0+IHNwcmludGYgXCIoJXMlcylcIiAoZmllbGQgeCAxKSAob3RoZXJfZmllbGRzIHggMilcblxubGV0IHVzZV9wcmludGVycyB4ID1cbiAgbGV0IHJlYyBjb252ID0gZnVuY3Rpb25cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIChtYXRjaCBoZCB4IHdpdGhcbiAgICAgICAgIHwgTm9uZSB8IGV4Y2VwdGlvbiBfIC0+IGNvbnYgdGxcbiAgICAgICAgIHwgU29tZSBzIC0+IFNvbWUgcylcbiAgICB8IFtdIC0+IE5vbmUgaW5cbiAgY29udiAoQXRvbWljLmdldCBwcmludGVycylcblxubGV0IHRvX3N0cmluZ19kZWZhdWx0ID0gZnVuY3Rpb25cbiAgfCBPdXRfb2ZfbWVtb3J5IC0+IFwiT3V0IG9mIG1lbW9yeVwiXG4gIHwgU3RhY2tfb3ZlcmZsb3cgLT4gXCJTdGFjayBvdmVyZmxvd1wiXG4gIHwgTWF0Y2hfZmFpbHVyZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNSkgXCJQYXR0ZXJuIG1hdGNoaW5nIGZhaWxlZFwiXG4gIHwgQXNzZXJ0X2ZhaWx1cmUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzYpIFwiQXNzZXJ0aW9uIGZhaWxlZFwiXG4gIHwgVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUoZmlsZSwgbGluZSwgY2hhcikgLT5cbiAgICAgIHNwcmludGYgbG9jZm10IGZpbGUgbGluZSBjaGFyIChjaGFyKzYpIFwiVW5kZWZpbmVkIHJlY3Vyc2l2ZSBtb2R1bGVcIlxuICB8IHggLT5cbiAgICAgIGxldCB4ID0gT2JqLnJlcHIgeCBpblxuICAgICAgaWYgT2JqLnRhZyB4IDw+IDAgdGhlblxuICAgICAgICAoT2JqLm1hZ2ljIChPYmouZmllbGQgeCAwKSA6IHN0cmluZylcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IGNvbnN0cnVjdG9yID1cbiAgICAgICAgICAoT2JqLm1hZ2ljIChPYmouZmllbGQgKE9iai5maWVsZCB4IDApIDApIDogc3RyaW5nKSBpblxuICAgICAgICBjb25zdHJ1Y3RvciBeIChmaWVsZHMgeClcblxubGV0IHRvX3N0cmluZyBlID1cbiAgbWF0Y2ggdXNlX3ByaW50ZXJzIGUgd2l0aFxuICB8IFNvbWUgcyAtPiBzXG4gIHwgTm9uZSAtPiB0b19zdHJpbmdfZGVmYXVsdCBlXG5cbmxldCBwcmludCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZmx1c2ggc3RkZXJyO1xuICAgIHJhaXNlIHhcblxubGV0IGNhdGNoIGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGZsdXNoIHN0ZG91dDtcbiAgICBlcHJpbnRmIFwiVW5jYXVnaHQgZXhjZXB0aW9uOiAlc1xcblwiICh0b19zdHJpbmcgeCk7XG4gICAgZXhpdCAyXG5cbnR5cGUgcmF3X2JhY2t0cmFjZV9zbG90XG50eXBlIHJhd19iYWNrdHJhY2VfZW50cnkgPSBwcml2YXRlIGludFxudHlwZSByYXdfYmFja3RyYWNlID0gcmF3X2JhY2t0cmFjZV9lbnRyeSBhcnJheVxuXG5sZXQgcmF3X2JhY2t0cmFjZV9lbnRyaWVzIGJ0ID0gYnRcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2U6XG4gIHVuaXQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2VcIlxuXG5leHRlcm5hbCByYWlzZV93aXRoX2JhY2t0cmFjZTogZXhuIC0+IHJhd19iYWNrdHJhY2UgLT4gJ2FcbiAgPSBcIiVyYWlzZV93aXRoX2JhY2t0cmFjZVwiXG5cbnR5cGUgYmFja3RyYWNlX3Nsb3QgPVxuICB8IEtub3duX2xvY2F0aW9uIG9mIHtcbiAgICAgIGlzX3JhaXNlICAgIDogYm9vbDtcbiAgICAgIGZpbGVuYW1lICAgIDogc3RyaW5nO1xuICAgICAgbGluZV9udW1iZXIgOiBpbnQ7XG4gICAgICBzdGFydF9jaGFyICA6IGludDtcbiAgICAgIGVuZF9jaGFyICAgIDogaW50O1xuICAgICAgaXNfaW5saW5lICAgOiBib29sO1xuICAgICAgZGVmbmFtZSAgICAgOiBzdHJpbmc7XG4gICAgfVxuICB8IFVua25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgOiBib29sXG4gICAgfVxuXG4oKiB0byBhdm9pZCB3YXJuaW5nICopXG5sZXQgXyA9IFtLbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2U7IGZpbGVuYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZV9udW1iZXIgPSAwOyBzdGFydF9jaGFyID0gMDsgZW5kX2NoYXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc19pbmxpbmUgPSBmYWxzZTsgZGVmbmFtZSA9IFwiXCIgfTtcbiAgICAgICAgIFVua25vd25fbG9jYXRpb24geyBpc19yYWlzZSA9IGZhbHNlIH1dXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90OlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gYmFja3RyYWNlX3Nsb3QgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2U6XG4gIHJhd19iYWNrdHJhY2UgLT4gYmFja3RyYWNlX3Nsb3QgYXJyYXkgPSBcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlXCJcblxubGV0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidCA9XG4gIHRyeSBTb21lIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBwb3Mgc2xvdCA9XG4gIGxldCBpbmZvIGlzX3JhaXNlID1cbiAgICBpZiBpc19yYWlzZSB0aGVuXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYXRcIiBlbHNlIFwiUmUtcmFpc2VkIGF0XCJcbiAgICBlbHNlXG4gICAgICBpZiBwb3MgPSAwIHRoZW4gXCJSYWlzZWQgYnkgcHJpbWl0aXZlIG9wZXJhdGlvbiBhdFwiIGVsc2UgXCJDYWxsZWQgZnJvbVwiXG4gIGluXG4gIG1hdGNoIHNsb3Qgd2l0aFxuICB8IFVua25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgaWYgbC5pc19yYWlzZSB0aGVuXG4gICAgICAgICgqIGNvbXBpbGVyLWluc2VydGVkIHJlLXJhaXNlLCBza2lwcGVkICopIE5vbmVcbiAgICAgIGVsc2VcbiAgICAgICAgU29tZSAoc3ByaW50ZiBcIiVzIHVua25vd24gbG9jYXRpb25cIiAoaW5mbyBmYWxzZSkpXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgICAgU29tZSAoc3ByaW50ZiBcIiVzICVzIGluIGZpbGUgXFxcIiVzXFxcIiVzLCBsaW5lICVkLCBjaGFyYWN0ZXJzICVkLSVkXCJcbiAgICAgICAgICAgICAgKGluZm8gbC5pc19yYWlzZSkgbC5kZWZuYW1lIGwuZmlsZW5hbWVcbiAgICAgICAgICAgICAgKGlmIGwuaXNfaW5saW5lIHRoZW4gXCIgKGlubGluZWQpXCIgZWxzZSBcIlwiKVxuICAgICAgICAgICAgICBsLmxpbmVfbnVtYmVyIGwuc3RhcnRfY2hhciBsLmVuZF9jaGFyKVxuXG5sZXQgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIGJhY2t0cmFjZSA9XG4gIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICAgZnByaW50ZiBvdXRjaGFuXG4gICAgICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGZwcmludGYgb3V0Y2hhbiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lXG5cbmxldCBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gcmF3X2JhY2t0cmFjZSA9XG4gIHByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2Ugb3V0Y2hhbiAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbigqIGNvbmZ1c2luZ2x5IG5hbWVkOiBwcmludHMgdGhlIGdsb2JhbCBjdXJyZW50IGJhY2t0cmFjZSAqKVxubGV0IHByaW50X2JhY2t0cmFjZSBvdXRjaGFuID1cbiAgcHJpbnRfcmF3X2JhY2t0cmFjZSBvdXRjaGFuIChnZXRfcmF3X2JhY2t0cmFjZSAoKSlcblxubGV0IGJhY2t0cmFjZV90b19zdHJpbmcgYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTAyNCBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBhIC0gMSBkb1xuICAgICAgICBtYXRjaCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgaSBhLihpKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIHN0ciAtPiBicHJpbnRmIGIgXCIlc1xcblwiIHN0clxuICAgICAgZG9uZTtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBiXG5cbmxldCByYXdfYmFja3RyYWNlX3RvX3N0cmluZyByYXdfYmFja3RyYWNlID1cbiAgYmFja3RyYWNlX3RvX3N0cmluZyAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX3JhaXNlXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX2lubGluZVxuICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuXG50eXBlIGxvY2F0aW9uID0ge1xuICBmaWxlbmFtZSA6IHN0cmluZztcbiAgbGluZV9udW1iZXIgOiBpbnQ7XG4gIHN0YXJ0X2NoYXIgOiBpbnQ7XG4gIGVuZF9jaGFyIDogaW50O1xufVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfbG9jYXRpb24gPSBmdW5jdGlvblxuICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBOb25lXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgIFNvbWUge1xuICAgICAgZmlsZW5hbWUgICAgPSBsLmZpbGVuYW1lO1xuICAgICAgbGluZV9udW1iZXIgPSBsLmxpbmVfbnVtYmVyO1xuICAgICAgc3RhcnRfY2hhciAgPSBsLnN0YXJ0X2NoYXI7XG4gICAgICBlbmRfY2hhciAgICA9IGwuZW5kX2NoYXI7XG4gICAgfVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfZGVmbmFtZSA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfXG4gIHwgS25vd25fbG9jYXRpb24geyBkZWZuYW1lID0gXCJcIiB9IC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IFNvbWUgbC5kZWZuYW1lXG5cbmxldCBiYWNrdHJhY2Vfc2xvdHMgcmF3X2JhY2t0cmFjZSA9XG4gICgqIFRoZSBkb2N1bWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gZ3VhcmFudGVlcyB0aGF0IFNvbWUgaXNcbiAgICAgcmV0dXJuZWQgb25seSBpZiBhIHBhcnQgb2YgdGhlIHRyYWNlIGlzIHVzYWJsZS4gVGhpcyBnaXZlcyB1c1xuICAgICBhIGJpdCBtb3JlIHdvcmsgdGhhbiBqdXN0IGNvbnZlcnRfcmF3X2JhY2t0cmFjZSwgYnV0IGl0IG1ha2VzIHRoZVxuICAgICBBUEkgbW9yZSB1c2VyLWZyaWVuZGx5IC0tIG90aGVyd2lzZSBtb3N0IHVzZXJzIHdvdWxkIGhhdmUgdG9cbiAgICAgcmVpbXBsZW1lbnQgdGhlIFwiUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIHNvcnJ5XCIgbG9naWNcbiAgICAgdGhlbXNlbHZlcy4gKilcbiAgbWF0Y2ggY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2Ugd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGJhY2t0cmFjZSAtPlxuICAgICAgbGV0IHVzYWJsZV9zbG90ID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbmtub3duX2xvY2F0aW9uIF8gLT4gZmFsc2VcbiAgICAgICAgfCBLbm93bl9sb2NhdGlvbiBfIC0+IHRydWUgaW5cbiAgICAgIGxldCByZWMgZXhpc3RzX3VzYWJsZSA9IGZ1bmN0aW9uXG4gICAgICAgIHwgKC0xKSAtPiBmYWxzZVxuICAgICAgICB8IGkgLT4gdXNhYmxlX3Nsb3QgYmFja3RyYWNlLihpKSB8fCBleGlzdHNfdXNhYmxlIChpIC0gMSkgaW5cbiAgICAgIGlmIGV4aXN0c191c2FibGUgKEFycmF5Lmxlbmd0aCBiYWNrdHJhY2UgLSAxKVxuICAgICAgdGhlbiBTb21lIGJhY2t0cmFjZVxuICAgICAgZWxzZSBOb25lXG5cbmxldCBiYWNrdHJhY2Vfc2xvdHNfb2ZfcmF3X2VudHJ5IGVudHJ5ID1cbiAgYmFja3RyYWNlX3Nsb3RzIFt8IGVudHJ5IHxdXG5cbm1vZHVsZSBTbG90ID0gc3RydWN0XG4gIHR5cGUgdCA9IGJhY2t0cmFjZV9zbG90XG4gIGxldCBmb3JtYXQgPSBmb3JtYXRfYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGlzX3JhaXNlID0gYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2VcbiAgbGV0IGlzX2lubGluZSA9IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZVxuICBsZXQgbG9jYXRpb24gPSBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvblxuICBsZXQgbmFtZSA9IGJhY2t0cmFjZV9zbG90X2RlZm5hbWVcbmVuZFxuXG5sZXQgcmF3X2JhY2t0cmFjZV9sZW5ndGggYnQgPSBBcnJheS5sZW5ndGggYnRcblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2UgLT4gaW50IC0+IHJhd19iYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QgOlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gcmF3X2JhY2t0cmFjZV9zbG90IG9wdGlvblxuICA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFwiXG5cbigqIGNvbmZ1c2luZ2x5IG5hbWVkOlxuICAgcmV0dXJucyB0aGUgKnN0cmluZyogY29ycmVzcG9uZGluZyB0byB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgZ2V0X2JhY2t0cmFjZSAoKSA9IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIChnZXRfcmF3X2JhY2t0cmFjZSAoKSlcblxuZXh0ZXJuYWwgcmVjb3JkX2JhY2t0cmFjZTogYm9vbCAtPiB1bml0ID0gXCJjYW1sX3JlY29yZF9iYWNrdHJhY2VcIlxuZXh0ZXJuYWwgYmFja3RyYWNlX3N0YXR1czogdW5pdCAtPiBib29sID0gXCJjYW1sX2JhY2t0cmFjZV9zdGF0dXNcIlxuXG5sZXQgcmVjIHJlZ2lzdGVyX3ByaW50ZXIgZm4gPVxuICBsZXQgb2xkX3ByaW50ZXJzID0gQXRvbWljLmdldCBwcmludGVycyBpblxuICBsZXQgbmV3X3ByaW50ZXJzID0gZm4gOjogb2xkX3ByaW50ZXJzIGluXG4gIGxldCBzdWNjZXNzID0gQXRvbWljLmNvbXBhcmVfYW5kX3NldCBwcmludGVycyBvbGRfcHJpbnRlcnMgbmV3X3ByaW50ZXJzIGluXG4gIGlmIG5vdCBzdWNjZXNzIHRoZW4gcmVnaXN0ZXJfcHJpbnRlciBmblxuXG5leHRlcm5hbCBnZXRfY2FsbHN0YWNrOiBpbnQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2tcIlxuXG5sZXQgZXhuX3Nsb3QgeCA9XG4gIGxldCB4ID0gT2JqLnJlcHIgeCBpblxuICBpZiBPYmoudGFnIHggPSAwIHRoZW4gT2JqLmZpZWxkIHggMCBlbHNlIHhcblxubGV0IGV4bl9zbG90X2lkIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDEpIDogaW50KVxuXG5sZXQgZXhuX3Nsb3RfbmFtZSB4ID1cbiAgbGV0IHNsb3QgPSBleG5fc2xvdCB4IGluXG4gIChPYmoub2JqIChPYmouZmllbGQgc2xvdCAwKSA6IHN0cmluZylcblxuZXh0ZXJuYWwgZ2V0X2RlYnVnX2luZm9fc3RhdHVzIDogdW5pdCAtPiBpbnQgPSBcImNhbWxfbWxfZGVidWdfaW5mb19zdGF0dXNcIlxuXG4oKiBEZXNjcmlwdGlvbnMgZm9yIGVycm9ycyBpbiBzdGFydHVwLmguIFNlZSBhbHNvIGJhY2t0cmFjZS5jICopXG5sZXQgZXJyb3JzID0gW3wgXCJcIjtcbiAgKCogRklMRV9OT1RfRk9VTkQgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIG5vdCBmb3VuZClcIjtcbiAgKCogQkFEX0JZVEVDT0RFICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBhcHBlYXJzIHRvIGJlIGNvcnJ1cHQpXCI7XG4gICgqIFdST05HX01BR0lDICopXG4gIFwiKENhbm5vdCBwcmludCBsb2NhdGlvbnM6XFxuIFxcXG4gICAgICBieXRlY29kZSBleGVjdXRhYmxlIHByb2dyYW0gZmlsZSBoYXMgd3JvbmcgbWFnaWMgbnVtYmVyKVwiO1xuICAoKiBOT19GRFMgKilcbiAgXCIoQ2Fubm90IHByaW50IGxvY2F0aW9uczpcXG4gXFxcbiAgICAgIGJ5dGVjb2RlIGV4ZWN1dGFibGUgcHJvZ3JhbSBmaWxlIGNhbm5vdCBiZSBvcGVuZWQ7XFxuIFxcXG4gICAgICAtLSB0b28gbWFueSBvcGVuIGZpbGVzLiBUcnkgcnVubmluZyB3aXRoIE9DQU1MUlVOUEFSQU09Yj0yKVwiXG58XVxuXG5sZXQgZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBleG4gcmF3X2JhY2t0cmFjZSA9XG4gIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICBsZXQgc3RhdHVzID0gZ2V0X2RlYnVnX2luZm9fc3RhdHVzICgpIGluXG4gIGlmIHN0YXR1cyA8IDAgdGhlblxuICAgIHByZXJyX2VuZGxpbmUgZXJyb3JzLihhYnMgc3RhdHVzKTtcbiAgZmx1c2ggc3RkZXJyXG5cbmxldCB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA9IHJlZiBkZWZhdWx0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyXG5cbmxldCBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgZm4gPSB1bmNhdWdodF9leGNlcHRpb25faGFuZGxlciA6PSBmblxuXG5sZXQgZW1wdHlfYmFja3RyYWNlIDogcmF3X2JhY2t0cmFjZSA9IFt8IHxdXG5cbmxldCB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgPVxuICB0cnlcbiAgICBnZXRfcmF3X2JhY2t0cmFjZSAoKVxuICB3aXRoIF8gKCogT3V0X29mX21lbW9yeT8gKikgLT5cbiAgICBlbXB0eV9iYWNrdHJhY2VcblxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICAoKiBHZXQgdGhlIGJhY2t0cmFjZSBub3csIGluIGNhc2Ugb25lIG9mIHRoZSBbYXRfZXhpdF0gZnVuY3Rpb25cbiAgICAgICBkZXN0cm95cyBpdC4gKilcbiAgICBsZXQgcmF3X2JhY2t0cmFjZSA9XG4gICAgICBpZiBkZWJ1Z2dlcl9pbl91c2UgKCogU2FtZSB0ZXN0IGFzIGluIFtydW50aW1lL3ByaW50ZXhjLmNdICopIHRoZW5cbiAgICAgICAgZW1wdHlfYmFja3RyYWNlXG4gICAgICBlbHNlXG4gICAgICAgIHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKVxuICAgIGluXG4gICAgKHRyeSBTdGRsaWIuZG9fYXRfZXhpdCAoKSB3aXRoIF8gLT4gKCkpO1xuICAgIHRyeVxuICAgICAgIXVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGV4biByYXdfYmFja3RyYWNlXG4gICAgd2l0aCBleG4nIC0+XG4gICAgICBsZXQgcmF3X2JhY2t0cmFjZScgPSB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvciBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlcjogZXhjZXB0aW9uICVzXFxuXCJcbiAgICAgICAgKHRvX3N0cmluZyBleG4nKTtcbiAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2UnO1xuICAgICAgZmx1c2ggc3RkZXJyXG4gIHdpdGhcbiAgICB8IE91dF9vZl9tZW1vcnkgLT5cbiAgICAgICAgcHJlcnJfZW5kbGluZVxuICAgICAgICAgIFwiRmF0YWwgZXJyb3I6IG91dCBvZiBtZW1vcnkgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJcIlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBbY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25dIGluXG4gICBbcnVudGltZS9wcmludGV4Yy5jXSB3aGljaCBleHBlY3RzIG5vIGV4Y2VwdGlvbiBpcyByYWlzZWQuICopXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbiBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZVxuICB3aXRoIF8gLT5cbiAgICAoKiBUaGVyZSBpcyBub3QgbXVjaCB3ZSBjYW4gZG8gYXQgdGhpcyBwb2ludCAqKVxuICAgICgpXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIlxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBYYXZpZXIgTGVyb3kgYW5kIERhbWllbiBEb2xpZ2V6LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGdlbmVyaWNfcXVvdGUgcXVvdGVxdW90ZSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBpZiBzLltpXSA9ICdcXCcnXG4gICAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBiIHF1b3RlcXVvdGVcbiAgICBlbHNlIEJ1ZmZlci5hZGRfY2hhciBiICBzLltpXVxuICBkb25lO1xuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1sxXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Jhc2VuYW1lLmh0bWxcbiAgSW4gc3RlcCAxIG9mIFtbMV1dLCB3ZSBjaG9vc2UgdG8gcmV0dXJuIFwiLlwiIGZvciBlbXB0eSBpbnB1dC5cbiAgICAoZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPQ2FtbClcbiAgSW4gc3RlcCAyLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4gIFN0ZXAgNiBpcyBub3QgaW1wbGVtZW50ZWQ6IHdlIGNvbnNpZGVyIHRoYXQgdGhlIFtzdWZmaXhdIG9wZXJhbmQgaXNcbiAgICBhbHdheXMgYWJzZW50LiAgU3VmZml4ZXMgYXJlIGhhbmRsZWQgYnkgW2Nob3Bfc3VmZml4XSBhbmQgW2Nob3BfZXh0ZW5zaW9uXS5cbiopXG5sZXQgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgZmluZF9lbmQgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGZpbmRfZW5kIChuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIG4gKG4gKyAxKVxuICBhbmQgZmluZF9iZWcgbiBwID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIHBcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gU3RyaW5nLnN1YiBuYW1lIChuICsgMSkgKHAgLSBuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIChuIC0gMSkgcFxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSBmaW5kX2VuZCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1syXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Rpcm5hbWUuaHRtbFxuICBJbiBzdGVwIDYgb2YgW1syXV0sIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiopXG5sZXQgZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyB0cmFpbGluZ19zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIHRyYWlsaW5nX3NlcCAobiAtIDEpXG4gICAgZWxzZSBiYXNlIG5cbiAgYW5kIGJhc2UgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgblxuICAgIGVsc2UgYmFzZSAobiAtIDEpXG4gIGFuZCBpbnRlcm1lZGlhdGVfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIChuIC0gMSlcbiAgICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChuICsgMSlcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgdHJhaWxpbmdfc2VwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5tb2R1bGUgdHlwZSBTWVNERVBTID0gc2lnXG4gIHZhbCBudWxsIDogc3RyaW5nXG4gIHZhbCBjdXJyZW50X2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBwYXJlbnRfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIGRpcl9zZXAgOiBzdHJpbmdcbiAgdmFsIGlzX2Rpcl9zZXAgOiBzdHJpbmcgLT4gaW50IC0+IGJvb2xcbiAgdmFsIGlzX3JlbGF0aXZlIDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGlzX2ltcGxpY2l0IDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGNoZWNrX3N1ZmZpeCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgY2hvcF9zdWZmaXhfb3B0IDogc3VmZml4OnN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nIG9wdGlvblxuICB2YWwgdGVtcF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgcXVvdGUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBxdW90ZV9jb21tYW5kIDpcbiAgICBzdHJpbmcgLT4gP3N0ZGluOiBzdHJpbmcgLT4gP3N0ZG91dDogc3RyaW5nIC0+ID9zdGRlcnI6IHN0cmluZ1xuICAgICAgICAgICAtPiBzdHJpbmcgbGlzdCAtPiBzdHJpbmdcbiAgdmFsIGJhc2VuYW1lIDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgZGlybmFtZSA6IHN0cmluZyAtPiBzdHJpbmdcbmVuZFxuXG5tb2R1bGUgVW5peCA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IHMuW2ldID0gJy8nXG4gIGxldCBpc19yZWxhdGl2ZSBuID0gU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLydcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgICBTdHJpbmcubGVuZ3RoIG5hbWUgPj0gU3RyaW5nLmxlbmd0aCBzdWZmICYmXG4gICAgU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgIChTdHJpbmcubGVuZ3RoIHN1ZmYpID0gc3VmZlxuXG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgfnN1ZmZpeCBmaWxlbmFtZSA9XG4gICAgbGV0IGxlbl9zID0gU3RyaW5nLmxlbmd0aCBzdWZmaXggYW5kIGxlbl9mID0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgIGlmIGxlbl9mID49IGxlbl9zIHRoZW5cbiAgICAgIGxldCByID0gU3RyaW5nLnN1YiBmaWxlbmFtZSAobGVuX2YgLSBsZW5fcykgbGVuX3MgaW5cbiAgICAgIGlmIHIgPSBzdWZmaXggdGhlblxuICAgICAgICBTb21lIChTdHJpbmcuc3ViIGZpbGVuYW1lIDAgKGxlbl9mIC0gbGVuX3MpKVxuICAgICAgZWxzZVxuICAgICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRNUERJUlwiIHdpdGggTm90X2ZvdW5kIC0+IFwiL3RtcFwiXG4gIGxldCBxdW90ZSA9IGdlbmVyaWNfcXVvdGUgXCInXFxcXCcnXCJcbiAgbGV0IHF1b3RlX2NvbW1hbmQgY21kID9zdGRpbiA/c3Rkb3V0ID9zdGRlcnIgYXJncyA9XG4gICAgU3RyaW5nLmNvbmNhdCBcIiBcIiAoTGlzdC5tYXAgcXVvdGUgKGNtZCA6OiBhcmdzKSlcbiAgICBeIChtYXRjaCBzdGRpbiAgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPFwiIF4gcXVvdGUgZilcbiAgICBeIChtYXRjaCBzdGRvdXQgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPlwiIF4gcXVvdGUgZilcbiAgICBeIChtYXRjaCBzdGRlcnIgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gaWYgc3RkZXJyID0gc3Rkb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIFwiIDI+JjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBcIiAyPlwiIF4gcXVvdGUgZilcbiAgbGV0IGJhc2VuYW1lID0gZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbiAgbGV0IGRpcm5hbWUgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG5lbmRcblxubW9kdWxlIFdpbjMyIDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiTlVMXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCJcXFxcXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gbGV0IGMgPSBzLltpXSBpbiBjID0gJy8nIHx8IGMgPSAnXFxcXCcgfHwgYyA9ICc6J1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9XG4gICAgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICdcXFxcJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBuLlsxXSA8PiAnOicpXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi5cXFxcXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLlxcXFxcIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgU3RyaW5nLmxlbmd0aCBuYW1lID49IFN0cmluZy5sZW5ndGggc3VmZiAmJlxuICAgKGxldCBzID0gU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFN0cmluZy5sZW5ndGggc3VmZikgaW5cbiAgICBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmYpXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSByID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzdWZmaXggdGhlblxuICAgICAgICBTb21lIChTdHJpbmcuc3ViIGZpbGVuYW1lIDAgKGxlbl9mIC0gbGVuX3MpKVxuICAgICAgZWxzZVxuICAgICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVEVNUFwiIHdpdGggTm90X2ZvdW5kIC0+IFwiLlwiXG4gIGxldCBxdW90ZSBzID1cbiAgICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAobCArIDIwKSBpblxuICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJyBlbHNlXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICdcXFwiJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCBjICAgIC0+IEJ1ZmZlci5hZGRfY2hhciBiIGM7IGxvb3AgKGkrMSk7XG4gICAgYW5kIGxvb3BfYnMgbiBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gYmVnaW5cbiAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgICAgICBhZGRfYnMgbjtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgICAgfCAnXFxcIicgLT4gYWRkX2JzICgyKm4rMSk7IEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJzsgbG9vcCAoaSsxKTtcbiAgICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAobisxKSAoaSsxKTtcbiAgICAgICAgfCBfICAgIC0+IGFkZF9icyBuOyBsb29wIGlcbiAgICAgIGVuZFxuICAgIGFuZCBhZGRfYnMgbiA9IGZvciBfaiA9IDEgdG8gbiBkbyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcXCc7IGRvbmVcbiAgICBpblxuICAgIGxvb3AgMDtcbiAgICBCdWZmZXIuY29udGVudHMgYlxuKCpcblF1b3RpbmcgY29tbWFuZHMgZm9yIGV4ZWN1dGlvbiBieSBjbWQuZXhlIGlzIGRpZmZpY3VsdC5cbjEtIEVhY2ggYXJndW1lbnQgaXMgZmlyc3QgcXVvdGVkIHVzaW5nIHRoZSBcInF1b3RlXCIgZnVuY3Rpb24gYWJvdmUsIHRvXG4gICBwcm90ZWN0IGl0IGFnYWluc3QgdGhlIHByb2Nlc3NpbmcgcGVyZm9ybWVkIGJ5IHRoZSBDIHJ1bnRpbWUgc3lzdGVtLFxuICAgdGhlbiBjbWQuZXhlJ3Mgc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkIHdpdGggJ14nLCB1c2luZ1xuICAgdGhlIFwicXVvdGVfY21kXCIgZnVuY3Rpb24gYmVsb3cuICBGb3IgbW9yZSBkZXRhaWxzLCBzZWVcbiAgIGh0dHBzOi8vYmxvZ3MubXNkbi5taWNyb3NvZnQuY29tL3R3aXN0eWxpdHRsZXBhc3NhZ2VzYWxsYWxpa2UvMjAxMS8wNC8yM1xuMi0gVGhlIGNvbW1hbmQgYW5kIHRoZSByZWRpcmVjdGlvbiBmaWxlcywgaWYgYW55LCBtdXN0IGJlIGRvdWJsZS1xdW90ZWRcbiAgIGluIGNhc2UgdGhleSBjb250YWluIHNwYWNlcy4gIFRoaXMgcXVvdGluZyBpcyBpbnRlcnByZXRlZCBieSBjbWQuZXhlLFxuICAgbm90IGJ5IHRoZSBDIHJ1bnRpbWUgc3lzdGVtLCBoZW5jZSB0aGUgXCJxdW90ZVwiIGZ1bmN0aW9uIGFib3ZlXG4gICBjYW5ub3QgYmUgdXNlZC4gIFRoZSB0d28gY2hhcmFjdGVycyB3ZSBkb24ndCBrbm93IGhvdyB0byBxdW90ZVxuICAgaW5zaWRlIGEgZG91YmxlLXF1b3RlZCBjbWQuZXhlIHN0cmluZyBhcmUgZG91YmxlLXF1b3RlIGFuZCBwZXJjZW50LlxuICAgV2UganVzdCBmYWlsIGlmIHRoZSBjb21tYW5kIG5hbWUgb3IgdGhlIHJlZGlyZWN0aW9uIGZpbGUgbmFtZXNcbiAgIGNvbnRhaW4gYSBkb3VibGUgcXVvdGUgKG5vdCBhbGxvd2VkIGluIFdpbmRvd3MgZmlsZSBuYW1lcywgYW55d2F5KVxuICAgb3IgYSBwZXJjZW50LiAgU2VlIGZ1bmN0aW9uIFwicXVvdGVfY21kX2ZpbGVuYW1lXCIgYmVsb3cuXG4zLSBUaGUgd2hvbGUgc3RyaW5nIHBhc3NlZCB0byBTeXMuY29tbWFuZCBpcyB0aGVuIGVuY2xvc2VkIGluIGRvdWJsZVxuICAgcXVvdGVzLCB3aGljaCBhcmUgaW1tZWRpYXRlbHkgc3RyaXBwZWQgYnkgY21kLmV4ZS4gIE90aGVyd2lzZSxcbiAgIHNvbWUgb2YgdGhlIGRvdWJsZSBxdW90ZXMgZnJvbSBzdGVwIDIgYWJvdmUgY2FuIGJlIG1pc3BhcnNlZC5cbiAgIFNlZSBlLmcuIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85OTY1MTQxXG4qKVxuICBsZXQgcXVvdGVfY21kIHMgPVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCBzICsgMjApIGluXG4gICAgU3RyaW5nLml0ZXJcbiAgICAgIChmdW4gYyAtPlxuICAgICAgICBtYXRjaCBjIHdpdGhcbiAgICAgICAgfCAnKCcgfCAnKScgfCAnIScgfCAnXicgfCAnJScgfCAnXFxcIicgfCAnPCcgfCAnPicgfCAnJicgfCAnfCcgLT5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiICdeJzsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiIGMpXG4gICAgICBzO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG4gIGxldCBxdW90ZV9jbWRfZmlsZW5hbWUgZiA9XG4gICAgaWYgU3RyaW5nLmNvbnRhaW5zIGYgJ1xcXCInIHx8IFN0cmluZy5jb250YWlucyBmICclJyB0aGVuXG4gICAgICBmYWlsd2l0aCAoXCJGaWxlbmFtZS5xdW90ZV9jb21tYW5kOiBiYWQgZmlsZSBuYW1lIFwiIF4gZilcbiAgICBlbHNlIGlmIFN0cmluZy5jb250YWlucyBmICcgJyB0aGVuXG4gICAgICBcIlxcXCJcIiBeIGYgXiBcIlxcXCJcIlxuICAgIGVsc2VcbiAgICAgIGZcbiAgKCogUmVkaXJlY3Rpb25zIGluIGNtZC5leGU6IHNlZSBodHRwczovL3NzNjQuY29tL250L3N5bnRheC1yZWRpcmVjdGlvbi5odG1sXG4gICAgIGFuZCBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9wcmV2aW91cy12ZXJzaW9ucy93aW5kb3dzL2l0LXByby93aW5kb3dzLXhwL2JiNDkwOTgyKHY9dGVjaG5ldC4xMClcbiAgKilcbiAgbGV0IHF1b3RlX2NvbW1hbmQgY21kID9zdGRpbiA/c3Rkb3V0ID9zdGRlcnIgYXJncyA9XG4gICAgU3RyaW5nLmNvbmNhdCBcIlwiIFtcbiAgICAgIFwiXFxcIlwiO1xuICAgICAgcXVvdGVfY21kX2ZpbGVuYW1lIGNtZDtcbiAgICAgIFwiIFwiO1xuICAgICAgcXVvdGVfY21kIChTdHJpbmcuY29uY2F0IFwiIFwiIChMaXN0Lm1hcCBxdW90ZSBhcmdzKSk7XG4gICAgICAobWF0Y2ggc3RkaW4gIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiIDxcIiBeIHF1b3RlX2NtZF9maWxlbmFtZSBmKTtcbiAgICAgIChtYXRjaCBzdGRvdXQgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPlwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgKG1hdGNoIHN0ZGVyciB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHN0ZGVyciA9IHN0ZG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gXCIgMj4mMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBcIiAyPlwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgXCJcXFwiXCJcbiAgICBdXG4gIGxldCBoYXNfZHJpdmUgcyA9XG4gICAgbGV0IGlzX2xldHRlciA9IGZ1bmN0aW9uXG4gICAgICB8ICdBJyAuLiAnWicgfCAnYScgLi4gJ3onIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuICAgIGluXG4gICAgU3RyaW5nLmxlbmd0aCBzID49IDIgJiYgaXNfbGV0dGVyIHMuWzBdICYmIHMuWzFdID0gJzonXG4gIGxldCBkcml2ZV9hbmRfcGF0aCBzID1cbiAgICBpZiBoYXNfZHJpdmUgc1xuICAgIHRoZW4gKFN0cmluZy5zdWIgcyAwIDIsIFN0cmluZy5zdWIgcyAyIChTdHJpbmcubGVuZ3RoIHMgLSAyKSlcbiAgICBlbHNlIChcIlwiLCBzKVxuICBsZXQgZGlybmFtZSBzID1cbiAgICBsZXQgKGRyaXZlLCBwYXRoKSA9IGRyaXZlX2FuZF9wYXRoIHMgaW5cbiAgICBsZXQgZGlyID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBwYXRoIGluXG4gICAgZHJpdmUgXiBkaXJcbiAgbGV0IGJhc2VuYW1lIHMgPVxuICAgIGxldCAoX2RyaXZlLCBwYXRoKSA9IGRyaXZlX2FuZF9wYXRoIHMgaW5cbiAgICBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBwYXRoXG5lbmRcblxubW9kdWxlIEN5Z3dpbiA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwID0gV2luMzIuaXNfZGlyX3NlcFxuICBsZXQgaXNfcmVsYXRpdmUgPSBXaW4zMi5pc19yZWxhdGl2ZVxuICBsZXQgaXNfaW1wbGljaXQgPSBXaW4zMi5pc19pbXBsaWNpdFxuICBsZXQgY2hlY2tfc3VmZml4ID0gV2luMzIuY2hlY2tfc3VmZml4XG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgPSBXaW4zMi5jaG9wX3N1ZmZpeF9vcHRcbiAgbGV0IHRlbXBfZGlyX25hbWUgPSBVbml4LnRlbXBfZGlyX25hbWVcbiAgbGV0IHF1b3RlID0gVW5peC5xdW90ZVxuICBsZXQgcXVvdGVfY29tbWFuZCA9IFVuaXgucXVvdGVfY29tbWFuZFxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgU3lzZGVwcyA9XG4gICh2YWwgKG1hdGNoIFN5cy5vc190eXBlIHdpdGhcbiAgICAgICB8IFwiV2luMzJcIiAtPiAobW9kdWxlIFdpbjMyOiBTWVNERVBTKVxuICAgICAgIHwgXCJDeWd3aW5cIiAtPiAobW9kdWxlIEN5Z3dpbjogU1lTREVQUylcbiAgICAgICB8IF8gLT4gKG1vZHVsZSBVbml4OiBTWVNERVBTKSkpXG5cbmluY2x1ZGUgU3lzZGVwc1xuXG5sZXQgY29uY2F0IGRpcm5hbWUgZmlsZW5hbWUgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggZGlybmFtZSBpblxuICBpZiBsID0gMCB8fCBpc19kaXJfc2VwIGRpcm5hbWUgKGwtMSlcbiAgdGhlbiBkaXJuYW1lIF4gZmlsZW5hbWVcbiAgZWxzZSBkaXJuYW1lIF4gZGlyX3NlcCBeIGZpbGVuYW1lXG5cbmxldCBjaG9wX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICBsZXQgbiA9IFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZiBpblxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9zdWZmaXhcIiBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIG5cblxubGV0IGV4dGVuc2lvbl9sZW4gbmFtZSA9XG4gIGxldCByZWMgY2hlY2sgaTAgaSA9XG4gICAgaWYgaSA8IDAgfHwgaXNfZGlyX3NlcCBuYW1lIGkgdGhlbiAwXG4gICAgZWxzZSBpZiBuYW1lLltpXSA9ICcuJyB0aGVuIGNoZWNrIGkwIChpIC0gMSlcbiAgICBlbHNlIFN0cmluZy5sZW5ndGggbmFtZSAtIGkwXG4gIGluXG4gIGxldCByZWMgc2VhcmNoX2RvdCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaSAoaSAtIDEpXG4gICAgZWxzZSBzZWFyY2hfZG90IChpIC0gMSlcbiAgaW5cbiAgc2VhcmNoX2RvdCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxubGV0IGV4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBcIlwiIGVsc2UgU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKSBsXG5cbmxldCBjaG9wX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZpbGVuYW1lLmNob3BfZXh0ZW5zaW9uXCJcbiAgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbClcblxubGV0IHJlbW92ZV9leHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gbmFtZSBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5leHRlcm5hbCBvcGVuX2Rlc2M6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcbmV4dGVybmFsIGNsb3NlX2Rlc2M6IGludCAtPiB1bml0ID0gXCJjYW1sX3N5c19jbG9zZVwiXG5cbmxldCBwcm5nID0gbGF6eShSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQgKCkpXG5cbmxldCB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJuZCA9IChSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSkgbGFuZCAweEZGRkZGRiBpblxuICBjb25jYXQgdGVtcF9kaXIgKFByaW50Zi5zcHJpbnRmIFwiJXMlMDZ4JXNcIiBwcmVmaXggcm5kIHN1ZmZpeClcblxuXG5sZXQgY3VycmVudF90ZW1wX2Rpcl9uYW1lID0gcmVmIHRlbXBfZGlyX25hbWVcblxubGV0IHNldF90ZW1wX2Rpcl9uYW1lIHMgPSBjdXJyZW50X3RlbXBfZGlyX25hbWUgOj0gc1xubGV0IGdldF90ZW1wX2Rpcl9uYW1lICgpID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZVxuXG5sZXQgdGVtcF9maWxlID8odGVtcF9kaXIgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lKSBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJlYyB0cnlfbmFtZSBjb3VudGVyID1cbiAgICBsZXQgbmFtZSA9IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggaW5cbiAgICB0cnlcbiAgICAgIGNsb3NlX2Rlc2Mob3Blbl9kZXNjIG5hbWUgW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX2V4Y2xdIDBvNjAwKTtcbiAgICAgIG5hbWVcbiAgICB3aXRoIFN5c19lcnJvciBfIGFzIGUgLT5cbiAgICAgIGlmIGNvdW50ZXIgPj0gMTAwMCB0aGVuIHJhaXNlIGUgZWxzZSB0cnlfbmFtZSAoY291bnRlciArIDEpXG4gIGluIHRyeV9uYW1lIDBcblxubGV0IG9wZW5fdGVtcF9maWxlID8obW9kZSA9IFtPcGVuX3RleHRdKSA/KHBlcm1zID0gMG82MDApXG4gICAgICAgICAgICAgICAgICAgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgKG5hbWUsXG4gICAgICAgb3Blbl9vdXRfZ2VuIChPcGVuX3dyb25seTo6T3Blbl9jcmVhdDo6T3Blbl9leGNsOjptb2RlKSBwZXJtcyBuYW1lKVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDb21wbGV4IG51bWJlcnMgKilcblxudHlwZSB0ID0geyByZTogZmxvYXQ7IGltOiBmbG9hdCB9XG5cbmxldCB6ZXJvID0geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxubGV0IG9uZSA9IHsgcmUgPSAxLjA7IGltID0gMC4wIH1cbmxldCBpID0geyByZSA9IDAuMDsgaW0gPSAxLjAgfVxuXG5sZXQgYWRkIHggeSA9IHsgcmUgPSB4LnJlICsuIHkucmU7IGltID0geC5pbSArLiB5LmltIH1cblxubGV0IHN1YiB4IHkgPSB7IHJlID0geC5yZSAtLiB5LnJlOyBpbSA9IHguaW0gLS4geS5pbSB9XG5cbmxldCBuZWcgeCA9IHsgcmUgPSAtLiB4LnJlOyBpbSA9IC0uIHguaW0gfVxuXG5sZXQgY29uaiB4ID0geyByZSA9IHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBtdWwgeCB5ID0geyByZSA9IHgucmUgKi4geS5yZSAtLiB4LmltICouIHkuaW07XG4gICAgICAgICAgICAgICAgaW0gPSB4LnJlICouIHkuaW0gKy4geC5pbSAqLiB5LnJlIH1cblxubGV0IGRpdiB4IHkgPVxuICBpZiBhYnNfZmxvYXQgeS5yZSA+PSBhYnNfZmxvYXQgeS5pbSB0aGVuXG4gICAgbGV0IHIgPSB5LmltIC8uIHkucmUgaW5cbiAgICBsZXQgZCA9IHkucmUgKy4gciAqLiB5LmltIGluXG4gICAgeyByZSA9ICh4LnJlICsuIHIgKi4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHguaW0gLS4gciAqLiB4LnJlKSAvLiBkIH1cbiAgZWxzZVxuICAgIGxldCByID0geS5yZSAvLiB5LmltIGluXG4gICAgbGV0IGQgPSB5LmltICsuIHIgKi4geS5yZSBpblxuICAgIHsgcmUgPSAociAqLiB4LnJlICsuIHguaW0pIC8uIGQ7XG4gICAgICBpbSA9IChyICouIHguaW0gLS4geC5yZSkgLy4gZCB9XG5cbmxldCBpbnYgeCA9IGRpdiBvbmUgeFxuXG5sZXQgbm9ybTIgeCA9IHgucmUgKi4geC5yZSArLiB4LmltICouIHguaW1cblxubGV0IG5vcm0geCA9XG4gICgqIFdhdGNoIG91dCBmb3Igb3ZlcmZsb3cgaW4gY29tcHV0aW5nIHJlXjIgKyBpbV4yICopXG4gIGxldCByID0gYWJzX2Zsb2F0IHgucmUgYW5kIGkgPSBhYnNfZmxvYXQgeC5pbSBpblxuICBpZiByID0gMC4wIHRoZW4gaVxuICBlbHNlIGlmIGkgPSAwLjAgdGhlbiByXG4gIGVsc2UgaWYgciA+PSBpIHRoZW5cbiAgICBsZXQgcSA9IGkgLy4gciBpbiByICouIHNxcnQoMS4wICsuIHEgKi4gcSlcbiAgZWxzZVxuICAgIGxldCBxID0gciAvLiBpIGluIGkgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuXG5sZXQgYXJnIHggPSBhdGFuMiB4LmltIHgucmVcblxubGV0IHBvbGFyIG4gYSA9IHsgcmUgPSBjb3MgYSAqLiBuOyBpbSA9IHNpbiBhICouIG4gfVxuXG5sZXQgc3FydCB4ID1cbiAgaWYgeC5yZSA9IDAuMCAmJiB4LmltID0gMC4wIHRoZW4geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gICAgbGV0IHcgPVxuICAgICAgaWYgciA+PSBpIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IHEgPSBpIC8uIHIgaW5cbiAgICAgICAgc3FydChyKSAqLiBzcXJ0KDAuNSAqLiAoMS4wICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IHEgPSByIC8uIGkgaW5cbiAgICAgICAgc3FydChpKSAqLiBzcXJ0KDAuNSAqLiAocSArLiBzcXJ0KDEuMCArLiBxICouIHEpKSlcbiAgICAgIGVuZCBpblxuICAgIGlmIHgucmUgPj0gMC4wXG4gICAgdGhlbiB7IHJlID0gdzsgIGltID0gMC41ICouIHguaW0gLy4gdyB9XG4gICAgZWxzZSB7IHJlID0gMC41ICouIGkgLy4gdzsgIGltID0gaWYgeC5pbSA+PSAwLjAgdGhlbiB3IGVsc2UgLS4gdyB9XG4gIGVuZFxuXG5sZXQgZXhwIHggPVxuICBsZXQgZSA9IGV4cCB4LnJlIGluIHsgcmUgPSBlICouIGNvcyB4LmltOyBpbSA9IGUgKi4gc2luIHguaW0gfVxuXG5sZXQgbG9nIHggPSB7IHJlID0gbG9nIChub3JtIHgpOyBpbSA9IGF0YW4yIHguaW0geC5yZSB9XG5cbmxldCBwb3cgeCB5ID0gZXhwIChtdWwgeSAobG9nIHgpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQYWRkaW5nIHBvc2l0aW9uLiAqKVxudHlwZSBwYWR0eSA9XG4gIHwgTGVmdCAgICgqIFRleHQgaXMgbGVmdCBqdXN0aWZpZWQgKCctJyBvcHRpb24pLiAgICAgICAgICAgICAgICopXG4gIHwgUmlnaHQgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIChubyAnLScgb3B0aW9uKS4gICAgICAgICAgICopXG4gIHwgWmVyb3MgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIGJ5IHplcm9zIChzZWUgJzAnIG9wdGlvbikuICopXG5cbigqKiopXG5cbigqIEludGVnZXIgY29udmVyc2lvbi4gKilcbnR5cGUgaW50X2NvbnYgPVxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkICAgICAgICAoKiAgJWQgfCAlK2QgfCAlIGQgICopXG4gIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2kgICAgICAgICgqICAlaSB8ICUraSB8ICUgaSAgKilcbiAgfCBJbnRfeCB8IEludF9DeCAgICAgICAgICAgICAgICAgKCogICV4IHwgJSN4ICAgICAgICAqKVxuICB8IEludF9YIHwgSW50X0NYICAgICAgICAgICAgICAgICAoKiAgJVggfCAlI1ggICAgICAgICopXG4gIHwgSW50X28gfCBJbnRfQ28gICAgICAgICAgICAgICAgICgqICAlbyB8ICUjbyAgICAgICAgKilcbiAgfCBJbnRfdSAgICAgICAgICAgICAgICAgICAgICAgICAgKCogICV1ICAgICAgICAgICAgICAqKVxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAgICAgICAoKiAgJSNkIHwgJSNpIHwgJSN1ICopXG5cbigqIEZsb2F0IGNvbnZlcnNpb24uICopXG50eXBlIGZsb2F0X2ZsYWdfY29udiA9XG4gIHwgRmxvYXRfZmxhZ18gICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gIHwgRmxvYXRfZmxhZ19wICAgICAgICAgICAgICAgICAgICgqICUrW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcyAgICAgICAgICAgICAgICAgICAoKiAlIFtmZUVnR0ZoSF0gKilcbnR5cGUgZmxvYXRfa2luZF9jb252ID1cbiAgfCBGbG9hdF9mICAgICAgICAgICAgICAgICAgICAgICAgKCogICVmIHwgJStmIHwgJSBmICAqKVxuICB8IEZsb2F0X2UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWUgfCAlK2UgfCAlIGUgICopXG4gIHwgRmxvYXRfRSAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRSB8ICUrRSB8ICUgRSAgKilcbiAgfCBGbG9hdF9nICAgICAgICAgICAgICAgICAgICAgICAgKCogICVnIHwgJStnIHwgJSBnICAqKVxuICB8IEZsb2F0X0cgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUcgfCAlK0cgfCAlIEcgICopXG4gIHwgRmxvYXRfRiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRiB8ICUrRiB8ICUgRiAgKilcbiAgfCBGbG9hdF9oICAgICAgICAgICAgICAgICAgICAgICAgKCogICVoIHwgJStoIHwgJSBoICAqKVxuICB8IEZsb2F0X0ggICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUggfCAlK0ggfCAlIEggICopXG4gIHwgRmxvYXRfQ0YgICAgICAgICAgICAgICAgICAgICAgICgqICAlI0Z8ICUrI0Z8ICUgI0YgKilcbnR5cGUgZmxvYXRfY29udiA9IGZsb2F0X2ZsYWdfY29udiAqIGZsb2F0X2tpbmRfY29udlxuXG4oKioqKVxuXG4oKiBDaGFyIHNldHMgKHNlZSAlWy4uLl0pIGFyZSBiaXRtYXBzIGltcGxlbWVudGVkIGFzIDMyLWNoYXIgc3RyaW5ncy4gKilcbnR5cGUgY2hhcl9zZXQgPSBzdHJpbmdcblxuKCoqKilcblxuKCogQ291bnRlciB1c2VkIGluIFNjYW5mLiAqKVxudHlwZSBjb3VudGVyID1cbiAgfCBMaW5lX2NvdW50ZXIgICAgICgqICAlbCAgICAgICopXG4gIHwgQ2hhcl9jb3VudGVyICAgICAoKiAgJW4gICAgICAqKVxuICB8IFRva2VuX2NvdW50ZXIgICAgKCogICVOLCAlTCAgKilcblxuKCoqKilcblxuKCogUGFkZGluZyBvZiBzdHJpbmdzIGFuZCBudW1iZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwYWRkaW5nID1cbiAgKCogTm8gcGFkZGluZyAoZXg6IFwiJWRcIikgKilcbiAgfCBOb19wYWRkaW5nICA6ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogTGl0ZXJhbCBwYWRkaW5nIChleDogXCIlOGRcIikgKilcbiAgfCBMaXRfcGFkZGluZyA6IHBhZHR5ICogaW50IC0+ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogUGFkZGluZyBhcyBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpkXCIpICopXG4gIHwgQXJnX3BhZGRpbmcgOiBwYWR0eSAtPiAoaW50IC0+ICdhLCAnYSkgcGFkZGluZ1xuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9kLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHBhZGRpbmcgb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcGFkX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogUHJlY2lzaW9uIG9mIGZsb2F0cyBhbmQgJzAnLXBhZGRpbmcgb2YgaW50ZWdlcnMuICopXG50eXBlICgnYSwgJ2IpIHByZWNpc2lvbiA9XG4gICgqIE5vIHByZWNpc2lvbiAoZXg6IFwiJWZcIikgKilcbiAgfCBOb19wcmVjaXNpb24gOiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogTGl0ZXJhbCBwcmVjaXNpb24gKGV4OiBcIiUuM2ZcIikgKilcbiAgfCBMaXRfcHJlY2lzaW9uIDogaW50IC0+ICgnYSwgJ2EpIHByZWNpc2lvblxuICAoKiBQcmVjaXNpb24gYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikgKilcbiAgfCBBcmdfcHJlY2lzaW9uIDogKGludCAtPiAnYSwgJ2EpIHByZWNpc2lvblxuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9mLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHByZWNpc2lvbiBvcHRpb24gKG5vIGV4dHJhIGFyZ3VtZW50KSAqKVxudHlwZSBwcmVjX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogc2VlIHRoZSBDdXN0b20gZm9ybWF0IGNvbWJpbmF0b3IgKilcbnR5cGUgKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSA9XG4gIHwgQ3VzdG9tX3plcm8gOiAoJ2EsIHN0cmluZywgJ2EpIGN1c3RvbV9hcml0eVxuICB8IEN1c3RvbV9zdWNjIDogKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSAtPlxuICAgICgnYSwgJ3ggLT4gJ2IsICd4IC0+ICdjKSBjdXN0b21fYXJpdHlcblxuKCoqKilcblxuKCogICAgICAgIFJlbGF0aW9uYWwgZm9ybWF0IHR5cGVzXG5cbkluIHRoZSBmaXJzdCBmb3JtYXQrZ2FkdHMgaW1wbGVtZW50YXRpb24sIHRoZSB0eXBlIGZvciAlKC4uJSkgaW4gdGhlXG5mbXQgR0FEVCB3YXMgYXMgZm9sbG93czpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqICgnZDEsICdxMSwgJ2QyLCAncTIpIHJlYWRlcl9uYl91bmlmaWVyICpcbiAgICAoJ3gsICdiLCAnYywgJ2QxLCAncTEsICd1KSBmbXR0eSAqXG4gICAgKCd1LCAnYiwgJ2MsICdxMSwgJ2UxLCAnZikgZm10IC0+XG4gICAgICAoKCd4LCAnYiwgJ2MsICdkMiwgJ3EyLCAndSkgZm9ybWF0NiAtPiAneCwgJ2IsICdjLCAnZDEsICdlMSwgJ2YpIGZtdFxuXG5Ob3RpY2UgdGhhdCB0aGUgJ3UgcGFyYW1ldGVyIGluICdmIHBvc2l0aW9uIGluIHRoZSBmb3JtYXQgYXJndW1lbnRcbigoJ3gsIC4uLCAndSkgZm9ybWF0NiAtPiAuLikgaXMgZXF1YWwgdG8gdGhlICd1IHBhcmFtZXRlciBpbiAnYVxucG9zaXRpb24gaW4gdGhlIGZvcm1hdCB0YWlsICgoJ3UsIC4uLCAnZikgZm10KS4gVGhpcyBtZWFucyB0aGF0IHRoZVxudHlwZSBvZiB0aGUgZXhwZWN0ZWQgZm9ybWF0IHBhcmFtZXRlciBkZXBlbmRzIG9mIHdoZXJlIHRoZSAlKC4uLiUpXG5hcmUgaW4gdGhlIGZvcm1hdCBzdHJpbmc6XG5cbiAgIyBQcmludGYucHJpbnRmIFwiJSglKVwiXG4gIC0gOiAodW5pdCwgb3V0X2NoYW5uZWwsIHVuaXQsICdfYSwgJ19hLCB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gdW5pdFxuICA9IDxmdW4+XG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSklZFwiXG4gIC0gOiAoaW50IC0+IHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgaW50IC0+IHVuaXQpXG4gICAgICBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NiAtPiBpbnQgLT4gdW5pdFxuICA9IDxmdW4+XG5cbk9uIHRoZSBjb250cmFyeSwgdGhlIGxlZ2FjeSB0eXBlciBnaXZlcyBhIGNsZXZlciB0eXBlIHRoYXQgZG9lcyBub3RcbmRlcGVuZCBvbiB0aGUgcG9zaXRpb24gb2YgJSguLiUpIGluIHRoZSBmb3JtYXQgc3RyaW5nLiBGb3IgZXhhbXBsZSxcbiUoJSkgd2lsbCBoYXZlIHRoZSBwb2x5bW9ycGhpYyB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKTogaXQgY2FuXG5iZSBjb25jYXRlbmF0ZWQgdG8gYW55IGZvcm1hdCB0eXBlLCBhbmQgb25seSBlbmZvcmNlcyB0aGUgY29uc3RyYWludFxudGhhdCBpdHMgJ2EgYW5kICdmIHBhcmFtZXRlcnMgYXJlIGVxdWFsIChubyBmb3JtYXQgYXJndW1lbnRzKSBhbmQgJ2RcbmFuZCAnZSBhcmUgZXF1YWwgKG5vIHJlYWRlciBhcmd1bWVudCkuXG5cblRoZSB3ZWFrZW5pbmcgb2YgdGhpcyBwYXJhbWV0ZXIgdHlwZSBpbiB0aGUgR0FEVCB2ZXJzaW9uIGJyb2tlIHVzZXJcbmNvZGUgKGluIGZhY3QgaXQgZXNzZW50aWFsbHkgbWFkZSAlKC4uLiUpIHVudXNhYmxlIGV4Y2VwdCBhdCB0aGUgbGFzdFxucG9zaXRpb24gb2YgYSBmb3JtYXQpLiBJbiBwYXJ0aWN1bGFyLCB0aGUgZm9sbG93aW5nIHdvdWxkIG5vdCB3b3JrXG5hbnltb3JlOlxuXG4gIGZ1biBzZXAgLT5cbiAgICBGb3JtYXQucHJpbnRmIFwiZm9vJSglKWJhciUoJSliYXpcIiBzZXAgc2VwXG5cbkFzIHRoZSB0eXBlLWNoZWNrZXIgd291bGQgcmVxdWlyZSB0d28gKmluY29tcGF0aWJsZSogdHlwZXMgZm9yIHRoZSAlKCUpXG5pbiBkaWZmZXJlbnQgcG9zaXRpb25zLlxuXG5UaGUgc29sdXRpb24gdG8gcmVnYWluIGEgZ2VuZXJhbCB0eXBlIGZvciAlKC4uJSkgaXMgdG8gZ2VuZXJhbGl6ZSB0aGlzXG50ZWNobmlxdWUsIG5vdCBvbmx5IG9uIHRoZSAnZCwgJ2UgcGFyYW1ldGVycywgYnV0IG9uIGFsbCBzaXhcbnBhcmFtZXRlcnMgb2YgYSBmb3JtYXQ6IHdlIGludHJvZHVjZSBhIFwicmVsYXRpb25hbFwiIHR5cGVcbiAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbndob3NlIHZhbHVlcyBhcmUgcHJvb2ZzIHRoYXQgKCdhMSwgLi4sICdmMSkgYW5kICgnYTIsIC4uLCAnZjIpIG1vcmFsbHlcbmNvcnJlc3BvbmQgdG8gdGhlIHNhbWUgZm9ybWF0IHR5cGU6ICdhMSBpcyBvYnRhaW5lZCBmcm9tICdmMSwnYjEsJ2MxXG5pbiB0aGUgZXhhY3Qgc2FtZSB3YXkgdGhhdCAnYTIgaXMgb2J0YWluZWQgZnJvbSAnZjIsJ2IyLCdjMiwgZXRjLlxuXG5Gb3IgZXhhbXBsZSwgdGhlIHJlbGF0aW9uIGJldHdlZW4gdHdvIGZvcm1hdCB0eXBlcyBiZWdpbm5pbmcgd2l0aCBhIENoYXJcbnBhcmFtZXRlciBpcyBhcyBmb2xsb3dzOlxuXG58IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgY2hhciAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuSW4gdGhlIGdlbmVyYWwgY2FzZSwgdGhlIHRlcm0gc3RydWN0dXJlIG9mIGZtdHR5X3JlbCBpcyAoYWxtb3N0WzFdKVxuaXNvbW9ycGhpYyB0byB0aGUgZm10dHkgb2YgdGhlIHByZXZpb3VzIGltcGxlbWVudGF0aW9uOiBldmVyeVxuY29uc3RydWN0b3IgaXMgcmUtcmVhZCB3aXRoIGEgYmluYXJ5LCByZWxhdGlvbmFsIHR5cGUsIGluc3RlYWQgb2YgdGhlXG5wcmV2aW91cyB1bmFyeSB0eXBpbmcuIGZtdHR5IGNhbiB0aGVuIGJlIHJlLWRlZmluZWQgYXMgdGhlIGRpYWdvbmFsIG9mXG5mbXR0eV9yZWw6XG5cbiAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgICAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9yZWxcblxuT25jZSB3ZSBoYXZlIHRoaXMgZm10dHlfcmVsIHR5cGUgaW4gcGxhY2UsIHdlIGNhbiBnaXZlIHRoZSBtb3JlXG5nZW5lcmFsIHR5cGUgdG8gJSguLi4lKTpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbldlIGFjY2VwdCBhbnkgZm9ybWF0ICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NikgKHRoaXMgaXNcbmNvbXBsZXRlbHkgdW5yZWxhdGVkIHRvIHRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IGZvcm1hdCksIGJ1dCBhbHNvXG5yZXF1aXJlIGEgcHJvb2YgdGhhdCB0aGlzIGZvcm1hdCBpcyBpbiByZWxhdGlvbiB0byBhbm90aGVyIGZvcm1hdCB0aGF0XG5pcyBjb25jYXRlbmFibGUgdG8gdGhlIGZvcm1hdCB0YWlsLiBXaGVuIGV4ZWN1dGluZyBhICUoLi4uJSkgZm9ybWF0XG4oaW4gY2FtbGludGVybmFsRm9ybWF0Lm1sOm1ha2VfcHJpbnRmIG9yIHNjYW5mLm1sOm1ha2Vfc2NhbmYpLCB3ZVxudHJhbnN0eXBlIHRoZSBmb3JtYXQgYWxvbmcgdGhpcyByZWxhdGlvbiB1c2luZyB0aGUgJ3JlY2FzdCcgZnVuY3Rpb25cbnRvIHRyYW5zcG9zZSBiZXR3ZWVuIHJlbGF0ZWQgZm9ybWF0IHR5cGVzLlxuXG4gIHZhbCByZWNhc3QgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSkgZm10XG4gIC0+ICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIC0+ICgnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXRcblxuTk9URSBbMV06IHRoZSB0eXBpbmcgb2YgRm9ybWF0X3N1YnN0X3R5IHJlcXVpcmVzIG5vdCBvbmUgZm9ybWF0IHR5cGUsIGJ1dFxudHdvLCBvbmUgdG8gZXN0YWJsaXNoIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdCBhcmd1bWVudCBhbmQgdGhlXG5maXJzdCBzaXggcGFyYW1ldGVycywgYW5kIHRoZSBvdGhlciBmb3IgdGhlIGxpbmsgYmV0d2VlbiB0aGUgZm9ybWF0XG5hcmd1bWVudCBhbmQgdGhlIGxhc3Qgc2l4IHBhcmFtZXRlcnMuXG5cbnwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZDEsICdhMSkgZm10dHlfcmVsICpcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG5XaGVuIHdlIGdlbmVyYXRlIGEgZm9ybWF0IEFTVCwgd2UgZ2VuZXJhdGUgZXhhY3RseSB0aGUgc2FtZSB3aXRuZXNzXG5mb3IgYm90aCByZWxhdGlvbnMsIGFuZCB0aGUgd2l0bmVzcy1jb252ZXJzaW9uIGZ1bmN0aW9ucyBpblxuY2FtbGludGVybmFsRm9ybWF0IGRvIHJlbHkgb24gdGhpcyBpbnZhcmlhbnQuIEZvciBleGFtcGxlLCB0aGVcbmZ1bmN0aW9uIHRoYXQgcHJvdmVzIHRoYXQgdGhlIHJlbGF0aW9uIGlzIHRyYW5zaXRpdmVcblxuICB2YWwgdHJhbnMgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMixcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuXG5kb2VzIGFzc3VtZSB0aGF0IHRoZSB0d28gaW5wdXRzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSB0ZXJtIHN0cnVjdHVyZVxuKGFuZCBpcyBvbmx5IGV2ZXJ5IHVzZWQgZm9yIGFyZ3VtZW50IHdpdG5lc3NlcyBvZiB0aGVcbkZvcm1hdF9zdWJzdF90eSBjb25zdHJ1Y3RvcikuXG4qKVxuXG4oKiBUeXBlIG9mIGEgYmxvY2sgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBibG9ja190eXBlID1cbiAgfCBQcF9oYm94ICAgKCogSG9yaXpvbnRhbCBibG9jayBubyBsaW5lIGJyZWFraW5nICopXG4gIHwgUHBfdmJveCAgICgqIFZlcnRpY2FsIGJsb2NrIGVhY2ggYnJlYWsgbGVhZHMgdG8gYSBuZXcgbGluZSAqKVxuICB8IFBwX2h2Ym94ICAoKiBIb3Jpem9udGFsLXZlcnRpY2FsIGJsb2NrOiBzYW1lIGFzIHZib3gsIGV4Y2VwdCBpZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICAgICAgIGlzIHNtYWxsIGVub3VnaCB0byBmaXQgb24gYSBzaW5nbGUgbGluZSAqKVxuICB8IFBwX2hvdmJveCAoKiBIb3Jpem9udGFsIG9yIFZlcnRpY2FsIGJsb2NrOiBicmVha3MgbGVhZCB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICBvbmx5IHdoZW4gbmVjZXNzYXJ5IHRvIHByaW50IHRoZSBjb250ZW50IG9mIHRoZSBibG9jayAqKVxuICB8IFBwX2JveCAgICAoKiBIb3Jpem9udGFsIG9yIEluZGVudCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2ssIG9yXG4gICAgICAgICAgICAgICAgIHdoZW4gaXQgbGVhZHMgdG8gYSBuZXcgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgbGluZSAqKVxuICB8IFBwX2ZpdHMgICAoKiBJbnRlcm5hbCB1c2FnZTogd2hlbiBhIGJsb2NrIGZpdHMgb24gYSBzaW5nbGUgbGluZSAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBmb3JtYXR0aW5nX2xpdCA9XG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBdICAgKilcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQH0gICAqKVxuICB8IEJyZWFrIG9mIHN0cmluZyAqIGludCAqIGludCAgICAgICAgICAoKiBALCB8IEAgIHwgQDsgfCBAOzw+ICopXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEA/ICAgKilcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFxcbiAgKilcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQC4gICAqKVxuICB8IE1hZ2ljX3NpemUgb2Ygc3RyaW5nICogaW50ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPG4+ICopXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBAICAgKilcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQCUlICAqKVxuICB8IFNjYW5faW5kaWMgb2YgY2hhciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAWCAgICopXG5cbigqIEZvcm1hdHRpbmcgZWxlbWVudCB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlbiA9XG4gIHwgT3Blbl90YWcgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEB7ICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cbiAgfCBPcGVuX2JveCA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICAgICAgKCogQFsgICAqKVxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlblxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCB0eXBlIGVsZW1lbnRzLiAqKVxuKCogSW4gcGFydGljdWxhciB1c2VkIHRvIHJlcHJlc2VudCAlKC4uLiUpIGFuZCAley4uLiV9IGNvbnRlbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSA9XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5hbmQgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCA9XG4gIHwgQ2hhcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoY2hhciAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgU3RyaW5nX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoc3RyaW5nIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgc3RyaW5nIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQzMl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQzMiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDMyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IE5hdGl2ZWludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbmQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKG5hdGl2ZWludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIG5hdGl2ZWludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQ2NF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQ2NCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDY0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEZsb2F0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGZsb2F0IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgZmxvYXQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQm9vbF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVCICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoYm9vbCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGJvb2wgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBGb3JtYXRfYXJnX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG4gIHwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiMiwgJ2MyLCAnajIsICdkMiwgJ2EyKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZTEsICdmMSxcbiAgICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKVxuICAgICAgICAgICBmbXR0eV9yZWxcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnMuICopXG4gIHwgQWxwaGFfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdiMSAtPiAneCAtPiAnYzEpIC0+ICd4IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdiMiAtPiAneCAtPiAnYzIpIC0+ICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFRoZXRhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ2MxKSAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ2MyKSAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBBbnlfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFVzZWQgZm9yIGN1c3RvbSBmb3JtYXRzICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IFJlYWRlcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCd4IC0+ICdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ3ggLT4gJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBFbmRfb2ZfZm10dHkgOlxuICAgICAgKCdmMSwgJ2IxLCAnYzEsICdkMSwgJ2QxLCAnZjEsXG4gICAgICAgJ2YyLCAnYjIsICdjMiwgJ2QyLCAnZDIsICdmMikgZm10dHlfcmVsXG5cbigqKiopXG5cbigqIExpc3Qgb2YgZm9ybWF0IGVsZW1lbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgPVxuICB8IENoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVDICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFN0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVTICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDMyIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgTmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5bZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBuYXRpdmVpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlTFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDY0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtmZUVnR0ZoSF0gKilcbiAgICAgIGZsb2F0X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBmbG9hdCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEJvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbYkJdICopXG4gICAgICAoJ3gsIGJvb2wgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGbHVzaCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlISAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBhYmMgKilcbiAgICAgIHN0cmluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENoYXJfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIHggKilcbiAgICAgIGNoYXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IEZvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYiwgJ2MsICdqMiwgJ2UsICdmKSBmbXRcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBBbHBoYSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICd4IC0+ICdjKSAtPiAneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBUaGV0YSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICdjKSAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3I6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgIGZvcm1hdHRpbmdfbGl0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0dGluZ19nZW4gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UxLCAnZjEpIGZvcm1hdHRpbmdfZ2VuICpcbiAgICAgICgnZjEsICdiLCAnYywgJ2UxLCAnZTIsICdmMikgZm10IC0+ICgnYTEsICdiLCAnYywgJ2QxLCAnZTIsICdmMikgZm10XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVyICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCAtPiAnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoc3RyaW5nIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChpbnQgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJTBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJZ25vcmVkX3BhcmFtIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGlnbm9yZWQgKiAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBDdXN0b20gcHJpbnRpbmcgZm9ybWF0IChQUiM2NDUyLCBHUFIjMTQwKVxuXG4gICAgIFdlIGluY2x1ZGUgYSB0eXBlIEN1c3RvbSBvZiBcImN1c3RvbSBjb252ZXJ0ZXJzXCIsIHdoZXJlIGFuXG4gICAgIGFyYml0cmFyeSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjb252ZXJ0IG9uZSBvciBtb3JlXG4gICAgIGFyZ3VtZW50cy4gVGhlcmUgaXMgbm8gc3ludGF4IGZvciBjdXN0b20gY29udmVydGVycywgaXQgaXMgb25seVxuICAgICBpbnRlbmRlZCBmb3IgY3VzdG9tIHByb2Nlc3NvcnMgdGhhdCB3aXNoIHRvIHJlbHkgb24gdGhlXG4gICAgIHN0ZGxpYi1kZWZpbmVkIGZvcm1hdCBHQURUcy5cblxuICAgICBGb3IgaW5zdGFuY2UgYSBwcmUtcHJvY2Vzc29yIGNvdWxkIGNob29zZSB0byBpbnRlcnByZXQgc3RyaW5nc1xuICAgICBwcmVmaXhlZCB3aXRoIFtcIiFcIl0gYXMgZm9ybWF0IHN0cmluZ3Mgd2hlcmUgWyV7eyAuLi4gfX1dIGlzXG4gICAgIGEgc3BlY2lhbCBmb3JtIHRvIHBhc3MgYSB0b19zdHJpbmcgZnVuY3Rpb24sIHNvIHRoYXQgb25lIGNvdWxkXG4gICAgIHdyaXRlOlxuXG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID0geyB4IDogaW50OyB5IDogaW50IH1cblxuICAgICAgIGxldCBzdHJpbmdfb2ZfdCB0ID0gUHJpbnRmLnNwcmludGYgXCJ7IHggPSAlZDsgeSA9ICVkIH1cIiB0LnggdC55XG5cbiAgICAgICBQcmludGYucHJpbnRmICFcInQgPSAle3tzdHJpbmdfb2ZfdH19XCIgeyB4ID0gNDI7IHkgPSA0MiB9XG4gICAgIF19XG4gICopXG4gIHwgQ3VzdG9tIDpcbiAgICAgICgnYSwgJ3gsICd5KSBjdXN0b21fYXJpdHkgKiAodW5pdCAtPiAneCkgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogZW5kIG9mIGEgZm9ybWF0IHNwZWNpZmljYXRpb24gKilcbiAgfCBFbmRfb2ZfZm9ybWF0IDpcbiAgICAgICAgKCdmLCAnYiwgJ2MsICdlLCAnZSwgJ2YpIGZtdFxuXG4oKioqKVxuXG4oKiBUeXBlIGZvciBpZ25vcmVkIHBhcmFtZXRlcnMgKHNlZSBcIiVfXCIpLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkID1cbiAgfCBJZ25vcmVkX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9DICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfcyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfUyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9sZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9uZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9MZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mbG9hdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9mICopXG4gICAgICBwYWRfb3B0aW9uICogcHJlY19vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Jvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0IgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3suLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9yZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9yICopXG4gICAgICAoJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0IC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXzBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAqIHN0cmluZ1xuXG5sZXQgcmVjIGVyYXNlX3JlbCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAoYSwgYiwgYywgZCwgZSwgZixcbiAgIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIF90eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGUgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0IHR5cGVzLiAqKVxuKCogVXNlZCBieTpcbiAgICogcmVhZGVyX25iX3VuaWZpZXJfb2ZfZm10dHkgdG8gY291bnQgcmVhZGVycyBpbiBhbiBmbXR0eSxcbiAgICogU2NhbmYudGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyB0byBleHRyYWN0IHJlYWRlcnMgaW5zaWRlICUoLi4uJSksXG4gICAqIENhbWxpbnRlcm5hbEZvcm1hdC5mbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCB0byBleHRyYWN0IGZvcm1hdCB0eXBlLiAqKVxuXG4oKlxubGV0IHJlYyBjb25jYXRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdHR5ID1cbiopXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAgICAgIGcxIGoxIGcyIGoyXG4gIC5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGQxLCBhMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGQyLCBhMikgZm10dHlfcmVsIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZTEsIGYxLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZTIsIGYyKSBmbXR0eV9yZWwgPVxuZnVuIGZtdHR5MSBmbXR0eTIgLT4gbWF0Y2ggZm10dHkxIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEVuZF9vZl9mbXR0eSAtPiBmbXR0eTJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXRzLiAqKVxubGV0IHJlYyBjb25jYXRfZm10IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdCA9XG5mdW4gZm10MSBmbXQyIC0+IG1hdGNoIGZtdDEgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIFN0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIENhbWxfc3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDY0IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBDaGFyIChyZXN0KSAtPlxuICAgIENoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgQ2FtbF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgQm9vbCAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgQWxwaGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBUaGV0YSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBDdXN0b20gKGFyaXR5LCBmLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBSZWFkZXIgcmVzdCAtPlxuICAgIFJlYWRlciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIEZsdXNoIChjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nX2xpdGVyYWwgKHN0ciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgQ2hhcl9saXRlcmFsICAgKGNociwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmcgICAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgKHJlc3QpIC0+XG4gICAgU2Nhbl9uZXh0X2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBJZ25vcmVkX3BhcmFtIChpZ24sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBmbXQyXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBHYWJyaWVsIFNjaGVyZXIsIHByb2pldCBQYXJ0b3V0LCBJTlJJQSBQYXJpcy1TYWNsYXkgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDIwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENhbWxpbnRlcm5hbEF0b21pYyBpcyBhIGRlcGVuZGVuY3kgb2YgU3RkbGliLCBzbyBpdCBpcyBjb21waWxlZCB3aXRoXG4gICAtbm9wZXJ2YXNpdmVzLiAqKVxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5cbigqIFdlIGFyZSBub3QgcmV1c2luZyAoJ2EgcmVmKSBkaXJlY3RseSB0byBtYWtlIGl0IGVhc2llciB0byByZWFzb25cbiAgIGFib3V0IGF0b21pY2l0eSBpZiB3ZSB3aXNoIHRvOiBldmVuIGluIGEgc2VxdWVudGlhbCBpbXBsZW1lbnRhdGlvbixcbiAgIHNpZ25hbHMgYW5kIG90aGVyIGFzeW5jaHJvbm91cyBjYWxsYmFja3MgbWlnaHQgYnJlYWsgYXRvbWljaXR5LiAqKVxudHlwZSAnYSB0ID0ge211dGFibGUgdjogJ2F9XG5cbmxldCBtYWtlIHYgPSB7dn1cbmxldCBnZXQgciA9IHIudlxubGV0IHNldCByIHYgPSByLnYgPC0gdlxuXG4oKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgc2V0IHRvIG5ldmVyIGJlIGlubGluZWQ6IEZsYW1iZGEgaXNcbiAgIGFsbG93ZWQgdG8gbW92ZSBzdXJyb3VuZGluZyBjb2RlIGluc2lkZSB0aGUgY3JpdGljYWwgc2VjdGlvbixcbiAgIGluY2x1ZGluZyBhbGxvY2F0aW9ucy4gKilcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGV4Y2hhbmdlIHIgdiA9XG4gICgqIEJFR0lOIEFUT01JQyAqKVxuICBsZXQgY3VyID0gci52IGluXG4gIHIudiA8LSB2O1xuICAoKiBFTkQgQVRPTUlDICopXG4gIGN1clxuXG5sZXRbQGlubGluZSBuZXZlcl0gY29tcGFyZV9hbmRfc2V0IHIgc2VlbiB2ID1cbiAgKCogQkVHSU4gQVRPTUlDICopXG4gIGxldCBjdXIgPSByLnYgaW5cbiAgaWYgY3VyID09IHNlZW4gdGhlbiAoXG4gICAgci52IDwtIHY7XG4gICAgKCogRU5EIEFUT01JQyAqKVxuICAgIHRydWVcbiAgKSBlbHNlXG4gICAgZmFsc2VcblxubGV0W0BpbmxpbmUgbmV2ZXJdIGZldGNoX2FuZF9hZGQgciBuID1cbiAgKCogQkVHSU4gQVRPTUlDICopXG4gIGxldCBjdXIgPSByLnYgaW5cbiAgci52IDwtIChjdXIgKyBuKTtcbiAgKCogRU5EIEFUT01JQyAqKVxuICBjdXJcblxubGV0IGluY3IgciA9IGlnbm9yZSAoZmV0Y2hfYW5kX2FkZCByIDEpXG5sZXQgZGVjciByID0gaWdub3JlIChmZXRjaF9hbmRfYWRkIHIgKC0xKSlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXhjZXB0aW9ucyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gICgqIGZvciBydW50aW1lL2ZhaWxfbmF0LmMgKilcbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQZXJ2YXNpdmVzLmFycmF5X2JvdW5kX2Vycm9yXCJcbiAgICAoSW52YWxpZF9hcmd1bWVudCBcImluZGV4IG91dCBvZiBib3VuZHNcIilcblxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZVwiXG5leHRlcm5hbCByYWlzZV9ub3RyYWNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2Vfbm90cmFjZVwiXG5cbmxldCBmYWlsd2l0aCBzID0gcmFpc2UoRmFpbHVyZSBzKVxubGV0IGludmFsaWRfYXJnIHMgPSByYWlzZShJbnZhbGlkX2FyZ3VtZW50IHMpXG5cbmV4Y2VwdGlvbiBFeGl0XG5leGNlcHRpb24gTWF0Y2hfZmFpbHVyZSA9IE1hdGNoX2ZhaWx1cmVcbmV4Y2VwdGlvbiBBc3NlcnRfZmFpbHVyZSA9IEFzc2VydF9mYWlsdXJlXG5leGNlcHRpb24gSW52YWxpZF9hcmd1bWVudCA9IEludmFsaWRfYXJndW1lbnRcbmV4Y2VwdGlvbiBGYWlsdXJlID0gRmFpbHVyZVxuZXhjZXB0aW9uIE5vdF9mb3VuZCA9IE5vdF9mb3VuZFxuZXhjZXB0aW9uIE91dF9vZl9tZW1vcnkgPSBPdXRfb2ZfbWVtb3J5XG5leGNlcHRpb24gU3RhY2tfb3ZlcmZsb3cgPSBTdGFja19vdmVyZmxvd1xuZXhjZXB0aW9uIFN5c19lcnJvciA9IFN5c19lcnJvclxuZXhjZXB0aW9uIEVuZF9vZl9maWxlID0gRW5kX29mX2ZpbGVcbmV4Y2VwdGlvbiBEaXZpc2lvbl9ieV96ZXJvID0gRGl2aXNpb25fYnlfemVyb1xuZXhjZXB0aW9uIFN5c19ibG9ja2VkX2lvID0gU3lzX2Jsb2NrZWRfaW9cbmV4Y2VwdGlvbiBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZSA9IFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlXG5cbigqIENvbXBvc2l0aW9uIG9wZXJhdG9ycyAqKVxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuKCogRGVidWdnaW5nICopXG5cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCBfX0ZVTkNUSU9OX18gOiBzdHJpbmcgPSBcIiVsb2NfRlVOQ1RJT05cIlxuXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuXG4oKiBDb21wYXJpc29ucyAqKVxuXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoID49ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcblxubGV0IG1pbiB4IHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcblxuKCogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggb3IgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcblxuKCogSW50ZWdlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcblxuZXh0ZXJuYWwgKCBsYW5kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcblxubGV0IGxub3QgeCA9IHggbHhvciAoLTEpXG5cbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcblxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5cbigqIEZsb2F0aW5nLXBvaW50IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LS4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgKCB+Ky4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCArLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCAoIC0uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsICggKi4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgKCAvLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCAoICoqICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxubGV0IGluZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5lZ19pbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHhGRl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuYW4gPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDFMXG5sZXQgbWF4X2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0VGX0ZGX0ZGX0ZGX0ZGX0ZGX0ZGTFxubGV0IG1pbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgwMF8xMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBlcHNpbG9uX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDNDX0IwXzAwXzAwXzAwXzAwXzAwXzAwTFxuXG50eXBlIGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cblxuKCogU3RyaW5nIGFuZCBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGVzIFN0cmluZyBhbmQgQnl0ZXMgKilcblxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2xlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19jcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHN0cmluZ19ibGl0IDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgKCBeICkgczEgczIgPVxuICBsZXQgbDEgPSBzdHJpbmdfbGVuZ3RoIHMxIGFuZCBsMiA9IHN0cmluZ19sZW5ndGggczIgaW5cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgKGwxICsgbDIpIGluXG4gIHN0cmluZ19ibGl0IHMxIDAgcyAwIGwxO1xuICBzdHJpbmdfYmxpdCBzMiAwIHMgbDEgbDI7XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBDaGFyICopXG5cbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hhcl9vZl9pbnQgOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcbmxldCBjaGFyX29mX2ludCBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiY2hhcl9vZl9pbnRcIiBlbHNlIHVuc2FmZV9jaGFyX29mX2ludCBuXG5cbigqIFVuaXQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogUGFpciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5cbigqIFJlZmVyZW5jZXMgKilcblxudHlwZSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG5cbigqIFJlc3VsdCB0eXBlICopXG5cbnR5cGUgKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG5cbigqIFN0cmluZyBjb252ZXJzaW9uIGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbmxldCBzdHJpbmdfb2ZfYm9vbCBiID1cbiAgaWYgYiB0aGVuIFwidHJ1ZVwiIGVsc2UgXCJmYWxzZVwiXG5sZXQgYm9vbF9vZl9zdHJpbmcgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBfIC0+IGludmFsaWRfYXJnIFwiYm9vbF9vZl9zdHJpbmdcIlxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiBTb21lIHRydWVcbiAgfCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxuICB8IF8gLT4gTm9uZVxuXG5sZXQgc3RyaW5nX29mX2ludCBuID1cbiAgZm9ybWF0X2ludCBcIiVkXCIgblxuXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuZXh0ZXJuYWwgc3RyaW5nX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5cbmxldCB2YWxpZF9mbG9hdF9sZXhlbSBzID1cbiAgbGV0IGwgPSBzdHJpbmdfbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPj0gbCB0aGVuIHMgXiBcIi5cIiBlbHNlXG4gICAgbWF0Y2ggc3RyaW5nX2dldCBzIGkgd2l0aFxuICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBsb29wIChpICsgMSlcbiAgICB8IF8gLT4gc1xuICBpblxuICBsb29wIDBcblxubGV0IHN0cmluZ19vZl9mbG9hdCBmID0gdmFsaWRfZmxvYXRfbGV4ZW0gKGZvcm1hdF9mbG9hdCBcIiUuMTJnXCIgZilcblxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgTGlzdCAqKVxuXG5sZXQgcmVjICggQCApIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgaGQgOjogdGwgLT4gaGQgOjogKHRsIEAgbDIpXG5cbigqIEkvTyBvcGVyYXRpb25zICopXG5cbnR5cGUgaW5fY2hhbm5lbFxudHlwZSBvdXRfY2hhbm5lbFxuXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDogaW50IC0+IG91dF9jaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcIlxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX2luIDogaW50IC0+IGluX2NoYW5uZWwgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXCJcblxubGV0IHN0ZGluID0gb3Blbl9kZXNjcmlwdG9yX2luIDBcbmxldCBzdGRvdXQgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDFcbmxldCBzdGRlcnIgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDJcblxuKCogR2VuZXJhbCBvdXRwdXQgZnVuY3Rpb25zICopXG5cbnR5cGUgb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seSB8IE9wZW5fd3Jvbmx5IHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0IHwgT3Blbl90cnVuYyB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5IHwgT3Blbl90ZXh0IHwgT3Blbl9ub25ibG9ja1xuXG5leHRlcm5hbCBvcGVuX2Rlc2MgOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5cbmV4dGVybmFsIHNldF9vdXRfY2hhbm5lbF9uYW1lOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5fb3V0X2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX291dChvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9vdXRfY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9vdXQgbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fdGV4dF0gMG82NjYgbmFtZVxuXG5sZXQgb3Blbl9vdXRfYmluIG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX2JpbmFyeV0gMG82NjYgbmFtZVxuXG5leHRlcm5hbCBmbHVzaCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfZmx1c2hcIlxuXG5leHRlcm5hbCBvdXRfY2hhbm5lbHNfbGlzdCA6IHVuaXQgLT4gb3V0X2NoYW5uZWwgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3RcIlxuXG5sZXQgZmx1c2hfYWxsICgpID1cbiAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIFtdIC0+ICgpXG4gICAgfCBhOjpsIC0+XG4gICAgICAgIGJlZ2luIHRyeVxuICAgICAgICAgICAgZmx1c2ggYVxuICAgICAgICB3aXRoIFN5c19lcnJvciBfIC0+XG4gICAgICAgICAgKCkgKCogaWdub3JlIGNoYW5uZWxzIGNsb3NlZCBkdXJpbmcgYSBwcmVjZWRpbmcgZmx1c2guICopXG4gICAgICAgIGVuZDtcbiAgICAgICAgaXRlciBsXG4gIGluIGl0ZXIgKG91dF9jaGFubmVsc19saXN0ICgpKVxuXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0IDogb3V0X2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dF9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0X3N0cmluZyA6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dFwiXG5cbmV4dGVybmFsIG91dHB1dF9jaGFyIDogb3V0X2NoYW5uZWwgLT4gY2hhciAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcblxubGV0IG91dHB1dF9ieXRlcyBvYyBzID1cbiAgdW5zYWZlX291dHB1dCBvYyBzIDAgKGJ5dGVzX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0X3N0cmluZyBvYyBzID1cbiAgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyAwIChzdHJpbmdfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXQgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXQgb2MgcyBvZnMgbGVuXG5cbmxldCBvdXRwdXRfc3Vic3RyaW5nIG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBzdHJpbmdfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dF9zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgb2ZzIGxlblxuXG5leHRlcm5hbCBvdXRwdXRfYnl0ZSA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcbmV4dGVybmFsIG91dHB1dF9iaW5hcnlfaW50IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2ludFwiXG5cbmV4dGVybmFsIG1hcnNoYWxfdG9fY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+ICdhIC0+IHVuaXQgbGlzdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5sZXQgb3V0cHV0X3ZhbHVlIGNoYW4gdiA9IG1hcnNoYWxfdG9fY2hhbm5lbCBjaGFuIHYgW11cblxuZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dFwiXG5leHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19vdXRcIlxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9vdXRfY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2Vfb3V0IG9jID0gZmx1c2ggb2M7IGNsb3NlX291dF9jaGFubmVsIG9jXG5sZXQgY2xvc2Vfb3V0X25vZXJyIG9jID1cbiAgKHRyeSBmbHVzaCBvYyB3aXRoIF8gLT4gKCkpO1xuICAodHJ5IGNsb3NlX291dF9jaGFubmVsIG9jIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9vdXQgOiBvdXRfY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogR2VuZXJhbCBpbnB1dCBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgc2V0X2luX2NoYW5uZWxfbmFtZTogaW5fY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5faW5fZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3JfaW4ob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfaW5fY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9pbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX3RleHRdIDAgbmFtZVxuXG5sZXQgb3Blbl9pbl9iaW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl9iaW5hcnldIDAgbmFtZVxuXG5leHRlcm5hbCBpbnB1dF9jaGFyIDogaW5fY2hhbm5lbCAtPiBjaGFyID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuXG5leHRlcm5hbCB1bnNhZmVfaW5wdXQgOiBpbl9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfaW5wdXRcIlxuXG5sZXQgaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJpbnB1dFwiXG4gIGVsc2UgdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVjIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgbGVuIDw9IDAgdGhlbiAoKSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuIGluXG4gICAgaWYgciA9IDBcbiAgICB0aGVuIHJhaXNlIEVuZF9vZl9maWxlXG4gICAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgKG9mcyArIHIpIChsZW4gLSByKVxuICBlbmRcblxubGV0IHJlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcInJlYWxseV9pbnB1dFwiXG4gIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYWxseV9pbnB1dF9zdHJpbmcgaWMgbGVuID1cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgbGVuIGluXG4gIHJlYWxseV9pbnB1dCBpYyBzIDAgbGVuO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuZXh0ZXJuYWwgaW5wdXRfc2Nhbl9saW5lIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXCJcblxubGV0IGlucHV0X2xpbmUgY2hhbiA9XG4gIGxldCByZWMgYnVpbGRfcmVzdWx0IGJ1ZiBwb3MgPSBmdW5jdGlvblxuICAgIFtdIC0+IGJ1ZlxuICB8IGhkIDo6IHRsIC0+XG4gICAgICBsZXQgbGVuID0gYnl0ZXNfbGVuZ3RoIGhkIGluXG4gICAgICBieXRlc19ibGl0IGhkIDAgYnVmIChwb3MgLSBsZW4pIGxlbjtcbiAgICAgIGJ1aWxkX3Jlc3VsdCBidWYgKHBvcyAtIGxlbikgdGwgaW5cbiAgbGV0IHJlYyBzY2FuIGFjY3UgbGVuID1cbiAgICBsZXQgbiA9IGlucHV0X3NjYW5fbGluZSBjaGFuIGluXG4gICAgaWYgbiA9IDAgdGhlbiBiZWdpbiAgICAgICAgICAgICAgICAgICAoKiBuID0gMDogd2UgYXJlIGF0IEVPRiAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJhaXNlIEVuZF9vZl9maWxlXG4gICAgICB8IF8gIC0+IGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIGFjY3VcbiAgICBlbmQgZWxzZSBpZiBuID4gMCB0aGVuIGJlZ2luICAgICAgICAgICgqIG4gPiAwOiBuZXdsaW5lIGZvdW5kIGluIGJ1ZmZlciAqKVxuICAgICAgbGV0IHJlcyA9IGJ5dGVzX2NyZWF0ZSAobiAtIDEpIGluXG4gICAgICBpZ25vcmUgKHVuc2FmZV9pbnB1dCBjaGFuIHJlcyAwIChuIC0gMSkpO1xuICAgICAgaWdub3JlIChpbnB1dF9jaGFyIGNoYW4pOyAgICAgICAgICAgKCogc2tpcCB0aGUgbmV3bGluZSAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJlc1xuICAgICAgfCAgXyAtPiBsZXQgbGVuID0gbGVuICsgbiAtIDEgaW5cbiAgICAgICAgICAgICAgYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gKHJlcyA6OiBhY2N1KVxuICAgIGVuZCBlbHNlIGJlZ2luICAgICAgICAgICAgICAgICAgICAgICAgKCogbiA8IDA6IG5ld2xpbmUgbm90IGZvdW5kICopXG4gICAgICBsZXQgYmVnID0gYnl0ZXNfY3JlYXRlICgtbikgaW5cbiAgICAgIGlnbm9yZSh1bnNhZmVfaW5wdXQgY2hhbiBiZWcgMCAoLW4pKTtcbiAgICAgIHNjYW4gKGJlZyA6OiBhY2N1KSAobGVuIC0gbilcbiAgICBlbmRcbiAgaW4gYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyAoc2NhbiBbXSAwKVxuXG5leHRlcm5hbCBpbnB1dF9ieXRlIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5leHRlcm5hbCBpbnB1dF9iaW5hcnlfaW50IDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfaW50XCJcbmV4dGVybmFsIGlucHV0X3ZhbHVlIDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXCJcbmV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19pblwiXG5leHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9pbl9ub2VyciBpYyA9ICh0cnkgY2xvc2VfaW4gaWMgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX2luIDogaW5fY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIG91dHB1dCAqKVxuXG5sZXQgcHJpbnRfY2hhciBjID0gb3V0cHV0X2NoYXIgc3Rkb3V0IGNcbmxldCBwcmludF9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IHNcbmxldCBwcmludF9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZG91dCBzXG5sZXQgcHJpbnRfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByaW50X2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJpbnRfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRvdXQgczsgb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcbmxldCBwcmludF9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBlcnJvciAqKVxuXG5sZXQgcHJlcnJfY2hhciBjID0gb3V0cHV0X2NoYXIgc3RkZXJyIGNcbmxldCBwcmVycl9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIHNcbmxldCBwcmVycl9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZGVyciBzXG5sZXQgcHJlcnJfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByZXJyX2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJlcnJfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRlcnIgczsgb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcbmxldCBwcmVycl9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcblxuKCogSW5wdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGlucHV0ICopXG5cbmxldCByZWFkX2xpbmUgKCkgPSBmbHVzaCBzdGRvdXQ7IGlucHV0X2xpbmUgc3RkaW5cbmxldCByZWFkX2ludCAoKSA9IGludF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9pbnRfb3B0ICgpID0gaW50X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdCAoKSA9IGZsb2F0X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0X29wdCAoKSA9IGZsb2F0X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5cbigqIE9wZXJhdGlvbnMgb24gbGFyZ2UgZmlsZXMgKilcblxubW9kdWxlIExhcmdlRmlsZSA9XG4gIHN0cnVjdFxuICAgIGV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dF82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19vdXRfNjRcIlxuICAgIGV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludDY0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gICAgZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXzY0XCJcbiAgICBleHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19pbl82NFwiXG4gICAgZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gIGVuZFxuXG4oKiBGb3JtYXRzICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG4gICA9IEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZtdFxuICAgICAgICAgICAgICAgKiBzdHJpbmdcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxuXG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcblxubGV0IHN0cmluZ19vZl9mb3JtYXQgKEZvcm1hdCAoX2ZtdCwgc3RyKSkgPSBzdHJcblxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcblxubGV0ICggXl4gKSAoRm9ybWF0IChmbXQxLCBzdHIxKSkgKEZvcm1hdCAoZm10Miwgc3RyMikpID1cbiAgRm9ybWF0IChDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuY29uY2F0X2ZtdCBmbXQxIGZtdDIsXG4gICAgICAgICAgc3RyMSBeIFwiJSxcIiBeIHN0cjIpXG5cbigqIE1pc2NlbGxhbmVvdXMgKilcblxuZXh0ZXJuYWwgc3lzX2V4aXQgOiBpbnQgLT4gJ2EgPSBcImNhbWxfc3lzX2V4aXRcIlxuXG5sZXQgZXhpdF9mdW5jdGlvbiA9IENhbWxpbnRlcm5hbEF0b21pYy5tYWtlIGZsdXNoX2FsbFxuXG5sZXQgcmVjIGF0X2V4aXQgZiA9XG4gIGxldCBtb2R1bGUgQXRvbWljID0gQ2FtbGludGVybmFsQXRvbWljIGluXG4gICgqIE1QUiM3MjUzLCBNUFIjNzc5NjogbWFrZSBzdXJlIFwiZlwiIGlzIGV4ZWN1dGVkIG9ubHkgb25jZSAqKVxuICBsZXQgZl95ZXRfdG9fcnVuID0gQXRvbWljLm1ha2UgdHJ1ZSBpblxuICBsZXQgb2xkX2V4aXQgPSBBdG9taWMuZ2V0IGV4aXRfZnVuY3Rpb24gaW5cbiAgbGV0IG5ld19leGl0ICgpID1cbiAgICBpZiBBdG9taWMuY29tcGFyZV9hbmRfc2V0IGZfeWV0X3RvX3J1biB0cnVlIGZhbHNlIHRoZW4gZiAoKSA7XG4gICAgb2xkX2V4aXQgKClcbiAgaW5cbiAgbGV0IHN1Y2Nlc3MgPSBBdG9taWMuY29tcGFyZV9hbmRfc2V0IGV4aXRfZnVuY3Rpb24gb2xkX2V4aXQgbmV3X2V4aXQgaW5cbiAgaWYgbm90IHN1Y2Nlc3MgdGhlbiBhdF9leGl0IGZcblxubGV0IGRvX2F0X2V4aXQgKCkgPSAoQ2FtbGludGVybmFsQXRvbWljLmdldCBleGl0X2Z1bmN0aW9uKSAoKVxuXG5sZXQgZXhpdCByZXRjb2RlID1cbiAgZG9fYXRfZXhpdCAoKTtcbiAgc3lzX2V4aXQgcmV0Y29kZVxuXG5sZXQgXyA9IHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIgZG9fYXRfZXhpdFxuXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBuYWtlZF9wb2ludGVyc19jaGVja2VkIDogdW5pdCAtPiBib29sXG4gID0gXCJjYW1sX3N5c19jb25zdF9uYWtlZF9wb2ludGVyc19jaGVja2VkXCJcbmxldCAoKSA9IGlmIG5ha2VkX3BvaW50ZXJzX2NoZWNrZWQgKCkgdGhlbiBhdF9leGl0IG1ham9yXG5cbigqTU9EVUxFX0FMSUFTRVMqKVxubW9kdWxlIEFyZyAgICAgICAgICA9IEFyZ1xubW9kdWxlIEFycmF5ICAgICAgICA9IEFycmF5XG5tb2R1bGUgQXJyYXlMYWJlbHMgID0gQXJyYXlMYWJlbHNcbm1vZHVsZSBBdG9taWMgICAgICAgPSBBdG9taWNcbm1vZHVsZSBCaWdhcnJheSAgICAgPSBCaWdhcnJheVxubW9kdWxlIEJvb2wgICAgICAgICA9IEJvb2xcbm1vZHVsZSBCdWZmZXIgICAgICAgPSBCdWZmZXJcbm1vZHVsZSBCeXRlcyAgICAgICAgPSBCeXRlc1xubW9kdWxlIEJ5dGVzTGFiZWxzICA9IEJ5dGVzTGFiZWxzXG5tb2R1bGUgQ2FsbGJhY2sgICAgID0gQ2FsbGJhY2tcbm1vZHVsZSBDaGFyICAgICAgICAgPSBDaGFyXG5tb2R1bGUgQ29tcGxleCAgICAgID0gQ29tcGxleFxubW9kdWxlIERpZ2VzdCAgICAgICA9IERpZ2VzdFxubW9kdWxlIEVpdGhlciAgICAgICA9IEVpdGhlclxubW9kdWxlIEVwaGVtZXJvbiAgICA9IEVwaGVtZXJvblxubW9kdWxlIEZpbGVuYW1lICAgICA9IEZpbGVuYW1lXG5tb2R1bGUgRmxvYXQgICAgICAgID0gRmxvYXRcbm1vZHVsZSBGb3JtYXQgICAgICAgPSBGb3JtYXRcbm1vZHVsZSBGdW4gICAgICAgICAgPSBGdW5cbm1vZHVsZSBHYyAgICAgICAgICAgPSBHY1xubW9kdWxlIEdlbmxleCAgICAgICA9IEdlbmxleFxubW9kdWxlIEhhc2h0YmwgICAgICA9IEhhc2h0Ymxcbm1vZHVsZSBJbnQgICAgICAgICAgPSBJbnRcbm1vZHVsZSBJbnQzMiAgICAgICAgPSBJbnQzMlxubW9kdWxlIEludDY0ICAgICAgICA9IEludDY0XG5tb2R1bGUgTGF6eSAgICAgICAgID0gTGF6eVxubW9kdWxlIExleGluZyAgICAgICA9IExleGluZ1xubW9kdWxlIExpc3QgICAgICAgICA9IExpc3Rcbm1vZHVsZSBMaXN0TGFiZWxzICAgPSBMaXN0TGFiZWxzXG5tb2R1bGUgTWFwICAgICAgICAgID0gTWFwXG5tb2R1bGUgTWFyc2hhbCAgICAgID0gTWFyc2hhbFxubW9kdWxlIE1vcmVMYWJlbHMgICA9IE1vcmVMYWJlbHNcbm1vZHVsZSBOYXRpdmVpbnQgICAgPSBOYXRpdmVpbnRcbm1vZHVsZSBPYmogICAgICAgICAgPSBPYmpcbm1vZHVsZSBPbyAgICAgICAgICAgPSBPb1xubW9kdWxlIE9wdGlvbiAgICAgICA9IE9wdGlvblxubW9kdWxlIFBhcnNpbmcgICAgICA9IFBhcnNpbmdcbm1vZHVsZSBQZXJ2YXNpdmVzICAgPSBQZXJ2YXNpdmVzXG5tb2R1bGUgUHJpbnRleGMgICAgID0gUHJpbnRleGNcbm1vZHVsZSBQcmludGYgICAgICAgPSBQcmludGZcbm1vZHVsZSBRdWV1ZSAgICAgICAgPSBRdWV1ZVxubW9kdWxlIFJhbmRvbSAgICAgICA9IFJhbmRvbVxubW9kdWxlIFJlc3VsdCAgICAgICA9IFJlc3VsdFxubW9kdWxlIFNjYW5mICAgICAgICA9IFNjYW5mXG5tb2R1bGUgU2VxICAgICAgICAgID0gU2VxXG5tb2R1bGUgU2V0ICAgICAgICAgID0gU2V0XG5tb2R1bGUgU3RhY2sgICAgICAgID0gU3RhY2tcbm1vZHVsZSBTdGRMYWJlbHMgICAgPSBTdGRMYWJlbHNcbm1vZHVsZSBTdHJlYW0gICAgICAgPSBTdHJlYW1cbm1vZHVsZSBTdHJpbmcgICAgICAgPSBTdHJpbmdcbm1vZHVsZSBTdHJpbmdMYWJlbHMgPSBTdHJpbmdMYWJlbHNcbm1vZHVsZSBTeXMgICAgICAgICAgPSBTeXNcbm1vZHVsZSBVY2hhciAgICAgICAgPSBVY2hhclxubW9kdWxlIFVuaXQgICAgICAgICA9IFVuaXRcbm1vZHVsZSBXZWFrICAgICAgICAgPSBXZWFrXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICBKZXJlbWllIERpbWlubywgSmFuZSBTdHJlZXQgRXVyb3BlICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE3IEphbmUgU3RyZWV0IEdyb3VwIExMQyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiBAZGVwcmVjYXRlZCBVc2UgeyFTdGRsaWJ9ICopXG5cbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2VcIlxuZXh0ZXJuYWwgcmFpc2Vfbm90cmFjZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlX25vdHJhY2VcIlxubGV0IGludmFsaWRfYXJnID0gaW52YWxpZF9hcmdcbmxldCBmYWlsd2l0aCA9IGZhaWx3aXRoXG5leGNlcHRpb24gRXhpdFxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA8PiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxdWFsXCJcbmV4dGVybmFsICggPCApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbmV4dGVybmFsICggPiApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJ0aGFuXCJcbmV4dGVybmFsICggPD0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzZXF1YWxcIlxuZXh0ZXJuYWwgKCA+PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5sZXQgbWluID0gbWluXG5sZXQgbWF4ID0gbWF4XG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbiAgW0BAb2NhbWwuZGVwcmVjYXRlZCBcIlVzZSAoJiYpIGluc3RlYWQuXCJdXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5leHRlcm5hbCAoIG9yICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgKHx8KSBpbnN0ZWFkLlwiXVxuZXh0ZXJuYWwgX19MT0NfXyA6IHN0cmluZyA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19GSUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfRklMRVwiXG5leHRlcm5hbCBfX0xJTkVfXyA6IGludCA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fTU9EVUxFX18gOiBzdHJpbmcgPSBcIiVsb2NfTU9EVUxFXCJcbmV4dGVybmFsIF9fUE9TX18gOiBzdHJpbmcgKiBpbnQgKiBpbnQgKiBpbnQgPSBcIiVsb2NfUE9TXCJcbmV4dGVybmFsIF9fTE9DX09GX18gOiAnYSAtPiBzdHJpbmcgKiAnYSA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19MSU5FX09GX18gOiAnYSAtPiBpbnQgKiAnYSA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fUE9TX09GX18gOiAnYSAtPiAoc3RyaW5nICogaW50ICogaW50ICogaW50KSAqICdhID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxubGV0IGFicyA9IGFic1xubGV0IG1heF9pbnQgPSBtYXhfaW50XG5sZXQgbWluX2ludCA9IG1pbl9pbnRcbmV4dGVybmFsICggbGFuZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgKCBsb3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuZXh0ZXJuYWwgKCBseG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXhvcmludFwiXG5sZXQgbG5vdCA9IGxub3RcbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcbmV4dGVybmFsICggfi0uICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJW5lZ2Zsb2F0XCJcbmV4dGVybmFsICggfisuICkgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsICggKy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWRkZmxvYXRcIlxuZXh0ZXJuYWwgKCAtLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVzdWJmbG9hdFwiXG5leHRlcm5hbCAoICouICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJW11bGZsb2F0XCJcbmV4dGVybmFsICggLy4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlZGl2ZmxvYXRcIlxuZXh0ZXJuYWwgKCAqKiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5sZXQgaW5maW5pdHkgPSBpbmZpbml0eVxubGV0IG5lZ19pbmZpbml0eSA9IG5lZ19pbmZpbml0eVxubGV0IG5hbiA9IG5hblxubGV0IG1heF9mbG9hdCA9IG1heF9mbG9hdFxubGV0IG1pbl9mbG9hdCA9IG1pbl9mbG9hdFxubGV0IGVwc2lsb25fZmxvYXQgPSBlcHNpbG9uX2Zsb2F0XG50eXBlIG5vbnJlYyBmcGNsYXNzID0gZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxubGV0ICggXiApID0gKCBeIClcbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5sZXQgY2hhcl9vZl9pbnQgPSBjaGFyX29mX2ludFxuZXh0ZXJuYWwgaWdub3JlIDogJ2EgLT4gdW5pdCA9IFwiJWlnbm9yZVwiXG5sZXQgc3RyaW5nX29mX2Jvb2wgPSBzdHJpbmdfb2ZfYm9vbFxubGV0IGJvb2xfb2Zfc3RyaW5nID0gYm9vbF9vZl9zdHJpbmdcbmxldCBib29sX29mX3N0cmluZ19vcHQgPSBib29sX29mX3N0cmluZ19vcHRcbmxldCBzdHJpbmdfb2ZfaW50ID0gc3RyaW5nX29mX2ludFxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5sZXQgaW50X29mX3N0cmluZ19vcHQgPSBpbnRfb2Zfc3RyaW5nX29wdFxubGV0IHN0cmluZ19vZl9mbG9hdCA9IHN0cmluZ19vZl9mbG9hdFxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCA9IGZsb2F0X29mX3N0cmluZ19vcHRcbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5sZXQgKCBAICkgID0gKCBAIClcbnR5cGUgbm9ucmVjIGluX2NoYW5uZWwgPSBpbl9jaGFubmVsXG50eXBlIG5vbnJlYyBvdXRfY2hhbm5lbCA9IG91dF9jaGFubmVsXG5sZXQgc3RkaW4gPSBzdGRpblxubGV0IHN0ZG91dCA9IHN0ZG91dFxubGV0IHN0ZGVyciA9IHN0ZGVyclxubGV0IHByaW50X2NoYXIgPSBwcmludF9jaGFyXG5sZXQgcHJpbnRfc3RyaW5nID0gcHJpbnRfc3RyaW5nXG5sZXQgcHJpbnRfYnl0ZXMgPSBwcmludF9ieXRlc1xubGV0IHByaW50X2ludCA9IHByaW50X2ludFxubGV0IHByaW50X2Zsb2F0ID0gcHJpbnRfZmxvYXRcbmxldCBwcmludF9lbmRsaW5lID0gcHJpbnRfZW5kbGluZVxubGV0IHByaW50X25ld2xpbmUgPSBwcmludF9uZXdsaW5lXG5sZXQgcHJlcnJfY2hhciA9IHByZXJyX2NoYXJcbmxldCBwcmVycl9zdHJpbmcgPSBwcmVycl9zdHJpbmdcbmxldCBwcmVycl9ieXRlcyA9IHByZXJyX2J5dGVzXG5sZXQgcHJlcnJfaW50ID0gcHJlcnJfaW50XG5sZXQgcHJlcnJfZmxvYXQgPSBwcmVycl9mbG9hdFxubGV0IHByZXJyX2VuZGxpbmUgPSBwcmVycl9lbmRsaW5lXG5sZXQgcHJlcnJfbmV3bGluZSA9IHByZXJyX25ld2xpbmVcbmxldCByZWFkX2xpbmUgPSByZWFkX2xpbmVcbmxldCByZWFkX2ludCA9IHJlYWRfaW50XG5sZXQgcmVhZF9pbnRfb3B0ID0gcmVhZF9pbnRfb3B0XG5sZXQgcmVhZF9mbG9hdCA9IHJlYWRfZmxvYXRcbmxldCByZWFkX2Zsb2F0X29wdCA9IHJlYWRfZmxvYXRfb3B0XG50eXBlIG5vbnJlYyBvcGVuX2ZsYWcgPSBvcGVuX2ZsYWcgPVxuICAgIE9wZW5fcmRvbmx5XG4gIHwgT3Blbl93cm9ubHlcbiAgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXRcbiAgfCBPcGVuX3RydW5jXG4gIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnlcbiAgfCBPcGVuX3RleHRcbiAgfCBPcGVuX25vbmJsb2NrXG5sZXQgb3Blbl9vdXQgPSBvcGVuX291dFxubGV0IG9wZW5fb3V0X2JpbiA9IG9wZW5fb3V0X2JpblxubGV0IG9wZW5fb3V0X2dlbiA9IG9wZW5fb3V0X2dlblxubGV0IGZsdXNoID0gZmx1c2hcbmxldCBmbHVzaF9hbGwgPSBmbHVzaF9hbGxcbmxldCBvdXRwdXRfY2hhciA9IG91dHB1dF9jaGFyXG5sZXQgb3V0cHV0X3N0cmluZyA9IG91dHB1dF9zdHJpbmdcbmxldCBvdXRwdXRfYnl0ZXMgPSBvdXRwdXRfYnl0ZXNcbmxldCBvdXRwdXQgPSBvdXRwdXRcbmxldCBvdXRwdXRfc3Vic3RyaW5nID0gb3V0cHV0X3N1YnN0cmluZ1xubGV0IG91dHB1dF9ieXRlID0gb3V0cHV0X2J5dGVcbmxldCBvdXRwdXRfYmluYXJ5X2ludCA9IG91dHB1dF9iaW5hcnlfaW50XG5sZXQgb3V0cHV0X3ZhbHVlID0gb3V0cHV0X3ZhbHVlXG5sZXQgc2Vla19vdXQgPSBzZWVrX291dFxubGV0IHBvc19vdXQgPSBwb3Nfb3V0XG5sZXQgb3V0X2NoYW5uZWxfbGVuZ3RoID0gb3V0X2NoYW5uZWxfbGVuZ3RoXG5sZXQgY2xvc2Vfb3V0ID0gY2xvc2Vfb3V0XG5sZXQgY2xvc2Vfb3V0X25vZXJyID0gY2xvc2Vfb3V0X25vZXJyXG5sZXQgc2V0X2JpbmFyeV9tb2RlX291dCA9IHNldF9iaW5hcnlfbW9kZV9vdXRcbmxldCBvcGVuX2luID0gb3Blbl9pblxubGV0IG9wZW5faW5fYmluID0gb3Blbl9pbl9iaW5cbmxldCBvcGVuX2luX2dlbiA9IG9wZW5faW5fZ2VuXG5sZXQgaW5wdXRfY2hhciA9IGlucHV0X2NoYXJcbmxldCBpbnB1dF9saW5lID0gaW5wdXRfbGluZVxubGV0IGlucHV0ID0gaW5wdXRcbmxldCByZWFsbHlfaW5wdXQgPSByZWFsbHlfaW5wdXRcbmxldCByZWFsbHlfaW5wdXRfc3RyaW5nID0gcmVhbGx5X2lucHV0X3N0cmluZ1xubGV0IGlucHV0X2J5dGUgPSBpbnB1dF9ieXRlXG5sZXQgaW5wdXRfYmluYXJ5X2ludCA9IGlucHV0X2JpbmFyeV9pbnRcbmxldCBpbnB1dF92YWx1ZSA9IGlucHV0X3ZhbHVlXG5sZXQgc2Vla19pbiA9IHNlZWtfaW5cbmxldCBwb3NfaW4gPSBwb3NfaW5cbmxldCBpbl9jaGFubmVsX2xlbmd0aCA9IGluX2NoYW5uZWxfbGVuZ3RoXG5sZXQgY2xvc2VfaW4gPSBjbG9zZV9pblxubGV0IGNsb3NlX2luX25vZXJyID0gY2xvc2VfaW5fbm9lcnJcbmxldCBzZXRfYmluYXJ5X21vZGVfaW4gPSBzZXRfYmluYXJ5X21vZGVfaW5cbm1vZHVsZSBMYXJnZUZpbGUgPSBMYXJnZUZpbGVcbnR5cGUgbm9ucmVjICdhIHJlZiA9ICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cbmV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcbmV4dGVybmFsIGluY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVpbmNyXCJcbmV4dGVybmFsIGRlY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVkZWNyXCJcbnR5cGUgbm9ucmVjICgnYSwnYikgcmVzdWx0ID0gKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG50eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnYywgJ2MsICdkKSBmb3JtYXQ2XG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcbmxldCBzdHJpbmdfb2ZfZm9ybWF0ID0gc3RyaW5nX29mX2Zvcm1hdFxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gXCIlaWRlbnRpdHlcIlxubGV0ICggXl4gKSA9ICggXl4gKVxubGV0IGV4aXQgPSBleGl0XG5sZXQgYXRfZXhpdCA9IGF0X2V4aXRcbmxldCB2YWxpZF9mbG9hdF9sZXhlbSA9IHZhbGlkX2Zsb2F0X2xleGVtXG5sZXQgZG9fYXRfZXhpdCA9IGRvX2F0X2V4aXRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgTmljb2xhcyBPamVkYSBCYXIsIExleGlGaSAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuZXh0ZXJuYWwgbmVnIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCBhZGQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsIHN1YiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgbXVsIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCBkaXYgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsIHJlbSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Ztb2RfZmxvYXRcIiBcImZtb2RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZm1hIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1hX2Zsb2F0XCIgXCJjYW1sX2ZtYVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnMgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcblxubGV0IHplcm8gPSAwLlxubGV0IG9uZSA9IDEuXG5sZXQgbWludXNfb25lID0gLTEuXG5sZXQgaW5maW5pdHkgPSBTdGRsaWIuaW5maW5pdHlcbmxldCBuZWdfaW5maW5pdHkgPSBTdGRsaWIubmVnX2luZmluaXR5XG5sZXQgbmFuID0gU3RkbGliLm5hblxubGV0IGlzX2Zpbml0ZSAoeDogZmxvYXQpID0geCAtLiB4ID0gMC5cbmxldCBpc19pbmZpbml0ZSAoeDogZmxvYXQpID0gMS4gLy4geCA9IDAuXG5sZXQgaXNfbmFuICh4OiBmbG9hdCkgPSB4IDw+IHhcblxubGV0IHBpID0gMHgxLjkyMWZiNTQ0NDJkMThwKzFcbmxldCBtYXhfZmxvYXQgPSBTdGRsaWIubWF4X2Zsb2F0XG5sZXQgbWluX2Zsb2F0ID0gU3RkbGliLm1pbl9mbG9hdFxubGV0IGVwc2lsb24gPSBTdGRsaWIuZXBzaWxvbl9mbG9hdFxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0b19pbnQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdF9vZl9zdHJpbmdcIlxubGV0IG9mX3N0cmluZ19vcHQgPSBTdGRsaWIuZmxvYXRfb2Zfc3RyaW5nX29wdFxubGV0IHRvX3N0cmluZyA9IFN0ZGxpYi5zdHJpbmdfb2ZfZmxvYXRcbnR5cGUgZnBjbGFzcyA9IFN0ZGxpYi5mcGNsYXNzID1cbiAgICBGUF9ub3JtYWxcbiAgfCBGUF9zdWJub3JtYWxcbiAgfCBGUF96ZXJvXG4gIHwgRlBfaW5maW5pdGVcbiAgfCBGUF9uYW5cbmV4dGVybmFsIGNsYXNzaWZ5X2Zsb2F0IDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IGZwY2xhc3MgPVxuICBcImNhbWxfY2xhc3NpZnlfZmxvYXRcIiBcImNhbWxfY2xhc3NpZnlfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBwb3cgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzEwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMTBfZmxvYXRcIiBcImxvZzEwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0cnVuYyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RydW5jX2Zsb2F0XCIgXCJjYW1sX3RydW5jXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHJvdW5kIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcm91bmRfZmxvYXRcIiBcImNhbWxfcm91bmRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IGlzX2ludGVnZXIgeCA9IHggPSB0cnVuYyB4ICYmIGlzX2Zpbml0ZSB4XG5cbmV4dGVybmFsIG5leHRfYWZ0ZXIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICA9IFwiY2FtbF9uZXh0YWZ0ZXJfZmxvYXRcIiBcImNhbWxfbmV4dGFmdGVyXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxubGV0IHN1Y2MgeCA9IG5leHRfYWZ0ZXIgeCBpbmZpbml0eVxubGV0IHByZWQgeCA9IG5leHRfYWZ0ZXIgeCBuZWdfaW5maW5pdHlcblxuZXh0ZXJuYWwgY29weV9zaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaWduX2JpdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBib29sXG4gID0gXCJjYW1sX3NpZ25iaXRfZmxvYXRcIiBcImNhbWxfc2lnbmJpdFwiIFtAQG5vYWxsb2NdXG5cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG50eXBlIHQgPSBmbG9hdFxuZXh0ZXJuYWwgY29tcGFyZSA6IGZsb2F0IC0+IGZsb2F0IC0+IGludCA9IFwiJWNvbXBhcmVcIlxubGV0IGVxdWFsIHggeSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXRbQGlubGluZV0gbWluICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcbiAgZWxzZSBpZiBpc19uYW4geCB0aGVuIHggZWxzZSB5XG5cbmxldFtAaW5saW5lXSBtYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4geSBlbHNlIHhcblxubGV0W0BpbmxpbmVdIG1pbl9tYXggKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggfHwgaXNfbmFuIHkgdGhlbiAobmFuLCBuYW4pXG4gIGVsc2UgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuICh4LCB5KSBlbHNlICh5LCB4KVxuXG5sZXRbQGlubGluZV0gbWluX251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSB4XG4gIGVsc2UgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgeVxuXG5sZXRbQGlubGluZV0gbWF4X251bSAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSB5XG4gIGVsc2UgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgeFxuXG5sZXRbQGlubGluZV0gbWluX21heF9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgaXNfbmFuIHggdGhlbiAoeSx5KVxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4gKHgseClcbiAgZWxzZSBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW4gKHgseSkgZWxzZSAoeSx4KVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6IGludCAtPiBpbnQgLT4gaW50IC0+IGZsb2F0IC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfaGFzaFwiIFtAQG5vYWxsb2NdXG5sZXQgaGFzaCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIDAgeFxuXG5tb2R1bGUgQXJyYXkgPSBzdHJ1Y3RcblxuICB0eXBlIHQgPSBmbG9hdGFycmF5XG5cbiAgZXh0ZXJuYWwgbGVuZ3RoIDogdCAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IHQgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IHQgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IHQgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogdCAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5cbiAgbGV0IHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBmb3IgaSA9IG9mcyB0byBvZnMgKyBsZW4gLSAxIGRvIHVuc2FmZV9zZXQgYSBpIHYgZG9uZVxuXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0OiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9XG4gICAgXCJjYW1sX2Zsb2F0YXJyYXlfYmxpdFwiIFtAQG5vYWxsb2NdXG5cbiAgbGV0IGNoZWNrIGEgb2ZzIGxlbiBtc2cgPVxuICAgIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IGxlbmd0aCBhIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIG1zZ1xuXG4gIGxldCBtYWtlIG4gdiA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBuIGluXG4gICAgdW5zYWZlX2ZpbGwgcmVzdWx0IDAgbiB2O1xuICAgIHJlc3VsdFxuXG4gIGxldCBpbml0IGwgZiA9XG4gICAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5LmluaXRcIlxuICAgIGVsc2VcbiAgICAgIGxldCByZXMgPSBjcmVhdGUgbCBpblxuICAgICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgICAgIGRvbmU7XG4gICAgICByZXNcblxuICBsZXQgYXBwZW5kIGExIGEyID1cbiAgICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgICBsZXQgbDIgPSBsZW5ndGggYTIgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChsMSArIGwyKSBpblxuICAgIHVuc2FmZV9ibGl0IGExIDAgcmVzdWx0IDAgbDE7XG4gICAgdW5zYWZlX2JsaXQgYTIgMCByZXN1bHQgbDEgbDI7XG4gICAgcmVzdWx0XG5cbiAgKCogbmV4dCAzIGZ1bmN0aW9uczogbW9kaWZpZWQgY29weSBvZiBjb2RlIGZyb20gc3RyaW5nLm1sICopXG4gIGxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID1cbiAgICBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5jb25jYXRcIlxuXG4gIGxldCByZWMgc3VtX2xlbmd0aHMgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgYWNjKSBhY2MpIHRsXG5cbiAgbGV0IGNvbmNhdCBsID1cbiAgICBsZXQgbGVuID0gc3VtX2xlbmd0aHMgMCBsIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgbCBpID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgKGkgPSBsZW4pXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGxldCBobGVuID0gbGVuZ3RoIGhkIGluXG4gICAgICAgIHVuc2FmZV9ibGl0IGhkIDAgcmVzdWx0IGkgaGxlbjtcbiAgICAgICAgbG9vcCB0bCAoaSArIGhsZW4pXG4gICAgaW5cbiAgICBsb29wIGwgMDtcbiAgICByZXN1bHRcblxuICBsZXQgc3ViIGEgb2ZzIGxlbiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuc3ViXCI7XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBhIG9mcyByZXN1bHQgMCBsZW47XG4gICAgcmVzdWx0XG5cbiAgbGV0IGNvcHkgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbCBpblxuICAgIHVuc2FmZV9ibGl0IGEgMCByZXN1bHQgMCBsO1xuICAgIHJlc3VsdFxuXG4gIGxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBjaGVjayBhIG9mcyBsZW4gXCJGbG9hdC5BcnJheS5maWxsXCI7XG4gICAgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxuICBsZXQgYmxpdCBzcmMgc29mcyBkc3QgZG9mcyBsZW4gPVxuICAgIGNoZWNrIHNyYyBzb2ZzIGxlbiBcIkZsb2F0LmFycmF5LmJsaXRcIjtcbiAgICBjaGVjayBkc3QgZG9mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgdW5zYWZlX2JsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuXG5cbiAgbGV0IHRvX2xpc3QgYSA9XG4gICAgTGlzdC5pbml0IChsZW5ndGggYSkgKHVuc2FmZV9nZXQgYSlcblxuICBsZXQgb2ZfbGlzdCBsID1cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICAgIGxldCByZWMgZmlsbCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IHJlc3VsdFxuICAgICAgfCBoIDo6IHQgLT4gdW5zYWZlX3NldCByZXN1bHQgaSBoOyBmaWxsIChpICsgMSkgdFxuICAgIGluXG4gICAgZmlsbCAwIGxcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXIgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyMiBmIGEgYiA9XG4gICAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2VcbiAgICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG4gIGxldCBtYXAgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICBsZXQgbWFwMiBmIGEgYiA9XG4gICAgbGV0IGxhID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICAgIGlmIGxhIDw+IGxiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkubWFwMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGEgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyaSBmIGEgPVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4gIGxldCBtYXBpIGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gICAgZG9uZTtcbiAgICAhclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICAgIGRvbmU7XG4gICAgIXJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGV4aXN0cyBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb3JfYWxsIHAgYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChpICsgMSlcbiAgICAgIGVsc2UgZmFsc2UgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG1lbSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sLCBidXQgc2xpZ2h0bHkgZGlmZmVyZW50ICopXG4gIGxldCBtZW1faWVlZSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHggPSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBleGNlcHRpb24gQm90dG9tIG9mIGludFxuICBsZXQgc29ydCBjbXAgYSA9XG4gICAgbGV0IG1heHNvbiBsIGkgPVxuICAgICAgbGV0IGkzMSA9IGkraStpKzEgaW5cbiAgICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgICAgaWYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDAgdGhlbiB4IDo9IGkzMSsxO1xuICAgICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICAgIXhcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgICB0aGVuIGkzMSsxXG4gICAgICAgIGVsc2UgaWYgaTMxIDwgbCB0aGVuIGkzMSBlbHNlIHJhaXNlIChCb3R0b20gaSlcbiAgICBpblxuICAgIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICAgIHRyaWNrbGVkb3duIGwgaiBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgICBsZXQgcmVjIGJ1YmJsZWRvd24gbCBpID1cbiAgICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICBidWJibGVkb3duIGwgalxuICAgIGluXG4gICAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gICAgbGV0IHJlYyB0cmlja2xldXAgaSBlID1cbiAgICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgICBpZiBjbXAgKGdldCBhIGZhdGhlcikgZSA8IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgICBmb3IgaSA9IGwgLSAxIGRvd250byAyIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgICB0cmlja2xldXAgKGJ1YmJsZSBpIDApIGU7XG4gICAgZG9uZTtcbiAgICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCwgZXhjZXB0IGZvciB0aGUgY2FsbCB0byBbY3JlYXRlXSAqKVxuICBsZXQgY3V0b2ZmID0gNVxuICBsZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICAgIGxldCBtZXJnZSBzcmMxb2ZzIHNyYzFsZW4gc3JjMiBzcmMyb2ZzIHNyYzJsZW4gZHN0IGRzdG9mcyA9XG4gICAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgICBpZiBjbXAgczEgczIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICAgIGlmIGkxIDwgc3JjMXIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IHNyYzIgaTIgZHN0IChkICsgMSkgKHNyYzJyIC0gaTIpXG4gICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICAgIGxldCBpMiA9IGkyICsgMSBpblxuICAgICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICAgIGVuZFxuICAgICAgaW4gbG9vcCBzcmMxb2ZzIChnZXQgYSBzcmMxb2ZzKSBzcmMyb2ZzIChnZXQgc3JjMiBzcmMyb2ZzKSBkc3RvZnM7XG4gICAgaW5cbiAgICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICAgIHdoaWxlICghaiA+PSBkc3RvZnMgJiYgY21wIChnZXQgZHN0ICFqKSBlID4gMCkgZG9cbiAgICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgICBkZWNyIGo7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICAgIGRvbmU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGwxID0gbGVuIC8gMiBpblxuICAgICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgICAgc29ydHRvIHNyY29mcyBhIChzcmNvZnMgKyBsMikgbDE7XG4gICAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsIC8gMiBpblxuICAgICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgICBsZXQgdCA9IGNyZWF0ZSBsMiBpblxuICAgICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICAgIHNvcnR0byAwIGEgbDIgbDE7XG4gICAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICAgIGVuZFxuXG4gIGxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgdG9fc2VxIGEgPVxuICAgIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgICB0aGVuXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IHRvX3NlcWkgYSA9XG4gICAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICAgIHRoZW5cbiAgICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9yZXZfbGlzdCBsID1cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCBhID0gY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgW10gLT4gYVxuICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGktMSkgdGxcbiAgICBpblxuICAgIGZpbGwgKGxlbi0xKSBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9zZXEgaSA9XG4gICAgbGV0IGwgPSBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBpIGluXG4gICAgb2ZfcmV2X2xpc3QgbFxuXG5cbiAgbGV0IG1hcF90b19hcnJheSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsID0gMCB0aGVuIFt8IHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gQXJyYXkubWFrZSBsIChmICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgICAgQXJyYXkudW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgbGV0IG1hcF9mcm9tX2FycmF5IGYgYSA9XG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIChBcnJheS51bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbmVuZFxuXG5tb2R1bGUgQXJyYXlMYWJlbHMgPSBBcnJheVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW05hdGl2ZWludF06IHByb2Nlc3Nvci1uYXRpdmUgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X25lZ1wiXG5leHRlcm5hbCBhZGQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FkZFwiXG5leHRlcm5hbCBzdWI6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X3N1YlwiXG5leHRlcm5hbCBtdWw6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X211bFwiXG5leHRlcm5hbCBkaXY6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2RpdlwiXG5leHRlcm5hbCByZW06IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X21vZFwiXG5leHRlcm5hbCBsb2dhbmQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FuZFwiXG5leHRlcm5hbCBsb2dvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb3JcIlxuZXh0ZXJuYWwgbG9neG9yOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0OiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNyXCJcbmV4dGVybmFsIG9mX2ludDogaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50OiBuYXRpdmVpbnQgLT4gaW50ID0gXCIlbmF0aXZlaW50X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2ZfZmxvYXRcIiBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBuYXRpdmVpbnQgLT4gZmxvYXRcbiAgPSBcImNhbWxfbmF0aXZlaW50X3RvX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyOiBpbnQzMiAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50MzJcIlxuZXh0ZXJuYWwgdG9faW50MzI6IG5hdGl2ZWludCAtPiBpbnQzMiA9IFwiJW5hdGl2ZWludF90b19pbnQzMlwiXG5cbmxldCB6ZXJvID0gMG5cbmxldCBvbmUgPSAxblxubGV0IG1pbnVzX29uZSA9IC0xblxubGV0IHN1Y2MgbiA9IGFkZCBuIDFuXG5sZXQgcHJlZCBuID0gc3ViIG4gMW5cbmxldCBhYnMgbiA9IGlmIG4gPj0gMG4gdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBzaXplID0gU3lzLndvcmRfc2l6ZVxubGV0IG1pbl9pbnQgPSBzaGlmdF9sZWZ0IDFuIChzaXplIC0gMSlcbmxldCBtYXhfaW50ID0gc3ViIG1pbl9pbnQgMW5cbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMW4pXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZzogc3RyaW5nIC0+IG5hdGl2ZWludCA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbnR5cGUgdCA9IG5hdGl2ZWludFxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIGxpc3RzLiAqKVxudHlwZSAnYSB0ID0gJ2EgbGlzdCA9IFtdIHwgKDo6KSBvZiAnYSAqICdhIGxpc3RcblxuKCogTGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZWMgbGVuZ3RoX2F1eCBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGxlblxuICB8IF86OmwgLT4gbGVuZ3RoX2F1eCAobGVuICsgMSkgbFxuXG5sZXQgbGVuZ3RoIGwgPSBsZW5ndGhfYXV4IDAgbFxuXG5sZXQgY29ucyBhIGwgPSBhOjpsXG5cbmxldCBoZCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJoZFwiXG4gIHwgYTo6XyAtPiBhXG5cbmxldCB0bCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJ0bFwiXG4gIHwgXzo6bCAtPiBsXG5cbmxldCBudGggbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGZhaWx3aXRoIFwibnRoXCJcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBudGhfb3B0IGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBhcHBlbmQgPSAoQClcblxubGV0IHJlYyByZXZfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgYSA6OiBsIC0+IHJldl9hcHBlbmQgbCAoYSA6OiBsMilcblxubGV0IHJldiBsID0gcmV2X2FwcGVuZCBsIFtdXG5cbmxldCByZWMgaW5pdF90YWlscmVjX2F1eCBhY2MgaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBhY2NcbiAgZWxzZSBpbml0X3RhaWxyZWNfYXV4IChmIGkgOjogYWNjKSAoaSsxKSBuIGZcblxubGV0IHJlYyBpbml0X2F1eCBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgciA9IGYgaSBpblxuICAgIHIgOjogaW5pdF9hdXggKGkrMSkgbiBmXG5cbmxldCByZXZfaW5pdF90aHJlc2hvbGQgPVxuICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBTeXMuTmF0aXZlIHwgU3lzLkJ5dGVjb2RlIC0+IDEwXzAwMFxuICAoKiBXZSBkb24ndCBrbm93IHRoZSBzaXplIG9mIHRoZSBzdGFjaywgYmV0dGVyIGJlIHNhZmUgYW5kIGFzc3VtZSBpdCdzXG4gICAgIHNtYWxsLiAqKVxuICB8IFN5cy5PdGhlciBfIC0+IDUwXG5cbmxldCBpbml0IGxlbiBmID1cbiAgaWYgbGVuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5pbml0XCIgZWxzZVxuICBpZiBsZW4gPiByZXZfaW5pdF90aHJlc2hvbGQgdGhlbiByZXYgKGluaXRfdGFpbHJlY19hdXggW10gMCBsZW4gZilcbiAgZWxzZSBpbml0X2F1eCAwIGxlbiBmXG5cbmxldCByZWMgZmxhdHRlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBsOjpyIC0+IGwgQCBmbGF0dGVuIHJcblxubGV0IGNvbmNhdCA9IGZsYXR0ZW5cblxubGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBhIGluIHIgOjogbWFwIGYgbFxuXG5sZXQgcmVjIG1hcGkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGE6OmwgLT4gbGV0IHIgPSBmIGkgYSBpbiByIDo6IG1hcGkgKGkgKyAxKSBmIGxcblxubGV0IG1hcGkgZiBsID0gbWFwaSAwIGYgbFxuXG5sZXQgcmV2X21hcCBmIGwgPVxuICBsZXQgcmVjIHJtYXBfZiBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IGE6OmwgLT4gcm1hcF9mIChmIGEgOjogYWNjdSkgbFxuICBpblxuICBybWFwX2YgW10gbFxuXG5cbmxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBhOyBpdGVyIGYgbFxuXG5sZXQgcmVjIGl0ZXJpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgaSBhOyBpdGVyaSAoaSArIDEpIGYgbFxuXG5sZXQgaXRlcmkgZiBsID0gaXRlcmkgMCBmIGxcblxubGV0IHJlYyBmb2xkX2xlZnQgZiBhY2N1IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmb2xkX2xlZnQgZiAoZiBhY2N1IGEpIGxcblxubGV0IHJlYyBmb2xkX3JpZ2h0IGYgbCBhY2N1ID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZiBhIChmb2xkX3JpZ2h0IGYgbCBhY2N1KVxuXG5sZXQgcmVjIG1hcDIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gbGV0IHIgPSBmIGExIGEyIGluIHIgOjogbWFwMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5tYXAyXCJcblxubGV0IHJldl9tYXAyIGYgbDEgbDIgPVxuICBsZXQgcmVjIHJtYXAyX2YgYWNjdSBsMSBsMiA9XG4gICAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIHwgKFtdLCBbXSkgLT4gYWNjdVxuICAgIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBybWFwMl9mIChmIGExIGEyIDo6IGFjY3UpIGwxIGwyXG4gICAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJldl9tYXAyXCJcbiAgaW5cbiAgcm1hcDJfZiBbXSBsMSBsMlxuXG5cbmxldCByZWMgaXRlcjIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiAoKVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMjsgaXRlcjIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuaXRlcjJcIlxuXG5sZXQgcmVjIGZvbGRfbGVmdDIgZiBhY2N1IGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGZvbGRfbGVmdDIgZiAoZiBhY2N1IGExIGEyKSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9sZWZ0MlwiXG5cbmxldCByZWMgZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1ID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTIgKGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSlcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfcmlnaHQyXCJcblxubGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IHRydWVcbiAgfCBhOjpsIC0+IHAgYSAmJiBmb3JfYWxsIHAgbFxuXG5sZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gcCBhIHx8IGV4aXN0cyBwIGxcblxubGV0IHJlYyBmb3JfYWxsMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IHRydWVcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgJiYgZm9yX2FsbDIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9yX2FsbDJcIlxuXG5sZXQgcmVjIGV4aXN0czIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBmYWxzZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiB8fCBleGlzdHMyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmV4aXN0czJcIlxuXG5sZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbSB4IGxcblxubGV0IHJlYyBtZW1xIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBhID09IHggfHwgbWVtcSB4IGxcblxubGV0IHJlYyBhc3NvYyB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBiIGVsc2UgYXNzb2MgeCBsXG5cbmxldCByZWMgYXNzb2Nfb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBTb21lIGIgZWxzZSBhc3NvY19vcHQgeCBsXG5cbmxldCByZWMgYXNzcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBiIGVsc2UgYXNzcSB4IGxcblxubGV0IHJlYyBhc3NxX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gU29tZSBiIGVsc2UgYXNzcV9vcHQgeCBsXG5cbmxldCByZWMgbWVtX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbV9hc3NvYyB4IGxcblxubGV0IHJlYyBtZW1fYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGEgPT0geCB8fCBtZW1fYXNzcSB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+XG4gICAgICBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzb2MgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+IGlmIGEgPT0geCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NxIHggbFxuXG5sZXQgcmVjIGZpbmQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHggZWxzZSBmaW5kIHAgbFxuXG5sZXQgcmVjIGZpbmRfb3B0IHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gU29tZSB4IGVsc2UgZmluZF9vcHQgcCBsXG5cbmxldCByZWMgZmluZF9tYXAgZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPlxuICAgICBiZWdpbiBtYXRjaCBmIHggd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPiByZXN1bHRcbiAgICAgICB8IE5vbmUgLT4gZmluZF9tYXAgZiBsXG4gICAgIGVuZFxuXG5sZXQgZmluZF9hbGwgcCA9XG4gIGxldCByZWMgZmluZCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjdVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBmaW5kICh4IDo6IGFjY3UpIGwgZWxzZSBmaW5kIGFjY3UgbCBpblxuICBmaW5kIFtdXG5cbmxldCBmaWx0ZXIgPSBmaW5kX2FsbFxuXG5sZXQgZmlsdGVyaSBwIGwgPVxuICBsZXQgcmVjIGF1eCBpIGFjYyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmV2IGFjY1xuICB8IHg6OmwgLT4gYXV4IChpICsgMSkgKGlmIHAgaSB4IHRoZW4geDo6YWNjIGVsc2UgYWNjKSBsXG4gIGluXG4gIGF1eCAwIFtdIGxcblxubGV0IGZpbHRlcl9tYXAgZiA9XG4gIGxldCByZWMgYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY3VcbiAgICB8IHggOjogbCAtPlxuICAgICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgICB8IE5vbmUgLT4gYXV4IGFjY3UgbFxuICAgICAgICB8IFNvbWUgdiAtPiBhdXggKHYgOjogYWNjdSkgbFxuICBpblxuICBhdXggW11cblxubGV0IGNvbmNhdF9tYXAgZiBsID1cbiAgbGV0IHJlYyBhdXggZiBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgbGV0IHhzID0gZiB4IGluXG4gICAgICAgYXV4IGYgKHJldl9hcHBlbmQgeHMgYWNjKSBsXG4gIGluIGF1eCBmIFtdIGxcblxubGV0IGZvbGRfbGVmdF9tYXAgZiBhY2N1IGwgPVxuICBsZXQgcmVjIGF1eCBhY2N1IGxfYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1LCByZXYgbF9hY2N1XG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICAgbGV0IGFjY3UsIHggPSBmIGFjY3UgeCBpblxuICAgICAgICBhdXggYWNjdSAoeCA6OiBsX2FjY3UpIGwgaW5cbiAgYXV4IGFjY3UgW10gbFxuXG5sZXQgcGFydGl0aW9uIHAgbCA9XG4gIGxldCByZWMgcGFydCB5ZXMgbm8gPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgeWVzLCByZXYgbm8pXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHBhcnQgKHggOjogeWVzKSBubyBsIGVsc2UgcGFydCB5ZXMgKHggOjogbm8pIGwgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCBwYXJ0aXRpb25fbWFwIHAgbCA9XG4gIGxldCByZWMgcGFydCBsZWZ0IHJpZ2h0ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAocmV2IGxlZnQsIHJldiByaWdodClcbiAgfCB4IDo6IGwgLT5cbiAgICAgYmVnaW4gbWF0Y2ggcCB4IHdpdGhcbiAgICAgICB8IEVpdGhlci5MZWZ0IHYgLT4gcGFydCAodiA6OiBsZWZ0KSByaWdodCBsXG4gICAgICAgfCBFaXRoZXIuUmlnaHQgdiAtPiBwYXJ0IGxlZnQgKHYgOjogcmlnaHQpIGxcbiAgICAgZW5kXG4gIGluXG4gIHBhcnQgW10gW10gbFxuXG5sZXQgcmVjIHNwbGl0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoW10sIFtdKVxuICB8ICh4LHkpOjpsIC0+XG4gICAgICBsZXQgKHJ4LCByeSkgPSBzcGxpdCBsIGluICh4OjpyeCwgeTo6cnkpXG5cbmxldCByZWMgY29tYmluZSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gKGExLCBhMikgOjogY29tYmluZSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuY29tYmluZVwiXG5cbigqKiBzb3J0aW5nICopXG5cbmxldCByZWMgbWVyZ2UgY21wIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgbDIgLT4gbDJcbiAgfCBsMSwgW10gLT4gbDFcbiAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICAgIGlmIGNtcCBoMSBoMiA8PSAwXG4gICAgICB0aGVuIGgxIDo6IG1lcmdlIGNtcCB0MSBsMlxuICAgICAgZWxzZSBoMiA6OiBtZXJnZSBjbXAgbDEgdDJcblxuXG5sZXQgc3RhYmxlX3NvcnQgY21wIGwgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyIDw9IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuXG4gICAgICAgICAgICBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2VfcmV2IHMxIHMyIFtdLCB0bClcbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9IGlmIGNtcCB4MSB4MiA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBpZiBjbXAgeDEgeDIgPiAwIHRoZW5cbiAgICAgICAgICAgIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA+IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZSBzMSBzMiBbXSwgdGwpXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcblxuXG5sZXQgc29ydCA9IHN0YWJsZV9zb3J0XG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCogTm90ZTogb24gYSBsaXN0IG9mIGxlbmd0aCBiZXR3ZWVuIGFib3V0IDEwMDAwMCAoZGVwZW5kaW5nIG9uIHRoZSBtaW5vclxuICAgaGVhcCBzaXplIGFuZCB0aGUgdHlwZSBvZiB0aGUgbGlzdCkgYW5kIFN5cy5tYXhfYXJyYXlfc2l6ZSwgaXQgaXNcbiAgIGFjdHVhbGx5IGZhc3RlciB0byB1c2UgdGhlIGZvbGxvd2luZywgYnV0IGl0IG1pZ2h0IGFsc28gdXNlIG1vcmUgbWVtb3J5XG4gICBiZWNhdXNlIHRoZSBhcmd1bWVudCBsaXN0IGNhbm5vdCBiZSBkZWFsbG9jYXRlZCBpbmNyZW1lbnRhbGx5LlxuXG4gICBBbHNvLCB0aGVyZSBzZWVtcyB0byBiZSBhIGJ1ZyBpbiB0aGlzIGNvZGUgb3IgaW4gdGhlXG4gICBpbXBsZW1lbnRhdGlvbiBvZiBvYmpfdHJ1bmNhdGUuXG5cbmV4dGVybmFsIG9ial90cnVuY2F0ZSA6ICdhIGFycmF5IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5cbmxldCBhcnJheV90b19saXN0X2luX3BsYWNlIGEgPVxuICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBhY2N1IG4gcCA9XG4gICAgaWYgcCA8PSAwIHRoZW4gYWNjdSBlbHNlIGJlZ2luXG4gICAgICBpZiBwID0gbiB0aGVuIGJlZ2luXG4gICAgICAgIG9ial90cnVuY2F0ZSBhIHA7XG4gICAgICAgIGxvb3AgKGEuKHAtMSkgOjogYWNjdSkgKG4tMTAwMCkgKHAtMSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxvb3AgKGEuKHAtMSkgOjogYWNjdSkgbiAocC0xKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgW10gKGwtMTAwMCkgbFxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCBhID0gQXJyYXkub2ZfbGlzdCBsIGluXG4gIEFycmF5LnN0YWJsZV9zb3J0IGNtcCBhO1xuICBhcnJheV90b19saXN0X2luX3BsYWNlIGFcblxuKilcblxuXG4oKiogc29ydGluZyArIHJlbW92aW5nIGR1cGxpY2F0ZXMgKilcblxubGV0IHNvcnRfdW5pcSBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZSB0MSB0MiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgbGV0IGMgPSBjbXAgaDEgaDIgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXSBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZV9yZXYgczEgczIgW10sIHRsKVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXSBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4Ml0gZWxzZSBbeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiB0bCAtPlxuICAgICAgICBsZXQgcyA9XG4gICAgICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzXSBlbHNlIFt4MzsgeDJdXG4gICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDE7IHgyXVxuICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgzOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgIChyZXZfbWVyZ2UgczEgczIgW10sIHRsKVxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBmc3QgKHNvcnQgbGVuIGwpXG5cblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aHMgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgXyA6OiBsMSwgXyA6OiBsMiAtPiBjb21wYXJlX2xlbmd0aHMgbDEgbDJcbjs7XG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhfd2l0aCBsIG4gPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIGlmIG4gPSAwIHRoZW4gMCBlbHNlXG4gICAgICBpZiBuID4gMCB0aGVuIC0xIGVsc2UgMVxuICB8IF8gOjogbCAtPlxuICAgIGlmIG4gPD0gMCB0aGVuIDEgZWxzZVxuICAgICAgY29tcGFyZV9sZW5ndGhfd2l0aCBsIChuLTEpXG47O1xuXG4oKiogezEgQ29tcGFyaXNvbn0gKilcblxuKCogTm90ZTogd2UgYXJlICpub3QqIHNob3J0Y3V0dGluZyB0aGUgbGlzdCBieSB1c2luZ1xuICAgW0xpc3QuY29tcGFyZV9sZW5ndGhzXSBmaXJzdDsgdGhpcyBtYXkgYmUgc2xvd2VyIG9uIGxvbmcgbGlzdHNcbiAgIGltbWVkaWF0ZWx5IHN0YXJ0IHdpdGggZGlzdGluY3QgZWxlbWVudHMuIEl0IGlzIGFsc28gaW5jb3JyZWN0IGZvclxuICAgW2NvbXBhcmVdIGJlbG93LCBhbmQgaXQgaXMgYmV0dGVyIChwcmluY2lwbGUgb2YgbGVhc3Qgc3VycHJpc2UpIHRvXG4gICB1c2UgdGhlIHNhbWUgYXBwcm9hY2ggZm9yIGJvdGggZnVuY3Rpb25zLiAqKVxubGV0IHJlYyBlcXVhbCBlcSBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IHRydWVcbiAgfCBbXSwgXzo6XyB8IF86Ol8sIFtdIC0+IGZhbHNlXG4gIHwgYTE6OmwxLCBhMjo6bDIgLT4gZXEgYTEgYTIgJiYgZXF1YWwgZXEgbDEgbDJcblxubGV0IHJlYyBjb21wYXJlIGNtcCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXzo6XyAtPiAtMVxuICB8IF86Ol8sIFtdIC0+IDFcbiAgfCBhMTo6bDEsIGEyOjpsMiAtPlxuICAgIGxldCBjID0gY21wIGExIGEyIGluXG4gICAgaWYgYyA8PiAwIHRoZW4gY1xuICAgIGVsc2UgY29tcGFyZSBjbXAgbDEgbDJcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBsID1cbiAgbGV0IHJlYyBhdXggbCAoKSA9IG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gU2VxLk5pbFxuICAgIHwgeCA6OiB0YWlsIC0+IFNlcS5Db25zICh4LCBhdXggdGFpbClcbiAgaW5cbiAgYXV4IGxcblxubGV0IG9mX3NlcSBzZXEgPVxuICBsZXQgcmVjIGRpcmVjdCBkZXB0aCBzZXEgOiBfIGxpc3QgPVxuICAgIGlmIGRlcHRoPTBcbiAgICB0aGVuXG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBzZXFcbiAgICAgIHw+IHJldiAoKiB0YWlscmVjICopXG4gICAgZWxzZSBtYXRjaCBzZXEoKSB3aXRoXG4gICAgICB8IFNlcS5OaWwgLT4gW11cbiAgICAgIHwgU2VxLkNvbnMgKHgsIG5leHQpIC0+IHggOjogZGlyZWN0IChkZXB0aC0xKSBuZXh0XG4gIGluXG4gIGRpcmVjdCA1MDAgc2VxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgU2ltb24gQ3J1YW5lcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbU2VxXTogZnVuY3Rpb25hbCBpdGVyYXRvcnMgKilcblxudHlwZSArJ2Egbm9kZSA9XG4gIHwgTmlsXG4gIHwgQ29ucyBvZiAnYSAqICdhIHRcblxuYW5kICdhIHQgPSB1bml0IC0+ICdhIG5vZGVcblxubGV0IGVtcHR5ICgpID0gTmlsXG5cbmxldCByZXR1cm4geCAoKSA9IENvbnMgKHgsIGVtcHR5KVxuXG5sZXQgY29ucyB4IG5leHQgKCkgPSBDb25zICh4LCBuZXh0KVxuXG5sZXQgcmVjIGFwcGVuZCBzZXExIHNlcTIgKCkgPVxuICBtYXRjaCBzZXExKCkgd2l0aFxuICB8IE5pbCAtPiBzZXEyKClcbiAgfCBDb25zICh4LCBuZXh0KSAtPiBDb25zICh4LCBhcHBlbmQgbmV4dCBzZXEyKVxuXG5sZXQgcmVjIG1hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gQ29ucyAoZiB4LCBtYXAgZiBuZXh0KVxuXG5sZXQgcmVjIGZpbHRlcl9tYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgICB8IE5vbmUgLT4gZmlsdGVyX21hcCBmIG5leHQgKClcbiAgICAgICAgfCBTb21lIHkgLT4gQ29ucyAoeSwgZmlsdGVyX21hcCBmIG5leHQpXG5cbmxldCByZWMgZmlsdGVyIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgaWYgZiB4XG4gICAgICB0aGVuIENvbnMgKHgsIGZpbHRlciBmIG5leHQpXG4gICAgICBlbHNlIGZpbHRlciBmIG5leHQgKClcblxubGV0IHJlYyBmbGF0X21hcCBmIHNlcSAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgZmxhdF9tYXBfYXBwIGYgKGYgeCkgbmV4dCAoKVxuXG4oKiB0aGlzIGlzIFthcHBlbmQgc2VxIChmbGF0X21hcCBmIHRhaWwpXSAqKVxuYW5kIGZsYXRfbWFwX2FwcCBmIHNlcSB0YWlsICgpID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBOaWwgLT4gZmxhdF9tYXAgZiB0YWlsICgpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICBDb25zICh4LCBmbGF0X21hcF9hcHAgZiBuZXh0IHRhaWwpXG5cbmxldCBmb2xkX2xlZnQgZiBhY2Mgc2VxID1cbiAgbGV0IHJlYyBhdXggZiBhY2Mgc2VxID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGF1eCBmIGFjYyBuZXh0XG4gIGluXG4gIGF1eCBmIGFjYyBzZXFcblxubGV0IGl0ZXIgZiBzZXEgPVxuICBsZXQgcmVjIGF1eCBzZXEgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICAgIHwgTmlsIC0+ICgpXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBmIHg7XG4gICAgICAgIGF1eCBuZXh0XG4gIGluXG4gIGF1eCBzZXFcblxubGV0IHJlYyB1bmZvbGQgZiB1ICgpID1cbiAgbWF0Y2ggZiB1IHdpdGhcbiAgfCBOb25lIC0+IE5pbFxuICB8IFNvbWUgKHgsIHUnKSAtPiBDb25zICh4LCB1bmZvbGQgZiB1JylcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0gJ2Egb3B0aW9uID0gTm9uZSB8IFNvbWUgb2YgJ2FcblxubGV0IG5vbmUgPSBOb25lXG5sZXQgc29tZSB2ID0gU29tZSB2XG5sZXQgdmFsdWUgbyB+ZGVmYXVsdCA9IG1hdGNoIG8gd2l0aCBTb21lIHYgLT4gdiB8IE5vbmUgLT4gZGVmYXVsdFxubGV0IGdldCA9IGZ1bmN0aW9uIFNvbWUgdiAtPiB2IHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIm9wdGlvbiBpcyBOb25lXCJcbmxldCBiaW5kIG8gZiA9IG1hdGNoIG8gd2l0aCBOb25lIC0+IE5vbmUgfCBTb21lIHYgLT4gZiB2XG5sZXQgam9pbiA9IGZ1bmN0aW9uIFNvbWUgbyAtPiBvIHwgTm9uZSAtPiBOb25lXG5sZXQgbWFwIGYgbyA9IG1hdGNoIG8gd2l0aCBOb25lIC0+IE5vbmUgfCBTb21lIHYgLT4gU29tZSAoZiB2KVxubGV0IGZvbGQgfm5vbmUgfnNvbWUgPSBmdW5jdGlvbiBTb21lIHYgLT4gc29tZSB2IHwgTm9uZSAtPiBub25lXG5sZXQgaXRlciBmID0gZnVuY3Rpb24gU29tZSB2IC0+IGYgdiB8IE5vbmUgLT4gKClcbmxldCBpc19ub25lID0gZnVuY3Rpb24gTm9uZSAtPiB0cnVlIHwgU29tZSBfIC0+IGZhbHNlXG5sZXQgaXNfc29tZSA9IGZ1bmN0aW9uIE5vbmUgLT4gZmFsc2UgfCBTb21lIF8gLT4gdHJ1ZVxuXG5sZXQgZXF1YWwgZXEgbzAgbzEgPSBtYXRjaCBvMCwgbzEgd2l0aFxufCBTb21lIHYwLCBTb21lIHYxIC0+IGVxIHYwIHYxXG58IE5vbmUsIE5vbmUgLT4gdHJ1ZVxufCBfIC0+IGZhbHNlXG5cbmxldCBjb21wYXJlIGNtcCBvMCBvMSA9IG1hdGNoIG8wLCBvMSB3aXRoXG58IFNvbWUgdjAsIFNvbWUgdjEgLT4gY21wIHYwIHYxXG58IE5vbmUsIE5vbmUgLT4gMFxufCBOb25lLCBTb21lIF8gLT4gLTFcbnwgU29tZSBfLCBOb25lIC0+IDFcblxubGV0IHRvX3Jlc3VsdCB+bm9uZSA9IGZ1bmN0aW9uIE5vbmUgLT4gRXJyb3Igbm9uZSB8IFNvbWUgdiAtPiBPayB2XG5sZXQgdG9fbGlzdCA9IGZ1bmN0aW9uIE5vbmUgLT4gW10gfCBTb21lIHYgLT4gW3ZdXG5sZXQgdG9fc2VxID0gZnVuY3Rpb24gTm9uZSAtPiBTZXEuZW1wdHkgfCBTb21lIHYgLT4gU2VxLnJldHVybiB2XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEdhYnJpZWwgU2NoZXJlciwgcHJvamV0IFBhcnNpZmFsLCBJTlJJQSBTYWNsYXkgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE5IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgKCdhLCAnYikgdCA9IExlZnQgb2YgJ2EgfCBSaWdodCBvZiAnYlxuXG5sZXQgbGVmdCB2ID0gTGVmdCB2XG5sZXQgcmlnaHQgdiA9IFJpZ2h0IHZcblxubGV0IGlzX2xlZnQgPSBmdW5jdGlvblxufCBMZWZ0IF8gLT4gdHJ1ZVxufCBSaWdodCBfIC0+IGZhbHNlXG5cbmxldCBpc19yaWdodCA9IGZ1bmN0aW9uXG58IExlZnQgXyAtPiBmYWxzZVxufCBSaWdodCBfIC0+IHRydWVcblxubGV0IGZpbmRfbGVmdCA9IGZ1bmN0aW9uXG58IExlZnQgdiAtPiBTb21lIHZcbnwgUmlnaHQgXyAtPiBOb25lXG5cbmxldCBmaW5kX3JpZ2h0ID0gZnVuY3Rpb25cbnwgTGVmdCBfIC0+IE5vbmVcbnwgUmlnaHQgdiAtPiBTb21lIHZcblxubGV0IG1hcF9sZWZ0IGYgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gTGVmdCAoZiB2KVxufCBSaWdodCBfIGFzIGUgLT4gZVxuXG5sZXQgbWFwX3JpZ2h0IGYgPSBmdW5jdGlvblxufCBMZWZ0IF8gYXMgZSAtPiBlXG58IFJpZ2h0IHYgLT4gUmlnaHQgKGYgdilcblxubGV0IG1hcCB+bGVmdCB+cmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gTGVmdCAobGVmdCB2KVxufCBSaWdodCB2IC0+IFJpZ2h0IChyaWdodCB2KVxuXG5sZXQgZm9sZCB+bGVmdCB+cmlnaHQgPSBmdW5jdGlvblxufCBMZWZ0IHYgLT4gbGVmdCB2XG58IFJpZ2h0IHYgLT4gcmlnaHQgdlxuXG5sZXQgaXRlciA9IGZvbGRcblxubGV0IGZvcl9hbGwgPSBmb2xkXG5cbmxldCBlcXVhbCB+bGVmdCB+cmlnaHQgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxufCBMZWZ0IHYxLCBMZWZ0IHYyIC0+IGxlZnQgdjEgdjJcbnwgUmlnaHQgdjEsIFJpZ2h0IHYyIC0+IHJpZ2h0IHYxIHYyXG58IExlZnQgXywgUmlnaHQgXyB8IFJpZ2h0IF8sIExlZnQgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSB+bGVmdCB+cmlnaHQgZTEgZTIgPSBtYXRjaCBlMSwgZTIgd2l0aFxufCBMZWZ0IHYxLCBMZWZ0IHYyIC0+IGxlZnQgdjEgdjJcbnwgUmlnaHQgdjEsIFJpZ2h0IHYyIC0+IHJpZ2h0IHYxIHYyXG58IExlZnQgXywgUmlnaHQgXyAtPiAoLTEpXG58IFJpZ2h0IF8sIExlZnQgXyAtPiAxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2VcblxubGV0IG9rIHYgPSBPayB2XG5sZXQgZXJyb3IgZSA9IEVycm9yIGVcbmxldCB2YWx1ZSByIH5kZWZhdWx0ID0gbWF0Y2ggciB3aXRoIE9rIHYgLT4gdiB8IEVycm9yIF8gLT4gZGVmYXVsdFxubGV0IGdldF9vayA9IGZ1bmN0aW9uIE9rIHYgLT4gdiB8IEVycm9yIF8gLT4gaW52YWxpZF9hcmcgXCJyZXN1bHQgaXMgRXJyb3IgX1wiXG5sZXQgZ2V0X2Vycm9yID0gZnVuY3Rpb24gRXJyb3IgZSAtPiBlIHwgT2sgXyAtPiBpbnZhbGlkX2FyZyBcInJlc3VsdCBpcyBPayBfXCJcbmxldCBiaW5kIHIgZiA9IG1hdGNoIHIgd2l0aCBPayB2IC0+IGYgdiB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgam9pbiA9IGZ1bmN0aW9uIE9rIHIgLT4gciB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgbWFwIGYgPSBmdW5jdGlvbiBPayB2IC0+IE9rIChmIHYpIHwgRXJyb3IgXyBhcyBlIC0+IGVcbmxldCBtYXBfZXJyb3IgZiA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gRXJyb3IgKGYgZSkgfCBPayBfIGFzIHYgLT4gdlxubGV0IGZvbGQgfm9rIH5lcnJvciA9IGZ1bmN0aW9uIE9rIHYgLT4gb2sgdiB8IEVycm9yIGUgLT4gZXJyb3IgZVxubGV0IGl0ZXIgZiA9IGZ1bmN0aW9uIE9rIHYgLT4gZiB2IHwgRXJyb3IgXyAtPiAoKVxubGV0IGl0ZXJfZXJyb3IgZiA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gZiBlIHwgT2sgXyAtPiAoKVxubGV0IGlzX29rID0gZnVuY3Rpb24gT2sgXyAtPiB0cnVlIHwgRXJyb3IgXyAtPiBmYWxzZVxubGV0IGlzX2Vycm9yID0gZnVuY3Rpb24gRXJyb3IgXyAtPiB0cnVlIHwgT2sgXyAtPiBmYWxzZVxuXG5sZXQgZXF1YWwgfm9rIH5lcnJvciByMCByMSA9IG1hdGNoIHIwLCByMSB3aXRoXG58IE9rIHYwLCBPayB2MSAtPiBvayB2MCB2MVxufCBFcnJvciBlMCwgRXJyb3IgZTEgLT4gZXJyb3IgZTAgZTFcbnwgXywgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSB+b2sgfmVycm9yIHIwIHIxID0gbWF0Y2ggcjAsIHIxIHdpdGhcbnwgT2sgdjAsIE9rIHYxIC0+IG9rIHYwIHYxXG58IEVycm9yIGUwLCBFcnJvciBlMSAtPiBlcnJvciBlMCBlMVxufCBPayBfLCBFcnJvciBfIC0+IC0xXG58IEVycm9yIF8sIE9rIF8gLT4gMVxuXG5sZXQgdG9fb3B0aW9uID0gZnVuY3Rpb24gT2sgdiAtPiBTb21lIHYgfCBFcnJvciBfIC0+IE5vbmVcbmxldCB0b19saXN0ID0gZnVuY3Rpb24gT2sgdiAtPiBbdl0gfCBFcnJvciBfIC0+IFtdXG5sZXQgdG9fc2VxID0gZnVuY3Rpb24gT2sgdiAtPiBTZXEucmV0dXJuIHYgfCBFcnJvciBfIC0+IFNlcS5lbXB0eVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHQgPSBib29sID0gZmFsc2UgfCB0cnVlXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmxldCBlcXVhbCA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gKCA9IClcbmxldCBjb21wYXJlIDogYm9vbCAtPiBib29sIC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5leHRlcm5hbCB0b19pbnQgOiBib29sIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmxldCB0b19mbG9hdCA9IGZ1bmN0aW9uIGZhbHNlIC0+IDAuIHwgdHJ1ZSAtPiAxLlxuXG4oKlxubGV0IG9mX3N0cmluZyA9IGZ1bmN0aW9uXG58IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG58IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxufCBfIC0+IE5vbmVcbiopXG5cbmxldCB0b19zdHJpbmcgPSBmdW5jdGlvbiBmYWxzZSAtPiBcImZhbHNlXCIgfCB0cnVlIC0+IFwidHJ1ZVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGNvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdW5zYWZlX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBjaHIgbiA9XG4gIGlmIG4gPCAwIHx8IG4gPiAyNTUgdGhlbiBpbnZhbGlkX2FyZyBcIkNoYXIuY2hyXCIgZWxzZSB1bnNhZmVfY2hyIG5cblxuZXh0ZXJuYWwgYnl0ZXNfY3JlYXRlOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCBlc2NhcGVkID0gZnVuY3Rpb25cbiAgfCAnXFwnJyAtPiBcIlxcXFwnXCJcbiAgfCAnXFxcXCcgLT4gXCJcXFxcXFxcXFwiXG4gIHwgJ1xcbicgLT4gXCJcXFxcblwiXG4gIHwgJ1xcdCcgLT4gXCJcXFxcdFwiXG4gIHwgJ1xccicgLT4gXCJcXFxcclwiXG4gIHwgJ1xcYicgLT4gXCJcXFxcYlwiXG4gIHwgJyAnIC4uICd+JyBhcyBjIC0+XG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAxIGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCBjO1xuICAgICAgdW5zYWZlX3RvX3N0cmluZyBzXG4gIHwgYyAtPlxuICAgICAgbGV0IG4gPSBjb2RlIGMgaW5cbiAgICAgIGxldCBzID0gYnl0ZXNfY3JlYXRlIDQgaW5cbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAwICdcXFxcJztcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAxICh1bnNhZmVfY2hyICg0OCArIG4gLyAxMDApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAyICh1bnNhZmVfY2hyICg0OCArIChuIC8gMTApIG1vZCAxMCkpO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDMgKHVuc2FmZV9jaHIgKDQ4ICsgbiBtb2QgMTApKTtcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuXG5sZXQgbG93ZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onXG4gIHwgJ1xcMTkyJyAuLiAnXFwyMTQnXG4gIHwgJ1xcMjE2JyAuLiAnXFwyMjInIGFzIGMgLT5cbiAgICB1bnNhZmVfY2hyKGNvZGUgYyArIDMyKVxuICB8IGMgLT4gY1xuXG5sZXQgdXBwZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onXG4gIHwgJ1xcMjI0JyAuLiAnXFwyNDYnXG4gIHwgJ1xcMjQ4JyAuLiAnXFwyNTQnIGFzIGMgLT5cbiAgICB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICB8IGMgLT4gY1xuXG5sZXQgbG93ZXJjYXNlX2FzY2lpID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onIGFzIGMgLT4gdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgfCBjIC0+IGNcblxubGV0IHVwcGVyY2FzZV9hc2NpaSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyBhcyBjIC0+IHVuc2FmZV9jaHIoY29kZSBjIC0gMzIpXG4gIHwgYyAtPiBjXG5cbnR5cGUgdCA9IGNoYXJcblxubGV0IGNvbXBhcmUgYzEgYzIgPSBjb2RlIGMxIC0gY29kZSBjMlxubGV0IGVxdWFsIChjMTogdCkgKGMyOiB0KSA9IGNvbXBhcmUgYzEgYzIgPSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIHN0cmluZy5tbC5cbiAgIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIGEgXCJkdXBsaWNhdGVkXCIgY29tbWVudCBhYm92ZSB0aGVpciBkZWZpbml0aW9uLlxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIHN0cmluZ19sZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2ZpbGxfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGJ5dGVzID0gXCIlYnl0ZXNfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV9ibGl0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbmxldCBtYWtlIG4gYyA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgdW5zYWZlX2ZpbGwgcyAwIG4gYztcbiAgc1xuXG5sZXQgaW5pdCBuIGYgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgcyBpIChmIGkpXG4gIGRvbmU7XG4gIHNcblxubGV0IGVtcHR5ID0gY3JlYXRlIDBcblxubGV0IGNvcHkgcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgdW5zYWZlX2JsaXQgcyAwIHIgMCBsZW47XG4gIHJcblxubGV0IHRvX3N0cmluZyBiID0gdW5zYWZlX3RvX3N0cmluZyAoY29weSBiKVxubGV0IG9mX3N0cmluZyBzID0gY29weSAodW5zYWZlX29mX3N0cmluZyBzKVxuXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLnN1YiAvIEJ5dGVzLnN1YlwiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBzIG9mcyByIDAgbGVuO1xuICAgIHJcbiAgZW5kXG5cbmxldCBzdWJfc3RyaW5nIGIgb2ZzIGxlbiA9IHVuc2FmZV90b19zdHJpbmcgKHN1YiBiIG9mcyBsZW4pXG5cbigqIGFkZGl0aW9uIHdpdGggYW4gb3ZlcmZsb3cgY2hlY2sgKilcbmxldCAoKyspIGEgYiA9XG4gIGxldCBjID0gYSArIGIgaW5cbiAgbWF0Y2ggYSA8IDAsIGIgPCAwLCBjIDwgMCB3aXRoXG4gIHwgdHJ1ZSAsIHRydWUgLCBmYWxzZVxuICB8IGZhbHNlLCBmYWxzZSwgdHJ1ZSAgLT4gaW52YWxpZF9hcmcgXCJCeXRlcy5leHRlbmRcIiAoKiBvdmVyZmxvdyAqKVxuICB8IF8gLT4gY1xuXG5sZXQgZXh0ZW5kIHMgbGVmdCByaWdodCA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyArKyBsZWZ0ICsrIHJpZ2h0IGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICBsZXQgKHNyY29mZiwgZHN0b2ZmKSA9IGlmIGxlZnQgPCAwIHRoZW4gLWxlZnQsIDAgZWxzZSAwLCBsZWZ0IGluXG4gIGxldCBjcHlsZW4gPSBtaW4gKGxlbmd0aCBzIC0gc3Jjb2ZmKSAobGVuIC0gZHN0b2ZmKSBpblxuICBpZiBjcHlsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgcyBzcmNvZmYgciBkc3RvZmYgY3B5bGVuO1xuICByXG5cbmxldCBmaWxsIHMgb2ZzIGxlbiBjID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuZmlsbCAvIEJ5dGVzLmZpbGxcIlxuICBlbHNlIHVuc2FmZV9maWxsIHMgb2ZzIGxlbiBjXG5cbmxldCBibGl0IHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCeXRlcy5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbmxldCBibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gc3RyaW5nX2xlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5ibGl0IC8gQnl0ZXMuYmxpdF9zdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9ibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlciBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJCeXRlcy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGVtcHR5XG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpblxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKGNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG5sZXQgY2F0IHMxIHMyID1cbiAgbGV0IGwxID0gbGVuZ3RoIHMxIGluXG4gIGxldCBsMiA9IGxlbmd0aCBzMiBpblxuICBsZXQgciA9IGNyZWF0ZSAobDEgKyBsMikgaW5cbiAgdW5zYWZlX2JsaXQgczEgMCByIDAgbDE7XG4gIHVuc2FmZV9ibGl0IHMyIDAgciBsMSBsMjtcbiAgclxuXG5cbmV4dGVybmFsIGNoYXJfY29kZTogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBjaGFyX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaSkgZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgbGV0IGogPSByZWYgKGxlbiAtIDEpIGluXG4gIHdoaWxlICFqID49ICFpICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWopIGRvXG4gICAgZGVjciBqXG4gIGRvbmU7XG4gIGlmICFqID49ICFpIHRoZW5cbiAgICBzdWIgcyAhaSAoIWogLSAhaSArIDEpXG4gIGVsc2VcbiAgICBlbXB0eVxuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgbiA6PSAhbiArXG4gICAgICAobWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcbicgfCAnXFx0JyB8ICdcXHInIHwgJ1xcYicgLT4gMlxuICAgICAgIHwgJyAnIC4uICd+JyAtPiAxXG4gICAgICAgfCBfIC0+IDQpXG4gIGRvbmU7XG4gIGlmICFuID0gbGVuZ3RoIHMgdGhlbiBjb3B5IHMgZWxzZSBiZWdpblxuICAgIGxldCBzJyA9IGNyZWF0ZSAhbiBpblxuICAgIG4gOj0gMDtcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgICBiZWdpbiBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICgnXFxcIicgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICduJ1xuICAgICAgfCAnXFx0JyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3QnXG4gICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAncidcbiAgICAgIHwgJ1xcYicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdiJ1xuICAgICAgfCAoJyAnIC4uICd+JykgYXMgYyAtPiB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgYyAtPlxuICAgICAgICAgIGxldCBhID0gY2hhcl9jb2RlIGMgaW5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSAvIDEwMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyAoYSAvIDEwKSBtb2QgMTApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSBtb2QgMTApKTtcbiAgICAgIGVuZDtcbiAgICAgIGluY3IgblxuICAgIGRvbmU7XG4gICAgcydcbiAgZW5kXG5cbmxldCBtYXAgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwaSBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbmxldCBhcHBseTEgZiBzID1cbiAgaWYgbGVuZ3RoIHMgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjb3B5IHMgaW5cbiAgICB1bnNhZmVfc2V0IHIgMCAoZih1bnNhZmVfZ2V0IHMgMCkpO1xuICAgIHJcbiAgZW5kXG5cbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjIHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgcmluZGV4X3JlYyBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleCBzIGMgPSByaW5kZXhfcmVjIHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyByaW5kZXhfcmVjX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIHJpbmRleF9yZWNfb3B0IHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X29wdCBzIGMgPSByaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgMCB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yY29udGFpbnNfZnJvbSAvIEJ5dGVzLnJjb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKHJpbmRleF9yZWMgcyBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cblxudHlwZSB0ID0gYnl0ZXNcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9ieXRlc19lcXVhbFwiIFtAQG5vYWxsb2NdXG5cbigqIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGltcGxlbWVudGVkIHZpYSBvdGhlciBkZXByZWNhdGVkIGZ1bmN0aW9ucyAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubGV0IHVwcGVyY2FzZSBzID0gbWFwIENoYXIudXBwZXJjYXNlIHNcbmxldCBsb3dlcmNhc2UgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZSBzXG5cbmxldCBjYXBpdGFsaXplIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2Ugc1xubGV0IHVuY2FwaXRhbGl6ZSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlIHNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA9IGxlbmd0aCBzIHRoZW4gU2VxLk5pbFxuICAgIGVsc2VcbiAgICAgIGxldCB4ID0gZ2V0IHMgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgcyA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPSBsZW5ndGggcyB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IGdldCBzIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgbiA9IHJlZiAwIGluXG4gIGxldCBidWYgPSByZWYgKG1ha2UgMjU2ICdcXDAwMCcpIGluXG4gIGxldCByZXNpemUgKCkgPVxuICAgICgqIHJlc2l6ZSAqKVxuICAgIGxldCBuZXdfbGVuID0gbWluICgyICogbGVuZ3RoICFidWYpIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBpblxuICAgIGlmIGxlbmd0aCAhYnVmID0gbmV3X2xlbiB0aGVuIGZhaWx3aXRoIFwiQnl0ZXMub2Zfc2VxOiBjYW5ub3QgZ3JvdyBieXRlc1wiO1xuICAgIGxldCBuZXdfYnVmID0gbWFrZSBuZXdfbGVuICdcXDAwMCcgaW5cbiAgICBibGl0ICFidWYgMCBuZXdfYnVmIDAgIW47XG4gICAgYnVmIDo9IG5ld19idWZcbiAgaW5cbiAgU2VxLml0ZXJcbiAgICAoZnVuIGMgLT5cbiAgICAgICBpZiAhbiA9IGxlbmd0aCAhYnVmIHRoZW4gcmVzaXplKCk7XG4gICAgICAgc2V0ICFidWYgIW4gYztcbiAgICAgICBpbmNyIG4pXG4gICAgaTtcbiAgc3ViICFidWYgMCAhblxuXG4oKiogezYgQmluYXJ5IGVuY29kaW5nL2RlY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG5leHRlcm5hbCBnZXRfdWludDggOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgZ2V0X3VpbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgPSBcIiVjYW1sX2J5dGVzX2dldDE2XCJcbmV4dGVybmFsIGdldF9pbnQzMl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiA9IFwiJWNhbWxfYnl0ZXNfZ2V0MzJcIlxuZXh0ZXJuYWwgZ2V0X2ludDY0X25lIDogYnl0ZXMgLT4gaW50IC0+IGludDY0ID0gXCIlY2FtbF9ieXRlc19nZXQ2NFwiXG5leHRlcm5hbCBzZXRfaW50OCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWJ5dGVzX3NhZmVfc2V0XCJcbmV4dGVybmFsIHNldF9pbnQxNl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0MTZcIlxuZXh0ZXJuYWwgc2V0X2ludDMyX25lIDogYnl0ZXMgLT4gaW50IC0+IGludDMyIC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDMyXCJcbmV4dGVybmFsIHNldF9pbnQ2NF9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NFwiXG5leHRlcm5hbCBzd2FwMTYgOiBpbnQgLT4gaW50ID0gXCIlYnN3YXAxNlwiXG5leHRlcm5hbCBzd2FwMzIgOiBpbnQzMiAtPiBpbnQzMiA9IFwiJWJzd2FwX2ludDMyXCJcbmV4dGVybmFsIHN3YXA2NCA6IGludDY0IC0+IGludDY0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5sZXQgZ2V0X2ludDggYiBpID1cbiAgKChnZXRfdWludDggYiBpKSBsc2wgKFN5cy5pbnRfc2l6ZSAtIDgpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDgpXG5cbmxldCBnZXRfdWludDE2X2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IChnZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSBnZXRfdWludDE2X25lIGIgaVxuXG5sZXQgZ2V0X3VpbnQxNl9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgKGdldF91aW50MTZfbmUgYiBpKVxuICBlbHNlIGdldF91aW50MTZfbmUgYiBpXG5cbmxldCBnZXRfaW50MTZfbmUgYiBpID1cbiAgKChnZXRfdWludDE2X25lIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MTZfbGUgYiBpID1cbiAgKChnZXRfdWludDE2X2xlIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MTZfYmUgYiBpID1cbiAgKChnZXRfdWludDE2X2JlIGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSAxNikpIGFzciAoU3lzLmludF9zaXplIC0gMTYpXG5cbmxldCBnZXRfaW50MzJfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgKGdldF9pbnQzMl9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDMyX25lIGIgaVxuXG5sZXQgZ2V0X2ludDMyX2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiAoZ2V0X2ludDMyX25lIGIgaSlcbiAgZWxzZSBnZXRfaW50MzJfbmUgYiBpXG5cbmxldCBnZXRfaW50NjRfbGUgYiBpID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgKGdldF9pbnQ2NF9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDY0X25lIGIgaVxuXG5sZXQgZ2V0X2ludDY0X2JlIGIgaSA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXA2NCAoZ2V0X2ludDY0X25lIGIgaSlcbiAgZWxzZSBnZXRfaW50NjRfbmUgYiBpXG5cbmxldCBzZXRfaW50MTZfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHNldF9pbnQxNl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDE2X2JlIGIgaSB4ID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDE2X25lIGIgaSAoc3dhcDE2IHgpXG4gIGVsc2Ugc2V0X2ludDE2X25lIGIgaSB4XG5cbmxldCBzZXRfaW50MzJfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQzMl9uZSBiIGkgKHN3YXAzMiB4KVxuICBlbHNlIHNldF9pbnQzMl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDMyX2JlIGIgaSB4ID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDMyX25lIGIgaSAoc3dhcDMyIHgpXG4gIGVsc2Ugc2V0X2ludDMyX25lIGIgaSB4XG5cbmxldCBzZXRfaW50NjRfbGUgYiBpIHggPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQ2NF9uZSBiIGkgKHN3YXA2NCB4KVxuICBlbHNlIHNldF9pbnQ2NF9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDY0X2JlIGIgaSB4ID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc2V0X2ludDY0X25lIGIgaSAoc3dhcDY0IHgpXG4gIGVsc2Ugc2V0X2ludDY0X25lIGIgaSB4XG5cbmxldCBzZXRfdWludDggPSBzZXRfaW50OFxubGV0IHNldF91aW50MTZfbmUgPSBzZXRfaW50MTZfbmVcbmxldCBzZXRfdWludDE2X2JlID0gc2V0X2ludDE2X2JlXG5sZXQgc2V0X3VpbnQxNl9sZSA9IHNldF9pbnQxNl9sZVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgR2FsbGl1bSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBTdHJpbmcgb3BlcmF0aW9ucywgYmFzZWQgb24gYnl0ZSBzZXF1ZW5jZSBvcGVyYXRpb25zICopXG5cbigqIFdBUk5JTkc6IFNvbWUgZnVuY3Rpb25zIGluIHRoaXMgZmlsZSBhcmUgZHVwbGljYXRlZCBpbiBieXRlcy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBieXRlcy5tbC5cbiAgIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIGEgXCJkdXBsaWNhdGVkXCIgY29tbWVudCBhYm92ZSB0aGVpciBkZWZpbml0aW9uLlxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVzdHJpbmdfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9zdHJpbmdcIlxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlc3RyaW5nX3Vuc2FmZV9zZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOiBzdHJpbmcgLT4gaW50IC0+ICBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV9maWxsIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2ZpbGxfc3RyaW5nXCIgW0BAbm9hbGxvY11cblxubW9kdWxlIEIgPSBCeXRlc1xuXG5sZXQgYnRzID0gQi51bnNhZmVfdG9fc3RyaW5nXG5sZXQgYm9zID0gQi51bnNhZmVfb2Zfc3RyaW5nXG5cbmxldCBtYWtlIG4gYyA9XG4gIEIubWFrZSBuIGMgfD4gYnRzXG5sZXQgaW5pdCBuIGYgPVxuICBCLmluaXQgbiBmIHw+IGJ0c1xubGV0IGNvcHkgcyA9XG4gIEIuY29weSAoYm9zIHMpIHw+IGJ0c1xubGV0IHN1YiBzIG9mcyBsZW4gPVxuICBCLnN1YiAoYm9zIHMpIG9mcyBsZW4gfD4gYnRzXG5sZXQgZmlsbCA9XG4gIEIuZmlsbFxubGV0IGJsaXQgPVxuICBCLmJsaXRfc3RyaW5nXG5cbmxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbmNhdFwiXG5cbmxldCByZWMgc3VtX2xlbmd0aHMgYWNjIHNlcGxlbiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjXG4gIHwgaGQgOjogW10gLT4gbGVuZ3RoIGhkICsgYWNjXG4gIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgc2VwbGVuICsgYWNjKSBhY2MpIHNlcGxlbiB0bFxuXG5sZXQgcmVjIHVuc2FmZV9ibGl0cyBkc3QgcG9zIHNlcCBzZXBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGRzdFxuICB8IGhkIDo6IFtdIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpOyBkc3RcbiAgfCBoZCA6OiB0bCAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTtcbiAgICB1bnNhZmVfYmxpdCBzZXAgMCBkc3QgKHBvcyArIGxlbmd0aCBoZCkgc2VwbGVuO1xuICAgIHVuc2FmZV9ibGl0cyBkc3QgKHBvcyArIGxlbmd0aCBoZCArIHNlcGxlbikgc2VwIHNlcGxlbiB0bFxuXG5sZXQgY29uY2F0IHNlcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gXCJcIlxuICB8IGwgLT4gbGV0IHNlcGxlbiA9IGxlbmd0aCBzZXAgaW4gYnRzIEBAXG4gICAgICAgICAgdW5zYWZlX2JsaXRzXG4gICAgICAgICAgICAoQi5jcmVhdGUgKHN1bV9sZW5ndGhzIDAgc2VwbGVuIGwpKVxuICAgICAgICAgICAgMCBzZXAgc2VwbGVuIGxcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGl0ZXIgZiBzID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkbyBmICh1bnNhZmVfZ2V0IHMgaSkgZG9uZVxuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaXRlcmkgZiBzID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgcyBpKSBkb25lXG5cbmxldCBtYXAgZiBzID1cbiAgQi5tYXAgZiAoYm9zIHMpIHw+IGJ0c1xubGV0IG1hcGkgZiBzID1cbiAgQi5tYXBpIGYgKGJvcyBzKSB8PiBidHNcblxuKCogQmV3YXJlOiB3ZSBjYW5ub3QgdXNlIEIudHJpbSBvciBCLmVzY2FwZSBiZWNhdXNlIHRoZXkgYWx3YXlzIG1ha2UgYVxuICAgY29weSwgYnV0IFN0cmluZy5tbGkgc3BlbGxzIG91dCBzb21lIGNhc2VzIHdoZXJlIHdlIGFyZSBub3QgYWxsb3dlZFxuICAgdG8gbWFrZSBhIGNvcHkuICopXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgaWYgcyA9IFwiXCIgdGhlbiBzXG4gIGVsc2UgaWYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAwKSB8fCBpc19zcGFjZSAodW5zYWZlX2dldCBzIChsZW5ndGggcyAtIDEpKVxuICAgIHRoZW4gYnRzIChCLnRyaW0gKGJvcyBzKSlcbiAgZWxzZSBzXG5cbmxldCBlc2NhcGVkIHMgPVxuICBsZXQgcmVjIGVzY2FwZV9pZl9uZWVkZWQgcyBuIGkgPVxuICAgIGlmIGkgPj0gbiB0aGVuIHMgZWxzZVxuICAgICAgbWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFwwMDAnLi4nXFwwMzEnIHwgJ1xcMTI3Jy4uICdcXDI1NScgLT5cbiAgICAgICAgICBidHMgKEIuZXNjYXBlZCAoYm9zIHMpKVxuICAgICAgfCBfIC0+IGVzY2FwZV9pZl9uZWVkZWQgcyBuIChpKzEpXG4gIGluXG4gIGVzY2FwZV9pZl9uZWVkZWQgcyAobGVuZ3RoIHMpIDBcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWMgcyBsaW0gaSBjID1cbiAgaWYgaSA+PSBsaW0gdGhlbiByYWlzZSBOb3RfZm91bmQgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBpIGVsc2UgaW5kZXhfcmVjIHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9vcHQgcyBjID0gaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICAgIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMuaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgcmluZGV4X3JlYyBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIHJpbmRleF9yZWMgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleCBzIGMgPSByaW5kZXhfcmVjIHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgcmluZGV4X3JlY19vcHQgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSByaW5kZXhfcmVjX29wdCBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X29wdCBzIGMgPSByaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJjb250YWluc19mcm9tIHMgaSBjID1cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5yY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChyaW5kZXhfcmVjIHMgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPVxuICBCLnVwcGVyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID1cbiAgQi5sb3dlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCB1bmNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIudW5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5cbmxldCBzcGxpdF9vbl9jaGFyIHNlcCBzID1cbiAgbGV0IHIgPSByZWYgW10gaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCBzKSBpblxuICBmb3IgaSA9IGxlbmd0aCBzIC0gMSBkb3dudG8gMCBkb1xuICAgIGlmIHVuc2FmZV9nZXQgcyBpID0gc2VwIHRoZW4gYmVnaW5cbiAgICAgIHIgOj0gc3ViIHMgKGkgKyAxKSAoIWogLSBpIC0gMSkgOjogIXI7XG4gICAgICBqIDo9IGlcbiAgICBlbmRcbiAgZG9uZTtcbiAgc3ViIHMgMCAhaiA6OiAhclxuXG4oKiBEZXByZWNhdGVkIGZ1bmN0aW9ucyBpbXBsZW1lbnRlZCB2aWEgb3RoZXIgZGVwcmVjYXRlZCBmdW5jdGlvbnMgKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmxldCB1cHBlcmNhc2UgcyA9XG4gIEIudXBwZXJjYXNlIChib3MgcykgfD4gYnRzXG5sZXQgbG93ZXJjYXNlIHMgPVxuICBCLmxvd2VyY2FzZSAoYm9zIHMpIHw+IGJ0c1xubGV0IGNhcGl0YWxpemUgcyA9XG4gIEIuY2FwaXRhbGl6ZSAoYm9zIHMpIHw+IGJ0c1xubGV0IHVuY2FwaXRhbGl6ZSBzID1cbiAgQi51bmNhcGl0YWxpemUgKGJvcyBzKSB8PiBidHNcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogc3RyaW5nIC0+IHN0cmluZyAtPiBib29sID0gXCJjYW1sX3N0cmluZ19lcXVhbFwiIFtAQG5vYWxsb2NdXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9IGJvcyBzIHw+IEIudG9fc2VxXG5cbmxldCB0b19zZXFpIHMgPSBib3MgcyB8PiBCLnRvX3NlcWlcblxubGV0IG9mX3NlcSBnID0gQi5vZl9zZXEgZyB8PiBidHNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gdW5pdCA9ICgpXG5cbmxldCBlcXVhbCAoKSAoKSA9IHRydWVcbmxldCBjb21wYXJlICgpICgpID0gMFxubGV0IHRvX3N0cmluZyAoKSA9IFwiKClcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGV4dGVybl9mbGFncyA9XG4gICAgTm9fc2hhcmluZ1xuICB8IENsb3N1cmVzXG4gIHwgQ29tcGF0XzMyXG4oKiBub3RlOiB0aGlzIHR5cGUgZGVmaW5pdGlvbiBpcyB1c2VkIGluICdydW50aW1lL2RlYnVnZ2VyLmMnICopXG5cbmV4dGVybmFsIHRvX2NoYW5uZWw6IG91dF9jaGFubmVsIC0+ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVcIlxuZXh0ZXJuYWwgdG9fYnl0ZXM6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IGJ5dGVzXG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzXCJcbmV4dGVybmFsIHRvX3N0cmluZzogJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gc3RyaW5nXG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZ1wiXG5leHRlcm5hbCB0b19idWZmZXJfdW5zYWZlOlxuICAgICAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBpbnRcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXCJcblxubGV0IHRvX2J1ZmZlciBidWZmIG9mcyBsZW4gdiBmbGFncyA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC50b19idWZmZXI6IHN1YnN0cmluZyBvdXQgb2YgYm91bmRzXCJcbiAgZWxzZSB0b19idWZmZXJfdW5zYWZlIGJ1ZmYgb2ZzIGxlbiB2IGZsYWdzXG5cbigqIFRoZSBmdW5jdGlvbnMgYmVsb3cgdXNlIGJ5dGUgc2VxdWVuY2VzIGFzIGlucHV0LCBuZXZlciB1c2luZyBhbnlcbiAgIG11dGF0aW9uLiBJdCBtYWtlcyBzZW5zZSB0byB1c2Ugbm9uLW11dGF0ZWQgW2J5dGVzXSByYXRoZXIgdGhhblxuICAgW3N0cmluZ10sIGJlY2F1c2Ugd2UgcmVhbGx5IHdvcmsgd2l0aCBzZXF1ZW5jZXMgb2YgYnl0ZXMsIG5vdFxuICAgYSB0ZXh0IHJlcHJlc2VudGF0aW9uLlxuKilcblxuZXh0ZXJuYWwgZnJvbV9jaGFubmVsOiBpbl9jaGFubmVsIC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlXCJcbmV4dGVybmFsIGZyb21fYnl0ZXNfdW5zYWZlOiBieXRlcyAtPiBpbnQgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlc1wiXG5leHRlcm5hbCBkYXRhX3NpemVfdW5zYWZlOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX21hcnNoYWxfZGF0YV9zaXplXCJcblxubGV0IGhlYWRlcl9zaXplID0gMjBcbmxldCBkYXRhX3NpemUgYnVmZiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gaGVhZGVyX3NpemVcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZGF0YV9zaXplXCJcbiAgZWxzZSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzXG5sZXQgdG90YWxfc2l6ZSBidWZmIG9mcyA9IGhlYWRlcl9zaXplICsgZGF0YV9zaXplIGJ1ZmYgb2ZzXG5cbmxldCBmcm9tX2J5dGVzIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmZyb21fYnl0ZXNcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IGxlbiA9IGRhdGFfc2l6ZV91bnNhZmUgYnVmZiBvZnMgaW5cbiAgICBpZiBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIChoZWFkZXJfc2l6ZSArIGxlbilcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgICBlbHNlIGZyb21fYnl0ZXNfdW5zYWZlIGJ1ZmYgb2ZzXG4gIGVuZFxuXG5sZXQgZnJvbV9zdHJpbmcgYnVmZiBvZnMgPVxuICAoKiBCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIGlzIHNhZmUgaGVyZSwgYXMgdGhlIHByb2R1Y2VkIGJ5dGVcbiAgICAgc2VxdWVuY2UgaXMgbmV2ZXIgbXV0YXRlZCAqKVxuICBmcm9tX2J5dGVzIChCeXRlcy51bnNhZmVfb2Zfc3RyaW5nIGJ1ZmYpIG9mc1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBPcGVyYXRpb25zIG9uIGludGVybmFsIHJlcHJlc2VudGF0aW9ucyBvZiB2YWx1ZXMgKilcblxudHlwZSB0XG5cbnR5cGUgcmF3X2RhdGEgPSBuYXRpdmVpbnRcblxuZXh0ZXJuYWwgcmVwciA6ICdhIC0+IHQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBvYmogOiB0IC0+ICdhID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgbWFnaWMgOiAnYSAtPiAnYiA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGlzX2ludCA6IHQgLT4gYm9vbCA9IFwiJW9ial9pc19pbnRcIlxubGV0IFtAaW5saW5lIGFsd2F5c10gaXNfYmxvY2sgYSA9IG5vdCAoaXNfaW50IGEpXG5leHRlcm5hbCB0YWcgOiB0IC0+IGludCA9IFwiY2FtbF9vYmpfdGFnXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHNldF90YWcgOiB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial9zZXRfdGFnXCJcbmV4dGVybmFsIHNpemUgOiB0IC0+IGludCA9IFwiJW9ial9zaXplXCJcbmV4dGVybmFsIHJlYWNoYWJsZV93b3JkcyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial9yZWFjaGFibGVfd29yZHNcIlxuZXh0ZXJuYWwgZmllbGQgOiB0IC0+IGludCAtPiB0ID0gXCIlb2JqX2ZpZWxkXCJcbmV4dGVybmFsIHNldF9maWVsZCA6IHQgLT4gaW50IC0+IHQgLT4gdW5pdCA9IFwiJW9ial9zZXRfZmllbGRcIlxuZXh0ZXJuYWwgZmxvYXRhcnJheV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdGFycmF5X2dldFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X3NldCA6XG4gICAgZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiY2FtbF9mbG9hdGFycmF5X3NldFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBkb3VibGVfZmllbGQgeCBpID0gZmxvYXRhcnJheV9nZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaVxubGV0IFtAaW5saW5lIGFsd2F5c10gc2V0X2RvdWJsZV9maWVsZCB4IGkgdiA9XG4gIGZsb2F0YXJyYXlfc2V0IChvYmogeCA6IGZsb2F0YXJyYXkpIGkgdlxuZXh0ZXJuYWwgcmF3X2ZpZWxkIDogdCAtPiBpbnQgLT4gcmF3X2RhdGEgPSBcImNhbWxfb2JqX3Jhd19maWVsZFwiXG5leHRlcm5hbCBzZXRfcmF3X2ZpZWxkIDogdCAtPiBpbnQgLT4gcmF3X2RhdGEgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfb2JqX3NldF9yYXdfZmllbGRcIlxuXG5leHRlcm5hbCBuZXdfYmxvY2sgOiBpbnQgLT4gaW50IC0+IHQgPSBcImNhbWxfb2JqX2Jsb2NrXCJcbmV4dGVybmFsIGR1cCA6IHQgLT4gdCA9IFwiY2FtbF9vYmpfZHVwXCJcbmV4dGVybmFsIHRydW5jYXRlIDogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfdHJ1bmNhdGVcIlxuZXh0ZXJuYWwgYWRkX29mZnNldCA6IHQgLT4gSW50MzIudCAtPiB0ID0gXCJjYW1sX29ial9hZGRfb2Zmc2V0XCJcbmV4dGVybmFsIHdpdGhfdGFnIDogaW50IC0+IHQgLT4gdCA9IFwiY2FtbF9vYmpfd2l0aF90YWdcIlxuXG5sZXQgbWFyc2hhbCAob2JqIDogdCkgPVxuICBNYXJzaGFsLnRvX2J5dGVzIG9iaiBbXVxubGV0IHVubWFyc2hhbCBzdHIgcG9zID1cbiAgKE1hcnNoYWwuZnJvbV9ieXRlcyBzdHIgcG9zLCBwb3MgKyBNYXJzaGFsLnRvdGFsX3NpemUgc3RyIHBvcylcblxubGV0IGZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWcgPSAwXG5sZXQgbGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMjQ1XG5cbmxldCBsYXp5X3RhZyA9IDI0NlxubGV0IGNsb3N1cmVfdGFnID0gMjQ3XG5sZXQgb2JqZWN0X3RhZyA9IDI0OFxubGV0IGluZml4X3RhZyA9IDI0OVxubGV0IGZvcndhcmRfdGFnID0gMjUwXG5cbmxldCBub19zY2FuX3RhZyA9IDI1MVxuXG5sZXQgYWJzdHJhY3RfdGFnID0gMjUxXG5sZXQgc3RyaW5nX3RhZyA9IDI1MlxubGV0IGRvdWJsZV90YWcgPSAyNTNcbmxldCBkb3VibGVfYXJyYXlfdGFnID0gMjU0XG5sZXQgY3VzdG9tX3RhZyA9IDI1NVxubGV0IGZpbmFsX3RhZyA9IGN1c3RvbV90YWdcblxuXG5sZXQgaW50X3RhZyA9IDEwMDBcbmxldCBvdXRfb2ZfaGVhcF90YWcgPSAxMDAxXG5sZXQgdW5hbGlnbmVkX3RhZyA9IDEwMDJcblxubW9kdWxlIENsb3N1cmUgPSBzdHJ1Y3RcbiAgdHlwZSBpbmZvID0ge1xuICAgIGFyaXR5OiBpbnQ7XG4gICAgc3RhcnRfZW52OiBpbnQ7XG4gIH1cblxuICBsZXQgaW5mb19vZl9yYXcgKGluZm8gOiBuYXRpdmVpbnQpID1cbiAgICBsZXQgb3BlbiBOYXRpdmVpbnQgaW5cbiAgICBsZXQgYXJpdHkgPVxuICAgICAgKCogc2lnbmVkOiBuZWdhdGl2ZSBmb3IgdHVwbGVkIGZ1bmN0aW9ucyAqKVxuICAgICAgaWYgU3lzLndvcmRfc2l6ZSA9IDY0IHRoZW5cbiAgICAgICAgdG9faW50IChzaGlmdF9yaWdodCBpbmZvIDU2KVxuICAgICAgZWxzZVxuICAgICAgICB0b19pbnQgKHNoaWZ0X3JpZ2h0IGluZm8gMjQpXG4gICAgaW5cbiAgICBsZXQgc3RhcnRfZW52ID1cbiAgICAgICgqIHN0YXJ0X2VudiBpcyB1bnNpZ25lZCwgYnV0IHdlIGtub3cgaXQgY2FuIGFsd2F5cyBmaXQgYW4gT0NhbWxcbiAgICAgICAgIGludGVnZXIgc28gd2UgdXNlIFt0b19pbnRdIGluc3RlYWQgb2YgW3Vuc2lnbmVkX3RvX2ludF0uICopXG4gICAgICB0b19pbnQgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgKHNoaWZ0X2xlZnQgaW5mbyA4KSA5KSBpblxuICAgIHsgYXJpdHk7IHN0YXJ0X2VudiB9XG5cbiAgKCogbm90ZTogd2UgZXhwZWN0IGEgY2xvc3VyZSwgbm90IGFuIGluZml4IHBvaW50ZXIgKilcbiAgbGV0IGluZm8gKG9iaiA6IHQpID1cbiAgICBhc3NlcnQgKHRhZyBvYmogPSBjbG9zdXJlX3RhZyk7XG4gICAgaW5mb19vZl9yYXcgKHJhd19maWVsZCBvYmogMSlcbmVuZFxuXG5tb2R1bGUgRXh0ZW5zaW9uX2NvbnN0cnVjdG9yID1cbnN0cnVjdFxuICB0eXBlIHQgPSBleHRlbnNpb25fY29uc3RydWN0b3JcbiAgbGV0IG9mX3ZhbCB4ID1cbiAgICBsZXQgeCA9IHJlcHIgeCBpblxuICAgIGxldCBzbG90ID1cbiAgICAgIGlmIChpc19ibG9jayB4KSAmJiAodGFnIHgpIDw+IG9iamVjdF90YWcgJiYgKHNpemUgeCkgPj0gMSB0aGVuIGZpZWxkIHggMFxuICAgICAgZWxzZSB4XG4gICAgaW5cbiAgICBsZXQgbmFtZSA9XG4gICAgICBpZiAoaXNfYmxvY2sgc2xvdCkgJiYgKHRhZyBzbG90KSA9IG9iamVjdF90YWcgdGhlbiBmaWVsZCBzbG90IDBcbiAgICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcbiAgICBpblxuICAgICAgaWYgKHRhZyBuYW1lKSA9IHN0cmluZ190YWcgdGhlbiAob2JqIHNsb3QgOiB0KVxuICAgICAgZWxzZSBpbnZhbGlkX2FyZyBcIk9iai5leHRlbnNpb25fY29uc3RydWN0b3JcIlxuXG4gIGxldCBbQGlubGluZSBhbHdheXNdIG5hbWUgKHNsb3QgOiB0KSA9XG4gICAgKG9iaiAoZmllbGQgKHJlcHIgc2xvdCkgMCkgOiBzdHJpbmcpXG5cbiAgbGV0IFtAaW5saW5lIGFsd2F5c10gaWQgKHNsb3QgOiB0KSA9XG4gICAgKG9iaiAoZmllbGQgKHJlcHIgc2xvdCkgMSkgOiBpbnQpXG5lbmRcblxubGV0IGV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9IEV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWxcbmxldCBleHRlbnNpb25fbmFtZSA9IEV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5uYW1lXG5sZXQgZXh0ZW5zaW9uX2lkID0gRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkXG5cbm1vZHVsZSBFcGhlbWVyb24gPSBzdHJ1Y3RcbiAgdHlwZSBvYmpfdCA9IHRcblxuICB0eXBlIHQgKCoqIGVwaGVtZXJvbiAqKVxuXG4gICAoKiogVG8gY2hhbmdlIGluIHN5bmMgd2l0aCB3ZWFrLmggKilcbiAgbGV0IGFkZGl0aW9uYWxfdmFsdWVzID0gMlxuICBsZXQgbWF4X2VwaGVfbGVuZ3RoID0gU3lzLm1heF9hcnJheV9sZW5ndGggLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiB0ID0gXCJjYW1sX2VwaGVfY3JlYXRlXCI7O1xuICBsZXQgY3JlYXRlIGwgPVxuICAgIGlmIG5vdCAoMCA8PSBsICYmIGwgPD0gbWF4X2VwaGVfbGVuZ3RoKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIk9iai5FcGhlbWVyb24uY3JlYXRlXCI7XG4gICAgY3JlYXRlIGxcblxuICBsZXQgbGVuZ3RoIHggPSBzaXplKHJlcHIgeCkgLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG4gIGxldCByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gbXNnID1cbiAgICBpZiBub3QgKDAgPD0gbyAmJiBvIDwgbGVuZ3RoIGUpIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIG1zZ1xuXG4gIGV4dGVybmFsIGdldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9rZXlcIlxuICBsZXQgZ2V0X2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uZ2V0X2tleVwiO1xuICAgIGdldF9rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgZ2V0X2tleV9jb3B5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5X2NvcHlcIlxuICBsZXQgZ2V0X2tleV9jb3B5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5nZXRfa2V5X2NvcHlcIjtcbiAgICBnZXRfa2V5X2NvcHkgZSBvXG5cbiAgZXh0ZXJuYWwgc2V0X2tleTogdCAtPiBpbnQgLT4gb2JqX3QgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9rZXlcIlxuICBsZXQgc2V0X2tleSBlIG8geCA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5zZXRfa2V5XCI7XG4gICAgc2V0X2tleSBlIG8geFxuXG4gIGV4dGVybmFsIHVuc2V0X2tleTogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2tleVwiXG4gIGxldCB1bnNldF9rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLnVuc2V0X2tleVwiO1xuICAgIHVuc2V0X2tleSBlIG9cblxuICBleHRlcm5hbCBjaGVja19rZXk6IHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfZXBoZV9jaGVja19rZXlcIlxuICBsZXQgY2hlY2tfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi5jaGVja19rZXlcIjtcbiAgICBjaGVja19rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgYmxpdF9rZXkgOiB0IC0+IGludCAtPiB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgID0gXCJjYW1sX2VwaGVfYmxpdF9rZXlcIlxuXG4gIGxldCBibGl0X2tleSBlMSBvMSBlMiBvMiBsID1cbiAgICBpZiBsIDwgMCB8fCBvMSA8IDAgfHwgbzEgPiBsZW5ndGggZTEgLSBsXG4gICAgICAgfHwgbzIgPCAwIHx8IG8yID4gbGVuZ3RoIGUyIC0gbFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJPYmouRXBoZW1lcm9uLmJsaXRfa2V5XCJcbiAgICBlbHNlIGlmIGwgPD4gMCB0aGVuIGJsaXRfa2V5IGUxIG8xIGUyIG8yIGxcblxuICBleHRlcm5hbCBnZXRfZGF0YTogdCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfZGF0YVwiXG4gIGV4dGVybmFsIGdldF9kYXRhX2NvcHk6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVwiXG4gIGV4dGVybmFsIHNldF9kYXRhOiB0IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfZGF0YVwiXG4gIGV4dGVybmFsIHVuc2V0X2RhdGE6IHQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2RhdGFcIlxuICBleHRlcm5hbCBjaGVja19kYXRhOiB0IC0+IGJvb2wgPSBcImNhbWxfZXBoZV9jaGVja19kYXRhXCJcbiAgZXh0ZXJuYWwgYmxpdF9kYXRhIDogdCAtPiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9ibGl0X2RhdGFcIlxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIGFycmF5cy4gKilcbnR5cGUgJ2EgdCA9ICdhIGFycmF5XG5cbigqIEFycmF5IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogJ2EgYXJyYXkgLT4gaW50ID0gXCIlYXJyYXlfbGVuZ3RoXCJcbmV4dGVybmFsIGdldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfc2FmZV9nZXRcIlxuZXh0ZXJuYWwgc2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3NhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9nZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSA9IFwiJWFycmF5X3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVhcnJheV91bnNhZmVfc2V0XCJcbmV4dGVybmFsIG1ha2U6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuZXh0ZXJuYWwgY3JlYXRlOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbmV4dGVybmFsIHVuc2FmZV9zdWIgOiAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X3N1YlwiXG5leHRlcm5hbCBhcHBlbmRfcHJpbSA6ICdhIGFycmF5IC0+ICdhIGFycmF5IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X2FwcGVuZFwiXG5leHRlcm5hbCBjb25jYXQgOiAnYSBhcnJheSBsaXN0IC0+ICdhIGFycmF5ID0gXCJjYW1sX2FycmF5X2NvbmNhdFwiXG5leHRlcm5hbCB1bnNhZmVfYmxpdCA6XG4gICdhIGFycmF5IC0+IGludCAtPiAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfYXJyYXlfYmxpdFwiXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6XG4gICdhIGFycmF5IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9hcnJheV9maWxsXCJcbmV4dGVybmFsIGNyZWF0ZV9mbG9hdDogaW50IC0+IGZsb2F0IGFycmF5ID0gXCJjYW1sX21ha2VfZmxvYXRfdmVjdFwiXG5sZXQgbWFrZV9mbG9hdCA9IGNyZWF0ZV9mbG9hdFxuXG5tb2R1bGUgRmxvYXRhcnJheSA9IHN0cnVjdFxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gZmxvYXRhcnJheSA9IFwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZVwiXG4gIGV4dGVybmFsIGxlbmd0aCA6IGZsb2F0YXJyYXkgLT4gaW50ID0gXCIlZmxvYXRhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBnZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV9zYWZlX3NldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0XG4gICAgICA9IFwiJWZsb2F0YXJyYXlfdW5zYWZlX3NldFwiXG5lbmRcblxubGV0IGluaXQgbCBmID1cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2VcbiAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmluaXRcIlxuICAoKiBTZWUgIzY1NzUuIFdlIGNvdWxkIGFsc28gY2hlY2sgZm9yIG1heGltdW0gYXJyYXkgc2l6ZSwgYnV0IHRoaXMgZGVwZW5kc1xuICAgICBvbiB3aGV0aGVyIHdlIGNyZWF0ZSBhIGZsb2F0IGFycmF5IG9yIGEgcmVndWxhciBvbmUuLi4gKilcbiAgZWxzZVxuICAgbGV0IHJlcyA9IGNyZWF0ZSBsIChmIDApIGluXG4gICBmb3IgaSA9IDEgdG8gcHJlZCBsIGRvXG4gICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgIGRvbmU7XG4gICByZXNcblxubGV0IG1ha2VfbWF0cml4IHN4IHN5IGluaXQgPVxuICBsZXQgcmVzID0gY3JlYXRlIHN4IFt8fF0gaW5cbiAgZm9yIHggPSAwIHRvIHByZWQgc3ggZG9cbiAgICB1bnNhZmVfc2V0IHJlcyB4IChjcmVhdGUgc3kgaW5pdClcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBjcmVhdGVfbWF0cml4ID0gbWFrZV9tYXRyaXhcblxubGV0IGNvcHkgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW4gaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgdW5zYWZlX3N1YiBhIDAgbFxuXG5sZXQgYXBwZW5kIGExIGEyID1cbiAgbGV0IGwxID0gbGVuZ3RoIGExIGluXG4gIGlmIGwxID0gMCB0aGVuIGNvcHkgYTJcbiAgZWxzZSBpZiBsZW5ndGggYTIgPSAwIHRoZW4gdW5zYWZlX3N1YiBhMSAwIGwxXG4gIGVsc2UgYXBwZW5kX3ByaW0gYTEgYTJcblxubGV0IHN1YiBhIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LnN1YlwiXG4gIGVsc2UgdW5zYWZlX3N1YiBhIG9mcyBsZW5cblxubGV0IGZpbGwgYSBvZnMgbGVuIHYgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGEgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZpbGxcIlxuICBlbHNlIHVuc2FmZV9maWxsIGEgb2ZzIGxlbiB2XG5cbmxldCBibGl0IGExIG9mczEgYTIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggYTEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIGEyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuXG5cbmxldCBpdGVyIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZih1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgaXRlcjIgZiBhIGIgPVxuICBpZiBsZW5ndGggYSA8PiBsZW5ndGggYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlXG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSBkb25lXG5cbmxldCBtYXAgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcDIgZiBhIGIgPVxuICBsZXQgbGEgPSBsZW5ndGggYSBpblxuICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICBpZiBsYSA8PiBsYiB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2UgYmVnaW5cbiAgICBpZiBsYSA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIChmICh1bnNhZmVfZ2V0IGEgMCkgKHVuc2FmZV9nZXQgYiAwKSkgaW5cbiAgICAgIGZvciBpID0gMSB0byBsYSAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpKVxuICAgICAgZG9uZTtcbiAgICAgIHJcbiAgICBlbmRcbiAgZW5kXG5cbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IG1hcGkgZiBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgKGYgMCAodW5zYWZlX2dldCBhIDApKSBpblxuICAgIGZvciBpID0gMSB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBhIGkpKVxuICAgIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHRvX2xpc3QgYSA9XG4gIGxldCByZWMgdG9saXN0IGkgcmVzID1cbiAgICBpZiBpIDwgMCB0aGVuIHJlcyBlbHNlIHRvbGlzdCAoaSAtIDEpICh1bnNhZmVfZ2V0IGEgaSA6OiByZXMpIGluXG4gIHRvbGlzdCAobGVuZ3RoIGEgLSAxKSBbXVxuXG4oKiBDYW5ub3QgdXNlIExpc3QubGVuZ3RoIGhlcmUgYmVjYXVzZSB0aGUgTGlzdCBtb2R1bGUgZGVwZW5kcyBvbiBBcnJheS4gKilcbmxldCByZWMgbGlzdF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gYWNjdVxuICB8IF86OnQgLT4gbGlzdF9sZW5ndGggKHN1Y2MgYWNjdSkgdFxuXG5sZXQgb2ZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgYSA9IGNyZWF0ZSAobGlzdF9sZW5ndGggMCBsKSBoZCBpblxuICAgICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICAgIFtdIC0+IGFcbiAgICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGkrMSkgdGwgaW5cbiAgICAgIGZpbGwgMSB0bFxuXG5sZXQgZm9sZF9sZWZ0IGYgeCBhID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IGEgaSlcbiAgZG9uZTtcbiAgIXJcblxubGV0IGZvbGRfcmlnaHQgZiBhIHggPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgciA6PSBmICh1bnNhZmVfZ2V0IGEgaSkgIXJcbiAgZG9uZTtcbiAgIXJcblxubGV0IGV4aXN0cyBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbCBwIGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgZm9yX2FsbDIgcCBsMSBsMiA9XG4gIGxldCBuMSA9IGxlbmd0aCBsMVxuICBhbmQgbjIgPSBsZW5ndGggbDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmZvcl9hbGwyXCJcbiAgZWxzZSBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4xIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBsMSBpKSAodW5zYWZlX2dldCBsMiBpKSB0aGVuIGxvb3AgKHN1Y2MgaSlcbiAgICBlbHNlIGZhbHNlIGluXG4gIGxvb3AgMFxuXG5sZXQgZXhpc3RzMiBwIGwxIGwyID1cbiAgbGV0IG4xID0gbGVuZ3RoIGwxXG4gIGFuZCBuMiA9IGxlbmd0aCBsMiBpblxuICBpZiBuMSA8PiBuMiB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZXhpc3RzMlwiXG4gIGVsc2UgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuMSB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGwxIGkpICh1bnNhZmVfZ2V0IGwyIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IG1lbSB4IGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGEgaSkgeCA9IDAgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5sZXQgbWVtcSB4IGEgPVxuICBsZXQgbiA9IGxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiB4ID09ICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiB0cnVlXG4gICAgZWxzZSBsb29wIChzdWNjIGkpIGluXG4gIGxvb3AgMFxuXG5leGNlcHRpb24gQm90dG9tIG9mIGludFxubGV0IHNvcnQgY21wIGEgPVxuICBsZXQgbWF4c29uIGwgaSA9XG4gICAgbGV0IGkzMSA9IGkraStpKzEgaW5cbiAgICBsZXQgeCA9IHJlZiBpMzEgaW5cbiAgICBpZiBpMzErMiA8IGwgdGhlbiBiZWdpblxuICAgICAgaWYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDAgdGhlbiB4IDo9IGkzMSsxO1xuICAgICAgaWYgY21wIChnZXQgYSAheCkgKGdldCBhIChpMzErMikpIDwgMCB0aGVuIHggOj0gaTMxKzI7XG4gICAgICAheFxuICAgIGVuZCBlbHNlXG4gICAgICBpZiBpMzErMSA8IGwgJiYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDBcbiAgICAgIHRoZW4gaTMxKzFcbiAgICAgIGVsc2UgaWYgaTMxIDwgbCB0aGVuIGkzMSBlbHNlIHJhaXNlIChCb3R0b20gaSlcbiAgaW5cbiAgbGV0IHJlYyB0cmlja2xlZG93biBsIGkgZSA9XG4gICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgaWYgY21wIChnZXQgYSBqKSBlID4gMCB0aGVuIGJlZ2luXG4gICAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICAgIHRyaWNrbGVkb3duIGwgaiBlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBzZXQgYSBpIGU7XG4gICAgZW5kO1xuICBpblxuICBsZXQgdHJpY2tsZSBsIGkgZSA9IHRyeSB0cmlja2xlZG93biBsIGkgZSB3aXRoIEJvdHRvbSBpIC0+IHNldCBhIGkgZSBpblxuICBsZXQgcmVjIGJ1YmJsZWRvd24gbCBpID1cbiAgICBsZXQgaiA9IG1heHNvbiBsIGkgaW5cbiAgICBzZXQgYSBpIChnZXQgYSBqKTtcbiAgICBidWJibGVkb3duIGwgalxuICBpblxuICBsZXQgYnViYmxlIGwgaSA9IHRyeSBidWJibGVkb3duIGwgaSB3aXRoIEJvdHRvbSBpIC0+IGkgaW5cbiAgbGV0IHJlYyB0cmlja2xldXAgaSBlID1cbiAgICBsZXQgZmF0aGVyID0gKGkgLSAxKSAvIDMgaW5cbiAgICBhc3NlcnQgKGkgPD4gZmF0aGVyKTtcbiAgICBpZiBjbXAgKGdldCBhIGZhdGhlcikgZSA8IDAgdGhlbiBiZWdpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgZmF0aGVyKTtcbiAgICAgIGlmIGZhdGhlciA+IDAgdGhlbiB0cmlja2xldXAgZmF0aGVyIGUgZWxzZSBzZXQgYSAwIGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHNldCBhIGkgZTtcbiAgICBlbmQ7XG4gIGluXG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgZm9yIGkgPSAobCArIDEpIC8gMyAtIDEgZG93bnRvIDAgZG8gdHJpY2tsZSBsIGkgKGdldCBhIGkpOyBkb25lO1xuICBmb3IgaSA9IGwgLSAxIGRvd250byAyIGRvXG4gICAgbGV0IGUgPSAoZ2V0IGEgaSkgaW5cbiAgICBzZXQgYSBpIChnZXQgYSAwKTtcbiAgICB0cmlja2xldXAgKGJ1YmJsZSBpIDApIGU7XG4gIGRvbmU7XG4gIGlmIGwgPiAxIHRoZW4gKGxldCBlID0gKGdldCBhIDEpIGluIHNldCBhIDEgKGdldCBhIDApOyBzZXQgYSAwIGUpXG5cblxubGV0IGN1dG9mZiA9IDVcbmxldCBzdGFibGVfc29ydCBjbXAgYSA9XG4gIGxldCBtZXJnZSBzcmMxb2ZzIHNyYzFsZW4gc3JjMiBzcmMyb2ZzIHNyYzJsZW4gZHN0IGRzdG9mcyA9XG4gICAgbGV0IHNyYzFyID0gc3JjMW9mcyArIHNyYzFsZW4gYW5kIHNyYzJyID0gc3JjMm9mcyArIHNyYzJsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgaTEgczEgaTIgczIgZCA9XG4gICAgICBpZiBjbXAgczEgczIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgIHNldCBkc3QgZCBzMTtcbiAgICAgICAgbGV0IGkxID0gaTEgKyAxIGluXG4gICAgICAgIGlmIGkxIDwgc3JjMXIgdGhlblxuICAgICAgICAgIGxvb3AgaTEgKGdldCBhIGkxKSBpMiBzMiAoZCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBibGl0IHNyYzIgaTIgZHN0IChkICsgMSkgKHNyYzJyIC0gaTIpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXQgZHN0IGQgczI7XG4gICAgICAgIGxldCBpMiA9IGkyICsgMSBpblxuICAgICAgICBpZiBpMiA8IHNyYzJyIHRoZW5cbiAgICAgICAgICBsb29wIGkxIHMxIGkyIChnZXQgc3JjMiBpMikgKGQgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmxpdCBhIGkxIGRzdCAoZCArIDEpIChzcmMxciAtIGkxKVxuICAgICAgZW5kXG4gICAgaW4gbG9vcCBzcmMxb2ZzIChnZXQgYSBzcmMxb2ZzKSBzcmMyb2ZzIChnZXQgc3JjMiBzcmMyb2ZzKSBkc3RvZnM7XG4gIGluXG4gIGxldCBpc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgIGxldCBlID0gKGdldCBhIChzcmNvZnMgKyBpKSkgaW5cbiAgICAgIGxldCBqID0gcmVmIChkc3RvZnMgKyBpIC0gMSkgaW5cbiAgICAgIHdoaWxlICghaiA+PSBkc3RvZnMgJiYgY21wIChnZXQgZHN0ICFqKSBlID4gMCkgZG9cbiAgICAgICAgc2V0IGRzdCAoIWogKyAxKSAoZ2V0IGRzdCAhaik7XG4gICAgICAgIGRlY3IgajtcbiAgICAgIGRvbmU7XG4gICAgICBzZXQgZHN0ICghaiArIDEpIGU7XG4gICAgZG9uZTtcbiAgaW5cbiAgbGV0IHJlYyBzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuID1cbiAgICBpZiBsZW4gPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gZWxzZSBiZWdpblxuICAgICAgbGV0IGwxID0gbGVuIC8gMiBpblxuICAgICAgbGV0IGwyID0gbGVuIC0gbDEgaW5cbiAgICAgIHNvcnR0byAoc3Jjb2ZzICsgbDEpIGRzdCAoZHN0b2ZzICsgbDEpIGwyO1xuICAgICAgc29ydHRvIHNyY29mcyBhIChzcmNvZnMgKyBsMikgbDE7XG4gICAgICBtZXJnZSAoc3Jjb2ZzICsgbDIpIGwxIGRzdCAoZHN0b2ZzICsgbDEpIGwyIGRzdCBkc3RvZnM7XG4gICAgZW5kO1xuICBpblxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPD0gY3V0b2ZmIHRoZW4gaXNvcnR0byAwIGEgMCBsIGVsc2UgYmVnaW5cbiAgICBsZXQgbDEgPSBsIC8gMiBpblxuICAgIGxldCBsMiA9IGwgLSBsMSBpblxuICAgIGxldCB0ID0gbWFrZSBsMiAoZ2V0IGEgMCkgaW5cbiAgICBzb3J0dG8gbDEgdCAwIGwyO1xuICAgIHNvcnR0byAwIGEgbDIgbDE7XG4gICAgbWVyZ2UgbDIgbDEgdCAwIGwyIGEgMDtcbiAgZW5kXG5cblxubGV0IGZhc3Rfc29ydCA9IHN0YWJsZV9zb3J0XG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgYSA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPCBsZW5ndGggYVxuICAgIHRoZW5cbiAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gICAgZWxzZSBTZXEuTmlsXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIGEgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICB0aGVuXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgICBlbHNlIFNlcS5OaWxcbiAgaW5cbiAgYXV4IDBcblxubGV0IG9mX3Jldl9saXN0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbfHxdXG4gIHwgaGQ6OnRsIGFzIGwgLT5cbiAgICAgIGxldCBsZW4gPSBsaXN0X2xlbmd0aCAwIGwgaW5cbiAgICAgIGxldCBhID0gY3JlYXRlIGxlbiBoZCBpblxuICAgICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgICAgIFtdIC0+IGFcbiAgICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGktMSkgdGxcbiAgICAgIGluXG4gICAgICBmaWxsIChsZW4tMikgdGxcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IGwgPSBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBpIGluXG4gIG9mX3Jldl9saXN0IGxcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gaW50XG5cbmxldCB6ZXJvID0gMFxubGV0IG9uZSA9IDFcbmxldCBtaW51c19vbmUgPSAtMVxuZXh0ZXJuYWwgbmVnIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCBhZGQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCBzdWIgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG5leHRlcm5hbCBtdWwgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCBkaXYgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCByZW0gOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5leHRlcm5hbCBzdWNjIDogaW50IC0+IGludCA9IFwiJXN1Y2NpbnRcIlxuZXh0ZXJuYWwgcHJlZCA6IGludCAtPiBpbnQgPSBcIiVwcmVkaW50XCJcbmxldCBhYnMgeCA9IGlmIHggPj0gMCB0aGVuIHggZWxzZSAteFxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5leHRlcm5hbCBsb2dhbmQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCBsb2dvciA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlb3JpbnRcIlxuZXh0ZXJuYWwgbG9neG9yIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxubGV0IGxvZ25vdCB4ID0gbG9neG9yIHggKC0xKVxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuXG4oKlxuZXh0ZXJuYWwgaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfaW50X29mX3N0cmluZ1wiXG5sZXQgb2Zfc3RyaW5nIHMgPSB0cnkgU29tZSAoaW50X29mX3N0cmluZyBzKSB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG4qKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5sZXQgdG9fc3RyaW5nIHggPSBmb3JtYXRfaW50IFwiJWRcIiB4XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50MzJdOiAzMi1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDMyIC0+IGludCAtPiBpbnQzMiA9IFwiJWludDMyX2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50MzIgLT4gaW50ID0gXCIlaW50MzJfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50MzJcbiAgPSBcImNhbWxfaW50MzJfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDMyIC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDMyX3RvX2Zsb2F0XCIgXCJjYW1sX2ludDMyX3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50MzJfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCB6ZXJvID0gMGxcbmxldCBvbmUgPSAxbFxubGV0IG1pbnVzX29uZSA9IC0xbFxubGV0IHN1Y2MgbiA9IGFkZCBuIDFsXG5sZXQgcHJlZCBuID0gc3ViIG4gMWxcbmxldCBhYnMgbiA9IGlmIG4gPj0gMGwgdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBtaW5faW50ID0gMHg4MDAwMDAwMGxcbmxldCBtYXhfaW50ID0gMHg3RkZGRkZGRmxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMWwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBtYXRjaCBTeXMud29yZF9zaXplIHdpdGhcbiAgfCAzMiAtPlxuICAgICAgbGV0IG1heF9pbnQgPSBvZl9pbnQgU3RkbGliLm1heF9pbnQgaW5cbiAgICAgIGZ1biBuIC0+XG4gICAgICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICAgICAgU29tZSAodG9faW50IG4pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBOb25lXG4gIHwgNjQgLT5cbiAgICAgICgqIFNvIHRoYXQgaXQgY29tcGlsZXMgaW4gMzItYml0ICopXG4gICAgICBsZXQgbW92ZSA9IGludF9vZl9zdHJpbmcgXCIweDFfMDAwMF8wMDAwXCIgaW5cbiAgICAgIGZ1biBuIC0+IGxldCBpID0gdG9faW50IG4gaW4gU29tZSAoaWYgaSA8IDAgdGhlbiBpICsgbW92ZSBlbHNlIGkpXG4gIHwgXyAtPlxuICAgICAgYXNzZXJ0IGZhbHNlXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQzMiAtPiBzdHJpbmcgPSBcImNhbWxfaW50MzJfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50MzIgPSBcImNhbWxfaW50MzJfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbnR5cGUgdCA9IGludDMyXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmxldCBlcXVhbCAoeDogdCkgKHk6IHQpID0gY29tcGFyZSB4IHkgPSAwXG5cbmxldCB1bnNpZ25lZF9jb21wYXJlIG4gbSA9XG4gIGNvbXBhcmUgKHN1YiBuIG1pbl9pbnQpIChzdWIgbSBtaW5faW50KVxuXG4oKiBVbnNpZ25lZCBkaXZpc2lvbiBmcm9tIHNpZ25lZCBkaXZpc2lvbiBvZiB0aGUgc2FtZVxuICAgYml0bmVzcy4gU2VlIFdhcnJlbiBKci4sIEhlbnJ5IFMuICgyMDEzKS4gSGFja2VyJ3MgRGVsaWdodCAoMiBlZC4pLCBTZWMgOS0zLlxuKilcbmxldCB1bnNpZ25lZF9kaXYgbiBkID1cbiAgaWYgZCA8IHplcm8gdGhlblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgbiBkIDwgMCB0aGVuIHplcm8gZWxzZSBvbmVcbiAgZWxzZVxuICAgIGxldCBxID0gc2hpZnRfbGVmdCAoZGl2IChzaGlmdF9yaWdodF9sb2dpY2FsIG4gMSkgZCkgMSBpblxuICAgIGxldCByID0gc3ViIG4gKG11bCBxIGQpIGluXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSByIGQgPj0gMCB0aGVuIHN1Y2MgcSBlbHNlIHFcblxubGV0IHVuc2lnbmVkX3JlbSBuIGQgPVxuICBzdWIgbiAobXVsICh1bnNpZ25lZF9kaXYgbiBkKSBkKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGUgcGFyc2luZyBlbmdpbmUgKilcblxub3BlbiBMZXhpbmdcblxuKCogSW50ZXJuYWwgaW50ZXJmYWNlIHRvIHRoZSBwYXJzaW5nIGVuZ2luZSAqKVxuXG50eXBlIHBhcnNlcl9lbnYgPVxuICB7IG11dGFibGUgc19zdGFjayA6IGludCBhcnJheTsgICAgICAgICgqIFN0YXRlcyAqKVxuICAgIG11dGFibGUgdl9zdGFjayA6IE9iai50IGFycmF5OyAgICAgICgqIFNlbWFudGljIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgKCogU3RhcnQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzeW1iX2VuZF9zdGFjayA6IHBvc2l0aW9uIGFycmF5OyAgICgqIEVuZCBwb3NpdGlvbnMgKilcbiAgICBtdXRhYmxlIHN0YWNrc2l6ZSA6IGludDsgICAgICAgICAgICAoKiBTaXplIG9mIHRoZSBzdGFja3MgKilcbiAgICBtdXRhYmxlIHN0YWNrYmFzZSA6IGludDsgICAgICAgICAgICAoKiBCYXNlIHNwIGZvciBjdXJyZW50IHBhcnNlICopXG4gICAgbXV0YWJsZSBjdXJyX2NoYXIgOiBpbnQ7ICAgICAgICAgICAgKCogTGFzdCB0b2tlbiByZWFkICopXG4gICAgbXV0YWJsZSBsdmFsIDogT2JqLnQ7ICAgICAgICAgICAgICAgKCogSXRzIHNlbWFudGljIGF0dHJpYnV0ZSAqKVxuICAgIG11dGFibGUgc3ltYl9zdGFydCA6IHBvc2l0aW9uOyAgICAgICgqIFN0YXJ0IHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sKilcbiAgICBtdXRhYmxlIHN5bWJfZW5kIDogcG9zaXRpb247ICAgICAgICAoKiBFbmQgcG9zLiBvZiB0aGUgY3VycmVudCBzeW1ib2wgKilcbiAgICBtdXRhYmxlIGFzcCA6IGludDsgICAgICAgICAgICAgICAgICAoKiBUaGUgc3RhY2sgcG9pbnRlciBmb3IgYXR0cmlidXRlcyAqKVxuICAgIG11dGFibGUgcnVsZV9sZW4gOiBpbnQ7ICAgICAgICAgICAgICgqIE51bWJlciBvZiByaHMgaXRlbXMgaW4gdGhlIHJ1bGUgKilcbiAgICBtdXRhYmxlIHJ1bGVfbnVtYmVyIDogaW50OyAgICAgICAgICAoKiBSdWxlIG51bWJlciB0byByZWR1Y2UgYnkgKilcbiAgICBtdXRhYmxlIHNwIDogaW50OyAgICAgICAgICAgICAgICAgICAoKiBTYXZlZCBzcCBmb3IgcGFyc2VfZW5naW5lICopXG4gICAgbXV0YWJsZSBzdGF0ZSA6IGludDsgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3RhdGUgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgZXJyZmxhZyA6IGludCB9ICAgICAgICAgICAgICgqIFNhdmVkIGVycm9yIGZsYWcgZm9yIHBhcnNlX2VuZ2luZSAqKVxuXG50eXBlIHBhcnNlX3RhYmxlcyA9XG4gIHsgYWN0aW9ucyA6IChwYXJzZXJfZW52IC0+IE9iai50KSBhcnJheTtcbiAgICB0cmFuc2xfY29uc3QgOiBpbnQgYXJyYXk7XG4gICAgdHJhbnNsX2Jsb2NrIDogaW50IGFycmF5O1xuICAgIGxocyA6IHN0cmluZztcbiAgICBsZW4gOiBzdHJpbmc7XG4gICAgZGVmcmVkIDogc3RyaW5nO1xuICAgIGRnb3RvIDogc3RyaW5nO1xuICAgIHNpbmRleCA6IHN0cmluZztcbiAgICByaW5kZXggOiBzdHJpbmc7XG4gICAgZ2luZGV4IDogc3RyaW5nO1xuICAgIHRhYmxlc2l6ZSA6IGludDtcbiAgICB0YWJsZSA6IHN0cmluZztcbiAgICBjaGVjayA6IHN0cmluZztcbiAgICBlcnJvcl9mdW5jdGlvbiA6IHN0cmluZyAtPiB1bml0O1xuICAgIG5hbWVzX2NvbnN0IDogc3RyaW5nO1xuICAgIG5hbWVzX2Jsb2NrIDogc3RyaW5nIH1cblxuZXhjZXB0aW9uIFlZZXhpdCBvZiBPYmoudFxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yXG5cbnR5cGUgcGFyc2VyX2lucHV0ID1cbiAgICBTdGFydFxuICB8IFRva2VuX3JlYWRcbiAgfCBTdGFja3NfZ3Jvd25fMVxuICB8IFN0YWNrc19ncm93bl8yXG4gIHwgU2VtYW50aWNfYWN0aW9uX2NvbXB1dGVkXG4gIHwgRXJyb3JfZGV0ZWN0ZWRcblxudHlwZSBwYXJzZXJfb3V0cHV0ID1cbiAgICBSZWFkX3Rva2VuXG4gIHwgUmFpc2VfcGFyc2VfZXJyb3JcbiAgfCBHcm93X3N0YWNrc18xXG4gIHwgR3Jvd19zdGFja3NfMlxuICB8IENvbXB1dGVfc2VtYW50aWNfYWN0aW9uXG4gIHwgQ2FsbF9lcnJvcl9mdW5jdGlvblxuXG4oKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxubGV0IF8gPSBbUmVhZF90b2tlbjsgUmFpc2VfcGFyc2VfZXJyb3I7IEdyb3dfc3RhY2tzXzE7IEdyb3dfc3RhY2tzXzI7XG4gICAgICAgICBDb21wdXRlX3NlbWFudGljX2FjdGlvbjsgQ2FsbF9lcnJvcl9mdW5jdGlvbl1cblxuZXh0ZXJuYWwgcGFyc2VfZW5naW5lIDpcbiAgICBwYXJzZV90YWJsZXMgLT4gcGFyc2VyX2VudiAtPiBwYXJzZXJfaW5wdXQgLT4gT2JqLnQgLT4gcGFyc2VyX291dHB1dFxuICAgID0gXCJjYW1sX3BhcnNlX2VuZ2luZVwiXG5cbmV4dGVybmFsIHNldF90cmFjZTogYm9vbCAtPiBib29sXG4gICAgPSBcImNhbWxfc2V0X3BhcnNlcl90cmFjZVwiXG5cbmxldCBlbnYgPVxuICB7IHNfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCAwO1xuICAgIHZfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCAoT2JqLnJlcHIgKCkpO1xuICAgIHN5bWJfc3RhcnRfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCBkdW1teV9wb3M7XG4gICAgc3ltYl9lbmRfc3RhY2sgPSBBcnJheS5tYWtlIDEwMCBkdW1teV9wb3M7XG4gICAgc3RhY2tzaXplID0gMTAwO1xuICAgIHN0YWNrYmFzZSA9IDA7XG4gICAgY3Vycl9jaGFyID0gMDtcbiAgICBsdmFsID0gT2JqLnJlcHIgKCk7XG4gICAgc3ltYl9zdGFydCA9IGR1bW15X3BvcztcbiAgICBzeW1iX2VuZCA9IGR1bW15X3BvcztcbiAgICBhc3AgPSAwO1xuICAgIHJ1bGVfbGVuID0gMDtcbiAgICBydWxlX251bWJlciA9IDA7XG4gICAgc3AgPSAwO1xuICAgIHN0YXRlID0gMDtcbiAgICBlcnJmbGFnID0gMCB9XG5cbmxldCBncm93X3N0YWNrcygpID1cbiAgbGV0IG9sZHNpemUgPSBlbnYuc3RhY2tzaXplIGluXG4gIGxldCBuZXdzaXplID0gb2xkc2l6ZSAqIDIgaW5cbiAgbGV0IG5ld19zID0gQXJyYXkubWFrZSBuZXdzaXplIDBcbiAgYW5kIG5ld192ID0gQXJyYXkubWFrZSBuZXdzaXplIChPYmoucmVwciAoKSlcbiAgYW5kIG5ld19zdGFydCA9IEFycmF5Lm1ha2UgbmV3c2l6ZSBkdW1teV9wb3NcbiAgYW5kIG5ld19lbmQgPSBBcnJheS5tYWtlIG5ld3NpemUgZHVtbXlfcG9zIGluXG4gICAgQXJyYXkuYmxpdCBlbnYuc19zdGFjayAwIG5ld19zIDAgb2xkc2l6ZTtcbiAgICBlbnYuc19zdGFjayA8LSBuZXdfcztcbiAgICBBcnJheS5ibGl0IGVudi52X3N0YWNrIDAgbmV3X3YgMCBvbGRzaXplO1xuICAgIGVudi52X3N0YWNrIDwtIG5ld192O1xuICAgIEFycmF5LmJsaXQgZW52LnN5bWJfc3RhcnRfc3RhY2sgMCBuZXdfc3RhcnQgMCBvbGRzaXplO1xuICAgIGVudi5zeW1iX3N0YXJ0X3N0YWNrIDwtIG5ld19zdGFydDtcbiAgICBBcnJheS5ibGl0IGVudi5zeW1iX2VuZF9zdGFjayAwIG5ld19lbmQgMCBvbGRzaXplO1xuICAgIGVudi5zeW1iX2VuZF9zdGFjayA8LSBuZXdfZW5kO1xuICAgIGVudi5zdGFja3NpemUgPC0gbmV3c2l6ZVxuXG5sZXQgY2xlYXJfcGFyc2VyKCkgPVxuICBBcnJheS5maWxsIGVudi52X3N0YWNrIDAgZW52LnN0YWNrc2l6ZSAoT2JqLnJlcHIgKCkpO1xuICBlbnYubHZhbCA8LSBPYmoucmVwciAoKVxuXG5sZXQgY3VycmVudF9sb29rYWhlYWRfZnVuID0gcmVmIChmdW4gKF8gOiBPYmoudCkgLT4gZmFsc2UpXG5cbmxldCB5eXBhcnNlIHRhYmxlcyBzdGFydCBsZXhlciBsZXhidWYgPVxuICBsZXQgcmVjIGxvb3AgY21kIGFyZyA9XG4gICAgbWF0Y2ggcGFyc2VfZW5naW5lIHRhYmxlcyBlbnYgY21kIGFyZyB3aXRoXG4gICAgICBSZWFkX3Rva2VuIC0+XG4gICAgICAgIGxldCB0ID0gT2JqLnJlcHIobGV4ZXIgbGV4YnVmKSBpblxuICAgICAgICBlbnYuc3ltYl9zdGFydCA8LSBsZXhidWYubGV4X3N0YXJ0X3A7XG4gICAgICAgIGVudi5zeW1iX2VuZCA8LSBsZXhidWYubGV4X2N1cnJfcDtcbiAgICAgICAgbG9vcCBUb2tlbl9yZWFkIHRcbiAgICB8IFJhaXNlX3BhcnNlX2Vycm9yIC0+XG4gICAgICAgIHJhaXNlIFBhcnNlX2Vycm9yXG4gICAgfCBDb21wdXRlX3NlbWFudGljX2FjdGlvbiAtPlxuICAgICAgICBsZXQgKGFjdGlvbiwgdmFsdWUpID1cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIChTZW1hbnRpY19hY3Rpb25fY29tcHV0ZWQsIHRhYmxlcy5hY3Rpb25zLihlbnYucnVsZV9udW1iZXIpIGVudilcbiAgICAgICAgICB3aXRoIFBhcnNlX2Vycm9yIC0+XG4gICAgICAgICAgICAoRXJyb3JfZGV0ZWN0ZWQsIE9iai5yZXByICgpKSBpblxuICAgICAgICBsb29wIGFjdGlvbiB2YWx1ZVxuICAgIHwgR3Jvd19zdGFja3NfMSAtPlxuICAgICAgICBncm93X3N0YWNrcygpOyBsb29wIFN0YWNrc19ncm93bl8xIChPYmoucmVwciAoKSlcbiAgICB8IEdyb3dfc3RhY2tzXzIgLT5cbiAgICAgICAgZ3Jvd19zdGFja3MoKTsgbG9vcCBTdGFja3NfZ3Jvd25fMiAoT2JqLnJlcHIgKCkpXG4gICAgfCBDYWxsX2Vycm9yX2Z1bmN0aW9uIC0+XG4gICAgICAgIHRhYmxlcy5lcnJvcl9mdW5jdGlvbiBcInN5bnRheCBlcnJvclwiO1xuICAgICAgICBsb29wIEVycm9yX2RldGVjdGVkIChPYmoucmVwciAoKSkgaW5cbiAgbGV0IGluaXRfYXNwID0gZW52LmFzcFxuICBhbmQgaW5pdF9zcCA9IGVudi5zcFxuICBhbmQgaW5pdF9zdGFja2Jhc2UgPSBlbnYuc3RhY2tiYXNlXG4gIGFuZCBpbml0X3N0YXRlID0gZW52LnN0YXRlXG4gIGFuZCBpbml0X2N1cnJfY2hhciA9IGVudi5jdXJyX2NoYXJcbiAgYW5kIGluaXRfbHZhbCA9IGVudi5sdmFsXG4gIGFuZCBpbml0X2VycmZsYWcgPSBlbnYuZXJyZmxhZyBpblxuICBlbnYuc3RhY2tiYXNlIDwtIGVudi5zcCArIDE7XG4gIGVudi5jdXJyX2NoYXIgPC0gc3RhcnQ7XG4gIGVudi5zeW1iX2VuZCA8LSBsZXhidWYubGV4X2N1cnJfcDtcbiAgdHJ5XG4gICAgbG9vcCBTdGFydCAoT2JqLnJlcHIgKCkpXG4gIHdpdGggZXhuIC0+XG4gICAgbGV0IGN1cnJfY2hhciA9IGVudi5jdXJyX2NoYXIgaW5cbiAgICBlbnYuYXNwIDwtIGluaXRfYXNwO1xuICAgIGVudi5zcCA8LSBpbml0X3NwO1xuICAgIGVudi5zdGFja2Jhc2UgPC0gaW5pdF9zdGFja2Jhc2U7XG4gICAgZW52LnN0YXRlIDwtIGluaXRfc3RhdGU7XG4gICAgZW52LmN1cnJfY2hhciA8LSBpbml0X2N1cnJfY2hhcjtcbiAgICBlbnYubHZhbCA8LSBpbml0X2x2YWw7XG4gICAgZW52LmVycmZsYWcgPC0gaW5pdF9lcnJmbGFnO1xuICAgIG1hdGNoIGV4biB3aXRoXG4gICAgICBZWWV4aXQgdiAtPlxuICAgICAgICBPYmoubWFnaWMgdlxuICAgIHwgXyAtPlxuICAgICAgICBjdXJyZW50X2xvb2thaGVhZF9mdW4gOj1cbiAgICAgICAgICAoZnVuIHRvayAtPlxuICAgICAgICAgICAgaWYgT2JqLmlzX2Jsb2NrIHRva1xuICAgICAgICAgICAgdGhlbiB0YWJsZXMudHJhbnNsX2Jsb2NrLihPYmoudGFnIHRvaykgPSBjdXJyX2NoYXJcbiAgICAgICAgICAgIGVsc2UgdGFibGVzLnRyYW5zbF9jb25zdC4oT2JqLm1hZ2ljIHRvaykgPSBjdXJyX2NoYXIpO1xuICAgICAgICByYWlzZSBleG5cblxubGV0IHBlZWtfdmFsIGVudiBuID1cbiAgT2JqLm1hZ2ljIGVudi52X3N0YWNrLihlbnYuYXNwIC0gbilcblxubGV0IHN5bWJvbF9zdGFydF9wb3MgKCkgPVxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA8PSAwIHRoZW4gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwKVxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCBzdCA9IGVudi5zeW1iX3N0YXJ0X3N0YWNrLihlbnYuYXNwIC0gaSArIDEpIGluXG4gICAgICBsZXQgZW4gPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3AgLSBpICsgMSkgaW5cbiAgICAgIGlmIHN0IDw+IGVuIHRoZW4gc3QgZWxzZSBsb29wIChpIC0gMSlcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBlbnYucnVsZV9sZW5cblxubGV0IHN5bWJvbF9lbmRfcG9zICgpID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwKVxubGV0IHJoc19zdGFydF9wb3MgbiA9IGVudi5zeW1iX3N0YXJ0X3N0YWNrLihlbnYuYXNwIC0gKGVudi5ydWxlX2xlbiAtIG4pKVxubGV0IHJoc19lbmRfcG9zIG4gPSBlbnYuc3ltYl9lbmRfc3RhY2suKGVudi5hc3AgLSAoZW52LnJ1bGVfbGVuIC0gbikpXG5cbmxldCBzeW1ib2xfc3RhcnQgKCkgPSAoc3ltYm9sX3N0YXJ0X3BvcyAoKSkucG9zX2NudW1cbmxldCBzeW1ib2xfZW5kICgpID0gKHN5bWJvbF9lbmRfcG9zICgpKS5wb3NfY251bVxubGV0IHJoc19zdGFydCBuID0gKHJoc19zdGFydF9wb3MgbikucG9zX2NudW1cbmxldCByaHNfZW5kIG4gPSAocmhzX2VuZF9wb3MgbikucG9zX2NudW1cblxubGV0IGlzX2N1cnJlbnRfbG9va2FoZWFkIHRvayA9XG4gICghY3VycmVudF9sb29rYWhlYWRfZnVuKShPYmoucmVwciB0b2spXG5cbmxldCBwYXJzZV9lcnJvciAoXyA6IHN0cmluZykgPSAoKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBTZXRzIG92ZXIgb3JkZXJlZCB0eXBlcyAqKVxuXG5tb2R1bGUgdHlwZSBPcmRlcmVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTID1cbiAgc2lnXG4gICAgdHlwZSBlbHRcbiAgICB0eXBlIHRcbiAgICB2YWwgZW1wdHk6IHRcbiAgICB2YWwgaXNfZW1wdHk6IHQgLT4gYm9vbFxuICAgIHZhbCBtZW06IGVsdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBlbHQgLT4gdCAtPiB0XG4gICAgdmFsIHNpbmdsZXRvbjogZWx0IC0+IHRcbiAgICB2YWwgcmVtb3ZlOiBlbHQgLT4gdCAtPiB0XG4gICAgdmFsIHVuaW9uOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBpbnRlcjogdCAtPiB0IC0+IHRcbiAgICB2YWwgZGlzam9pbnQ6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGRpZmY6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIHN1YnNldDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGVsdCAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgICB2YWwgbWFwOiAoZWx0IC0+IGVsdCkgLT4gdCAtPiB0XG4gICAgdmFsIGZvbGQ6IChlbHQgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgICB2YWwgZm9yX2FsbDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZXhpc3RzOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBmaWx0ZXI6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiB0XG4gICAgdmFsIGZpbHRlcl9tYXA6IChlbHQgLT4gZWx0IG9wdGlvbikgLT4gdCAtPiB0XG4gICAgdmFsIHBhcnRpdGlvbjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHQgKiB0XG4gICAgdmFsIGNhcmRpbmFsOiB0IC0+IGludFxuICAgIHZhbCBlbGVtZW50czogdCAtPiBlbHQgbGlzdFxuICAgIHZhbCBtaW5fZWx0OiB0IC0+IGVsdFxuICAgIHZhbCBtaW5fZWx0X29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIG1heF9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1heF9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgY2hvb3NlOiB0IC0+IGVsdFxuICAgIHZhbCBjaG9vc2Vfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGVsdCAtPiB0IC0+IHQgKiBib29sICogdFxuICAgIHZhbCBmaW5kOiBlbHQgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9vcHQ6IGVsdCAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIG9mX2xpc3Q6IGVsdCBsaXN0IC0+IHRcbiAgICB2YWwgdG9fc2VxX2Zyb20gOiBlbHQgLT4gdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgdG9fc2VxIDogdCAtPiBlbHQgU2VxLnRcbiAgICB2YWwgdG9fcmV2X3NlcSA6IHQgLT4gZWx0IFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiBlbHQgU2VxLnQgLT4gdCAtPiB0XG4gICAgdmFsIG9mX3NlcSA6IGVsdCBTZXEudCAtPiB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9XG4gIHN0cnVjdFxuICAgIHR5cGUgZWx0ID0gT3JkLnRcbiAgICB0eXBlIHQgPSBFbXB0eSB8IE5vZGUgb2Yge2w6dDsgdjplbHQ7IHI6dDsgaDppbnR9XG5cbiAgICAoKiBTZXRzIGFyZSByZXByZXNlbnRlZCBieSBiYWxhbmNlZCBiaW5hcnkgdHJlZXMgKHRoZSBoZWlnaHRzIG9mIHRoZVxuICAgICAgIGNoaWxkcmVuIGRpZmZlciBieSBhdCBtb3N0IDIgKilcblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgICgqIENyZWF0ZXMgYSBuZXcgbm9kZSB3aXRoIGxlZnQgc29uIGwsIHZhbHVlIHYgYW5kIHJpZ2h0IHNvbiByLlxuICAgICAgIFdlIG11c3QgaGF2ZSBhbGwgZWxlbWVudHMgb2YgbCA8IHYgPCBhbGwgZWxlbWVudHMgb2Ygci5cbiAgICAgICBsIGFuZCByIG11c3QgYmUgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBoZWlnaHQgZm9yIGJldHRlciBzcGVlZC4gKilcblxuICAgIGxldCBjcmVhdGUgbCB2IHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUsIGJ1dCBwZXJmb3JtcyBvbmUgc3RlcCBvZiByZWJhbGFuY2luZyBpZiBuZWNlc3NhcnkuXG4gICAgICAgQXNzdW1lcyBsIGFuZCByIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAzLlxuICAgICAgIElubGluZSBleHBhbnNpb24gb2YgY3JlYXRlIGZvciBiZXR0ZXIgc3BlZWQgaW4gdGhlIG1vc3QgZnJlcXVlbnQgY2FzZVxuICAgICAgIHdoZXJlIG5vIHJlYmFsYW5jaW5nIGlzIHJlcXVpcmVkLiAqKVxuXG4gICAgbGV0IGJhbCBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgKGNyZWF0ZSBsciB2IHIpXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1scmw7IHY9bHJ2OyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbHJsKSBscnYgKGNyZWF0ZSBscnIgdiByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybCkgcnYgcnJcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPXJsbDsgdj1ybHY7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsbCkgcmx2IChjcmVhdGUgcmxyIHJ2IHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgICgqIEluc2VydGlvbiBvZiBvbmUgZWxlbWVudCAqKVxuXG4gICAgbGV0IHJlYyBhZGQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vZGV7bD1FbXB0eTsgdj14OyByPUVtcHR5OyBoPTF9XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB0IGVsc2VcbiAgICAgICAgICBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gdCBlbHNlIGJhbCBsbCB2IHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gdCBlbHNlIGJhbCBsIHYgcnJcblxuICAgIGxldCBzaW5nbGV0b24geCA9IE5vZGV7bD1FbXB0eTsgdj14OyByPUVtcHR5OyBoPTF9XG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIHYgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQgZWxlbWVudHMgaW4gdGhlIHRyZWU7IGl0XG4gICAgICAgZG9lcyBub3QgdGVzdCBmb3IgZXF1YWxpdHkgd2l0aCB0aGUgY3VycmVudCBtaW4gKG9yIG1heCkgZWxlbWVudC5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fZWxlbWVudCB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgYmFsIChhZGRfbWluX2VsZW1lbnQgeCBsKSB2IHJcblxuICAgIGxldCByZWMgYWRkX21heF9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgbCB2IChhZGRfbWF4X2VsZW1lbnQgeCByKVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZVxuICAgICAgIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCByZWMgam9pbiBsIHYgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fZWxlbWVudCB2IHJcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBhZGRfbWF4X2VsZW1lbnQgdiBsXG4gICAgICB8IChOb2Rle2w9bGw7IHY9bHY7IHI9bHI7IGg9bGh9LCBOb2Rle2w9cmw7IHY9cnY7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IChqb2luIGxyIHYgcikgZWxzZVxuICAgICAgICAgIGlmIHJoID4gbGggKyAyIHRoZW4gYmFsIChqb2luIGwgdiBybCkgcnYgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgclxuXG4gICAgKCogU21hbGxlc3QgYW5kIGdyZWF0ZXN0IGVsZW1lbnQgb2YgYSBzZXQgKilcblxuICAgIGxldCByZWMgbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHZ9IC0+IHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0IGxcblxuICAgIGxldCByZWMgbWluX2VsdF9vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gU29tZSB2XG4gICAgICB8IE5vZGV7bH0gLT4gbWluX2VsdF9vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7djsgcj1FbXB0eX0gLT4gdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHQgclxuXG4gICAgbGV0IHJlYyBtYXhfZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtyfSAtPiBtYXhfZWx0X29wdCByXG5cbiAgICAoKiBSZW1vdmUgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNldCAqKVxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyByfSAtPiByXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2VsdCBsKSB2IHJcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBBc3N1bWUgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi4gKilcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGJhbCB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiBqb2luIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBTcGxpdHRpbmcuICBzcGxpdCB4IHMgcmV0dXJucyBhIHRyaXBsZSAobCwgcHJlc2VudCwgcikgd2hlcmVcbiAgICAgICAgLSBsIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgb2YgcyB0aGF0IGFyZSA8IHhcbiAgICAgICAgLSByIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgb2YgcyB0aGF0IGFyZSA+IHhcbiAgICAgICAgLSBwcmVzZW50IGlzIGZhbHNlIGlmIHMgY29udGFpbnMgbm8gZWxlbWVudCBlcXVhbCB0byB4LFxuICAgICAgICAgIG9yIHRydWUgaWYgcyBjb250YWlucyBhbiBlbGVtZW50IGVxdWFsIHRvIHguICopXG5cbiAgICBsZXQgcmVjIHNwbGl0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIChFbXB0eSwgZmFsc2UsIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIChsLCB0cnVlLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBsciwgcHJlcywgcnIpXG5cbiAgICAoKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgc2V0IG9wZXJhdGlvbnMgKilcblxuICAgIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvbiBFbXB0eSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9IGFzIHQpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpblxuICAgICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIGJhbCBsbCB2IHJcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpblxuICAgICAgICAgICAgICBpZiByID09IHJyIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIGJhbCBsIHYgcnJcblxuICAgIGxldCByZWMgdW5pb24gczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIHQyKSAtPiB0MlxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxOyBoPWgxfSwgTm9kZXtsPWwyOyB2PXYyOyByPXIyOyBoPWgyfSkgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMiB0aGVuXG4gICAgICAgICAgICBpZiBoMiA9IDEgdGhlbiBhZGQgdjIgczEgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwyLCBfLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjEgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgaDEgPSAxIHRoZW4gYWRkIHYxIHMyIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbGV0IChsMSwgXywgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYyICh1bmlvbiByMSByMilcbiAgICAgICAgICAgIGVuZFxuXG4gICAgbGV0IHJlYyBpbnRlciBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoaW50ZXIgbDEgbDIpIChpbnRlciByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGludGVyIGwxIGwyKSB2MSAoaW50ZXIgcjEgcjIpXG5cbiAgICAoKiBTYW1lIGFzIHNwbGl0LCBidXQgY29tcHV0ZSB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZXNcbiAgICAgICBvbmx5IGlmIHRoZSBwaXZvdCBlbGVtZW50IGlzIG5vdCBpbiB0aGUgc2V0LiAgVGhlIHJpZ2h0IHN1YnRyZWVcbiAgICAgICBpcyBjb21wdXRlZCBvbiBkZW1hbmQuICopXG5cbiAgICB0eXBlIHNwbGl0X2JpcyA9XG4gICAgICB8IEZvdW5kXG4gICAgICB8IE5vdEZvdW5kIG9mIHQgKiAodW5pdCAtPiB0KVxuXG4gICAgbGV0IHJlYyBzcGxpdF9iaXMgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm90Rm91bmQgKEVtcHR5LCAoZnVuICgpIC0+IEVtcHR5KSlcbiAgICAgIHwgTm9kZXtsOyB2OyByOyBffSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBGb3VuZFxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbWF0Y2ggc3BsaXRfYmlzIHggbCB3aXRoXG4gICAgICAgICAgICB8IEZvdW5kIC0+IEZvdW5kXG4gICAgICAgICAgICB8IE5vdEZvdW5kIChsbCwgcmwpIC0+IE5vdEZvdW5kIChsbCwgKGZ1biAoKSAtPiBqb2luIChybCAoKSkgdiByKSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXRjaCBzcGxpdF9iaXMgeCByIHdpdGhcbiAgICAgICAgICAgIHwgRm91bmQgLT4gRm91bmRcbiAgICAgICAgICAgIHwgTm90Rm91bmQgKGxyLCBycikgLT4gTm90Rm91bmQgKGpvaW4gbCB2IGxyLCBycilcblxuICAgIGxldCByZWMgZGlzam9pbnQgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIHwgKF8sIEVtcHR5KSAtPiB0cnVlXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBpZiBzMSA9PSBzMiB0aGVuIGZhbHNlXG4gICAgICAgICAgZWxzZSBtYXRjaCBzcGxpdF9iaXMgdjEgdDIgd2l0aFxuICAgICAgICAgICAgICBOb3RGb3VuZChsMiwgcjIpIC0+IGRpc2pvaW50IGwxIGwyICYmIGRpc2pvaW50IHIxIChyMiAoKSlcbiAgICAgICAgICAgIHwgRm91bmQgLT4gZmFsc2VcblxuICAgIGxldCByZWMgZGlmZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChkaWZmIGwxIGwyKSB2MSAoZGlmZiByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoZGlmZiBsMSBsMikgKGRpZmYgcjEgcjIpXG5cbiAgICB0eXBlIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBlbHQgKiB0ICogZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIHIsIGUpKVxuXG4gICAgbGV0IHJlYyBjb21wYXJlX2F1eCBlMSBlMiA9XG4gICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICB8IChFbmQsIF8pICAtPiAtMVxuICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICB8IChNb3JlKHYxLCByMSwgZTEpLCBNb3JlKHYyLCByMiwgZTIpKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG5cbiAgICBsZXQgY29tcGFyZSBzMSBzMiA9XG4gICAgICBjb21wYXJlX2F1eCAoY29uc19lbnVtIHMxIEVuZCkgKGNvbnNfZW51bSBzMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgczEgczIgPVxuICAgICAgY29tcGFyZSBzMSBzMiA9IDBcblxuICAgIGxldCByZWMgc3Vic2V0IHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgRW1wdHksIF8gLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IF8sIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bD1sMTsgdj12MTsgcj1yMX0sIChOb2RlIHtsPWwyOyB2PXYyOyByPXIyfSBhcyB0MikgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IGwxIGwyICYmIHN1YnNldCByMSByMlxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPWwxOyB2PXYxOyByPUVtcHR5OyBoPTB9KSBsMiAmJiBzdWJzZXQgcjEgdDJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9RW1wdHk7IHY9djE7IHI9cjE7IGg9MH0pIHIyICYmIHN1YnNldCBsMSB0MlxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGl0ZXIgZiBsOyBmIHY7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIGZvbGQgZiBzIGFjY3UgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBmb2xkIGYgciAoZiB2IChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2IHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9KSBhcyB0IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXIgcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyIHAgciBpblxuICAgICAgICAgIGlmIHB2IHRoZW5cbiAgICAgICAgICAgIGlmIGw9PWwnICYmIHI9PXInIHRoZW4gdCBlbHNlIGpvaW4gbCcgdiByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdlxuICAgICAgICAgIHRoZW4gKGpvaW4gbHQgdiBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IHJmKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZXtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgZWxlbWVudHNfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZWxlbWVudHNfYXV4ICh2IDo6IGVsZW1lbnRzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBlbGVtZW50cyBzID1cbiAgICAgIGVsZW1lbnRzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2VsdFxuXG4gICAgbGV0IGNob29zZV9vcHQgPSBtaW5fZWx0X29wdFxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB2XG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSB2XG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHRyeV9qb2luIGwgdiByID1cbiAgICAgICgqIFtqb2luIGwgdiByXSBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiAoZWxlbWVudHMgb2YgbCA8IHYgPFxuICAgICAgICAgZWxlbWVudHMgb2Ygcik7IHVzZSBbdHJ5X2pvaW4gbCB2IHJdIHdoZW4gdGhpcyBwcm9wZXJ0eSBtYXlcbiAgICAgICAgIG5vdCBob2xkLCBidXQgeW91IGhvcGUgaXQgZG9lcyBob2xkIGluIHRoZSBjb21tb24gY2FzZSAqKVxuICAgICAgaWYgKGwgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSAobWF4X2VsdCBsKSB2IDwgMClcbiAgICAgICYmIChyID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgdiAobWluX2VsdCByKSA8IDApXG4gICAgICB0aGVuIGpvaW4gbCB2IHJcbiAgICAgIGVsc2UgdW5pb24gbCAoYWRkIHYgcilcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICgqIGVuZm9yY2UgbGVmdC10by1yaWdodCBldmFsdWF0aW9uIG9yZGVyICopXG4gICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgIGlmIGwgPT0gbCcgJiYgdiA9PSB2JyAmJiByID09IHInIHRoZW4gdFxuICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuXG4gICAgbGV0IHRyeV9jb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiB0cnlfam9pbiB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgbGV0IHJlYyBmaWx0ZXJfbWFwIGYgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICgqIGVuZm9yY2UgbGVmdC10by1yaWdodCBldmFsdWF0aW9uIG9yZGVyICopXG4gICAgICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwIGYgbCBpblxuICAgICAgICAgbGV0IHYnID0gZiB2IGluXG4gICAgICAgICBsZXQgcicgPSBmaWx0ZXJfbWFwIGYgciBpblxuICAgICAgICAgYmVnaW4gbWF0Y2ggdicgd2l0aFxuICAgICAgICAgICB8IFNvbWUgdicgLT5cbiAgICAgICAgICAgICAgaWYgbCA9PSBsJyAmJiB2ID09IHYnICYmIHIgPT0gcicgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgdHJ5X2pvaW4gbCcgdicgcidcbiAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIHRyeV9jb25jYXQgbCcgcidcbiAgICAgICAgIGVuZFxuXG4gICAgbGV0IG9mX3NvcnRlZF9saXN0IGwgPVxuICAgICAgbGV0IHJlYyBzdWIgbiBsID1cbiAgICAgICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgICAgIHwgMCwgbCAtPiBFbXB0eSwgbFxuICAgICAgICB8IDEsIHgwIDo6IGwgLT4gTm9kZSB7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfSwgbFxuICAgICAgICB8IDIsIHgwIDo6IHgxIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7IHI9RW1wdHk7IGg9Mn0sIGxcbiAgICAgICAgfCAzLCB4MCA6OiB4MSA6OiB4MiA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxO1xuICAgICAgICAgICAgICAgICByPU5vZGV7bD1FbXB0eTsgdj14Mjsgcj1FbXB0eTsgaD0xfTsgaD0yfSwgbFxuICAgICAgICB8IG4sIGwgLT5cbiAgICAgICAgICBsZXQgbmwgPSBuIC8gMiBpblxuICAgICAgICAgIGxldCBsZWZ0LCBsID0gc3ViIG5sIGwgaW5cbiAgICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgbWlkIDo6IGwgLT5cbiAgICAgICAgICAgIGxldCByaWdodCwgbCA9IHN1YiAobiAtIG5sIC0gMSkgbCBpblxuICAgICAgICAgICAgY3JlYXRlIGxlZnQgbWlkIHJpZ2h0LCBsXG4gICAgICBpblxuICAgICAgZnN0IChzdWIgKExpc3QubGVuZ3RoIGwpIGwpXG5cbiAgICBsZXQgb2ZfbGlzdCBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBlbXB0eVxuICAgICAgfCBbeDBdIC0+IHNpbmdsZXRvbiB4MFxuICAgICAgfCBbeDA7IHgxXSAtPiBhZGQgeDEgKHNpbmdsZXRvbiB4MClcbiAgICAgIHwgW3gwOyB4MTsgeDJdIC0+IGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDNdIC0+IGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDM7IHg0XSAtPiBhZGQgeDQgKGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKSlcbiAgICAgIHwgXyAtPiBvZl9zb3J0ZWRfbGlzdCAoTGlzdC5zb3J0X3VuaXEgT3JkLmNvbXBhcmUgbClcblxuICAgIGxldCBhZGRfc2VxIGkgbSA9XG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gcyB4IC0+IGFkZCB4IHMpIG0gaVxuXG4gICAgbGV0IG9mX3NlcSBpID0gYWRkX3NlcSBpIGVtcHR5XG5cbiAgICBsZXQgcmVjIHNlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKHgsIHQsIHJlc3QpIC0+IFNlcS5Db25zICh4LCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBjID0gc2VxX29mX2VudW1fIChjb25zX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgcmVjIHNub2NfZW51bSBzIGUgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBzbm9jX2VudW0gciAoTW9yZSh2LCBsLCBlKSlcblxuICAgIGxldCByZWMgcmV2X3NlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKHgsIHQsIHJlc3QpIC0+IFNlcS5Db25zICh4LCByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gdCByZXN0KSlcblxuICAgIGxldCB0b19yZXZfc2VxIGMgPSByZXZfc2VxX29mX2VudW1fIChzbm9jX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgdG9fc2VxX2Zyb20gbG93IHMgPVxuICAgICAgbGV0IHJlYyBhdXggbG93IHMgYyA9IG1hdGNoIHMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGNcbiAgICAgICAgfCBOb2RlIHtsOyByOyB2OyBffSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggT3JkLmNvbXBhcmUgdiBsb3cgd2l0aFxuICAgICAgICAgICAgICB8IDAgLT4gTW9yZSAodiwgciwgYylcbiAgICAgICAgICAgICAgfCBuIHdoZW4gbjwwIC0+IGF1eCBsb3cgciBjXG4gICAgICAgICAgICAgIHwgXyAtPiBhdXggbG93IGwgKE1vcmUgKHYsIHIsIGMpKVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgc2VxX29mX2VudW1fIChhdXggbG93IHMgRW5kKVxuICBlbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhKydhIHRcbiAgICB2YWwgZW1wdHk6ICdhIHRcbiAgICB2YWwgaXNfZW1wdHk6ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBtZW06ICBrZXkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGFkZDoga2V5IC0+ICdhIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCB1cGRhdGU6IGtleSAtPiAoJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHNpbmdsZXRvbjoga2V5IC0+ICdhIC0+ICdhIHRcbiAgICB2YWwgcmVtb3ZlOiBrZXkgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIG1lcmdlOlxuICAgICAgICAgIChrZXkgLT4gJ2Egb3B0aW9uIC0+ICdiIG9wdGlvbiAtPiAnYyBvcHRpb24pIC0+ICdhIHQgLT4gJ2IgdCAtPiAnYyB0XG4gICAgdmFsIHVuaW9uOiAoa2V5IC0+ICdhIC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgY29tcGFyZTogKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQ6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgZm9yX2FsbDogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgZXhpc3RzOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBmaWx0ZXI6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGZpbHRlcl9tYXA6IChrZXkgLT4gJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgcGFydGl0aW9uOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAqICdhIHRcbiAgICB2YWwgY2FyZGluYWw6ICdhIHQgLT4gaW50XG4gICAgdmFsIGJpbmRpbmdzOiAnYSB0IC0+IChrZXkgKiAnYSkgbGlzdFxuICAgIHZhbCBtaW5fYmluZGluZzogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIG1pbl9iaW5kaW5nX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBtYXhfYmluZGluZzogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIG1heF9iaW5kaW5nX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBjaG9vc2U6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBjaG9vc2Vfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIHNwbGl0OiBrZXkgLT4gJ2EgdCAtPiAnYSB0ICogJ2Egb3B0aW9uICogJ2EgdFxuICAgIHZhbCBmaW5kOiBrZXkgLT4gJ2EgdCAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDoga2V5IC0+ICdhIHQgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfZmlyc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGZpbmRfbGFzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBtYXA6ICgnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIG1hcGk6IChrZXkgLT4gJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fcmV2X3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfZnJvbSA6IGtleSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIE1ha2UoT3JkOiBPcmRlcmVkVHlwZSkgPSBzdHJ1Y3RcblxuICAgIHR5cGUga2V5ID0gT3JkLnRcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUgb2Yge2w6J2EgdDsgdjprZXk7IGQ6J2E7IHI6J2EgdDsgaDppbnR9XG5cbiAgICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtofSAtPiBoXG5cbiAgICBsZXQgY3JlYXRlIGwgeCBkIHIgPVxuICAgICAgbGV0IGhsID0gaGVpZ2h0IGwgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgc2luZ2xldG9uIHggZCA9IE5vZGV7bD1FbXB0eTsgdj14OyBkOyByPUVtcHR5OyBoPTF9XG5cbiAgICBsZXQgYmFsIGwgeCBkIHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGlmIGhsID4gaHIgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9bGw7IHY9bHY7IGQ9bGQ7IHI9bHJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIGxsIGx2IGxkIChjcmVhdGUgbHIgeCBkIHIpXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1scmw7IHY9bHJ2OyBkPWxyZDsgcj1scnJ9LT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxkIGxybCkgbHJ2IGxyZCAoY3JlYXRlIGxyciB4IGQgcilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2UgaWYgaHIgPiBobCArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmwgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybCkgcnYgcmQgcnJcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPXJsbDsgdj1ybHY7IGQ9cmxkOyByPXJscn0gLT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsbCkgcmx2IHJsZCAoY3JlYXRlIHJsciBydiByZCBycilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvbiBFbXB0eSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBhZGQgeCBkYXRhID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gYWRkIHggZGF0YSBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IGRhdGEgciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgZmluZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gZFxuICAgICAgICAgIGVsc2UgZmluZCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX29wdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFNvbWUgZFxuICAgICAgICAgIGVsc2UgZmluZF9vcHQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBjID0gMCB8fCBtZW0geCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge2x9IC0+IG1pbl9iaW5kaW5nIGxcblxuICAgIGxldCByZWMgbWluX2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfS0+IG1pbl9iaW5kaW5nX29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZyByXG5cbiAgICBsZXQgcmVjIG1heF9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmdfb3B0IHJcblxuICAgIGxldCByZWMgcmVtb3ZlX21pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyByfSAtPiByXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJhbCAocmVtb3ZlX21pbl9iaW5kaW5nIGwpIHYgZCByXG5cbiAgICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPlxuICAgICAgICAgIGxldCAoeCwgZCkgPSBtaW5fYmluZGluZyB0MiBpblxuICAgICAgICAgIGJhbCB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCByZWMgcmVtb3ZlIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IChOb2RlIHtsOyB2OyBkOyByfSBhcyBtKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBtZXJnZSBsIHJcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHJlbW92ZSB4IGwgaW4gaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIHVwZGF0ZSB4IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIGYgTm9uZSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IEVtcHR5XG4gICAgICAgICAgfCBTb21lIGRhdGEgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgICAgIGVuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgICBtYXRjaCBmIChTb21lIGQpIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBtZXJnZSBsIHJcbiAgICAgICAgICAgIHwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZW5kIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gdXBkYXRlIHggZiBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHVwZGF0ZSB4IGYgciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpdGVyIGYgbDsgZiB2IGQ7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSAtPlxuICAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgICBsZXQgZCcgPSBmIGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBtYXAgZiByIGluXG4gICAgICAgICAgTm9kZXtsPWwnOyB2OyBkPWQnOyByPXInOyBofVxuXG4gICAgbGV0IHJlYyBtYXBpIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwaSBmIGwgaW5cbiAgICAgICAgICBsZXQgZCcgPSBmIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcGkgZiByIGluXG4gICAgICAgICAgTm9kZXtsPWwnOyB2OyBkPWQnOyByPXInOyBofVxuXG4gICAgbGV0IHJlYyBmb2xkIGYgbSBhY2N1ID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgZm9sZCBmIHIgKGYgdiBkIChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBwIHYgZCAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkIHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgKCogQmV3YXJlOiB0aG9zZSB0d28gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IHRoZSBhZGRlZCBrIGlzICpzdHJpY3RseSpcbiAgICAgICBzbWFsbGVyIChvciBiaWdnZXIpIHRoYW4gYWxsIHRoZSBwcmVzZW50IGtleXMgaW4gdGhlIHRyZWU7IGl0XG4gICAgICAgZG9lcyBub3QgdGVzdCBmb3IgZXF1YWxpdHkgd2l0aCB0aGUgY3VycmVudCBtaW4gKG9yIG1heCkga2V5LlxuXG4gICAgICAgSW5kZWVkLCB0aGV5IGFyZSBvbmx5IHVzZWQgZHVyaW5nIHRoZSBcImpvaW5cIiBvcGVyYXRpb24gd2hpY2hcbiAgICAgICByZXNwZWN0cyB0aGlzIHByZWNvbmRpdGlvbi5cbiAgICAqKVxuXG4gICAgbGV0IHJlYyBhZGRfbWluX2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fYmluZGluZyBrIHggbCkgdiBkIHJcblxuICAgIGxldCByZWMgYWRkX21heF9iaW5kaW5nIGsgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiBrIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgYmFsIGwgdiBkIChhZGRfbWF4X2JpbmRpbmcgayB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiBkIHIgPVxuICAgICAgbWF0Y2ggKGwsIHIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBhZGRfbWluX2JpbmRpbmcgdiBkIHJcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBhZGRfbWF4X2JpbmRpbmcgdiBkIGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scjsgaD1saH0sXG4gICAgICAgICBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IGxkIChqb2luIGxyIHYgZCByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IGQgcmwpIHJ2IHJkIHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IGQgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPlxuICAgICAgICAgIGxldCAoeCwgZCkgPSBtaW5fYmluZGluZyB0MiBpblxuICAgICAgICAgIGpvaW4gdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgY29uY2F0X29yX2pvaW4gdDEgdiBkIHQyID1cbiAgICAgIG1hdGNoIGQgd2l0aFxuICAgICAgfCBTb21lIGQgLT4gam9pbiB0MSB2IGQgdDJcbiAgICAgIHwgTm9uZSAtPiBjb25jYXQgdDEgdDJcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBOb25lLCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIFNvbWUgZCwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiBkIHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBkIGxyLCBwcmVzLCBycilcblxuICAgIGxldCByZWMgbWVyZ2UgZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSwgXykgd2hlbiBoMSA+PSBoZWlnaHQgczIgLT5cbiAgICAgICAgICBsZXQgKGwyLCBkMiwgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICBjb25jYXRfb3Jfam9pbiAobWVyZ2UgZiBsMSBsMikgdjEgKGYgdjEgKFNvbWUgZDEpIGQyKSAobWVyZ2UgZiByMSByMilcbiAgICAgIHwgKF8sIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjJ9KSAtPlxuICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MiAoZiB2MiBkMSAoU29tZSBkMikpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCBfIC0+XG4gICAgICAgICAgYXNzZXJ0IGZhbHNlXG5cbiAgICBsZXQgcmVjIHVuaW9uIGYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgfCAoRW1wdHksIHMpIHwgKHMsIEVtcHR5KSAtPiBzXG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSxcbiAgICAgICAgIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgICAgbGV0IGwgPSB1bmlvbiBmIGwxIGwyIGFuZCByID0gdW5pb24gZiByMSByMiBpblxuICAgICAgICAgICAgbWF0Y2ggZDIgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGpvaW4gbCB2MSBkMSByXG4gICAgICAgICAgICB8IFNvbWUgZDIgLT4gY29uY2F0X29yX2pvaW4gbCB2MSAoZiB2MSBkMSBkMikgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgbGV0IGwgPSB1bmlvbiBmIGwxIGwyIGFuZCByID0gdW5pb24gZiByMSByMiBpblxuICAgICAgICAgICAgbWF0Y2ggZDEgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGpvaW4gbCB2MiBkMiByXG4gICAgICAgICAgICB8IFNvbWUgZDEgLT4gY29uY2F0X29yX2pvaW4gbCB2MiAoZiB2MiBkMSBkMikgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHZkIHRoZW4gaWYgbD09bCcgJiYgcj09cicgdGhlbiBtIGVsc2Ugam9pbiBsJyB2IGQgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuXG4gICAgbGV0IHJlYyBmaWx0ZXJfbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW2ZdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyX21hcCBmIGwgaW5cbiAgICAgICAgICBsZXQgZnZkID0gZiB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXJfbWFwIGYgciBpblxuICAgICAgICAgIGJlZ2luIG1hdGNoIGZ2ZCB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgZCcgLT4gam9pbiBsJyB2IGQnIHInXG4gICAgICAgICAgICB8IE5vbmUgLT4gY29uY2F0IGwnIHInXG4gICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZkXG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IGQgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiBkIHJmKVxuXG4gICAgdHlwZSAnYSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2Yga2V5ICogJ2EgKiAnYSB0ICogJ2EgZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIG0gZSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCBkLCByLCBlKSlcblxuICAgIGxldCBjb21wYXJlIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIGQxIGQyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBjb21wYXJlX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgZXF1YWxfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiB0cnVlXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IGZhbHNlXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gZmFsc2VcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgT3JkLmNvbXBhcmUgdjEgdjIgPSAwICYmIGNtcCBkMSBkMiAmJlxuICAgICAgICAgICAgZXF1YWxfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBlcXVhbF9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGJpbmRpbmdzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiaW5kaW5nc19hdXggKCh2LCBkKSA6OiBiaW5kaW5nc19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgYmluZGluZ3MgcyA9XG4gICAgICBiaW5kaW5nc19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9iaW5kaW5nXG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9iaW5kaW5nX29wdFxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBtIChrLHYpIC0+IGFkZCBrIHYgbSkgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoayx2LHQscmVzdCkgLT4gU2VxLkNvbnMgKChrLHYpLCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBtID1cbiAgICAgIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIG0gRW5kKVxuXG4gICAgbGV0IHJlYyBzbm9jX2VudW0gcyBlID1cbiAgICAgIG1hdGNoIHMgd2l0aFxuICAgICAgICBFbXB0eSAtPiBlXG4gICAgICB8IE5vZGV7bDsgdjsgZDsgcn0gLT4gc25vY19lbnVtIHIgKE1vcmUodiwgZCwgbCwgZSkpXG5cbiAgICBsZXQgcmVjIHJldl9zZXFfb2ZfZW51bV8gYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgICAgfCBFbmQgLT4gU2VxLk5pbFxuICAgICAgfCBNb3JlIChrLHYsdCxyZXN0KSAtPlxuICAgICAgICAgIFNlcS5Db25zICgoayx2KSwgcmV2X3NlcV9vZl9lbnVtXyAoc25vY19lbnVtIHQgcmVzdCkpXG5cbiAgICBsZXQgdG9fcmV2X3NlcSBjID1cbiAgICAgIHJldl9zZXFfb2ZfZW51bV8gKHNub2NfZW51bSBjIEVuZClcblxuICAgIGxldCB0b19zZXFfZnJvbSBsb3cgbSA9XG4gICAgICBsZXQgcmVjIGF1eCBsb3cgbSBjID0gbWF0Y2ggbSB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gY1xuICAgICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IF99IC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBPcmQuY29tcGFyZSB2IGxvdyB3aXRoXG4gICAgICAgICAgICAgIHwgMCAtPiBNb3JlICh2LCBkLCByLCBjKVxuICAgICAgICAgICAgICB8IG4gd2hlbiBuPDAgLT4gYXV4IGxvdyByIGNcbiAgICAgICAgICAgICAgfCBfIC0+IGF1eCBsb3cgbCAoTW9yZSAodiwgZCwgciwgYykpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBzZXFfb2ZfZW51bV8gKGF1eCBsb3cgbSBFbmQpXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0geyBtdXRhYmxlIGMgOiAnYSBsaXN0OyBtdXRhYmxlIGxlbiA6IGludDsgfVxuXG5leGNlcHRpb24gRW1wdHlcblxubGV0IGNyZWF0ZSAoKSA9IHsgYyA9IFtdOyBsZW4gPSAwOyB9XG5cbmxldCBjbGVhciBzID0gcy5jIDwtIFtdOyBzLmxlbiA8LSAwXG5cbmxldCBjb3B5IHMgPSB7IGMgPSBzLmM7IGxlbiA9IHMubGVuOyB9XG5cbmxldCBwdXNoIHggcyA9IHMuYyA8LSB4IDo6IHMuYzsgcy5sZW4gPC0gcy5sZW4gKyAxXG5cbmxldCBwb3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6OnRsIC0+IHMuYyA8LSB0bDsgcy5sZW4gPC0gcy5sZW4gLSAxOyBoZFxuICB8IFtdICAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgcG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IFNvbWUgaGRcbiAgfCBbXSAgICAgLT4gTm9uZVxuXG5sZXQgdG9wIHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjpfIC0+IGhkXG4gIHwgW10gICAgLT4gcmFpc2UgRW1wdHlcblxubGV0IHRvcF9vcHQgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gU29tZSBoZFxuICB8IFtdICAgIC0+IE5vbmVcblxubGV0IGlzX2VtcHR5IHMgPSAocy5jID0gW10pXG5cbmxldCBsZW5ndGggcyA9IHMubGVuXG5cbmxldCBpdGVyIGYgcyA9IExpc3QuaXRlciBmIHMuY1xuXG5sZXQgZm9sZCBmIGFjYyBzID0gTGlzdC5mb2xkX2xlZnQgZiBhY2Mgcy5jXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9IExpc3QudG9fc2VxIHMuY1xuXG5sZXQgYWRkX3NlcSBxIGkgPSBTZXEuaXRlciAoZnVuIHggLT4gcHVzaCB4IHEpIGlcblxubGV0IG9mX3NlcSBnID1cbiAgbGV0IHMgPSBjcmVhdGUoKSBpblxuICBhZGRfc2VxIHMgZztcbiAgc1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICBGcmFuY29pcyBQb3R0aWVyLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICBKZXJlbWllIERpbWlubywgSmFuZSBTdHJlZXQgRXVyb3BlICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leGNlcHRpb24gRW1wdHlcblxudHlwZSAnYSBjZWxsID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mIHsgY29udGVudDogJ2E7IG11dGFibGUgbmV4dDogJ2EgY2VsbCB9XG5cbnR5cGUgJ2EgdCA9IHtcbiAgbXV0YWJsZSBsZW5ndGg6IGludDtcbiAgbXV0YWJsZSBmaXJzdDogJ2EgY2VsbDtcbiAgbXV0YWJsZSBsYXN0OiAnYSBjZWxsXG59XG5cbmxldCBjcmVhdGUgKCkgPSB7XG4gIGxlbmd0aCA9IDA7XG4gIGZpcnN0ID0gTmlsO1xuICBsYXN0ID0gTmlsXG59XG5cbmxldCBjbGVhciBxID1cbiAgcS5sZW5ndGggPC0gMDtcbiAgcS5maXJzdCA8LSBOaWw7XG4gIHEubGFzdCA8LSBOaWxcblxubGV0IGFkZCB4IHEgPVxuICBsZXQgY2VsbCA9IENvbnMge1xuICAgIGNvbnRlbnQgPSB4O1xuICAgIG5leHQgPSBOaWxcbiAgfSBpblxuICBtYXRjaCBxLmxhc3Qgd2l0aFxuICB8IE5pbCAtPlxuICAgIHEubGVuZ3RoIDwtIDE7XG4gICAgcS5maXJzdCA8LSBjZWxsO1xuICAgIHEubGFzdCA8LSBjZWxsXG4gIHwgQ29ucyBsYXN0IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggKyAxO1xuICAgIGxhc3QubmV4dCA8LSBjZWxsO1xuICAgIHEubGFzdCA8LSBjZWxsXG5cbmxldCBwdXNoID1cbiAgYWRkXG5cbmxldCBwZWVrIHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gcmFpc2UgRW1wdHlcbiAgfCBDb25zIHsgY29udGVudCB9IC0+IGNvbnRlbnRcblxubGV0IHBlZWtfb3B0IHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gTm9uZVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gU29tZSBjb250ZW50XG5cbmxldCB0b3AgPVxuICBwZWVrXG5cbmxldCB0YWtlIHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gcmFpc2UgRW1wdHlcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBjb250ZW50XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgIHEubGVuZ3RoIDwtIHEubGVuZ3RoIC0gMTtcbiAgICBxLmZpcnN0IDwtIG5leHQ7XG4gICAgY29udGVudFxuXG5sZXQgdGFrZV9vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSAtPlxuICAgIGNsZWFyIHE7XG4gICAgU29tZSBjb250ZW50XG4gIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgIHEubGVuZ3RoIDwtIHEubGVuZ3RoIC0gMTtcbiAgICBxLmZpcnN0IDwtIG5leHQ7XG4gICAgU29tZSBjb250ZW50XG5cbmxldCBwb3AgPVxuICB0YWtlXG5cbmxldCBjb3B5ID1cbiAgbGV0IHJlYyBjb3B5IHFfcmVzIHByZXYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gcV9yZXMubGFzdCA8LSBwcmV2OyBxX3Jlc1xuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgbGV0IHJlcyA9IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gaW5cbiAgICAgIGJlZ2luIG1hdGNoIHByZXYgd2l0aFxuICAgICAgfCBOaWwgLT4gcV9yZXMuZmlyc3QgPC0gcmVzXG4gICAgICB8IENvbnMgcCAtPiBwLm5leHQgPC0gcmVzXG4gICAgICBlbmQ7XG4gICAgICBjb3B5IHFfcmVzIHJlcyBuZXh0XG4gIGluXG4gIGZ1biBxIC0+IGNvcHkgeyBsZW5ndGggPSBxLmxlbmd0aDsgZmlyc3QgPSBOaWw7IGxhc3QgPSBOaWwgfSBOaWwgcS5maXJzdFxuXG5sZXQgaXNfZW1wdHkgcSA9XG4gIHEubGVuZ3RoID0gMFxuXG5sZXQgbGVuZ3RoIHEgPVxuICBxLmxlbmd0aFxuXG5sZXQgaXRlciA9XG4gIGxldCByZWMgaXRlciBmIGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+ICgpXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBmIGNvbnRlbnQ7XG4gICAgICBpdGVyIGYgbmV4dFxuICBpblxuICBmdW4gZiBxIC0+IGl0ZXIgZiBxLmZpcnN0XG5cbmxldCBmb2xkID1cbiAgbGV0IHJlYyBmb2xkIGYgYWNjdSBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBhY2N1XG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgYWNjdSA9IGYgYWNjdSBjb250ZW50IGluXG4gICAgICBmb2xkIGYgYWNjdSBuZXh0XG4gIGluXG4gIGZ1biBmIGFjY3UgcSAtPiBmb2xkIGYgYWNjdSBxLmZpcnN0XG5cbmxldCB0cmFuc2ZlciBxMSBxMiA9XG4gIGlmIHExLmxlbmd0aCA+IDAgdGhlblxuICAgIG1hdGNoIHEyLmxhc3Qgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICBxMi5sZW5ndGggPC0gcTEubGVuZ3RoO1xuICAgICAgcTIuZmlyc3QgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuICAgIHwgQ29ucyBsYXN0IC0+XG4gICAgICBxMi5sZW5ndGggPC0gcTIubGVuZ3RoICsgcTEubGVuZ3RoO1xuICAgICAgbGFzdC5uZXh0IDwtIHExLmZpcnN0O1xuICAgICAgcTIubGFzdCA8LSBxMS5sYXN0O1xuICAgICAgY2xlYXIgcTFcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBxID1cbiAgbGV0IHJlYyBhdXggYyAoKSA9IG1hdGNoIGMgd2l0aFxuICAgIHwgTmlsIC0+IFNlcS5OaWxcbiAgICB8IENvbnMgeyBjb250ZW50PXg7IG5leHQ7IH0gLT4gU2VxLkNvbnMgKHgsIGF1eCBuZXh0KVxuICBpblxuICBhdXggcS5maXJzdFxuXG5sZXQgYWRkX3NlcSBxIGkgPSBTZXEuaXRlciAoZnVuIHggLT4gcHVzaCB4IHEpIGlcblxubGV0IG9mX3NlcSBnID1cbiAgbGV0IHEgPSBjcmVhdGUoKSBpblxuICBhZGRfc2VxIHEgZztcbiAgcVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBJbnRlcm5hbHMgb2YgZm9yY2luZyBsYXp5IHZhbHVlcy4gKilcblxudHlwZSAnYSB0ID0gJ2EgbGF6eV90XG5cbmV4Y2VwdGlvbiBVbmRlZmluZWRcblxubGV0IHJhaXNlX3VuZGVmaW5lZCA9IE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgVW5kZWZpbmVkKVxuXG5leHRlcm5hbCBtYWtlX2ZvcndhcmQgOiBPYmoudCAtPiBPYmoudCAtPiB1bml0ID0gXCJjYW1sX29ial9tYWtlX2ZvcndhcmRcIlxuXG4oKiBBc3N1bWUgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBsYXp5ICopXG5sZXQgZm9yY2VfbGF6eV9ibG9jayAoYmxrIDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIChPYmoucmVwciBibGspIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgcmFpc2VfdW5kZWZpbmVkO1xuICB0cnlcbiAgICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICAgIG1ha2VfZm9yd2FyZCAoT2JqLnJlcHIgYmxrKSAoT2JqLnJlcHIgcmVzdWx0KTtcbiAgICByZXN1bHRcbiAgd2l0aCBlIC0+XG4gICAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIChPYmoucmVwciAoZnVuICgpIC0+IHJhaXNlIGUpKTtcbiAgICByYWlzZSBlXG5cblxuKCogQXNzdW1lIFtibGtdIGlzIGEgYmxvY2sgd2l0aCB0YWcgbGF6eSAqKVxubGV0IGZvcmNlX3ZhbF9sYXp5X2Jsb2NrIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgKE9iai5yZXByIGJsaykgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCByYWlzZV91bmRlZmluZWQ7XG4gIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gIG1ha2VfZm9yd2FyZCAoT2JqLnJlcHIgYmxrKSAoT2JqLnJlcHIgcmVzdWx0KTtcbiAgcmVzdWx0XG5cblxuKCogW2ZvcmNlXSBpcyBub3QgdXNlZCwgc2luY2UgW0xhenkuZm9yY2VdIGlzIGRlY2xhcmVkIGFzIGEgcHJpbWl0aXZlXG4gICB3aG9zZSBjb2RlIGlubGluZXMgdGhlIHRhZyB0ZXN0cyBvZiBpdHMgYXJndW1lbnQsIGV4Y2VwdCB3aGVuIGFmbFxuICAgaW5zdHJ1bWVudGF0aW9uIGlzIHR1cm5lZCBvbi4gKilcblxubGV0IGZvcmNlIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICAoKiBVc2luZyBbU3lzLm9wYXF1ZV9pZGVudGl0eV0gcHJldmVudHMgdHdvIHBvdGVudGlhbCBwcm9ibGVtczpcbiAgICAgLSBJZiB0aGUgdmFsdWUgaXMga25vd24gdG8gaGF2ZSBGb3J3YXJkX3RhZywgdGhlbiBpdHMgdGFnIGNvdWxkIGhhdmVcbiAgICAgICBjaGFuZ2VkIGR1cmluZyBHQywgc28gdGhhdCBpbmZvcm1hdGlvbiBtdXN0IGJlIGZvcmdvdHRlbiAoc2VlIEdQUiM3MTNcbiAgICAgICBhbmQgaXNzdWUgIzczMDEpXG4gICAgIC0gSWYgdGhlIHZhbHVlIGlzIGtub3duIHRvIGJlIGltbXV0YWJsZSwgdGhlbiBpZiB0aGUgY29tcGlsZXJcbiAgICAgICBjYW5ub3QgcHJvdmUgdGhhdCB0aGUgbGFzdCBicmFuY2ggaXMgbm90IHRha2VuIGl0IHdpbGwgaXNzdWUgYVxuICAgICAgIHdhcm5pbmcgNTkgKG1vZGlmaWNhdGlvbiBvZiBhbiBpbW11dGFibGUgdmFsdWUpICopXG4gIGxldCBsenYgPSBTeXMub3BhcXVlX2lkZW50aXR5IGx6diBpblxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW4gKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZykgZWxzZVxuICBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX2xhenlfYmxvY2sgbHp2XG5cblxubGV0IGZvcmNlX3ZhbCAobHp2IDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IHggPSBPYmoucmVwciBsenYgaW5cbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuIChPYmoub2JqIChPYmouZmllbGQgeCAwKSA6ICdhcmcpIGVsc2VcbiAgaWYgdCA8PiBPYmoubGF6eV90YWcgdGhlbiAoT2JqLm9iaiB4IDogJ2FyZylcbiAgZWxzZSBmb3JjZV92YWxfbGF6eV9ibG9jayBsenZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtMYXp5XTogZGVmZXJyZWQgY29tcHV0YXRpb25zICopXG5cblxuKCpcbiAgIFdBUk5JTkc6IHNvbWUgcHVycGxlIG1hZ2ljIGlzIGdvaW5nIG9uIGhlcmUuICBEbyBub3QgdGFrZSB0aGlzIGZpbGVcbiAgIGFzIGFuIGV4YW1wbGUgb2YgaG93IHRvIHByb2dyYW0gaW4gT0NhbWwuXG4qKVxuXG5cbigqIFdlIG1ha2UgdXNlIG9mIHR3byBzcGVjaWFsIHRhZ3MgcHJvdmlkZWQgYnkgdGhlIHJ1bnRpbWU6XG4gICBbbGF6eV90YWddIGFuZCBbZm9yd2FyZF90YWddLlxuXG4gICBBIHZhbHVlIG9mIHR5cGUgWydhIExhenkudF0gY2FuIGJlIG9uZSBvZiB0aHJlZSB0aGluZ3M6XG4gICAxLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbbGF6eV90YWddLiAgSXRzIGZpZWxkIGlzIGEgY2xvc3VyZSBvZlxuICAgICAgdHlwZSBbdW5pdCAtPiAnYV0gdGhhdCBjb21wdXRlcyB0aGUgdmFsdWUuXG4gICAyLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbZm9yd2FyZF90YWddLiAgSXRzIGZpZWxkIGlzIHRoZSB2YWx1ZVxuICAgICAgb2YgdHlwZSBbJ2FdIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgMy4gQW55dGhpbmcgZWxzZSBleGNlcHQgYSBmbG9hdC4gIFRoaXMgaGFzIHR5cGUgWydhXSBhbmQgaXMgdGhlIHZhbHVlXG4gICAgICB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIEV4Y2VwdGlvbnMgYXJlIHN0b3JlZCBpbiBmb3JtYXQgKDEpLlxuICAgVGhlIEdDIHdpbGwgbWFnaWNhbGx5IGNoYW5nZSB0aGluZ3MgZnJvbSAoMikgdG8gKDMpIGFjY29yZGluZyB0byBpdHNcbiAgIGZhbmN5LlxuXG4gICBJZiBPQ2FtbCB3YXMgY29uZmlndXJlZCB3aXRoIHRoZSAtZmxhdC1mbG9hdC1hcnJheSBvcHRpb24gKHdoaWNoIGlzXG4gICBjdXJyZW50bHkgdGhlIGRlZmF1bHQpLCB0aGUgZm9sbG93aW5nIGlzIGFsc28gdHJ1ZTpcbiAgIFdlIGNhbm5vdCB1c2UgcmVwcmVzZW50YXRpb24gKDMpIGZvciBhIFtmbG9hdCBMYXp5LnRdIGJlY2F1c2VcbiAgIFtjYW1sX21ha2VfYXJyYXldIGFzc3VtZXMgdGhhdCBvbmx5IGEgW2Zsb2F0XSB2YWx1ZSBjYW4gaGF2ZSB0YWdcbiAgIFtEb3VibGVfdGFnXS5cblxuICAgV2UgaGF2ZSB0byB1c2UgdGhlIGJ1aWx0LWluIHR5cGUgY29uc3RydWN0b3IgW2xhenlfdF0gdG9cbiAgIGxldCB0aGUgY29tcGlsZXIgaW1wbGVtZW50IHRoZSBzcGVjaWFsIHR5cGluZyBhbmQgY29tcGlsYXRpb25cbiAgIHJ1bGVzIGZvciB0aGUgW2xhenldIGtleXdvcmQuXG4qKVxuXG50eXBlICdhIHQgPSAnYSBDYW1saW50ZXJuYWxMYXp5LnRcblxuZXhjZXB0aW9uIFVuZGVmaW5lZCA9IENhbWxpbnRlcm5hbExhenkuVW5kZWZpbmVkXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6ICdhIC0+ICdhIGxhenlfdCA9IFwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZFwiXG5cbmV4dGVybmFsIGZvcmNlIDogJ2EgdCAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuXG4oKiBsZXQgZm9yY2UgPSBmb3JjZSAqKVxuXG5sZXQgZm9yY2VfdmFsID0gQ2FtbGludGVybmFsTGF6eS5mb3JjZV92YWxcblxubGV0IGZyb21fZnVuIChmIDogdW5pdCAtPiAnYXJnKSA9XG4gIGxldCB4ID0gT2JqLm5ld19ibG9jayBPYmoubGF6eV90YWcgMSBpblxuICBPYmouc2V0X2ZpZWxkIHggMCAoT2JqLnJlcHIgZik7XG4gIChPYmoub2JqIHggOiAnYXJnIHQpXG5cblxubGV0IGZyb21fdmFsICh2IDogJ2FyZykgPVxuICBsZXQgdCA9IE9iai50YWcgKE9iai5yZXByIHYpIGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgfHwgdCA9IE9iai5sYXp5X3RhZyB8fCB0ID0gT2JqLmRvdWJsZV90YWcgdGhlbiBiZWdpblxuICAgIG1ha2VfZm9yd2FyZCB2XG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgKE9iai5tYWdpYyB2IDogJ2FyZyB0KVxuICBlbmRcblxuXG5sZXQgaXNfdmFsIChsIDogJ2FyZyB0KSA9IE9iai50YWcgKE9iai5yZXByIGwpIDw+IE9iai5sYXp5X3RhZ1xuXG5sZXQgbGF6eV9mcm9tX2Z1biA9IGZyb21fZnVuXG5cbmxldCBsYXp5X2Zyb21fdmFsID0gZnJvbV92YWxcblxubGV0IGxhenlfaXNfdmFsID0gaXNfdmFsXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIERhbmllbCBkZSBSYXVnbGF1ZHJlLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9ICdhIGNlbGwgb3B0aW9uXG5hbmQgJ2EgY2VsbCA9IHsgbXV0YWJsZSBjb3VudCA6IGludDsgbXV0YWJsZSBkYXRhIDogJ2EgZGF0YSB9XG5hbmQgJ2EgZGF0YSA9XG4gICAgU2VtcHR5XG4gIHwgU2NvbnMgb2YgJ2EgKiAnYSBkYXRhXG4gIHwgU2FwcCBvZiAnYSBkYXRhICogJ2EgZGF0YVxuICB8IFNsYXp5IG9mICdhIGRhdGEgTGF6eS50XG4gIHwgU2dlbiBvZiAnYSBnZW5cbiAgfCBTYnVmZmlvIDogYnVmZmlvIC0+IGNoYXIgZGF0YVxuYW5kICdhIGdlbiA9IHsgbXV0YWJsZSBjdXJyIDogJ2Egb3B0aW9uIG9wdGlvbjsgZnVuYyA6IGludCAtPiAnYSBvcHRpb24gfVxuYW5kIGJ1ZmZpbyA9XG4gIHsgaWMgOiBpbl9jaGFubmVsOyBidWZmIDogYnl0ZXM7IG11dGFibGUgbGVuIDogaW50OyBtdXRhYmxlIGluZCA6IGludCB9XG5cbmV4Y2VwdGlvbiBGYWlsdXJlXG5leGNlcHRpb24gRXJyb3Igb2Ygc3RyaW5nXG5cbmxldCBjb3VudCA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAwXG4gIHwgU29tZSB7IGNvdW50IH0gLT4gY291bnRcbmxldCBkYXRhID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFNlbXB0eVxuICB8IFNvbWUgeyBkYXRhIH0gLT4gZGF0YVxuXG5sZXQgZmlsbF9idWZmIGIgPVxuICBiLmxlbiA8LSBpbnB1dCBiLmljIGIuYnVmZiAwIChCeXRlcy5sZW5ndGggYi5idWZmKTsgYi5pbmQgPC0gMFxuXG5cbmxldCByZWMgZ2V0X2RhdGEgOiB0eXBlIHYuIGludCAtPiB2IGRhdGEgLT4gdiBkYXRhID0gZnVuIGNvdW50IGQgLT4gbWF0Y2ggZCB3aXRoXG4gKCogUmV0dXJucyBlaXRoZXIgU2VtcHR5IG9yIFNjb25zKGEsIF8pIGV2ZW4gd2hlbiBkIGlzIGEgZ2VuZXJhdG9yXG4gICAgb3IgYSBidWZmZXIuIEluIHRob3NlIGNhc2VzLCB0aGUgaXRlbSBhIGlzIHNlZW4gYXMgZXh0cmFjdGVkIGZyb21cbiB0aGUgZ2VuZXJhdG9yL2J1ZmZlci5cbiBUaGUgY291bnQgcGFyYW1ldGVyIGlzIHVzZWQgZm9yIGNhbGxpbmcgYFNnZW4tZnVuY3Rpb25zJy4gICopXG4gICBTZW1wdHkgfCBTY29ucyAoXywgXykgLT4gZFxuIHwgU2FwcCAoZDEsIGQyKSAtPlxuICAgICBiZWdpbiBtYXRjaCBnZXRfZGF0YSBjb3VudCBkMSB3aXRoXG4gICAgICAgU2NvbnMgKGEsIGQxMSkgLT4gU2NvbnMgKGEsIFNhcHAgKGQxMSwgZDIpKVxuICAgICB8IFNlbXB0eSAtPiBnZXRfZGF0YSBjb3VudCBkMlxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2dlbiB7Y3VyciA9IFNvbWUgTm9uZX0gLT4gU2VtcHR5XG4gfCBTZ2VuICh7Y3VyciA9IFNvbWUoU29tZSBhKX0gYXMgZykgLT5cbiAgICAgZy5jdXJyIDwtIE5vbmU7IFNjb25zKGEsIGQpXG4gfCBTZ2VuIGcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZy5mdW5jIGNvdW50IHdpdGhcbiAgICAgICBOb25lIC0+IGcuY3VyciA8LSBTb21lKE5vbmUpOyBTZW1wdHlcbiAgICAgfCBTb21lIGEgLT4gU2NvbnMoYSwgZClcbiAgICAgICAgICgqIFdhcm5pbmc6IGFueW9uZSB1c2luZyBnIHRoaW5rcyB0aGF0IGFuIGl0ZW0gaGFzIGJlZW4gcmVhZCAqKVxuICAgICBlbmRcbiB8IFNidWZmaW8gYiAtPlxuICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gU2VtcHR5IGVsc2VcbiAgICAgICBsZXQgciA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmIGIuaW5kIGluXG4gICAgICAgKCogV2FybmluZzogYW55b25lIHVzaW5nIGcgdGhpbmtzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZWFkICopXG4gICAgICAgYi5pbmQgPC0gc3VjYyBiLmluZDsgU2NvbnMociwgZClcbiB8IFNsYXp5IGYgLT4gZ2V0X2RhdGEgY291bnQgKExhenkuZm9yY2UgZilcblxuXG5sZXQgcmVjIHBlZWtfZGF0YSA6IHR5cGUgdi4gdiBjZWxsIC0+IHYgb3B0aW9uID0gZnVuIHMgLT5cbiAoKiBjb25zdWx0IHRoZSBmaXJzdCBpdGVtIG9mIHMgKilcbiBtYXRjaCBzLmRhdGEgd2l0aFxuICAgU2VtcHR5IC0+IE5vbmVcbiB8IFNjb25zIChhLCBfKSAtPiBTb21lIGFcbiB8IFNhcHAgKF8sIF8pIC0+XG4gICAgIGJlZ2luIG1hdGNoIGdldF9kYXRhIHMuY291bnQgcy5kYXRhIHdpdGhcbiAgICAgICBTY29ucyhhLCBfKSBhcyBkIC0+IHMuZGF0YSA8LSBkOyBTb21lIGFcbiAgICAgfCBTZW1wdHkgLT4gTm9uZVxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2xhenkgZiAtPiBzLmRhdGEgPC0gKExhenkuZm9yY2UgZik7IHBlZWtfZGF0YSBzXG4gfCBTZ2VuIHtjdXJyID0gU29tZSBhfSAtPiBhXG4gfCBTZ2VuIGcgLT4gbGV0IHggPSBnLmZ1bmMgcy5jb3VudCBpbiBnLmN1cnIgPC0gU29tZSB4OyB4XG4gfCBTYnVmZmlvIGIgLT5cbiAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIGJlZ2luIHMuZGF0YSA8LSBTZW1wdHk7IE5vbmUgZW5kXG4gICAgIGVsc2UgU29tZSAoQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmYgYi5pbmQpXG5cblxubGV0IHBlZWsgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgcyAtPiBwZWVrX2RhdGEgc1xuXG5cbmxldCByZWMganVua19kYXRhIDogdHlwZSB2LiB2IGNlbGwgLT4gdW5pdCA9IGZ1biBzIC0+XG4gIG1hdGNoIHMuZGF0YSB3aXRoXG4gICAgU2NvbnMgKF8sIGQpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IHMuZGF0YSA8LSBkXG4gIHwgU2dlbiAoe2N1cnIgPSBTb21lIF99IGFzIGcpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGcuY3VyciA8LSBOb25lXG4gIHwgU2J1ZmZpbyBiIC0+XG4gICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIHMuZGF0YSA8LSBTZW1wdHlcbiAgICAgIGVsc2UgKHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGIuaW5kIDwtIHN1Y2MgYi5pbmQpXG4gIHwgXyAtPlxuICAgICAgbWF0Y2ggcGVla19kYXRhIHMgd2l0aFxuICAgICAgICBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyAtPiBqdW5rX2RhdGEgc1xuXG5cbmxldCBqdW5rID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBkYXRhIC0+IGp1bmtfZGF0YSBkYXRhXG5cbmxldCByZWMgbmdldF9kYXRhIG4gcyA9XG4gIGlmIG4gPD0gMCB0aGVuIFtdLCBzLmRhdGEsIDBcbiAgZWxzZVxuICAgIG1hdGNoIHBlZWtfZGF0YSBzIHdpdGhcbiAgICAgIFNvbWUgYSAtPlxuICAgICAgICBqdW5rX2RhdGEgcztcbiAgICAgICAgbGV0IChhbCwgZCwgaykgPSBuZ2V0X2RhdGEgKHByZWQgbikgcyBpbiBhIDo6IGFsLCBTY29ucyAoYSwgZCksIHN1Y2Mga1xuICAgIHwgTm9uZSAtPiBbXSwgcy5kYXRhLCAwXG5cblxubGV0IG5wZWVrX2RhdGEgbiBzID1cbiAgbGV0IChhbCwgZCwgbGVuKSA9IG5nZXRfZGF0YSBuIHMgaW5cbiAgcy5jb3VudCA8LSAocy5jb3VudCAtIGxlbik7XG4gIHMuZGF0YSA8LSBkO1xuICBhbFxuXG5cbmxldCBucGVlayBuID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSBkIC0+IG5wZWVrX2RhdGEgbiBkXG5cbmxldCBuZXh0IHMgPVxuICBtYXRjaCBwZWVrIHMgd2l0aFxuICAgIFNvbWUgYSAtPiBqdW5rIHM7IGFcbiAgfCBOb25lIC0+IHJhaXNlIEZhaWx1cmVcblxuXG5sZXQgZW1wdHkgcyA9XG4gIG1hdGNoIHBlZWsgcyB3aXRoXG4gICAgU29tZSBfIC0+IHJhaXNlIEZhaWx1cmVcbiAgfCBOb25lIC0+ICgpXG5cblxubGV0IGl0ZXIgZiBzdHJtID1cbiAgbGV0IHJlYyBkb19yZWMgKCkgPVxuICAgIG1hdGNoIHBlZWsgc3RybSB3aXRoXG4gICAgICBTb21lIGEgLT4ganVuayBzdHJtOyBpZ25vcmUoZiBhKTsgZG9fcmVjICgpXG4gICAgfCBOb25lIC0+ICgpXG4gIGluXG4gIGRvX3JlYyAoKVxuXG5cbigqIFN0cmVhbSBidWlsZGluZyBmdW5jdGlvbnMgKilcblxubGV0IGZyb20gZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNnZW4ge2N1cnIgPSBOb25lOyBmdW5jID0gZn19XG5cbmxldCBvZl9saXN0IGwgPVxuICBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBMaXN0LmZvbGRfcmlnaHQgKGZ1biB4IGwgLT4gU2NvbnMgKHgsIGwpKSBsIFNlbXB0eX1cblxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgICgqIFdlIGNhbm5vdCB1c2UgdGhlIGluZGV4IHBhc3NlZCBieSB0aGUgW2Zyb21dIGZ1bmN0aW9uIGRpcmVjdGx5XG4gICAgICAgYmVjYXVzZSBpdCByZXR1cm5zIHRoZSBjdXJyZW50IHN0cmVhbSBjb3VudCwgd2l0aCBhYnNvbHV0ZWx5IG5vXG4gICAgICAgZ3VhcmFudGVlIHRoYXQgaXQgd2lsbCBzdGFydCBmcm9tIDAuIEZvciBleGFtcGxlLCBpbiB0aGUgY2FzZVxuICAgICAgIG9mIFtTdHJlYW0uaWNvbnMgJ2MnIChTdHJlYW0uZnJvbV9zdHJpbmcgXCJhYlwiKV0sIHRoZSBmaXJzdFxuICAgICAgIGFjY2VzcyB0byB0aGUgc3RyaW5nIHdpbGwgYmUgbWFkZSB3aXRoIGNvdW50IFsxXSBhbHJlYWR5LlxuICAgICopXG4gICAgbGV0IGMgPSAhY291bnQgaW5cbiAgICBpZiBjIDwgU3RyaW5nLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSBzLltjXSlcbiAgICBlbHNlIE5vbmUpXG5cblxubGV0IG9mX2J5dGVzIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgIGxldCBjID0gIWNvdW50IGluXG4gICAgaWYgYyA8IEJ5dGVzLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSAoQnl0ZXMuZ2V0IHMgYykpXG4gICAgZWxzZSBOb25lKVxuXG5cbmxldCBvZl9jaGFubmVsIGljID1cbiAgU29tZSB7Y291bnQgPSAwO1xuICAgICAgICBkYXRhID0gU2J1ZmZpbyB7aWMgPSBpYzsgYnVmZiA9IEJ5dGVzLmNyZWF0ZSA0MDk2OyBsZW4gPSAwOyBpbmQgPSAwfX1cblxuXG4oKiBTdHJlYW0gZXhwcmVzc2lvbnMgYnVpbGRlcnMgKilcblxubGV0IGlhcHAgaSBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2FwcCAoZGF0YSBpLCBkYXRhIHMpfVxubGV0IGljb25zIGkgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNjb25zIChpLCBkYXRhIHMpfVxubGV0IGlzaW5nIGkgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTY29ucyAoaSwgU2VtcHR5KX1cblxubGV0IGxhcHAgZiBzID1cbiAgU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2FwcCAoZGF0YSAoZiAoKSksIGRhdGEgcykpKX1cblxubGV0IGxjb25zIGYgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBkYXRhIHMpKSl9XG5sZXQgbHNpbmcgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBTZW1wdHkpKSl9XG5cbmxldCBzZW1wdHkgPSBOb25lXG5sZXQgc2xhenkgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KGRhdGEgKGYgKCkpKSl9XG5cbigqIEZvciBkZWJ1Z2dpbmcgdXNlICopXG5cbmxldCByZWMgZHVtcCA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiB0IC0+IHVuaXQgPSBmdW4gZiBzIC0+XG4gIHByaW50X3N0cmluZyBcIntjb3VudCA9IFwiO1xuICBwcmludF9pbnQgKGNvdW50IHMpO1xuICBwcmludF9zdHJpbmcgXCI7IGRhdGEgPSBcIjtcbiAgZHVtcF9kYXRhIGYgKGRhdGEgcyk7XG4gIHByaW50X3N0cmluZyBcIn1cIjtcbiAgcHJpbnRfbmV3bGluZSAoKVxuYW5kIGR1bXBfZGF0YSA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiBkYXRhIC0+IHVuaXQgPSBmdW4gZiAtPlxuICBmdW5jdGlvblxuICAgIFNlbXB0eSAtPiBwcmludF9zdHJpbmcgXCJTZW1wdHlcIlxuICB8IFNjb25zIChhLCBkKSAtPlxuICAgICAgcHJpbnRfc3RyaW5nIFwiU2NvbnMgKFwiO1xuICAgICAgZiBhO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQ7XG4gICAgICBwcmludF9zdHJpbmcgXCIpXCJcbiAgfCBTYXBwIChkMSwgZDIpIC0+XG4gICAgICBwcmludF9zdHJpbmcgXCJTYXBwIChcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQxO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQyO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiKVwiXG4gIHwgU2xhenkgXyAtPiBwcmludF9zdHJpbmcgXCJTbGF6eVwiXG4gIHwgU2dlbiBfIC0+IHByaW50X3N0cmluZyBcIlNnZW5cIlxuICB8IFNidWZmaW8gXyAtPiBwcmludF9zdHJpbmcgXCJTYnVmZmlvXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgIFBpZXJyZSBXZWlzIGFuZCBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTkgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXh0ZW5zaWJsZSBidWZmZXJzICopXG5cbnR5cGUgdCA9XG4ge211dGFibGUgYnVmZmVyIDogYnl0ZXM7XG4gIG11dGFibGUgcG9zaXRpb24gOiBpbnQ7XG4gIG11dGFibGUgbGVuZ3RoIDogaW50O1xuICBpbml0aWFsX2J1ZmZlciA6IGJ5dGVzfVxuKCogSW52YXJpYW50czogYWxsIHBhcnRzIG9mIHRoZSBjb2RlIHByZXNlcnZlIHRoZSBpbnZhcmlhbnRzIHRoYXQ6XG4gICAtIFswIDw9IGIucG9zaXRpb24gPD0gYi5sZW5ndGhdXG4gICAtIFtiLmxlbmd0aCA9IEJ5dGVzLmxlbmd0aCBiLmJ1ZmZlcl1cblxuICAgTm90ZSBpbiBwYXJ0aWN1bGFyIHRoYXQgW2IucG9zaXRpb24gPSBiLmxlbmd0aF0gaXMgbGVnYWwsXG4gICBpdCBtZWFucyB0aGF0IHRoZSBidWZmZXIgaXMgZnVsbCBhbmQgd2lsbCBoYXZlIHRvIGJlIGV4dGVuZGVkXG4gICBiZWZvcmUgYW55IGZ1cnRoZXIgYWRkaXRpb24uICopXG5cbmxldCBjcmVhdGUgbiA9XG4gbGV0IG4gPSBpZiBuIDwgMSB0aGVuIDEgZWxzZSBuIGluXG4gbGV0IG4gPSBpZiBuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGVsc2UgbiBpblxuIGxldCBzID0gQnl0ZXMuY3JlYXRlIG4gaW5cbiB7YnVmZmVyID0gczsgcG9zaXRpb24gPSAwOyBsZW5ndGggPSBuOyBpbml0aWFsX2J1ZmZlciA9IHN9XG5cbmxldCBjb250ZW50cyBiID0gQnl0ZXMuc3ViX3N0cmluZyBiLmJ1ZmZlciAwIGIucG9zaXRpb25cbmxldCB0b19ieXRlcyBiID0gQnl0ZXMuc3ViIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgc3ViIGIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBiLnBvc2l0aW9uIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuc3ViXCJcbiAgZWxzZSBCeXRlcy5zdWJfc3RyaW5nIGIuYnVmZmVyIG9mcyBsZW5cblxuXG5sZXQgYmxpdCBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBzcmNvZmYgPCAwIHx8IHNyY29mZiA+IHNyYy5wb3NpdGlvbiAtIGxlblxuICAgICAgICAgICAgIHx8IGRzdG9mZiA8IDAgfHwgZHN0b2ZmID4gKEJ5dGVzLmxlbmd0aCBkc3QpIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYmxpdFwiXG4gIGVsc2VcbiAgICBCeXRlcy51bnNhZmVfYmxpdCBzcmMuYnVmZmVyIHNyY29mZiBkc3QgZHN0b2ZmIGxlblxuXG5cbmxldCBudGggYiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+PSBiLnBvc2l0aW9uIHRoZW5cbiAgIGludmFsaWRfYXJnIFwiQnVmZmVyLm50aFwiXG4gIGVsc2UgQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBvZnNcblxuXG5sZXQgbGVuZ3RoIGIgPSBiLnBvc2l0aW9uXG5cbmxldCBjbGVhciBiID0gYi5wb3NpdGlvbiA8LSAwXG5cbmxldCByZXNldCBiID1cbiAgYi5wb3NpdGlvbiA8LSAwO1xuICBiLmJ1ZmZlciA8LSBiLmluaXRpYWxfYnVmZmVyO1xuICBiLmxlbmd0aCA8LSBCeXRlcy5sZW5ndGggYi5idWZmZXJcblxuKCogW3Jlc2l6ZSBiIG1vcmVdIGVuc3VyZXMgdGhhdCBbYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGhdIGhvbGRzXG4gICBieSBkeW5hbWljYWxseSBleHRlbmRpbmcgW2IuYnVmZmVyXSBpZiBuZWNlc3NhcnkgLS0gYW5kIHRodXNcbiAgIGluY3JlYXNpbmcgW2IubGVuZ3RoXS5cblxuICAgSW4gcGFydGljdWxhciwgYWZ0ZXIgW3Jlc2l6ZSBiIG1vcmVdIGlzIGNhbGxlZCwgYSBkaXJlY3QgYWNjZXNzIG9mXG4gICBzaXplIFttb3JlXSBhdCBbYi5wb3NpdGlvbl0gd2lsbCBhbHdheXMgYmUgaW4tYm91bmRzLCBzbyB0aGF0XG4gICAodW5zYWZlX3tnZXQsc2V0fSkgbWF5IGJlIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuKilcbmxldCByZXNpemUgYiBtb3JlID1cbiAgbGV0IG9sZF9wb3MgPSBiLnBvc2l0aW9uIGluXG4gIGxldCBvbGRfbGVuID0gYi5sZW5ndGggaW5cbiAgbGV0IG5ld19sZW4gPSByZWYgb2xkX2xlbiBpblxuICB3aGlsZSBvbGRfcG9zICsgbW9yZSA+ICFuZXdfbGVuIGRvIG5ld19sZW4gOj0gMiAqICFuZXdfbGVuIGRvbmU7XG4gIGlmICFuZXdfbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBpZiBvbGRfcG9zICsgbW9yZSA8PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICB0aGVuIG5ld19sZW4gOj0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgZWxzZSBmYWlsd2l0aCBcIkJ1ZmZlci5hZGQ6IGNhbm5vdCBncm93IGJ1ZmZlclwiXG4gIGVuZDtcbiAgbGV0IG5ld19idWZmZXIgPSBCeXRlcy5jcmVhdGUgIW5ld19sZW4gaW5cbiAgKCogUFIjNjE0ODogbGV0J3Mga2VlcCB1c2luZyBbYmxpdF0gcmF0aGVyIHRoYW4gW3Vuc2FmZV9ibGl0XSBpblxuICAgICB0aGlzIHRyaWNreSBmdW5jdGlvbiB0aGF0IGlzIHNsb3cgYW55d2F5LiAqKVxuICBCeXRlcy5ibGl0IGIuYnVmZmVyIDAgbmV3X2J1ZmZlciAwIGIucG9zaXRpb247XG4gIGIuYnVmZmVyIDwtIG5ld19idWZmZXI7XG4gIGIubGVuZ3RoIDwtICFuZXdfbGVuO1xuICBhc3NlcnQgKGIucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoKTtcbiAgYXNzZXJ0IChvbGRfcG9zICsgbW9yZSA8PSBiLmxlbmd0aCk7XG4gICgpXG4gICgqIE5vdGU6IHRoZXJlIGFyZSB2YXJpb3VzIHNpdHVhdGlvbnMgKHByZWVtcHRpdmUgdGhyZWFkcywgc2lnbmFscyBhbmRcbiAgICAgZ2MgZmluYWxpemVycykgd2hlcmUgT0NhbWwgY29kZSBtYXkgYmUgcnVuIGFzeW5jaHJvbm91c2x5OyBpblxuICAgICBwYXJ0aWN1bGFyLCB0aGVyZSBtYXkgYmUgYSByYWNlIHdpdGggYW5vdGhlciB1c2VyIG9mIFtiXSwgY2hhbmdpbmdcbiAgICAgaXRzIG11dGFibGUgZmllbGRzIGluIHRoZSBtaWRkbGUgb2YgdGhlIFtyZXNpemVdIGNhbGwuIFRoZSBCdWZmZXJcbiAgICAgbW9kdWxlIGRvZXMgbm90IHByb3ZpZGUgYW55IGNvcnJlY3RuZXNzIGd1YXJhbnRlZSBpZiB0aGF0IGhhcHBlbnMsXG4gICAgIGJ1dCB3ZSBtdXN0IHN0aWxsIGVuc3VyZSB0aGF0IHRoZSBkYXRhc3RydWN0dXJlIGludmFyaWFudHMgaG9sZCBmb3JcbiAgICAgbWVtb3J5LXNhZmV0eSAtLSBhcyB3ZSBwbGFuIHRvIHVzZSBbdW5zYWZlX3tnZXQsc2V0fV0uXG5cbiAgICAgVGhlcmUgYXJlIHR3byBwb3RlbnRpYWwgYWxsb2NhdGlvbiBwb2ludHMgaW4gdGhpcyBmdW5jdGlvbixcbiAgICAgW3JlZl0gYW5kIFtCeXRlcy5jcmVhdGVdLCBidXQgYWxsIHJlYWRzIGFuZCB3cml0ZXMgdG8gdGhlIGZpZWxkc1xuICAgICBvZiBbYl0gaGFwcGVuIGJlZm9yZSBib3RoIG9mIHRoZW0gb3IgYWZ0ZXIgYm90aCBvZiB0aGVtLlxuXG4gICAgIFdlIHRoZXJlZm9yZSBhc3N1bWUgdGhhdCBbYi5wb3NpdGlvbl0gbWF5IGNoYW5nZSBhdCB0aGVzZSBhbGxvY2F0aW9ucyxcbiAgICAgYW5kIGNoZWNrIHRoYXQgdGhlIFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aF0gcG9zdGNvbmRpdGlvblxuICAgICBob2xkcyBmb3IgYm90aCB2YWx1ZXMgb2YgW2IucG9zaXRpb25dLCBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGZ1bmN0aW9uXG4gICAgIGlzIGNhbGxlZC4gTW9yZSBwcmVjaXNlbHksIHRoZSBmb2xsb3dpbmcgaW52YXJpYW50cyBtdXN0IGhvbGQgaWYgdGhlXG4gICAgIGZ1bmN0aW9uIHJldHVybnMgY29ycmVjdGx5LCBpbiBhZGRpdGlvbiB0byB0aGUgdXN1YWwgYnVmZmVyIGludmFyaWFudHM6XG4gICAgIC0gW29sZChiLnBvc2l0aW9uKSArIG1vcmUgPD0gbmV3KGIubGVuZ3RoKV1cbiAgICAgLSBbbmV3KGIucG9zaXRpb24pICsgbW9yZSA8PSBuZXcoYi5sZW5ndGgpXVxuICAgICAtIFtvbGQoYi5sZW5ndGgpIDw9IG5ldyhiLmxlbmd0aCldXG5cbiAgICAgTm90ZTogW2IucG9zaXRpb24gKyBtb3JlIDw9IG9sZChiLmxlbmd0aCldIGRvZXMgKm5vdCpcbiAgICAgaG9sZCBpbiBnZW5lcmFsLCBhcyBpdCBpcyBwcmVjaXNlbHkgdGhlIGNhc2Ugd2hlcmUgeW91IG5lZWRcbiAgICAgdG8gY2FsbCBbcmVzaXplXSB0byBpbmNyZWFzZSBbYi5sZW5ndGhdLlxuXG4gICAgIE5vdGU6IFthc3NlcnRdIGFib3ZlIGRvZXMgbm90IG1lYW4gdGhhdCB3ZSBrbm93IHRoZSBjb25kaXRpb25zXG4gICAgIGFsd2F5cyBob2xkLCBidXQgdGhhdCB0aGUgZnVuY3Rpb24gbWF5IHJldHVybiBjb3JyZWN0bHlcbiAgICAgb25seSBpZiB0aGV5IGhvbGQuXG5cbiAgICAgTm90ZTogdGhlIG90aGVyIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSBkb2VzIG5vdCBuZWVkXG4gICAgIHRvIGJlIGNoZWNrZWQgd2l0aCB0aGlzIGxldmVsIG9mIHNjcnV0aW55LCBnaXZlbiB0aGF0IHRoZXlcbiAgICAgcmVhZC93cml0ZSB0aGUgYnVmZmVyIGltbWVkaWF0ZWx5IGFmdGVyIGNoZWNraW5nIHRoYXRcbiAgICAgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoXSBob2xkIG9yIGNhbGxpbmcgW3Jlc2l6ZV0uXG4gICopXG5cbmxldCBhZGRfY2hhciBiIGMgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5sZW5ndGggdGhlbiByZXNpemUgYiAxO1xuICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIHBvcyBjO1xuICBiLnBvc2l0aW9uIDwtIHBvcyArIDFcblxuIGxldCBhZGRfdXRmXzhfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHgwMDdGIC0+XG4gICAgIGFkZF9jaGFyIGIgKENoYXIudW5zYWZlX2NociB1KVxuIHwgdSB3aGVuIHUgPD0gMHgwN0ZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhDMCBsb3IgKHUgbHNyIDYpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAzID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAzO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4RTAgbG9yICh1IGxzciAxMikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSlcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMilcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgM1xuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEYwIGxvciAodSBsc3IgMTgpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciAxMikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gbGV0IGFkZF91dGZfMTZiZV91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAodSBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyICh1IGxhbmQgMHhGRikpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgIGxldCBoaSA9IDB4RDgwMCBsb3IgKHUnIGxzciAxMCkgaW5cbiAgICAgbGV0IGxvID0gMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikgaW5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAoaGkgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAoaGkgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxhbmQgMHhGRikpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiBsZXQgYWRkX3V0Zl8xNmxlX3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyICh1IGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyICh1IGxzciA4KSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgMlxuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgbGV0IGhpID0gMHhEODAwIGxvciAodScgbHNyIDEwKSBpblxuICAgICBsZXQgbG8gPSAweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSBpblxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyA0ID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAoaGkgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMikgKENoYXIudW5zYWZlX2NociAobG8gbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxzciA4KSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGFkZF9zdWJzdHJpbmcgYiBzIG9mZnNldCBsZW4gPVxuICBpZiBvZmZzZXQgPCAwIHx8IGxlbiA8IDAgfHwgb2Zmc2V0ID4gU3RyaW5nLmxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX3N1YnN0cmluZy9hZGRfc3ViYnl0ZXNcIjtcbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIG9mZnNldCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9zdWJieXRlcyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGFkZF9zdWJzdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKSBvZmZzZXQgbGVuXG5cbmxldCBhZGRfc3RyaW5nIGIgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIDAgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfYnl0ZXMgYiBzID0gYWRkX3N0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpXG5cbmxldCBhZGRfYnVmZmVyIGIgYnMgPVxuICBhZGRfc3ViYnl0ZXMgYiBicy5idWZmZXIgMCBicy5wb3NpdGlvblxuXG4oKiB0aGlzIChwcml2YXRlKSBmdW5jdGlvbiBjb3VsZCBtb3ZlIGludG8gdGhlIHN0YW5kYXJkIGxpYnJhcnkgKilcbmxldCByZWFsbHlfaW5wdXRfdXBfdG8gaWMgYnVmIG9mcyBsZW4gPVxuICBsZXQgcmVjIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQgfm9mcyB+dG9fcmVhZCA9XG4gICAgaWYgdG9fcmVhZCA9IDAgdGhlbiBhbHJlYWR5X3JlYWRcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGlucHV0IGljIGJ1ZiBvZnMgdG9fcmVhZCBpblxuICAgICAgaWYgciA9IDAgdGhlbiBhbHJlYWR5X3JlYWRcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGFscmVhZHlfcmVhZCA9IGFscmVhZHlfcmVhZCArIHIgaW5cbiAgICAgICAgbGV0IG9mcyA9IG9mcyArIHIgaW5cbiAgICAgICAgbGV0IHRvX3JlYWQgPSB0b19yZWFkIC0gciBpblxuICAgICAgICBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkIH5vZnMgfnRvX3JlYWRcbiAgICAgIGVuZFxuICAgIGVuZFxuICBpbiBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkOjAgfm9mcyB+dG9fcmVhZDpsZW5cblxuXG5sZXQgdW5zYWZlX2FkZF9jaGFubmVsX3VwX3RvIGIgaWMgbGVuID1cbiAgaWYgYi5wb3NpdGlvbiArIGxlbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBsZXQgbiA9IHJlYWxseV9pbnB1dF91cF90byBpYyBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbiBpblxuICAoKiBUaGUgYXNzZXJ0aW9uIGJlbG93IG1heSBmYWlsIGluIHdlaXJkIHNjZW5hcmlvIHdoZXJlXG4gICAgIHRocmVhZGVkL2ZpbmFsaXplciBjb2RlLCBydW4gYXN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZVxuICAgICBbcmVhbGx5X2lucHV0X3VwX3RvXSBjYWxsLCByYWNlcyBvbiB0aGUgYnVmZmVyOyB3ZSBkb24ndCBlbnN1cmVcbiAgICAgY29ycmVjdG5lc3MgaW4gdGhpcyBjYXNlLCBidXQgbmVlZCB0byBwcmVzZXJ2ZSB0aGUgaW52YXJpYW50cyBmb3JcbiAgICAgbWVtb3J5LXNhZmV0eSAoc2VlIGRpc2N1c3Npb24gb2YgW3Jlc2l6ZV0pLiAqKVxuICBhc3NlcnQgKGIucG9zaXRpb24gKyBuIDw9IGIubGVuZ3RoKTtcbiAgYi5wb3NpdGlvbiA8LSBiLnBvc2l0aW9uICsgbjtcbiAgblxuXG5sZXQgYWRkX2NoYW5uZWwgYiBpYyBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IGxlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuICAgKCogUFIjNTAwNCAqKVxuICAgIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9jaGFubmVsXCI7XG4gIGxldCBuID0gdW5zYWZlX2FkZF9jaGFubmVsX3VwX3RvIGIgaWMgbGVuIGluXG4gICgqIEl0IGlzIGludGVudGlvbmFsIHRoYXQgYSBjb25zdW1lciBjYXRjaGluZyBFbmRfb2ZfZmlsZVxuICAgICB3aWxsIHNlZSB0aGUgZGF0YSB3cml0dGVuIChzZWUgIzY3MTksICM3MTM2KS4gKilcbiAgaWYgbiA8IGxlbiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAoKVxuXG5sZXQgb3V0cHV0X2J1ZmZlciBvYyBiID1cbiAgb3V0cHV0IG9jIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgY2xvc2luZyA9IGZ1bmN0aW9uXG4gIHwgJygnIC0+ICcpJ1xuICB8ICd7JyAtPiAnfSdcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4oKiBvcGVuaW5nIGFuZCBjbG9zaW5nOiBvcGVuIGFuZCBjbG9zZSBjaGFyYWN0ZXJzLCB0eXBpY2FsbHkgKCBhbmQgKVxuICAgazogYmFsYW5jZSBvZiBvcGVuaW5nIGFuZCBjbG9zaW5nIGNoYXJzXG4gICBzOiB0aGUgc3RyaW5nIHdoZXJlIHdlIGFyZSBzZWFyY2hpbmdcbiAgIHN0YXJ0OiB0aGUgaW5kZXggd2hlcmUgd2Ugc3RhcnQgdGhlIHNlYXJjaC4gKilcbmxldCBhZHZhbmNlX3RvX2Nsb3Npbmcgb3BlbmluZyBjbG9zaW5nIGsgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBrIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gICAgaWYgcy5baV0gPSBvcGVuaW5nIHRoZW4gYWR2YW5jZSAoayArIDEpIChpICsgMSkgbGltIGVsc2VcbiAgICBpZiBzLltpXSA9IGNsb3NpbmcgdGhlblxuICAgICAgaWYgayA9IDAgdGhlbiBpIGVsc2UgYWR2YW5jZSAoayAtIDEpIChpICsgMSkgbGltXG4gICAgZWxzZSBhZHZhbmNlIGsgKGkgKyAxKSBsaW0gaW5cbiAgYWR2YW5jZSBrIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbmxldCBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIGxpbSBlbHNlXG4gICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknIHwgJ18nIC0+IGFkdmFuY2UgKGkgKyAxKSBsaW1cbiAgICB8IF8gLT4gaSBpblxuICBhZHZhbmNlIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbigqIFdlIGFyZSBqdXN0IGF0IHRoZSBiZWdpbm5pbmcgb2YgYW4gaWRlbnQgaW4gcywgc3RhcnRpbmcgYXQgc3RhcnQuICopXG5sZXQgZmluZF9pZGVudCBzIHN0YXJ0IGxpbSA9XG4gIGlmIHN0YXJ0ID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIG1hdGNoIHMuW3N0YXJ0XSB3aXRoXG4gICgqIFBhcmVudGhlc2l6ZWQgaWRlbnQgPyAqKVxuICB8ICcoJyB8ICd7JyBhcyBjIC0+XG4gICAgIGxldCBuZXdfc3RhcnQgPSBzdGFydCArIDEgaW5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX2Nsb3NpbmcgYyAoY2xvc2luZyBjKSAwIHMgbmV3X3N0YXJ0IGluXG4gICAgIFN0cmluZy5zdWIgcyBuZXdfc3RhcnQgKHN0b3AgLSBzdGFydCAtIDEpLCBzdG9wICsgMVxuICAoKiBSZWd1bGFyIGlkZW50ICopXG4gIHwgXyAtPlxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgKHN0YXJ0ICsgMSkgaW5cbiAgICAgU3RyaW5nLnN1YiBzIHN0YXJ0IChzdG9wIC0gc3RhcnQpLCBzdG9wXG5cbigqIFN1YnN0aXR1dGUgJGlkZW50LCAkKGlkZW50KSwgb3IgJHtpZGVudH0gaW4gcyxcbiAgICBhY2NvcmRpbmcgdG8gdGhlIGZ1bmN0aW9uIG1hcHBpbmcgZi4gKilcbmxldCBhZGRfc3Vic3RpdHV0ZSBiIGYgcyA9XG4gIGxldCBsaW0gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBzdWJzdCBwcmV2aW91cyBpID1cbiAgICBpZiBpIDwgbGltIHRoZW4gYmVnaW5cbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJyQnIGFzIGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJyQnIC0+XG4gICAgICAgICBsZXQgaiA9IGkgKyAxIGluXG4gICAgICAgICBsZXQgaWRlbnQsIG5leHRfaSA9IGZpbmRfaWRlbnQgcyBqIGxpbSBpblxuICAgICAgICAgYWRkX3N0cmluZyBiIChmIGlkZW50KTtcbiAgICAgICAgIHN1YnN0ICcgJyBuZXh0X2lcbiAgICAgIHwgY3VycmVudCB3aGVuIHByZXZpb3VzID09ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiAnXFxcXCc7XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnXFxcXCcgYXMgY3VycmVudCAtPlxuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgICB8IGN1cnJlbnQgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgIGVuZCBlbHNlXG4gICAgaWYgcHJldmlvdXMgPSAnXFxcXCcgdGhlbiBhZGRfY2hhciBiIHByZXZpb3VzIGluXG4gIHN1YnN0ICcgJyAwXG5cbmxldCB0cnVuY2F0ZSBiIGxlbiA9XG4gICAgaWYgbGVuIDwgMCB8fCBsZW4gPiBsZW5ndGggYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci50cnVuY2F0ZVwiXG4gICAgZWxzZVxuICAgICAgYi5wb3NpdGlvbiA8LSBsZW5cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgKCogTm90ZSB0aGF0IGIucG9zaXRpb24gaXMgbm90IGEgY29uc3RhbnQgYW5kIGNhbm5vdCBiZSBsaWZ0ZWQgb3V0IG9mIGF1eCAqKVxuICAgIGlmIGkgPj0gYi5wb3NpdGlvbiB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICgqIE5vdGUgdGhhdCBiLnBvc2l0aW9uIGlzIG5vdCBhIGNvbnN0YW50IGFuZCBjYW5ub3QgYmUgbGlmdGVkIG91dCBvZiBhdXggKilcbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgYWRkX3NlcSBiIHNlcSA9IFNlcS5pdGVyIChhZGRfY2hhciBiKSBzZXFcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IGIgPSBjcmVhdGUgMzIgaW5cbiAgYWRkX3NlcSBiIGk7XG4gIGJcblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDE2IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQxNnVcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQzMiA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQzMnVcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ2NCA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NHVcIlxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIlxuZXh0ZXJuYWwgc3dhcDMyIDogaW50MzIgLT4gaW50MzIgPSBcIiVic3dhcF9pbnQzMlwiXG5leHRlcm5hbCBzd2FwNjQgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWJzd2FwX2ludDY0XCJcblxuXG5sZXQgYWRkX2ludDggYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyAxIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMTtcbiAgdW5zYWZlX3NldF9pbnQ4IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDIgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICB1bnNhZmVfc2V0X2ludDE2IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQzMl9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDQgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICB1bnNhZmVfc2V0X2ludDMyIGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQ2NF9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDggaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA4O1xuICB1bnNhZmVfc2V0X2ludDY0IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9sZSBiIHggPVxuICBhZGRfaW50MTZfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50MTZfYmUgYiB4ID1cbiAgYWRkX2ludDE2X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXAxNiB4KVxuXG5sZXQgYWRkX2ludDMyX2xlIGIgeCA9XG4gIGFkZF9pbnQzMl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQzMl9iZSBiIHggPVxuICBhZGRfaW50MzJfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDMyIHgpXG5cbmxldCBhZGRfaW50NjRfbGUgYiB4ID1cbiAgYWRkX2ludDY0X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDY0X2JlIGIgeCA9XG4gIGFkZF9pbnQ2NF9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwNjQgeClcblxubGV0IGFkZF91aW50OCA9IGFkZF9pbnQ4XG5sZXQgYWRkX3VpbnQxNl9uZSA9IGFkZF9pbnQxNl9uZVxubGV0IGFkZF91aW50MTZfbGUgPSBhZGRfaW50MTZfbGVcbmxldCBhZGRfdWludDE2X2JlID0gYWRkX2ludDE2X2JlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIFhhdmllciBMZXJveSBhbmQgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG5sZXQga2ZwcmludGYgayBvIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBvIGFjYzsgayBvKSBFbmRfb2ZfYWNjIGZtdFxubGV0IGticHJpbnRmIGsgYiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IGJ1ZnB1dF9hY2MgYiBhY2M7IGsgYikgRW5kX29mX2FjYyBmbXRcbmxldCBpa2ZwcmludGYgayBvYyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIG9jIGZtdFxubGV0IGlrYnByaW50ZiA9IGlrZnByaW50ZlxuXG5sZXQgZnByaW50ZiBvYyBmbXQgPSBrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgYnByaW50ZiBiIGZtdCA9IGticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IGlmcHJpbnRmIG9jIGZtdCA9IGlrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgaWJwcmludGYgYiBmbXQgPSBpa2JwcmludGYgaWdub3JlIGIgZm10XG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3Rkb3V0IGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBzdGRlcnIgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGsnIGFjYyA9XG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgNjQgaW5cbiAgICBzdHJwdXRfYWNjIGJ1ZiBhY2M7XG4gICAgayAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXRcblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUga2V5ID0gc3RyaW5nXG50eXBlIGRvYyA9IHN0cmluZ1xudHlwZSB1c2FnZV9tc2cgPSBzdHJpbmdcbnR5cGUgYW5vbl9mdW4gPSAoc3RyaW5nIC0+IHVuaXQpXG5cbnR5cGUgc3BlYyA9XG4gIHwgVW5pdCBvZiAodW5pdCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB1bml0IGFyZ3VtZW50ICopXG4gIHwgQm9vbCBvZiAoYm9vbCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGJvb2wgYXJndW1lbnQgKilcbiAgfCBTZXQgb2YgYm9vbCByZWYgICAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0cnVlICopXG4gIHwgQ2xlYXIgb2YgYm9vbCByZWYgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gZmFsc2UgKilcbiAgfCBTdHJpbmcgb2YgKHN0cmluZyAtPiB1bml0KSAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgU2V0X3N0cmluZyBvZiBzdHJpbmcgcmVmICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IEludCBvZiAoaW50IC0+IHVuaXQpICAgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYW4gaW50IGFyZ3VtZW50ICopXG4gIHwgU2V0X2ludCBvZiBpbnQgcmVmICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGludCBhcmd1bWVudCAqKVxuICB8IEZsb2F0IG9mIChmbG9hdCAtPiB1bml0KSAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFNldF9mbG9hdCBvZiBmbG9hdCByZWYgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFR1cGxlIG9mIHNwZWMgbGlzdCAgICAgICAgICgqIFRha2Ugc2V2ZXJhbCBhcmd1bWVudHMgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWMgbGlzdCAqKVxuICB8IFN5bWJvbCBvZiBzdHJpbmcgbGlzdCAqIChzdHJpbmcgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUYWtlIG9uZSBvZiB0aGUgc3ltYm9scyBhcyBhcmd1bWVudCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBzeW1ib2wuICopXG4gIHwgUmVzdCBvZiAoc3RyaW5nIC0+IHVuaXQpICAgKCogU3RvcCBpbnRlcnByZXRpbmcga2V5d29yZHMgYW5kIGNhbGwgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gd2l0aCBlYWNoIHJlbWFpbmluZyBhcmd1bWVudCAqKVxuICB8IFJlc3RfYWxsIG9mIChzdHJpbmcgbGlzdCAtPiB1bml0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFN0b3AgaW50ZXJwcmV0aW5nIGtleXdvcmRzIGFuZCBjYWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdpdGggYWxsIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG4gIHwgRXhwYW5kIG9mIChzdHJpbmcgLT4gc3RyaW5nIGFycmF5KSAoKiBJZiB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cyB0byBwcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgb2YgdGhlIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtbXCItZm9vXCI7IFwiYXJnXCJdIEAgcmVzdF0gd2hlcmUgXCJmb29cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgcmVnaXN0ZXJlZCBhcyBbRXhwYW5kIGZdLCB0aGVuIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzIFtmIFwiYXJnXCIgQCByZXN0XSBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZC4gT25seSBhbGxvd2VkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNdLiAqKVxuXG5leGNlcHRpb24gQmFkIG9mIHN0cmluZ1xuZXhjZXB0aW9uIEhlbHAgb2Ygc3RyaW5nXG5cbnR5cGUgZXJyb3IgPVxuICB8IFVua25vd24gb2Ygc3RyaW5nXG4gIHwgV3Jvbmcgb2Ygc3RyaW5nICogc3RyaW5nICogc3RyaW5nICAoKiBvcHRpb24sIGFjdHVhbCwgZXhwZWN0ZWQgKilcbiAgfCBNaXNzaW5nIG9mIHN0cmluZ1xuICB8IE1lc3NhZ2Ugb2Ygc3RyaW5nXG5cbmV4Y2VwdGlvbiBTdG9wIG9mIGVycm9yICgqIHVzZWQgaW50ZXJuYWxseSAqKVxuXG5vcGVuIFByaW50ZlxuXG5sZXQgcmVjIGFzc29jMyB4IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoeTEsIHkyLCBfKSA6OiBfIHdoZW4geTEgPSB4IC0+IHkyXG4gIHwgXyA6OiB0IC0+IGFzc29jMyB4IHRcblxuXG5sZXQgc3BsaXQgcyA9XG4gIGxldCBpID0gU3RyaW5nLmluZGV4IHMgJz0nIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgU3RyaW5nLnN1YiBzIDAgaSwgU3RyaW5nLnN1YiBzIChpKzEpIChsZW4tKGkrMSkpXG5cblxubGV0IG1ha2Vfc3ltbGlzdCBwcmVmaXggc2VwIHN1ZmZpeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gXCI8bm9uZT5cIlxuICB8IGg6OnQgLT4gKExpc3QuZm9sZF9sZWZ0IChmdW4geCB5IC0+IHggXiBzZXAgXiB5KSAocHJlZml4IF4gaCkgdCkgXiBzdWZmaXhcblxuXG5sZXQgcHJpbnRfc3BlYyBidWYgKGtleSwgc3BlYywgZG9jKSA9XG4gIGlmIFN0cmluZy5sZW5ndGggZG9jID4gMCB0aGVuXG4gICAgbWF0Y2ggc3BlYyB3aXRoXG4gICAgfCBTeW1ib2wgKGwsIF8pIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlcyVzXFxuXCIga2V5IChtYWtlX3N5bWxpc3QgXCJ7XCIgXCJ8XCIgXCJ9XCIgbCkgZG9jXG4gICAgfCBfIC0+XG4gICAgICAgIGJwcmludGYgYnVmIFwiICAlcyAlc1xcblwiIGtleSBkb2NcblxuXG5sZXQgaGVscF9hY3Rpb24gKCkgPSByYWlzZSAoU3RvcCAoVW5rbm93biBcIi1oZWxwXCIpKVxuXG5sZXQgYWRkX2hlbHAgc3BlY2xpc3QgPVxuICBsZXQgYWRkMSA9XG4gICAgdHJ5IGlnbm9yZSAoYXNzb2MzIFwiLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgYW5kIGFkZDIgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi0taGVscFwiIHNwZWNsaXN0KTsgW11cbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgW1wiLS1oZWxwXCIsIFVuaXQgaGVscF9hY3Rpb24sIFwiIERpc3BsYXkgdGhpcyBsaXN0IG9mIG9wdGlvbnNcIl1cbiAgaW5cbiAgc3BlY2xpc3QgQCAoYWRkMSBAIGFkZDIpXG5cblxubGV0IHVzYWdlX2IgYnVmIHNwZWNsaXN0IGVycm1zZyA9XG4gIGJwcmludGYgYnVmIFwiJXNcXG5cIiBlcnJtc2c7XG4gIExpc3QuaXRlciAocHJpbnRfc3BlYyBidWYpIChhZGRfaGVscCBzcGVjbGlzdClcblxuXG5sZXQgdXNhZ2Vfc3RyaW5nIHNwZWNsaXN0IGVycm1zZyA9XG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgdXNhZ2VfYiBiIHNwZWNsaXN0IGVycm1zZztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuXG5sZXQgdXNhZ2Ugc3BlY2xpc3QgZXJybXNnID1cbiAgZXByaW50ZiBcIiVzXCIgKHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cpXG5cblxubGV0IGN1cnJlbnQgPSByZWYgMFxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoYm9vbF9vZl9zdHJpbmcgeClcbiAgd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gTm9uZVxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgeClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IGFsbG93X2V4cGFuZCBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1blxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJtc2cgPVxuICBsZXQgaW5pdHBvcyA9ICFjdXJyZW50IGluXG4gIGxldCBjb252ZXJ0X2Vycm9yIGVycm9yID1cbiAgICAoKiBjb252ZXJ0IGFuIGludGVybmFsIGVycm9yIHRvIGEgQmFkL0hlbHAgZXhjZXB0aW9uXG4gICAgICAgKm9yKiBhZGQgdGhlIHByb2dyYW0gbmFtZSBhcyBhIHByZWZpeCBhbmQgdGhlIHVzYWdlIG1lc3NhZ2UgYXMgYSBzdWZmaXhcbiAgICAgICB0byBhbiB1c2VyLXJhaXNlZCBCYWQgZXhjZXB0aW9uLlxuICAgICopXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICAgIGxldCBwcm9nbmFtZSA9XG4gICAgICBpZiBpbml0cG9zIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oaW5pdHBvcykgZWxzZSBcIig/KVwiIGluXG4gICAgYmVnaW4gbWF0Y2ggZXJyb3Igd2l0aFxuICAgICAgfCBVbmtub3duIFwiLWhlbHBcIiAtPiAoKVxuICAgICAgfCBVbmtub3duIFwiLS1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IHVua25vd24gb3B0aW9uICclcycuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBNaXNzaW5nIHMgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogb3B0aW9uICclcycgbmVlZHMgYW4gYXJndW1lbnQuXFxuXCIgcHJvZ25hbWUgc1xuICAgICAgfCBXcm9uZyAob3B0LCBhcmcsIGV4cGVjdGVkKSAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB3cm9uZyBhcmd1bWVudCAnJXMnOyBvcHRpb24gJyVzJyBleHBlY3RzICVzLlxcblwiXG4gICAgICAgICAgICAgICAgICBwcm9nbmFtZSBhcmcgb3B0IGV4cGVjdGVkXG4gICAgICB8IE1lc3NhZ2UgcyAtPiAoKiB1c2VyIGVycm9yIG1lc3NhZ2UgKilcbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogJXMuXFxuXCIgcHJvZ25hbWUgc1xuICAgIGVuZDtcbiAgICB1c2FnZV9iIGIgIXNwZWNsaXN0IGVycm1zZztcbiAgICBpZiBlcnJvciA9IFVua25vd24gXCItaGVscFwiIHx8IGVycm9yID0gVW5rbm93biBcIi0taGVscFwiXG4gICAgdGhlbiBIZWxwIChCdWZmZXIuY29udGVudHMgYilcbiAgICBlbHNlIEJhZCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gIGluXG4gIGluY3IgY3VycmVudDtcbiAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSBkb1xuICAgIGJlZ2luIHRyeVxuICAgICAgbGV0IHMgPSAhYXJndi4oIWN1cnJlbnQpIGluXG4gICAgICBpZiBTdHJpbmcubGVuZ3RoIHMgPj0gMSAmJiBzLlswXSA9ICctJyB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBhY3Rpb24sIGZvbGxvdyA9XG4gICAgICAgICAgdHJ5IGFzc29jMyBzICFzcGVjbGlzdCwgTm9uZVxuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBsZXQga2V5d29yZCwgYXJnID0gc3BsaXQgcyBpblxuICAgICAgICAgICAgYXNzb2MzIGtleXdvcmQgIXNwZWNsaXN0LCBTb21lIGFyZ1xuICAgICAgICAgIHdpdGggTm90X2ZvdW5kIC0+IHJhaXNlIChTdG9wIChVbmtub3duIHMpKVxuICAgICAgICBpblxuICAgICAgICBsZXQgbm9fYXJnICgpID1cbiAgICAgICAgICBtYXRjaCBmb2xsb3cgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwibm8gYXJndW1lbnRcIikpKSBpblxuICAgICAgICBsZXQgZ2V0X2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgaWYgIWN1cnJlbnQgKyAxIDwgKEFycmF5Lmxlbmd0aCAhYXJndikgdGhlbiAhYXJndi4oIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgICBlbHNlIHJhaXNlIChTdG9wIChNaXNzaW5nIHMpKVxuICAgICAgICAgIHwgU29tZSBhcmcgLT4gYXJnXG4gICAgICAgIGluXG4gICAgICAgIGxldCBjb25zdW1lX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gaW5jciBjdXJyZW50XG4gICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHJlYyB0cmVhdF9hY3Rpb24gPSBmdW5jdGlvblxuICAgICAgICB8IFVuaXQgZiAtPiBub19hcmcgKCk7IGYgKCk7XG4gICAgICAgIHwgQm9vbCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggYm9vbF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBib29sZWFuXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSBzIC0+IGYgc1xuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0IHIgLT4gbm9fYXJnICgpOyByIDo9IHRydWU7XG4gICAgICAgIHwgQ2xlYXIgciAtPiBub19hcmcgKCk7IHIgOj0gZmFsc2U7XG4gICAgICAgIHwgU3RyaW5nIGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFN5bWJvbCAoc3ltYiwgZikgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBpZiBMaXN0Lm1lbSBhcmcgc3ltYiB0aGVuIGJlZ2luXG4gICAgICAgICAgICAgIGYgYXJnO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm9uZSBvZjogXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF4gKG1ha2Vfc3ltbGlzdCBcIlwiIFwiIFwiIFwiXCIgc3ltYikpKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IFNldF9zdHJpbmcgciAtPlxuICAgICAgICAgICAgciA6PSBnZXRfYXJnICgpO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgSW50IGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfaW50IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBpbnRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImFuIGludGVnZXJcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gciA6PSB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBGbG9hdCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggZmxvYXRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgZmxvYXRcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gZiB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXRfZmxvYXQgciAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgVHVwbGUgc3BlY3MgLT5cbiAgICAgICAgICAgIG5vX2FyZyAoKTtcbiAgICAgICAgICAgIExpc3QuaXRlciB0cmVhdF9hY3Rpb24gc3BlY3M7XG4gICAgICAgIHwgUmVzdCBmIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICB3aGlsZSAhY3VycmVudCA8IChBcnJheS5sZW5ndGggIWFyZ3YpIC0gMSBkb1xuICAgICAgICAgICAgICBmICFhcmd2LighY3VycmVudCArIDEpO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGRvbmU7XG4gICAgICAgIHwgUmVzdF9hbGwgZiAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgbGV0IGFjYyA9IHJlZiBbXSBpblxuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCBBcnJheS5sZW5ndGggIWFyZ3YgLSAxIGRvXG4gICAgICAgICAgICAgIGFjYyA6PSAhYXJndi4oIWN1cnJlbnQgKyAxKSA6OiAhYWNjO1xuICAgICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGRvbmU7XG4gICAgICAgICAgICBmIChMaXN0LnJldiAhYWNjKVxuICAgICAgICB8IEV4cGFuZCBmIC0+XG4gICAgICAgICAgICBpZiBub3QgYWxsb3dfZXhwYW5kIHRoZW5cbiAgICAgICAgICAgICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJBcmcuRXhwYW5kIGlzIGlzIG9ubHkgYWxsb3dlZCB3aXRoIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcmcucGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNcIik7XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgbGV0IG5ld2FyZyA9IGYgYXJnIGluXG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBBcnJheS5zdWIgIWFyZ3YgMCAoIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgYW5kIGFmdGVyID1cbiAgICAgICAgICAgICAgQXJyYXkuc3ViICFhcmd2ICghY3VycmVudCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAoKEFycmF5Lmxlbmd0aCAhYXJndikgLSAhY3VycmVudCAtIDEpIGluXG4gICAgICAgICAgICBhcmd2Oj0gQXJyYXkuY29uY2F0IFtiZWZvcmU7bmV3YXJnO2FmdGVyXTtcbiAgICAgICAgaW5cbiAgICAgICAgdHJlYXRfYWN0aW9uIGFjdGlvbiBlbmRcbiAgICAgIGVsc2UgYW5vbmZ1biBzXG4gICAgd2l0aCB8IEJhZCBtIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIChNZXNzYWdlIG0pKTtcbiAgICAgICAgIHwgU3RvcCBlIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIGUpO1xuICAgIGVuZDtcbiAgICBpbmNyIGN1cnJlbnRcbiAgZG9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IHRydWUgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnXG5cbmxldCBwYXJzZV9hcmd2X2R5bmFtaWMgPyhjdXJyZW50PWN1cnJlbnQpIGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggZmFsc2UgY3VycmVudCAocmVmIGFyZ3YpIHNwZWNsaXN0IGFub25mdW5cbiAgICBlcnJtc2dcblxuXG5sZXQgcGFyc2VfYXJndiA/KGN1cnJlbnQ9Y3VycmVudCkgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FyZ3ZfZHluYW1pYyB+Y3VycmVudDpjdXJyZW50IGFyZ3YgKHJlZiBzcGVjbGlzdCkgYW5vbmZ1biBlcnJtc2dcblxuXG5sZXQgcGFyc2UgbCBmIG1zZyA9XG4gIHRyeVxuICAgIHBhcnNlX2FyZ3YgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgcGFyc2VfZHluYW1pYyBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndl9keW5hbWljIFN5cy5hcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cbmxldCBwYXJzZV9leHBhbmQgbCBmIG1zZyA9XG4gIHRyeVxuICAgIGxldCBhcmd2ID0gcmVmIFN5cy5hcmd2IGluXG4gICAgbGV0IHNwZWMgPSByZWYgbCBpblxuICAgIGxldCBjdXJyZW50ID0gcmVmICghY3VycmVudCkgaW5cbiAgICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyBjdXJyZW50IGFyZ3Ygc3BlYyBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgc2Vjb25kX3dvcmQgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIG4gPVxuICAgIGlmIG4gPj0gbGVuIHRoZW4gbGVuXG4gICAgZWxzZSBpZiBzLltuXSA9ICcgJyB0aGVuIGxvb3AgKG4rMSlcbiAgICBlbHNlIG5cbiAgaW5cbiAgbWF0Y2ggU3RyaW5nLmluZGV4IHMgJ1xcdCcgd2l0aFxuICB8IG4gLT4gbG9vcCAobisxKVxuICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAgIGJlZ2luIG1hdGNoIFN0cmluZy5pbmRleCBzICcgJyB3aXRoXG4gICAgICB8IG4gLT4gbG9vcCAobisxKVxuICAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IGxlblxuICAgICAgZW5kXG5cblxubGV0IG1heF9hcmdfbGVuIGN1ciAoa3dkLCBzcGVjLCBkb2MpID1cbiAgbWF0Y2ggc3BlYyB3aXRoXG4gIHwgU3ltYm9sIF8gLT4gbWF4IGN1ciAoU3RyaW5nLmxlbmd0aCBrd2QpXG4gIHwgXyAtPiBtYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZCArIHNlY29uZF93b3JkIGRvYylcblxuXG5sZXQgcmVwbGFjZV9sZWFkaW5nX3RhYiBzID1cbiAgbGV0IHNlZW4gPSByZWYgZmFsc2UgaW5cbiAgU3RyaW5nLm1hcCAoZnVuY3Rpb24gJ1xcdCcgd2hlbiBub3QgIXNlZW4gLT4gc2VlbiA6PSB0cnVlOyAnICcgfCBjIC0+IGMpIHNcblxubGV0IGFkZF9wYWRkaW5nIGxlbiBrc2QgPVxuICBtYXRjaCBrc2Qgd2l0aFxuICB8IChfLCBfLCBcIlwiKSAtPlxuICAgICAgKCogRG8gbm90IHBhZCB1bmRvY3VtZW50ZWQgb3B0aW9ucywgc28gdGhhdCB0aGV5IHN0aWxsIGRvbid0IHNob3cgdXAgd2hlblxuICAgICAgICogcnVuIHRocm91Z2ggW3VzYWdlXSBvciBbcGFyc2VdLiAqKVxuICAgICAga3NkXG4gIHwgKGt3ZCwgKFN5bWJvbCBfIGFzIHNwZWMpLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgKChtYXggMCAobGVuIC0gY3V0Y29sKSkgKyAzKSAnICcgaW5cbiAgICAgIChrd2QsIHNwZWMsIFwiXFxuXCIgXiBzcGFjZXMgXiByZXBsYWNlX2xlYWRpbmdfdGFiIG1zZylcbiAgfCAoa3dkLCBzcGVjLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQga3dkX2xlbiA9IFN0cmluZy5sZW5ndGgga3dkIGluXG4gICAgICBsZXQgZGlmZiA9IGxlbiAtIGt3ZF9sZW4gLSBjdXRjb2wgaW5cbiAgICAgIGlmIGRpZmYgPD0gMCB0aGVuXG4gICAgICAgIChrd2QsIHNwZWMsIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgZGlmZiAnICcgaW5cbiAgICAgICAgbGV0IHByZWZpeCA9IFN0cmluZy5zdWIgKHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKSAwIGN1dGNvbCBpblxuICAgICAgICBsZXQgc3VmZml4ID0gU3RyaW5nLnN1YiBtc2cgY3V0Y29sIChTdHJpbmcubGVuZ3RoIG1zZyAtIGN1dGNvbCkgaW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcHJlZml4IF4gc3BhY2VzIF4gc3VmZml4KVxuXG5cbmxldCBhbGlnbiA/KGxpbWl0PW1heF9pbnQpIHNwZWNsaXN0ID1cbiAgbGV0IGNvbXBsZXRlZCA9IGFkZF9oZWxwIHNwZWNsaXN0IGluXG4gIGxldCBsZW4gPSBMaXN0LmZvbGRfbGVmdCBtYXhfYXJnX2xlbiAwIGNvbXBsZXRlZCBpblxuICBsZXQgbGVuID0gbWluIGxlbiBsaW1pdCBpblxuICBMaXN0Lm1hcCAoYWRkX3BhZGRpbmcgbGVuKSBjb21wbGV0ZWRcblxubGV0IHRyaW1fY3IgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgaWYgbGVuID4gMCAmJiBTdHJpbmcuZ2V0IHMgKGxlbiAtIDEpID0gJ1xccicgdGhlblxuICAgIFN0cmluZy5zdWIgcyAwIChsZW4gLSAxKVxuICBlbHNlXG4gICAgc1xuXG5sZXQgcmVhZF9hdXggdHJpbSBzZXAgZmlsZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGUgaW5cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIGxldCB3b3JkcyA9IHJlZiBbXSBpblxuICBsZXQgc3Rhc2ggKCkgPVxuICAgIGxldCB3b3JkID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICAgIGxldCB3b3JkID0gaWYgdHJpbSB0aGVuIHRyaW1fY3Igd29yZCBlbHNlIHdvcmQgaW5cbiAgICB3b3JkcyA6PSB3b3JkIDo6ICF3b3JkcztcbiAgICBCdWZmZXIuY2xlYXIgYnVmXG4gIGluXG4gIGJlZ2luXG4gICAgdHJ5IHdoaWxlIHRydWUgZG9cbiAgICAgICAgbGV0IGMgPSBpbnB1dF9jaGFyIGljIGluXG4gICAgICAgIGlmIGMgPSBzZXAgdGhlbiBzdGFzaCAoKSBlbHNlIEJ1ZmZlci5hZGRfY2hhciBidWYgY1xuICAgICAgZG9uZVxuICAgIHdpdGggRW5kX29mX2ZpbGUgLT4gKClcbiAgZW5kO1xuICBpZiBCdWZmZXIubGVuZ3RoIGJ1ZiA+IDAgdGhlbiBzdGFzaCAoKTtcbiAgY2xvc2VfaW4gaWM7XG4gIEFycmF5Lm9mX2xpc3QgKExpc3QucmV2ICF3b3JkcylcblxubGV0IHJlYWRfYXJnID0gcmVhZF9hdXggdHJ1ZSAnXFxuJ1xuXG5sZXQgcmVhZF9hcmcwID0gcmVhZF9hdXggZmFsc2UgJ1xceDAwJ1xuXG5sZXQgd3JpdGVfYXV4IHNlcCBmaWxlIGFyZ3MgPVxuICBsZXQgb2MgPSBvcGVuX291dF9iaW4gZmlsZSBpblxuICBBcnJheS5pdGVyIChmdW4gcyAtPiBmcHJpbnRmIG9jIFwiJXMlY1wiIHMgc2VwKSBhcmdzO1xuICBjbG9zZV9vdXQgb2NcblxubGV0IHdyaXRlX2FyZyA9IHdyaXRlX2F1eCAnXFxuJ1xuXG5sZXQgd3JpdGVfYXJnMCA9IHdyaXRlX2F1eCAnXFx4MDAnXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGlkIDogJ2EgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5sZXQgY29uc3QgYyBfID0gY1xubGV0IGZsaXAgZiB4IHkgPSBmIHkgeFxubGV0IG5lZ2F0ZSBwIHYgPSBub3QgKHAgdilcblxuZXhjZXB0aW9uIEZpbmFsbHlfcmFpc2VkIG9mIGV4blxuXG5sZXQgKCkgPSBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIEBAIGZ1bmN0aW9uXG58IEZpbmFsbHlfcmFpc2VkIGV4biAtPiBTb21lIChcIkZ1bi5GaW5hbGx5X3JhaXNlZDogXCIgXiBQcmludGV4Yy50b19zdHJpbmcgZXhuKVxufCBfIC0+IE5vbmVcblxubGV0IHByb3RlY3QgfihmaW5hbGx5IDogdW5pdCAtPiB1bml0KSB3b3JrID1cbiAgbGV0IGZpbmFsbHlfbm9fZXhuICgpID1cbiAgICB0cnkgZmluYWxseSAoKSB3aXRoIGUgLT5cbiAgICAgIGxldCBidCA9IFByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBQcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSAoRmluYWxseV9yYWlzZWQgZSkgYnRcbiAgaW5cbiAgbWF0Y2ggd29yayAoKSB3aXRoXG4gIHwgcmVzdWx0IC0+IGZpbmFsbHlfbm9fZXhuICgpIDsgcmVzdWx0XG4gIHwgZXhjZXB0aW9uIHdvcmtfZXhuIC0+XG4gICAgICBsZXQgd29ya19idCA9IFByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBmaW5hbGx5X25vX2V4biAoKSA7XG4gICAgICBQcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSB3b3JrX2V4biB3b3JrX2J0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIEphY3F1ZXMtSGVucmkgSm91cmRhbiwgcHJvamV0IEdhbGxpdW0sIElOUklBIFBhcmlzICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2LTIwMTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSAgICopXG4oKiAgICAgZXQgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgc3RhdCA9IHtcbiAgbWlub3Jfd29yZHMgOiBmbG9hdDtcbiAgcHJvbW90ZWRfd29yZHMgOiBmbG9hdDtcbiAgbWFqb3Jfd29yZHMgOiBmbG9hdDtcbiAgbWlub3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIG1ham9yX2NvbGxlY3Rpb25zIDogaW50O1xuICBoZWFwX3dvcmRzIDogaW50O1xuICBoZWFwX2NodW5rcyA6IGludDtcbiAgbGl2ZV93b3JkcyA6IGludDtcbiAgbGl2ZV9ibG9ja3MgOiBpbnQ7XG4gIGZyZWVfd29yZHMgOiBpbnQ7XG4gIGZyZWVfYmxvY2tzIDogaW50O1xuICBsYXJnZXN0X2ZyZWUgOiBpbnQ7XG4gIGZyYWdtZW50cyA6IGludDtcbiAgY29tcGFjdGlvbnMgOiBpbnQ7XG4gIHRvcF9oZWFwX3dvcmRzIDogaW50O1xuICBzdGFja19zaXplIDogaW50O1xuICBmb3JjZWRfbWFqb3JfY29sbGVjdGlvbnM6IGludDtcbn1cblxudHlwZSBjb250cm9sID0ge1xuICBtdXRhYmxlIG1pbm9yX2hlYXBfc2l6ZSA6IGludDtcbiAgbXV0YWJsZSBtYWpvcl9oZWFwX2luY3JlbWVudCA6IGludDtcbiAgbXV0YWJsZSBzcGFjZV9vdmVyaGVhZCA6IGludDtcbiAgbXV0YWJsZSB2ZXJib3NlIDogaW50O1xuICBtdXRhYmxlIG1heF9vdmVyaGVhZCA6IGludDtcbiAgbXV0YWJsZSBzdGFja19saW1pdCA6IGludDtcbiAgbXV0YWJsZSBhbGxvY2F0aW9uX3BvbGljeSA6IGludDtcbiAgd2luZG93X3NpemUgOiBpbnQ7XG4gIGN1c3RvbV9tYWpvcl9yYXRpbyA6IGludDtcbiAgY3VzdG9tX21pbm9yX3JhdGlvIDogaW50O1xuICBjdXN0b21fbWlub3JfbWF4X3NpemUgOiBpbnQ7XG59XG5cbmV4dGVybmFsIHN0YXQgOiB1bml0IC0+IHN0YXQgPSBcImNhbWxfZ2Nfc3RhdFwiXG5leHRlcm5hbCBxdWlja19zdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3F1aWNrX3N0YXRcIlxuZXh0ZXJuYWwgY291bnRlcnMgOiB1bml0IC0+IChmbG9hdCAqIGZsb2F0ICogZmxvYXQpID0gXCJjYW1sX2djX2NvdW50ZXJzXCJcbmV4dGVybmFsIG1pbm9yX3dvcmRzIDogdW5pdCAtPiAoZmxvYXQgW0B1bmJveGVkXSlcbiAgPSBcImNhbWxfZ2NfbWlub3Jfd29yZHNcIiBcImNhbWxfZ2NfbWlub3Jfd29yZHNfdW5ib3hlZFwiXG5leHRlcm5hbCBnZXQgOiB1bml0IC0+IGNvbnRyb2wgPSBcImNhbWxfZ2NfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGNvbnRyb2wgLT4gdW5pdCA9IFwiY2FtbF9nY19zZXRcIlxuZXh0ZXJuYWwgbWlub3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWlub3JcIlxuZXh0ZXJuYWwgbWFqb3Jfc2xpY2UgOiBpbnQgLT4gaW50ID0gXCJjYW1sX2djX21ham9yX3NsaWNlXCJcbmV4dGVybmFsIG1ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21ham9yXCJcbmV4dGVybmFsIGZ1bGxfbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfZnVsbF9tYWpvclwiXG5leHRlcm5hbCBjb21wYWN0IDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2NvbXBhY3Rpb25cIlxuZXh0ZXJuYWwgZ2V0X21pbm9yX2ZyZWUgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWlub3JfZnJlZVwiXG5leHRlcm5hbCBnZXRfYnVja2V0IDogaW50IC0+IGludCA9IFwiY2FtbF9nZXRfbWFqb3JfYnVja2V0XCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGdldF9jcmVkaXQgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nZXRfbWFqb3JfY3JlZGl0XCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGh1Z2VfZmFsbGJhY2tfY291bnQgOiB1bml0IC0+IGludCA9IFwiY2FtbF9nY19odWdlX2ZhbGxiYWNrX2NvdW50XCJcbmV4dGVybmFsIGV2ZW50bG9nX3BhdXNlIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2V2ZW50bG9nX3BhdXNlXCJcbmV4dGVybmFsIGV2ZW50bG9nX3Jlc3VtZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9ldmVudGxvZ19yZXN1bWVcIlxuXG5vcGVuIFByaW50ZlxuXG5sZXQgcHJpbnRfc3RhdCBjID1cbiAgbGV0IHN0ID0gc3RhdCAoKSBpblxuICBmcHJpbnRmIGMgXCJtaW5vcl9jb2xsZWN0aW9uczogICAgICAlZFxcblwiIHN0Lm1pbm9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJtYWpvcl9jb2xsZWN0aW9uczogICAgICAlZFxcblwiIHN0Lm1ham9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJjb21wYWN0aW9uczogICAgICAgICAgICAlZFxcblwiIHN0LmNvbXBhY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJmb3JjZWRfbWFqb3JfY29sbGVjdGlvbnM6ICVkXFxuXCIgc3QuZm9yY2VkX21ham9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgbGV0IGwxID0gU3RyaW5nLmxlbmd0aCAoc3ByaW50ZiBcIiUuMGZcIiBzdC5taW5vcl93b3JkcykgaW5cbiAgZnByaW50ZiBjIFwibWlub3Jfd29yZHM6ICAgICUqLjBmXFxuXCIgbDEgc3QubWlub3Jfd29yZHM7XG4gIGZwcmludGYgYyBcInByb21vdGVkX3dvcmRzOiAlKi4wZlxcblwiIGwxIHN0LnByb21vdGVkX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJtYWpvcl93b3JkczogICAgJSouMGZcXG5cIiBsMSBzdC5tYWpvcl93b3JkcztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGxldCBsMiA9IFN0cmluZy5sZW5ndGggKHNwcmludGYgXCIlZFwiIHN0LnRvcF9oZWFwX3dvcmRzKSBpblxuICBmcHJpbnRmIGMgXCJ0b3BfaGVhcF93b3JkczogJSpkXFxuXCIgbDIgc3QudG9wX2hlYXBfd29yZHM7XG4gIGZwcmludGYgYyBcImhlYXBfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5oZWFwX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJsaXZlX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QubGl2ZV93b3JkcztcbiAgZnByaW50ZiBjIFwiZnJlZV93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmZyZWVfd29yZHM7XG4gIGZwcmludGYgYyBcImxhcmdlc3RfZnJlZTogICAlKmRcXG5cIiBsMiBzdC5sYXJnZXN0X2ZyZWU7XG4gIGZwcmludGYgYyBcImZyYWdtZW50czogICAgICAlKmRcXG5cIiBsMiBzdC5mcmFnbWVudHM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBmcHJpbnRmIGMgXCJsaXZlX2Jsb2NrczogJWRcXG5cIiBzdC5saXZlX2Jsb2NrcztcbiAgZnByaW50ZiBjIFwiZnJlZV9ibG9ja3M6ICVkXFxuXCIgc3QuZnJlZV9ibG9ja3M7XG4gIGZwcmludGYgYyBcImhlYXBfY2h1bmtzOiAlZFxcblwiIHN0LmhlYXBfY2h1bmtzXG5cblxubGV0IGFsbG9jYXRlZF9ieXRlcyAoKSA9XG4gIGxldCAobWksIHBybywgbWEpID0gY291bnRlcnMgKCkgaW5cbiAgKG1pICsuIG1hIC0uIHBybykgKi4gZmxvYXRfb2ZfaW50IChTeXMud29yZF9zaXplIC8gOClcblxuXG5leHRlcm5hbCBmaW5hbGlzZSA6ICgnYSAtPiB1bml0KSAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2ZpbmFsX3JlZ2lzdGVyXCJcbmV4dGVybmFsIGZpbmFsaXNlX2xhc3QgOiAodW5pdCAtPiB1bml0KSAtPiAnYSAtPiB1bml0ID1cbiAgXCJjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlXCJcbmV4dGVybmFsIGZpbmFsaXNlX3JlbGVhc2UgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZmluYWxfcmVsZWFzZVwiXG5cblxudHlwZSBhbGFybSA9IGJvb2wgcmVmXG50eXBlIGFsYXJtX3JlYyA9IHthY3RpdmUgOiBhbGFybTsgZiA6IHVuaXQgLT4gdW5pdH1cblxubGV0IHJlYyBjYWxsX2FsYXJtIGFyZWMgPVxuICBpZiAhKGFyZWMuYWN0aXZlKSB0aGVuIGJlZ2luXG4gICAgZmluYWxpc2UgY2FsbF9hbGFybSBhcmVjO1xuICAgIGFyZWMuZiAoKTtcbiAgZW5kXG5cblxubGV0IGNyZWF0ZV9hbGFybSBmID1cbiAgbGV0IGFyZWMgPSB7IGFjdGl2ZSA9IHJlZiB0cnVlOyBmID0gZiB9IGluXG4gIGZpbmFsaXNlIGNhbGxfYWxhcm0gYXJlYztcbiAgYXJlYy5hY3RpdmVcblxuXG5sZXQgZGVsZXRlX2FsYXJtIGEgPSBhIDo9IGZhbHNlXG5cbm1vZHVsZSBNZW1wcm9mID1cbiAgc3RydWN0XG4gICAgdHlwZSBhbGxvY2F0aW9uX3NvdXJjZSA9IE5vcm1hbCB8IE1hcnNoYWwgfCBDdXN0b21cbiAgICB0eXBlIGFsbG9jYXRpb24gPVxuICAgICAgeyBuX3NhbXBsZXMgOiBpbnQ7XG4gICAgICAgIHNpemUgOiBpbnQ7XG4gICAgICAgIHNvdXJjZSA6IGFsbG9jYXRpb25fc291cmNlO1xuICAgICAgICBjYWxsc3RhY2sgOiBQcmludGV4Yy5yYXdfYmFja3RyYWNlIH1cblxuICAgIHR5cGUgKCdtaW5vciwgJ21ham9yKSB0cmFja2VyID0ge1xuICAgICAgYWxsb2NfbWlub3I6IGFsbG9jYXRpb24gLT4gJ21pbm9yIG9wdGlvbjtcbiAgICAgIGFsbG9jX21ham9yOiBhbGxvY2F0aW9uIC0+ICdtYWpvciBvcHRpb247XG4gICAgICBwcm9tb3RlOiAnbWlub3IgLT4gJ21ham9yIG9wdGlvbjtcbiAgICAgIGRlYWxsb2NfbWlub3I6ICdtaW5vciAtPiB1bml0O1xuICAgICAgZGVhbGxvY19tYWpvcjogJ21ham9yIC0+IHVuaXQ7XG4gICAgfVxuXG4gICAgbGV0IG51bGxfdHJhY2tlciA9IHtcbiAgICAgIGFsbG9jX21pbm9yID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgYWxsb2NfbWFqb3IgPSAoZnVuIF8gLT4gTm9uZSk7XG4gICAgICBwcm9tb3RlID0gKGZ1biBfIC0+IE5vbmUpO1xuICAgICAgZGVhbGxvY19taW5vciA9IChmdW4gXyAtPiAoKSk7XG4gICAgICBkZWFsbG9jX21ham9yID0gKGZ1biBfIC0+ICgpKTtcbiAgICB9XG5cbiAgICBleHRlcm5hbCBjX3N0YXJ0IDpcbiAgICAgIGZsb2F0IC0+IGludCAtPiAoJ21pbm9yLCAnbWFqb3IpIHRyYWNrZXIgLT4gdW5pdFxuICAgICAgPSBcImNhbWxfbWVtcHJvZl9zdGFydFwiXG5cbiAgICBsZXQgc3RhcnRcbiAgICAgIH5zYW1wbGluZ19yYXRlXG4gICAgICA/KGNhbGxzdGFja19zaXplID0gbWF4X2ludClcbiAgICAgIHRyYWNrZXIgPVxuICAgICAgY19zdGFydCBzYW1wbGluZ19yYXRlIGNhbGxzdGFja19zaXplIHRyYWNrZXJcblxuICAgIGV4dGVybmFsIHN0b3AgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfbWVtcHJvZl9zdG9wXCJcbiAgZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1lc3NhZ2UgZGlnZXN0IChNRDUpICopXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSA9IFN0cmluZy5jb21wYXJlXG5sZXQgZXF1YWwgPSBTdHJpbmcuZXF1YWxcblxuZXh0ZXJuYWwgdW5zYWZlX3N0cmluZzogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfc3RyaW5nXCJcbmV4dGVybmFsIGNoYW5uZWw6IGluX2NoYW5uZWwgLT4gaW50IC0+IHQgPSBcImNhbWxfbWQ1X2NoYW5cIlxuXG5sZXQgc3RyaW5nIHN0ciA9XG4gIHVuc2FmZV9zdHJpbmcgc3RyIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG5sZXQgYnl0ZXMgYiA9IHN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKVxuXG5sZXQgc3Vic3RyaW5nIHN0ciBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IFN0cmluZy5sZW5ndGggc3RyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3Quc3Vic3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfc3RyaW5nIHN0ciBvZnMgbGVuXG5cbmxldCBzdWJieXRlcyBiIG9mcyBsZW4gPSBzdWJzdHJpbmcgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgYikgb2ZzIGxlblxuXG5sZXQgZmlsZSBmaWxlbmFtZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGVuYW1lIGluXG4gIG1hdGNoIGNoYW5uZWwgaWMgKC0xKSB3aXRoXG4gICAgfCBkIC0+IGNsb3NlX2luIGljOyBkXG4gICAgfCBleGNlcHRpb24gZSAtPiBjbG9zZV9pbiBpYzsgcmFpc2UgZVxuXG5sZXQgb3V0cHV0IGNoYW4gZGlnZXN0ID1cbiAgb3V0cHV0X3N0cmluZyBjaGFuIGRpZ2VzdFxuXG5sZXQgaW5wdXQgY2hhbiA9IHJlYWxseV9pbnB1dF9zdHJpbmcgY2hhbiAxNlxuXG5sZXQgY2hhcl9oZXggbiA9XG4gIENoYXIudW5zYWZlX2NociAobiArIGlmIG4gPCAxMCB0aGVuIENoYXIuY29kZSAnMCcgZWxzZSAoQ2hhci5jb2RlICdhJyAtIDEwKSlcblxubGV0IHRvX2hleCBkID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBkIDw+IDE2IHRoZW4gaW52YWxpZF9hcmcgXCJEaWdlc3QudG9faGV4XCI7XG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMzIgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgbGV0IHggPSBDaGFyLmNvZGUgZC5baV0gaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKSAoY2hhcl9oZXggKHggbHNyIDQpKTtcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlc3VsdCAoaSoyKzEpIChjaGFyX2hleCAoeCBsYW5kIDB4MGYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcblxubGV0IGZyb21faGV4IHMgPVxuICBpZiBTdHJpbmcubGVuZ3RoIHMgPD4gMzIgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5mcm9tX2hleFwiO1xuICBsZXQgZGlnaXQgYyA9XG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnMCcuLic5JyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnMCdcbiAgICB8ICdBJy4uJ0YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdBJyArIDEwXG4gICAgfCAnYScuLidmJyAtPiBDaGFyLmNvZGUgYyAtIENoYXIuY29kZSAnYScgKyAxMFxuICAgIHwgXyAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkRpZ2VzdC5mcm9tX2hleFwiKVxuICBpblxuICBsZXQgYnl0ZSBpID0gZGlnaXQgcy5baV0gbHNsIDQgKyBkaWdpdCBzLltpKzFdIGluXG4gIGxldCByZXN1bHQgPSBCeXRlcy5jcmVhdGUgMTYgaW5cbiAgZm9yIGkgPSAwIHRvIDE1IGRvXG4gICAgQnl0ZXMuc2V0IHJlc3VsdCBpIChDaGFyLmNociAoYnl0ZSAoMiAqIGkpKSk7XG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzdWx0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvclxuICAgVGhpcyBpcyBhIGxhZ2dlZC1GaWJvbmFjY2kgRig1NSwgMjQsICspIHdpdGggYSBtb2RpZmllZCBhZGRpdGlvblxuICAgZnVuY3Rpb24gdG8gZW5oYW5jZSB0aGUgbWl4aW5nIG9mIGJpdHMuXG4gICBJZiB3ZSB1c2Ugbm9ybWFsIGFkZGl0aW9uLCB0aGUgbG93LW9yZGVyIGJpdCBmYWlscyB0ZXN0cyAxIGFuZCA3XG4gICBvZiB0aGUgRGllaGFyZCB0ZXN0IHN1aXRlLCBhbmQgYml0cyAxIGFuZCAyIGFsc28gZmFpbCB0ZXN0IDcuXG4gICBJZiB3ZSB1c2UgbXVsdGlwbGljYXRpb24gYXMgc3VnZ2VzdGVkIGJ5IE1hcnNhZ2xpYSwgaXQgZG9lc24ndCBmYXJlXG4gICBtdWNoIGJldHRlci5cbiAgIEJ5IG1peGluZyB0aGUgYml0cyBvZiBvbmUgb2YgdGhlIG51bWJlcnMgYmVmb3JlIGFkZGl0aW9uIChYT1IgdGhlXG4gICA1IGhpZ2gtb3JkZXIgYml0cyBpbnRvIHRoZSBsb3ctb3JkZXIgYml0cyksIHdlIGdldCBhIGdlbmVyYXRvciB0aGF0XG4gICBwYXNzZXMgYWxsIHRoZSBEaWVoYXJkIHRlc3RzLlxuKilcblxuZXh0ZXJuYWwgcmFuZG9tX3NlZWQ6IHVuaXQgLT4gaW50IGFycmF5ID0gXCJjYW1sX3N5c19yYW5kb21fc2VlZFwiXG5cbm1vZHVsZSBTdGF0ZSA9IHN0cnVjdFxuXG4gIHR5cGUgdCA9IHsgc3QgOiBpbnQgYXJyYXk7IG11dGFibGUgaWR4IDogaW50IH1cblxuICBsZXQgbmV3X3N0YXRlICgpID0geyBzdCA9IEFycmF5Lm1ha2UgNTUgMDsgaWR4ID0gMCB9XG4gIGxldCBhc3NpZ24gc3QxIHN0MiA9XG4gICAgQXJyYXkuYmxpdCBzdDIuc3QgMCBzdDEuc3QgMCA1NTtcbiAgICBzdDEuaWR4IDwtIHN0Mi5pZHhcblxuXG4gIGxldCBmdWxsX2luaXQgcyBzZWVkID1cbiAgICBsZXQgY29tYmluZSBhY2N1IHggPSBEaWdlc3Quc3RyaW5nIChhY2N1IF4gSW50LnRvX3N0cmluZyB4KSBpblxuICAgIGxldCBleHRyYWN0IGQgPVxuICAgICAgQ2hhci5jb2RlIGQuWzBdICsgKENoYXIuY29kZSBkLlsxXSBsc2wgOCkgKyAoQ2hhci5jb2RlIGQuWzJdIGxzbCAxNilcbiAgICAgICsgKENoYXIuY29kZSBkLlszXSBsc2wgMjQpXG4gICAgaW5cbiAgICBsZXQgc2VlZCA9IGlmIEFycmF5Lmxlbmd0aCBzZWVkID0gMCB0aGVuIFt8IDAgfF0gZWxzZSBzZWVkIGluXG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGggc2VlZCBpblxuICAgIGZvciBpID0gMCB0byA1NCBkb1xuICAgICAgcy5zdC4oaSkgPC0gaTtcbiAgICBkb25lO1xuICAgIGxldCBhY2N1ID0gcmVmIFwieFwiIGluXG4gICAgZm9yIGkgPSAwIHRvIDU0ICsgbWF4IDU1IGwgZG9cbiAgICAgIGxldCBqID0gaSBtb2QgNTUgaW5cbiAgICAgIGxldCBrID0gaSBtb2QgbCBpblxuICAgICAgYWNjdSA6PSBjb21iaW5lICFhY2N1IHNlZWQuKGspO1xuICAgICAgcy5zdC4oaikgPC0gKHMuc3QuKGopIGx4b3IgZXh0cmFjdCAhYWNjdSkgbGFuZCAweDNGRkZGRkZGOyAgKCogUFIjNTU3NSAqKVxuICAgIGRvbmU7XG4gICAgcy5pZHggPC0gMFxuXG5cbiAgbGV0IG1ha2Ugc2VlZCA9XG4gICAgbGV0IHJlc3VsdCA9IG5ld19zdGF0ZSAoKSBpblxuICAgIGZ1bGxfaW5pdCByZXN1bHQgc2VlZDtcbiAgICByZXN1bHRcblxuXG4gIGxldCBtYWtlX3NlbGZfaW5pdCAoKSA9IG1ha2UgKHJhbmRvbV9zZWVkICgpKVxuXG4gIGxldCBjb3B5IHMgPVxuICAgIGxldCByZXN1bHQgPSBuZXdfc3RhdGUgKCkgaW5cbiAgICBhc3NpZ24gcmVzdWx0IHM7XG4gICAgcmVzdWx0XG5cblxuICAoKiBSZXR1cm5zIDMwIHJhbmRvbSBiaXRzIGFzIGFuIGludGVnZXIgMCA8PSB4IDwgMTA3Mzc0MTgyNCAqKVxuICBsZXQgYml0cyBzID1cbiAgICBzLmlkeCA8LSAocy5pZHggKyAxKSBtb2QgNTU7XG4gICAgbGV0IGN1cnZhbCA9IHMuc3QuKHMuaWR4KSBpblxuICAgIGxldCBuZXd2YWwgPSBzLnN0Ligocy5pZHggKyAyNCkgbW9kIDU1KVxuICAgICAgICAgICAgICAgICArIChjdXJ2YWwgbHhvciAoKGN1cnZhbCBsc3IgMjUpIGxhbmQgMHgxRikpIGluXG4gICAgbGV0IG5ld3ZhbDMwID0gbmV3dmFsIGxhbmQgMHgzRkZGRkZGRiBpbiAgKCogUFIjNTU3NSAqKVxuICAgIHMuc3QuKHMuaWR4KSA8LSBuZXd2YWwzMDtcbiAgICBuZXd2YWwzMFxuXG5cbiAgbGV0IHJlYyBpbnRhdXggcyBuID1cbiAgICBsZXQgciA9IGJpdHMgcyBpblxuICAgIGxldCB2ID0gciBtb2QgbiBpblxuICAgIGlmIHIgLSB2ID4gMHgzRkZGRkZGRiAtIG4gKyAxIHRoZW4gaW50YXV4IHMgbiBlbHNlIHZcblxuICBsZXQgaW50IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kID4gMHgzRkZGRkZGRiB8fCBib3VuZCA8PSAwXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnRcIlxuICAgIGVsc2UgaW50YXV4IHMgYm91bmRcblxuXG4gIGxldCByZWMgaW50MzJhdXggcyBuID1cbiAgICBsZXQgYjEgPSBJbnQzMi5vZl9pbnQgKGJpdHMgcykgaW5cbiAgICBsZXQgYjIgPSBJbnQzMi5zaGlmdF9sZWZ0IChJbnQzMi5vZl9pbnQgKGJpdHMgcyBsYW5kIDEpKSAzMCBpblxuICAgIGxldCByID0gSW50MzIubG9nb3IgYjEgYjIgaW5cbiAgICBsZXQgdiA9IEludDMyLnJlbSByIG4gaW5cbiAgICBpZiBJbnQzMi5zdWIgciB2ID4gSW50MzIuYWRkIChJbnQzMi5zdWIgSW50MzIubWF4X2ludCBuKSAxbFxuICAgIHRoZW4gaW50MzJhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDMyIHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBsXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQzMlwiXG4gICAgZWxzZSBpbnQzMmF1eCBzIGJvdW5kXG5cblxuICBsZXQgcmVjIGludDY0YXV4IHMgbiA9XG4gICAgbGV0IGIxID0gSW50NjQub2ZfaW50IChiaXRzIHMpIGluXG4gICAgbGV0IGIyID0gSW50NjQuc2hpZnRfbGVmdCAoSW50NjQub2ZfaW50IChiaXRzIHMpKSAzMCBpblxuICAgIGxldCBiMyA9IEludDY0LnNoaWZ0X2xlZnQgKEludDY0Lm9mX2ludCAoYml0cyBzIGxhbmQgNykpIDYwIGluXG4gICAgbGV0IHIgPSBJbnQ2NC5sb2dvciBiMSAoSW50NjQubG9nb3IgYjIgYjMpIGluXG4gICAgbGV0IHYgPSBJbnQ2NC5yZW0gciBuIGluXG4gICAgaWYgSW50NjQuc3ViIHIgdiA+IEludDY0LmFkZCAoSW50NjQuc3ViIEludDY0Lm1heF9pbnQgbikgMUxcbiAgICB0aGVuIGludDY0YXV4IHMgblxuICAgIGVsc2UgdlxuXG4gIGxldCBpbnQ2NCBzIGJvdW5kID1cbiAgICBpZiBib3VuZCA8PSAwTFxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJSYW5kb20uaW50NjRcIlxuICAgIGVsc2UgaW50NjRhdXggcyBib3VuZFxuXG5cbiAgbGV0IG5hdGl2ZWludCA9XG4gICAgaWYgTmF0aXZlaW50LnNpemUgPSAzMlxuICAgIHRoZW4gZnVuIHMgYm91bmQgLT4gTmF0aXZlaW50Lm9mX2ludDMyIChpbnQzMiBzIChOYXRpdmVpbnQudG9faW50MzIgYm91bmQpKVxuICAgIGVsc2UgZnVuIHMgYm91bmQgLT4gSW50NjQudG9fbmF0aXZlaW50IChpbnQ2NCBzIChJbnQ2NC5vZl9uYXRpdmVpbnQgYm91bmQpKVxuXG5cbiAgKCogUmV0dXJucyBhIGZsb2F0IDAgPD0geCA8PSAxIHdpdGggYXQgbW9zdCA2MCBiaXRzIG9mIHByZWNpc2lvbi4gKilcbiAgbGV0IHJhd2Zsb2F0IHMgPVxuICAgIGxldCBzY2FsZSA9IDEwNzM3NDE4MjQuMCAgKCogMl4zMCAqKVxuICAgIGFuZCByMSA9IFN0ZGxpYi5mbG9hdCAoYml0cyBzKVxuICAgIGFuZCByMiA9IFN0ZGxpYi5mbG9hdCAoYml0cyBzKVxuICAgIGluIChyMSAvLiBzY2FsZSArLiByMikgLy4gc2NhbGVcblxuXG4gIGxldCBmbG9hdCBzIGJvdW5kID0gcmF3ZmxvYXQgcyAqLiBib3VuZFxuXG4gIGxldCBib29sIHMgPSAoYml0cyBzIGxhbmQgMSA9IDApXG5cbmVuZFxuXG4oKiBUaGlzIGlzIHRoZSBzdGF0ZSB5b3UgZ2V0IHdpdGggW2luaXQgMjcxODI4MThdIGFuZCB0aGVuIGFwcGx5aW5nXG4gICB0aGUgXCJsYW5kIDB4M0ZGRkZGRkZcIiBmaWx0ZXIgdG8gdGhlbS4gIFNlZSAjNTU3NSwgIzU3OTMsICM1OTc3LiAqKVxubGV0IGRlZmF1bHQgPSB7XG4gIFN0YXRlLnN0ID0gW3xcbiAgICAgIDB4M2FlMjUyMmI7IDB4MWQ4ZDQ2MzQ7IDB4MTViNGZhZDA7IDB4MThiMTRhY2U7IDB4MTJmOGEzYzQ7IDB4M2IwODZjNDc7XG4gICAgICAweDE2ZDQ2N2Q2OyAweDEwMWQ5MWM3OyAweDMyMWRmMTc3OyAweDAxNzZjMTkzOyAweDFmZjcyYmYxOyAweDFlODg5MTA5O1xuICAgICAgMHgwYjQ2NGIxODsgMHgyYjg2Yjk3YzsgMHgwODkxZGE0ODsgMHgwMzEzNzQ2MzsgMHgwODVhYzVhMTsgMHgxNWQ2MWYyZjtcbiAgICAgIDB4M2JjZWQzNTk7IDB4MjljMWMxMzI7IDB4M2E4Njc2NmU7IDB4MzY2ZDhjODY7IDB4MWY1YjYyMjI7IDB4M2NlMWI1OWY7XG4gICAgICAweDJlYmY3OGUxOyAweDI3Y2QxYjg2OyAweDI1OGYzZGMzOyAweDM4OWE4MTk0OyAweDAyZTRjNDRjOyAweDE4YzQzZjdkO1xuICAgICAgMHgwZjZlNTM0ZjsgMHgxZTdkZjM1OTsgMHgwNTVkMGI3ZTsgMHgxMGU4NGU3ZTsgMHgxMjYxOThlNDsgMHgwZTc3MjJjYjtcbiAgICAgIDB4MWNiZWRlMjg7IDB4MzM5MWI5NjQ7IDB4M2Q0MGU5MmE7IDB4MGM1OTkzM2Q7IDB4MGI4Y2QwYjc7IDB4MjRlZmZmMWM7XG4gICAgICAweDI4MDNmZGFhOyAweDA4ZWJjNzJlOyAweDBmNTIyZTMyOyAweDA1Mzk4ZWRjOyAweDIxNDRhMDRjOyAweDBhZWYzY2JkO1xuICAgICAgMHgwMWFkNDcxOTsgMHgzNWI5M2NkNjsgMHgyYTU1OWQ0ZjsgMHgxZTZmZDc2ODsgMHgyNmUyN2YzNjsgMHgxODZmMThjMztcbiAgICAgIDB4MmZiZjk2N2E7XG4gICAgfF07XG4gIFN0YXRlLmlkeCA9IDA7XG59XG5cbmxldCBiaXRzICgpID0gU3RhdGUuYml0cyBkZWZhdWx0XG5sZXQgaW50IGJvdW5kID0gU3RhdGUuaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQzMiBib3VuZCA9IFN0YXRlLmludDMyIGRlZmF1bHQgYm91bmRcbmxldCBuYXRpdmVpbnQgYm91bmQgPSBTdGF0ZS5uYXRpdmVpbnQgZGVmYXVsdCBib3VuZFxubGV0IGludDY0IGJvdW5kID0gU3RhdGUuaW50NjQgZGVmYXVsdCBib3VuZFxubGV0IGZsb2F0IHNjYWxlID0gU3RhdGUuZmxvYXQgZGVmYXVsdCBzY2FsZVxubGV0IGJvb2wgKCkgPSBTdGF0ZS5ib29sIGRlZmF1bHRcblxubGV0IGZ1bGxfaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IGRlZmF1bHQgc2VlZFxubGV0IGluaXQgc2VlZCA9IFN0YXRlLmZ1bGxfaW5pdCBkZWZhdWx0IFt8IHNlZWQgfF1cbmxldCBzZWxmX2luaXQgKCkgPSBmdWxsX2luaXQgKHJhbmRvbV9zZWVkKCkpXG5cbigqIE1hbmlwdWxhdGluZyB0aGUgY3VycmVudCBzdGF0ZS4gKilcblxubGV0IGdldF9zdGF0ZSAoKSA9IFN0YXRlLmNvcHkgZGVmYXVsdFxubGV0IHNldF9zdGF0ZSBzID0gU3RhdGUuYXNzaWduIGRlZmF1bHQgc1xuXG4oKioqKioqKioqKioqKioqKioqKipcblxuKCogVGVzdCBmdW5jdGlvbnMuICBOb3QgaW5jbHVkZWQgaW4gdGhlIGxpYnJhcnkuXG4gICBUaGUgW2NoaXNxdWFyZV0gZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCB3aXRoIG4gPiAxMHIuXG4gICBJdCByZXR1cm5zIGEgdHJpcGxlIChsb3csIGFjdHVhbCwgaGlnaCkuXG4gICBJZiBsb3cgPD0gYWN0dWFsIDw9IGhpZ2gsIHRoZSBbZ10gZnVuY3Rpb24gcGFzc2VkIHRoZSB0ZXN0LFxuICAgb3RoZXJ3aXNlIGl0IGZhaWxlZC5cblxuICBTb21lIHJlc3VsdHM6XG5cbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgNTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAwIDEwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMjk5NzkyNjQzOyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDE0MTQyMTM2OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYgMTAyNDsgY2hpc3F1YXJlIGRpZmYgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZiAxMDA7IGNoaXNxdWFyZSBkaWZmIDEwMDAwMCAxMDBcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZjIgMTAyNDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbmluaXQgMTQxNDIxMzY7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuaW5pdCAyOTk3OTI2NDM7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5MzYuNzU0NDQ2Nzk2NjMyNDY1LCA5OTcuNSwgMTA2My4yNDU1NTMyMDMzNjc1NClcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg5Ljc0MDAwMDAwMDAwNTIzODcsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoNDg1OC41Nzg2NDM3NjI2OSwgNTA0NS41LCA1MTQxLjQyMTM1NjIzNzMxKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID1cbig5MzYuNzU0NDQ2Nzk2NjMyNDY1LCA5NDQuODA1OTk5OTk5OTgyMzA1LCAxMDYzLjI0NTU1MzIwMzM2NzU0KVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwMTkuMTk3NDQwMDAwMDAzNTUsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNTkuMzE3NzYwMDAwMDA1MzYsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwMzkuOTg0NjM5OTk5OTk1MTIsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNTQuMzgyMDc5OTk5OTk1NzcsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgOTAuMDk2MDAwMDAwMDA1LCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDk2MC4sIDEwNzYuNzg3MjAwMDAwMDA2MTIsIDEwODguKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODUuMTc2MDAwMDAwMDA2NzUyMSwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg1LjIxNjAwMDAwMDAwMDM0OTIsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4MC42MjIwMDAwMDAwMDMwMjY4LCAxMjAuKVxuXG4qKVxuXG4oKiBSZXR1cm4gdGhlIHN1bSBvZiB0aGUgc3F1YXJlcyBvZiB2W2kwLGkxWyAqKVxubGV0IHJlYyBzdW1zcSB2IGkwIGkxID1cbiAgaWYgaTAgPj0gaTEgdGhlbiAwLjBcbiAgZWxzZSBpZiBpMSA9IGkwICsgMSB0aGVuIFN0ZGxpYi5mbG9hdCB2LihpMCkgKi4gU3RkbGliLmZsb2F0IHYuKGkwKVxuICBlbHNlIHN1bXNxIHYgaTAgKChpMCtpMSkvMikgKy4gc3Vtc3EgdiAoKGkwK2kxKS8yKSBpMVxuXG5cbmxldCBjaGlzcXVhcmUgZyBuIHIgPVxuICBpZiBuIDw9IDEwICogciB0aGVuIGludmFsaWRfYXJnIFwiY2hpc3F1YXJlXCI7XG4gIGxldCBmID0gQXJyYXkubWFrZSByIDAgaW5cbiAgZm9yIGkgPSAxIHRvIG4gZG9cbiAgICBsZXQgdCA9IGcgciBpblxuICAgIGYuKHQpIDwtIGYuKHQpICsgMVxuICBkb25lO1xuICBsZXQgdCA9IHN1bXNxIGYgMCByXG4gIGFuZCByID0gU3RkbGliLmZsb2F0IHJcbiAgYW5kIG4gPSBTdGRsaWIuZmxvYXQgbiBpblxuICBsZXQgc3IgPSAyLjAgKi4gc3FydCByIGluXG4gIChyIC0uIHNyLCAgIChyICouIHQgLy4gbikgLS4gbiwgICByICsuIHNyKVxuXG5cbigqIFRoaXMgaXMgdG8gdGVzdCBmb3IgbGluZWFyIGRlcGVuZGVuY2llcyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgcmFuZG9tIG51bWJlcnMuXG4qKVxubGV0IHN0ID0gcmVmIDBcbmxldCBpbml0X2RpZmYgciA9IHN0IDo9IGludCByXG5sZXQgZGlmZiByID1cbiAgbGV0IHgxID0gIXN0XG4gIGFuZCB4MiA9IGludCByXG4gIGluXG4gIHN0IDo9IHgyO1xuICBpZiB4MSA+PSB4MiB0aGVuXG4gICAgeDEgLSB4MlxuICBlbHNlXG4gICAgciArIHgxIC0geDJcblxuXG5sZXQgc3QxID0gcmVmIDBcbmFuZCBzdDIgPSByZWYgMFxuXG5cbigqIFRoaXMgaXMgdG8gdGVzdCBmb3IgcXVhZHJhdGljIGRlcGVuZGVuY2llcyBiZXR3ZWVuIHN1Y2Nlc3NpdmUgcmFuZG9tXG4gICBudW1iZXJzLlxuKilcbmxldCBpbml0X2RpZmYyIHIgPSBzdDEgOj0gaW50IHI7IHN0MiA6PSBpbnQgclxubGV0IGRpZmYyIHIgPVxuICBsZXQgeDEgPSAhc3QxXG4gIGFuZCB4MiA9ICFzdDJcbiAgYW5kIHgzID0gaW50IHJcbiAgaW5cbiAgc3QxIDo9IHgyO1xuICBzdDIgOj0geDM7XG4gICh4MyAtIHgyIC0geDIgKyB4MSArIDIqcikgbW9kIHJcblxuXG4qKioqKioqKioqKioqKioqKioqKilcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSGFzaCB0YWJsZXMgKilcblxuKCogV2UgZG8gZHluYW1pYyBoYXNoaW5nLCBhbmQgcmVzaXplIHRoZSB0YWJsZSBhbmQgcmVoYXNoIHRoZSBlbGVtZW50c1xuICAgd2hlbiBidWNrZXRzIGJlY29tZSB0b28gbG9uZy4gKilcblxudHlwZSAoJ2EsICdiKSB0ID1cbiAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgIG11dGFibGUgZGF0YTogKCdhLCAnYikgYnVja2V0bGlzdCBhcnJheTsgICgqIHRoZSBidWNrZXRzICopXG4gICAgbXV0YWJsZSBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICBtdXRhYmxlIGluaXRpYWxfc2l6ZTogaW50OyAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgfVxuXG5hbmQgKCdhLCAnYikgYnVja2V0bGlzdCA9XG4gICAgRW1wdHlcbiAgfCBDb25zIG9mIHsgbXV0YWJsZSBrZXk6ICdhO1xuICAgICAgICAgICAgICBtdXRhYmxlIGRhdGE6ICdiO1xuICAgICAgICAgICAgICBtdXRhYmxlIG5leHQ6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgfVxuXG4oKiBUaGUgc2lnbiBvZiBpbml0aWFsX3NpemUgZW5jb2RlcyB0aGUgZmFjdCB0aGF0IGEgdHJhdmVyc2FsIGlzXG4gICBvbmdvaW5nIG9yIG5vdC5cblxuICAgVGhpcyBkaXNhYmxlcyB0aGUgZWZmaWNpZW50IGluIHBsYWNlIGltcGxlbWVudGF0aW9uIG9mIHJlc2l6aW5nLlxuKilcblxubGV0IG9uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPCA0ICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgfHwgaC5pbml0aWFsX3NpemUgPCAwXG5cbmxldCBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGggPVxuICBoLmluaXRpYWxfc2l6ZSA8LSAtIGguaW5pdGlhbF9zaXplXG5cbigqIFRvIHBpY2sgcmFuZG9tIHNlZWRzIGlmIHJlcXVlc3RlZCAqKVxuXG5sZXQgcmFuZG9taXplZF9kZWZhdWx0ID1cbiAgbGV0IHBhcmFtcyA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJPQ0FNTFJVTlBBUkFNXCIgd2l0aCBOb3RfZm91bmQgLT5cbiAgICB0cnkgU3lzLmdldGVudiBcIkNBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+IFwiXCIgaW5cbiAgU3RyaW5nLmNvbnRhaW5zIHBhcmFtcyAnUidcblxubGV0IHJhbmRvbWl6ZWQgPSByZWYgcmFuZG9taXplZF9kZWZhdWx0XG5cbmxldCByYW5kb21pemUgKCkgPSByYW5kb21pemVkIDo9IHRydWVcbmxldCBpc19yYW5kb21pemVkICgpID0gIXJhbmRvbWl6ZWRcblxubGV0IHBybmcgPSBsYXp5IChSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQoKSlcblxuKCogRnVuY3Rpb25zIHdoaWNoIGFwcGVhciBiZWZvcmUgdGhlIGZ1bmN0b3JpYWwgaW50ZXJmYWNlIG11c3QgZWl0aGVyIGJlXG4gICBpbmRlcGVuZGVudCBvZiB0aGUgaGFzaCBmdW5jdGlvbiBvciB0YWtlIGl0IGFzIGEgcGFyYW1ldGVyIChzZWUgIzIyMDIgYW5kXG4gICBjb2RlIGJlbG93IHRoZSBmdW5jdG9yIGRlZmluaXRpb25zLiAqKVxuXG4oKiBDcmVhdGluZyBhIGZyZXNoLCBlbXB0eSB0YWJsZSAqKVxuXG5sZXQgcmVjIHBvd2VyXzJfYWJvdmUgeCBuID1cbiAgaWYgeCA+PSBuIHRoZW4geFxuICBlbHNlIGlmIHggKiAyID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiB4XG4gIGVsc2UgcG93ZXJfMl9hYm92ZSAoeCAqIDIpIG5cblxubGV0IGNyZWF0ZSA/KHJhbmRvbSA9ICFyYW5kb21pemVkKSBpbml0aWFsX3NpemUgPVxuICBsZXQgcyA9IHBvd2VyXzJfYWJvdmUgMTYgaW5pdGlhbF9zaXplIGluXG4gIGxldCBzZWVkID0gaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykgZWxzZSAwIGluXG4gIHsgaW5pdGlhbF9zaXplID0gczsgc2l6ZSA9IDA7IHNlZWQgPSBzZWVkOyBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5IH1cblxubGV0IGNsZWFyIGggPVxuICBpZiBoLnNpemUgPiAwIHRoZW4gYmVnaW5cbiAgICBoLnNpemUgPC0gMDtcbiAgICBBcnJheS5maWxsIGguZGF0YSAwIChBcnJheS5sZW5ndGggaC5kYXRhKSBFbXB0eVxuICBlbmRcblxubGV0IHJlc2V0IGggPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPCA0ICgqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGQgaGFzaCB0YWJsZXMgKilcbiAgICB8fCBsZW4gPSBhYnMgaC5pbml0aWFsX3NpemUgdGhlblxuICAgIGNsZWFyIGhcbiAgZWxzZSBiZWdpblxuICAgIGguc2l6ZSA8LSAwO1xuICAgIGguZGF0YSA8LSBBcnJheS5tYWtlIChhYnMgaC5pbml0aWFsX3NpemUpIEVtcHR5XG4gIGVuZFxuXG5sZXQgY29weV9idWNrZXRsaXN0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBFbXB0eVxuICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgIGxldCByZWMgbG9vcCBwcmVjID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICAgIGxldCByID0gQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgICAgfCBDb25zIHByZWMgLT4gIHByZWMubmV4dCA8LSByXG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBsb29wIHIgbmV4dFxuICAgICAgaW5cbiAgICAgIGxldCByID0gQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSBpblxuICAgICAgbG9vcCByIG5leHQ7XG4gICAgICByXG5cbmxldCBjb3B5IGggPSB7IGggd2l0aCBkYXRhID0gQXJyYXkubWFwIGNvcHlfYnVja2V0bGlzdCBoLmRhdGEgfVxuXG5sZXQgbGVuZ3RoIGggPSBoLnNpemVcblxubGV0IGluc2VydF9hbGxfYnVja2V0cyBpbmRleGZ1biBpbnBsYWNlIG9kYXRhIG5kYXRhID1cbiAgbGV0IG5zaXplID0gQXJyYXkubGVuZ3RoIG5kYXRhIGluXG4gIGxldCBuZGF0YV90YWlsID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gYXMgY2VsbCAtPlxuICAgICAgICBsZXQgY2VsbCA9XG4gICAgICAgICAgaWYgaW5wbGFjZSB0aGVuIGNlbGxcbiAgICAgICAgICBlbHNlIENvbnMge2tleTsgZGF0YTsgbmV4dCA9IEVtcHR5fVxuICAgICAgICBpblxuICAgICAgICBsZXQgbmlkeCA9IGluZGV4ZnVuIGtleSBpblxuICAgICAgICBiZWdpbiBtYXRjaCBuZGF0YV90YWlsLihuaWR4KSB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gbmRhdGEuKG5pZHgpIDwtIGNlbGw7XG4gICAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBjZWxsO1xuICAgICAgICBlbmQ7XG4gICAgICAgIG5kYXRhX3RhaWwuKG5pZHgpIDwtIGNlbGw7XG4gICAgICAgIGluc2VydF9idWNrZXQgbmV4dFxuICBpblxuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIG9kYXRhIC0gMSBkb1xuICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gIGRvbmU7XG4gIGlmIGlucGxhY2UgdGhlblxuICAgIGZvciBpID0gMCB0byBuc2l6ZSAtIDEgZG9cbiAgICAgIG1hdGNoIG5kYXRhX3RhaWwuKGkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBFbXB0eVxuICAgIGRvbmVcblxubGV0IHJlc2l6ZSBpbmRleGZ1biBoID1cbiAgbGV0IG9kYXRhID0gaC5kYXRhIGluXG4gIGxldCBvc2l6ZSA9IEFycmF5Lmxlbmd0aCBvZGF0YSBpblxuICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgaWYgbnNpemUgPCBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIGJlZ2luXG4gICAgbGV0IG5kYXRhID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgIGxldCBpbnBsYWNlID0gbm90IChvbmdvaW5nX3RyYXZlcnNhbCBoKSBpblxuICAgIGguZGF0YSA8LSBuZGF0YTsgICAgICAgICAgKCogc28gdGhhdCBpbmRleGZ1biBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgaW5zZXJ0X2FsbF9idWNrZXRzIChpbmRleGZ1biBoKSBpbnBsYWNlIG9kYXRhIG5kYXRhXG4gIGVuZFxuXG5sZXQgaXRlciBmIGggPVxuICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPlxuICAgICAgICAoKVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGYga2V5IGRhdGE7IGRvX2J1Y2tldCBuZXh0IGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGRvX2J1Y2tldCBkLihpKVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IHJlYyBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBFbXB0eVxuICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIEVtcHR5XG4gICAgICBlbmRcbiAgfCAoQ29ucyAoe2tleTsgZGF0YTsgbmV4dH0gYXMgYykpIGFzIHNsb3QgLT5cbiAgICAgIGJlZ2luIG1hdGNoIGYga2V5IGRhdGEgd2l0aFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBwcmVjIG5leHRcbiAgICAgIHwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIHNsb3RcbiAgICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gc2xvdFxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBjLmRhdGEgPC0gZGF0YTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHNsb3QgbmV4dFxuICAgICAgZW5kXG5cbmxldCBmaWx0ZXJfbWFwX2lucGxhY2UgZiBoID1cbiAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgRW1wdHkgaC5kYXRhLihpKVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoXG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgZm9sZCBmIGggaW5pdCA9XG4gIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgbWF0Y2ggYiB3aXRoXG4gICAgICBFbXB0eSAtPlxuICAgICAgICBhY2N1XG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZG9fYnVja2V0IG5leHQgKGYga2V5IGRhdGEgYWNjdSkgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgIGFjY3UgOj0gZG9fYnVja2V0IGQuKGkpICFhY2N1XG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgIWFjY3VcbiAgd2l0aCBleG4gd2hlbiBub3Qgb2xkX3RyYXYgLT5cbiAgICBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gICAgcmFpc2UgZXhuXG5cbnR5cGUgc3RhdGlzdGljcyA9IHtcbiAgbnVtX2JpbmRpbmdzOiBpbnQ7XG4gIG51bV9idWNrZXRzOiBpbnQ7XG4gIG1heF9idWNrZXRfbGVuZ3RoOiBpbnQ7XG4gIGJ1Y2tldF9oaXN0b2dyYW06IGludCBhcnJheVxufVxuXG5sZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYWNjdVxuICB8IENvbnN7bmV4dH0gLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIG5leHRcblxubGV0IHN0YXRzIGggPVxuICBsZXQgbWJsID1cbiAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gbWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICBBcnJheS5pdGVyXG4gICAgKGZ1biBiIC0+XG4gICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGggMCBiIGluXG4gICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICBoLmRhdGE7XG4gIHsgbnVtX2JpbmRpbmdzID0gaC5zaXplO1xuICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHRibCA9XG4gICgqIGNhcHR1cmUgY3VycmVudCBhcnJheSwgc28gdGhhdCBldmVuIGlmIHRoZSB0YWJsZSBpcyByZXNpemVkIHdlXG4gICAgIGtlZXAgaXRlcmF0aW5nIG9uIHRoZSBzYW1lIGFycmF5ICopXG4gIGxldCB0YmxfZGF0YSA9IHRibC5kYXRhIGluXG4gICgqIHN0YXRlOiBpbmRleCAqIG5leHQgYnVja2V0IHRvIHRyYXZlcnNlICopXG4gIGxldCByZWMgYXV4IGkgYnVjayAoKSA9IG1hdGNoIGJ1Y2sgd2l0aFxuICAgIHwgRW1wdHkgLT5cbiAgICAgICAgaWYgaSA9IEFycmF5Lmxlbmd0aCB0YmxfZGF0YVxuICAgICAgICB0aGVuIFNlcS5OaWxcbiAgICAgICAgZWxzZSBhdXgoaSsxKSB0YmxfZGF0YS4oaSkgKClcbiAgICB8IENvbnMge2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgU2VxLkNvbnMgKChrZXksIGRhdGEpLCBhdXggaSBuZXh0KVxuICBpblxuICBhdXggMCBFbXB0eVxuXG5sZXQgdG9fc2VxX2tleXMgbSA9IFNlcS5tYXAgZnN0ICh0b19zZXEgbSlcblxubGV0IHRvX3NlcV92YWx1ZXMgbSA9IFNlcS5tYXAgc25kICh0b19zZXEgbSlcblxuKCogRnVuY3RvcmlhbCBpbnRlcmZhY2UgKilcblxubW9kdWxlIHR5cGUgSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IGludCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAhJ2EgdFxuICAgIHZhbCBjcmVhdGU6IGludCAtPiAnYSB0XG4gICAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIGNvcHk6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQ6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgcmVtb3ZlOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gICAgdmFsIGZpbmQ6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGw6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2U6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGg6ICdhIHQgLT4gaW50XG4gICAgdmFsIHN0YXRzOiAnYSB0IC0+IHN0YXRpc3RpY3NcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9rZXlzIDogXyB0IC0+IGtleSBTZXEudFxuICAgIHZhbCB0b19zZXFfdmFsdWVzIDogJ2EgdCAtPiAnYSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgISdhIHRcbiAgICB2YWwgY3JlYXRlIDogP3JhbmRvbTpib29sIC0+IGludCAtPiAnYSB0XG4gICAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIGNvcHkgOiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgYWRkIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmUgOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gICAgdmFsIGZpbmQgOiAnYSB0IC0+IGtleSAtPiAnYVxuICAgIHZhbCBmaW5kX29wdDogJ2EgdCAtPiBrZXkgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGZpbmRfYWxsIDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXIgOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2U6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZCA6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICAgIHZhbCB0b19zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX2tleXMgOiBfIHQgLT4ga2V5IFNlcS50XG4gICAgdmFsIHRvX3NlcV92YWx1ZXMgOiAnYSB0IC0+ICdhIFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCByZXBsYWNlX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIE1ha2VTZWVkZWQoSDogU2VlZGVkSGFzaGVkVHlwZSk6IChTZWVkZWRTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgdHlwZSBrZXkgPSBILnRcbiAgICB0eXBlICdhIGhhc2h0YmwgPSAoa2V5LCAnYSkgdFxuICAgIHR5cGUgJ2EgdCA9ICdhIGhhc2h0YmxcbiAgICBsZXQgY3JlYXRlID0gY3JlYXRlXG4gICAgbGV0IGNsZWFyID0gY2xlYXJcbiAgICBsZXQgcmVzZXQgPSByZXNldFxuICAgIGxldCBjb3B5ID0gY29weVxuXG4gICAgbGV0IGtleV9pbmRleCBoIGtleSA9XG4gICAgICAoSC5oYXNoIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuXG4gICAgbGV0IGFkZCBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgICAgIGguZGF0YS4oaSkgPC0gYnVja2V0O1xuICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgaCBpIGtleSBwcmVjID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAoKVxuICAgICAgfCAoQ29ucyB7a2V5PWs7IG5leHR9KSBhcyBjIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgbWF0Y2ggcHJlYyB3aXRoXG4gICAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gbmV4dFxuICAgICAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlIHJlbW92ZV9idWNrZXQgaCBpIGtleSBjIG5leHRcblxuICAgIGxldCByZW1vdmUgaCBrZXkgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIHJlbW92ZV9idWNrZXQgaCBpIGtleSBFbXB0eSBoLmRhdGEuKGkpXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIGQzIGVsc2UgZmluZF9yZWMga2V5IG5leHQzXG5cbiAgICBsZXQgcmVjIGZpbmRfcmVjX29wdCBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gU29tZSBkYXRhIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0XG5cbiAgICBsZXQgZmluZF9vcHQgaCBrZXkgPVxuICAgICAgbWF0Y2ggaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQxIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBuZXh0MiB3aXRoXG4gICAgICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIFtdXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE9ZDsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiBkIDo6IGZpbmRfaW5fYnVja2V0IG5leHRcbiAgICAgICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgICAgIGZpbmRfaW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IHJlYyByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgfCBDb25zICh7a2V5PWs7IG5leHR9IGFzIHNsb3QpIC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgICAgIGVsc2UgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbmV4dFxuXG4gICAgbGV0IHJlcGxhY2UgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGwgPSBoLmRhdGEuKGkpIGluXG4gICAgICBpZiByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBsIHRoZW4gYmVnaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcbiAgICAgIGVuZFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnN7a2V5PWs7IG5leHR9IC0+XG4gICAgICAgICAgSC5lcXVhbCBrIGtleSB8fCBtZW1faW5fYnVja2V0IG5leHQgaW5cbiAgICAgIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgYWRkX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbiAgICBsZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuXG4gICAgbGV0IGl0ZXIgPSBpdGVyXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSA9IGZpbHRlcl9tYXBfaW5wbGFjZVxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgc3RhdHMgPSBzdGF0c1xuICAgIGxldCB0b19zZXEgPSB0b19zZXFcbiAgICBsZXQgdG9fc2VxX2tleXMgPSB0b19zZXFfa2V5c1xuICAgIGxldCB0b19zZXFfdmFsdWVzID0gdG9fc2VxX3ZhbHVlc1xuICBlbmRcblxubW9kdWxlIE1ha2UoSDogSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG4oKiBQb2x5bW9ycGhpYyBoYXNoIGZ1bmN0aW9uLWJhc2VkIHRhYmxlcyAqKVxuKCogQ29kZSBpbmNsdWRlZCBiZWxvdyB0aGUgZnVuY3RvcmlhbCBpbnRlcmZhY2UgdG8gZ3VhcmQgYWdhaW5zdCBhY2NpZGVudGFsXG4gICB1c2UgLSBzZWUgIzIyMDIgKilcblxuZXh0ZXJuYWwgc2VlZGVkX2hhc2hfcGFyYW0gOlxuICBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiBpbnQgPSBcImNhbWxfaGFzaFwiIFtAQG5vYWxsb2NdXG5cbmxldCBoYXNoIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgMCB4XG5sZXQgaGFzaF9wYXJhbSBuMSBuMiB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gbjEgbjIgMCB4XG5sZXQgc2VlZGVkX2hhc2ggc2VlZCB4ID0gc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIHNlZWQgeFxuXG5sZXQga2V5X2luZGV4IGgga2V5ID1cbiAgaWYgT2JqLnNpemUgKE9iai5yZXByIGgpID49IDRcbiAgdGhlbiAoc2VlZGVkX2hhc2hfcGFyYW0gMTAgMTAwIGguc2VlZCBrZXkpIGxhbmQgKEFycmF5Lmxlbmd0aCBoLmRhdGEgLSAxKVxuICBlbHNlIGludmFsaWRfYXJnIFwiSGFzaHRibDogdW5zdXBwb3J0ZWQgaGFzaCB0YWJsZSBmb3JtYXRcIlxuXG5sZXQgYWRkIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbmxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICAoKVxuICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgIGVuZFxuICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbmxldCByZW1vdmUgaCBrZXkgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG5sZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG5sZXQgZmluZCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrMSA9IDAgdGhlbiBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMiA9IDAgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgaWYgY29tcGFyZSBrZXkgazMgPSAwIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxubGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgTm9uZVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG5sZXQgZmluZF9vcHQgaCBrZXkgPVxuICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG5sZXQgZmluZF9hbGwgaCBrZXkgPVxuICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgW11cbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gZGF0YSA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbmxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gIGVuZFxuXG5sZXQgbWVtIGgga2V5ID1cbiAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgY29tcGFyZSBrIGtleSA9IDAgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCBhZGRfc2VxIHRibCBpID1cbiAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG5sZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gIHJlcGxhY2Vfc2VxIHRibCBpO1xuICB0YmxcblxubGV0IHJlYnVpbGQgPyhyYW5kb20gPSAhcmFuZG9taXplZCkgaCA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiAoQXJyYXkubGVuZ3RoIGguZGF0YSkgaW5cbiAgbGV0IHNlZWQgPVxuICAgIGlmIHJhbmRvbSB0aGVuIFJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHBybmcpXG4gICAgZWxzZSBpZiBPYmouc2l6ZSAoT2JqLnJlcHIgaCkgPj0gNCB0aGVuIGguc2VlZFxuICAgIGVsc2UgMCBpblxuICBsZXQgaCcgPSB7XG4gICAgc2l6ZSA9IGguc2l6ZTtcbiAgICBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5O1xuICAgIHNlZWQgPSBzZWVkO1xuICAgIGluaXRpYWxfc2l6ZSA9IGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSA0IHRoZW4gaC5pbml0aWFsX3NpemUgZWxzZSBzXG4gIH0gaW5cbiAgaW5zZXJ0X2FsbF9idWNrZXRzIChrZXlfaW5kZXggaCcpIGZhbHNlIGguZGF0YSBoJy5kYXRhO1xuICBoJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogV2VhayBhcnJheSBvcGVyYXRpb25zICopXG5cbnR5cGUgISdhIHRcblxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+ICdhIHQgPSBcImNhbWxfd2Vha19jcmVhdGVcIlxuXG5sZXQgY3JlYXRlIGwgPVxuICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IE9iai5FcGhlbWVyb24ubWF4X2VwaGVfbGVuZ3RoKSB0aGVuXG4gICAgaW52YWxpZF9hcmcoXCJXZWFrLmNyZWF0ZVwiKTtcbiAgY3JlYXRlIGxcblxuKCoqIG51bWJlciBvZiBhZGRpdGlvbmFsIHZhbHVlcyBpbiBhIHdlYWsgcG9pbnRlciAqKVxubGV0IGFkZGl0aW9uYWxfdmFsdWVzID0gMlxuXG5sZXQgbGVuZ3RoIHggPSBPYmouc2l6ZShPYmoucmVwciB4KSAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbmxldCByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gbXNnID1cbiAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgaW52YWxpZF9hcmcobXNnKVxuXG5leHRlcm5hbCBzZXQnIDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9rZXlcIlxuZXh0ZXJuYWwgdW5zZXQgOiAnYSB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbmxldCBzZXQgZSBvIHggPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLnNldFwiO1xuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHVuc2V0IGUgb1xuICB8IFNvbWUgeCAtPiBzZXQnIGUgbyB4XG5cbmV4dGVybmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldFwiXG5sZXQgZ2V0IGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuZ2V0XCI7XG4gIGdldCBlIG9cblxuZXh0ZXJuYWwgZ2V0X2NvcHkgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRfY29weVwiXG5sZXQgZ2V0X2NvcHkgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5nZXRfY29weVwiO1xuICBnZXRfY29weSBlIG9cblxuZXh0ZXJuYWwgY2hlY2sgOiAnYSB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX3dlYWtfY2hlY2tcIlxubGV0IGNoZWNrIGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuY2hlY2tcIjtcbiAgY2hlY2sgZSBvXG5cbmV4dGVybmFsIGJsaXQgOiAnYSB0IC0+IGludCAtPiAnYSB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF93ZWFrX2JsaXRcIlxuXG4oKiBibGl0OiBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuICopXG5sZXQgYmxpdCBlMSBvMSBlMiBvMiBsID1cbiAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICB8fCBvMiA8IDAgfHwgbzIgPiBsZW5ndGggZTIgLSBsXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJXZWFrLmJsaXRcIlxuICBlbHNlIGlmIGwgPD4gMCB0aGVuIGJsaXQgZTEgbzEgZTIgbzIgbFxuXG5sZXQgZmlsbCBhciBvZnMgbGVuIHggPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGFyIC0gbGVuXG4gIHRoZW4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJXZWFrLmZpbGxcIilcbiAgZWxzZSBiZWdpblxuICAgIGZvciBpID0gb2ZzIHRvIChvZnMgKyBsZW4gLSAxKSBkb1xuICAgICAgc2V0IGFyIGkgeFxuICAgIGRvbmVcbiAgZW5kXG5cblxuKCoqIFdlYWsgaGFzaCB0YWJsZXMgKilcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIGRhdGFcbiAgdHlwZSB0XG4gIHZhbCBjcmVhdGUgOiBpbnQgLT4gdFxuICB2YWwgY2xlYXIgOiB0IC0+IHVuaXRcbiAgdmFsIG1lcmdlIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGFkZCA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCByZW1vdmUgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgZmluZCA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBmaW5kX29wdCA6IHQgLT4gZGF0YSAtPiBkYXRhIG9wdGlvblxuICB2YWwgZmluZF9hbGwgOiB0IC0+IGRhdGEgLT4gZGF0YSBsaXN0XG4gIHZhbCBtZW0gOiB0IC0+IGRhdGEgLT4gYm9vbFxuICB2YWwgaXRlciA6IChkYXRhIC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICB2YWwgZm9sZCA6IChkYXRhIC0+ICdhIC0+ICdhKSAtPiB0IC0+ICdhIC0+ICdhXG4gIHZhbCBjb3VudCA6IHQgLT4gaW50XG4gIHZhbCBzdGF0cyA6IHQgLT4gaW50ICogaW50ICogaW50ICogaW50ICogaW50ICogaW50XG5lbmRcblxubW9kdWxlIE1ha2UgKEggOiBIYXNodGJsLkhhc2hlZFR5cGUpIDogKFMgd2l0aCB0eXBlIGRhdGEgPSBILnQpID0gc3RydWN0XG5cbiAgdHlwZSAnYSB3ZWFrX3QgPSAnYSB0XG4gIGxldCB3ZWFrX2NyZWF0ZSA9IGNyZWF0ZVxuICBsZXQgZW1wdHlidWNrZXQgPSB3ZWFrX2NyZWF0ZSAwXG5cbiAgdHlwZSBkYXRhID0gSC50XG5cbiAgdHlwZSB0ID0ge1xuICAgIG11dGFibGUgdGFibGUgOiBkYXRhIHdlYWtfdCBhcnJheTtcbiAgICBtdXRhYmxlIGhhc2hlcyA6IGludCBhcnJheSBhcnJheTtcbiAgICBtdXRhYmxlIGxpbWl0IDogaW50OyAgICAgICAgICAgICAgICgqIGJ1Y2tldCBzaXplIGxpbWl0ICopXG4gICAgbXV0YWJsZSBvdmVyc2l6ZSA6IGludDsgICAgICAgICAgICAoKiBudW1iZXIgb2Ygb3ZlcnNpemUgYnVja2V0cyAqKVxuICAgIG11dGFibGUgcm92ZXIgOiBpbnQ7ICAgICAgICAgICAgICAgKCogZm9yIGludGVybmFsIGJvb2trZWVwaW5nICopXG4gIH1cblxuICBsZXQgZ2V0X2luZGV4IHQgaCA9IChoIGxhbmQgbWF4X2ludCkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuICBsZXQgbGltaXQgPSA3XG4gIGxldCBvdmVyX2xpbWl0ID0gMlxuXG4gIGxldCBjcmVhdGUgc3ogPVxuICAgIGxldCBzeiA9IGlmIHN6IDwgNyB0aGVuIDcgZWxzZSBzeiBpblxuICAgIGxldCBzeiA9IGlmIHN6ID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBTeXMubWF4X2FycmF5X2xlbmd0aCBlbHNlIHN6IGluXG4gICAge1xuICAgICAgdGFibGUgPSBBcnJheS5tYWtlIHN6IGVtcHR5YnVja2V0O1xuICAgICAgaGFzaGVzID0gQXJyYXkubWFrZSBzeiBbfCB8XTtcbiAgICAgIGxpbWl0ID0gbGltaXQ7XG4gICAgICBvdmVyc2l6ZSA9IDA7XG4gICAgICByb3ZlciA9IDA7XG4gICAgfVxuXG4gIGxldCBjbGVhciB0ID1cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgICB0LnRhYmxlLihpKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgIHQuaGFzaGVzLihpKSA8LSBbfCB8XTtcbiAgICBkb25lO1xuICAgIHQubGltaXQgPC0gbGltaXQ7XG4gICAgdC5vdmVyc2l6ZSA8LSAwXG5cblxuICBsZXQgZm9sZCBmIHQgaW5pdCA9XG4gICAgbGV0IHJlYyBmb2xkX2J1Y2tldCBpIGIgYWNjdSA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGZvbGRfYnVja2V0IChpKzEpIGIgKGYgdiBhY2N1KVxuICAgICAgfCBOb25lIC0+IGZvbGRfYnVja2V0IChpKzEpIGIgYWNjdVxuICAgIGluXG4gICAgQXJyYXkuZm9sZF9yaWdodCAoZm9sZF9idWNrZXQgMCkgdC50YWJsZSBpbml0XG5cblxuICBsZXQgaXRlciBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGYgdjsgaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgICAgfCBOb25lIC0+IGl0ZXJfYnVja2V0IChpKzEpIGJcbiAgICBpblxuICAgIEFycmF5Lml0ZXIgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCBpdGVyX3dlYWsgZiB0ID1cbiAgICBsZXQgcmVjIGl0ZXJfYnVja2V0IGkgaiBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBjaGVjayBiIGkgd2l0aFxuICAgICAgfCB0cnVlIC0+IGYgYiB0Lmhhc2hlcy4oaikgaTsgaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgICB8IGZhbHNlIC0+IGl0ZXJfYnVja2V0IChpKzEpIGogYlxuICAgIGluXG4gICAgQXJyYXkuaXRlcmkgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCByZWMgY291bnRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgY291bnRfYnVja2V0IChpKzEpIGIgKGFjY3UgKyAoaWYgY2hlY2sgYiBpIHRoZW4gMSBlbHNlIDApKVxuXG5cbiAgbGV0IGNvdW50IHQgPVxuICAgIEFycmF5LmZvbGRfcmlnaHQgKGNvdW50X2J1Y2tldCAwKSB0LnRhYmxlIDBcblxuXG4gIGxldCBuZXh0X3N6IG4gPSBtaW4gKDMgKiBuIC8gMiArIDMpIFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG4gIGxldCBwcmV2X3N6IG4gPSAoKG4gLSAzKSAqIDIgKyAyKSAvIDNcblxuICBsZXQgdGVzdF9zaHJpbmtfYnVja2V0IHQgPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLih0LnJvdmVyKSBpblxuICAgIGxldCBoYnVja2V0ID0gdC5oYXNoZXMuKHQucm92ZXIpIGluXG4gICAgbGV0IGxlbiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcHJldl9sZW4gPSBwcmV2X3N6IGxlbiBpblxuICAgIGxldCBsaXZlID0gY291bnRfYnVja2V0IDAgYnVja2V0IDAgaW5cbiAgICBpZiBsaXZlIDw9IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCByZWMgbG9vcCBpIGogPVxuICAgICAgICBpZiBqID49IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgICBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGxvb3AgKGkgKyAxKSBqXG4gICAgICAgICAgZWxzZSBpZiBjaGVjayBidWNrZXQgaiB0aGVuIGJlZ2luXG4gICAgICAgICAgICBibGl0IGJ1Y2tldCBqIGJ1Y2tldCBpIDE7XG4gICAgICAgICAgICBoYnVja2V0LihpKSA8LSBoYnVja2V0LihqKTtcbiAgICAgICAgICAgIGxvb3AgKGkgKyAxKSAoaiAtIDEpO1xuICAgICAgICAgIGVuZCBlbHNlIGxvb3AgaSAoaiAtIDEpO1xuICAgICAgICBlbmQ7XG4gICAgICBpblxuICAgICAgbG9vcCAwIChsZW5ndGggYnVja2V0IC0gMSk7XG4gICAgICBpZiBwcmV2X2xlbiA9IDAgdGhlbiBiZWdpblxuICAgICAgICB0LnRhYmxlLih0LnJvdmVyKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIFt8IHxdO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIHByZXZfbGVuIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgcHJldl9sZW47XG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIEFycmF5LnN1YiBoYnVja2V0IDAgcHJldl9sZW5cbiAgICAgIGVuZDtcbiAgICAgIGlmIGxlbiA+IHQubGltaXQgJiYgcHJldl9sZW4gPD0gdC5saW1pdCB0aGVuIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSAtIDE7XG4gICAgZW5kO1xuICAgIHQucm92ZXIgPC0gKHQucm92ZXIgKyAxKSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG5cbiAgbGV0IHJlYyByZXNpemUgdCA9XG4gICAgbGV0IG9sZGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IG5ld2xlbiA9IG5leHRfc3ogb2xkbGVuIGluXG4gICAgaWYgbmV3bGVuID4gb2xkbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCBuZXd0ID0gY3JlYXRlIG5ld2xlbiBpblxuICAgICAgbGV0IGFkZF93ZWFrIG9iIG9oIG9pID1cbiAgICAgICAgbGV0IHNldHRlciBuYiBuaSBfID0gYmxpdCBvYiBvaSBuYiBuaSAxIGluXG4gICAgICAgIGxldCBoID0gb2guKG9pKSBpblxuICAgICAgICBhZGRfYXV4IG5ld3Qgc2V0dGVyIE5vbmUgaCAoZ2V0X2luZGV4IG5ld3QgaCk7XG4gICAgICBpblxuICAgICAgaXRlcl93ZWFrIGFkZF93ZWFrIHQ7XG4gICAgICB0LnRhYmxlIDwtIG5ld3QudGFibGU7XG4gICAgICB0Lmhhc2hlcyA8LSBuZXd0Lmhhc2hlcztcbiAgICAgIHQubGltaXQgPC0gbmV3dC5saW1pdDtcbiAgICAgIHQub3ZlcnNpemUgPC0gbmV3dC5vdmVyc2l6ZTtcbiAgICAgIHQucm92ZXIgPC0gdC5yb3ZlciBtb2QgQXJyYXkubGVuZ3RoIG5ld3QudGFibGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHQubGltaXQgPC0gbWF4X2ludDsgICAgICAgICAgICAgKCogbWF4aW11bSBzaXplIGFscmVhZHkgcmVhY2hlZCAqKVxuICAgICAgdC5vdmVyc2l6ZSA8LSAwO1xuICAgIGVuZFxuXG4gIGFuZCBhZGRfYXV4IHQgc2V0dGVyIGQgaCBpbmRleCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmV3c3ogPVxuICAgICAgICAgIG1pbiAoMyAqIHN6IC8gMiArIDMpIChTeXMubWF4X2FycmF5X2xlbmd0aCAtIGFkZGl0aW9uYWxfdmFsdWVzKVxuICAgICAgICBpblxuICAgICAgICBpZiBuZXdzeiA8PSBzeiB0aGVuIGZhaWx3aXRoIFwiV2Vhay5NYWtlOiBoYXNoIGJ1Y2tldCBjYW5ub3QgZ3JvdyBtb3JlXCI7XG4gICAgICAgIGxldCBuZXdidWNrZXQgPSB3ZWFrX2NyZWF0ZSBuZXdzeiBpblxuICAgICAgICBsZXQgbmV3aGFzaGVzID0gQXJyYXkubWFrZSBuZXdzeiAwIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgc3o7XG4gICAgICAgIEFycmF5LmJsaXQgaGFzaGVzIDAgbmV3aGFzaGVzIDAgc3o7XG4gICAgICAgIHNldHRlciBuZXdidWNrZXQgc3ogZDtcbiAgICAgICAgbmV3aGFzaGVzLihzeikgPC0gaDtcbiAgICAgICAgdC50YWJsZS4oaW5kZXgpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKGluZGV4KSA8LSBuZXdoYXNoZXM7XG4gICAgICAgIGlmIHN6IDw9IHQubGltaXQgJiYgbmV3c3ogPiB0LmxpbWl0IHRoZW4gYmVnaW5cbiAgICAgICAgICB0Lm92ZXJzaXplIDwtIHQub3ZlcnNpemUgKyAxO1xuICAgICAgICAgIGZvciBfaSA9IDAgdG8gb3Zlcl9saW1pdCBkbyB0ZXN0X3Nocmlua19idWNrZXQgdCBkb25lO1xuICAgICAgICBlbmQ7XG4gICAgICAgIGlmIHQub3ZlcnNpemUgPiBBcnJheS5sZW5ndGggdC50YWJsZSAvIG92ZXJfbGltaXQgdGhlbiByZXNpemUgdDtcbiAgICAgIGVuZCBlbHNlIGlmIGNoZWNrIGJ1Y2tldCBpIHRoZW4gYmVnaW5cbiAgICAgICAgbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXR0ZXIgYnVja2V0IGkgZDtcbiAgICAgICAgaGFzaGVzLihpKSA8LSBoO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgYWRkIHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGFkZF9hdXggdCBzZXQgKFNvbWUgZCkgaCAoZ2V0X2luZGV4IHQgaClcblxuXG4gIGxldCBmaW5kX29yIHQgZCBpZm5vdGZvdW5kID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gaWZub3Rmb3VuZCBoIGluZGV4XG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IHZcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBtZXJnZSB0IGQgPVxuICAgIGZpbmRfb3IgdCBkIChmdW4gaCBpbmRleCAtPiBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggaW5kZXg7IGQpXG5cblxuICBsZXQgZmluZCB0IGQgPSBmaW5kX29yIHQgZCAoZnVuIF9oIF9pbmRleCAtPiByYWlzZSBOb3RfZm91bmQpXG5cbiAgbGV0IGZpbmRfb3B0IHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIE5vbmVcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgZmluZF9zaGFkb3cgdCBkIGlmZm91bmQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmRcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGQgLT4gaWZmb3VuZCBidWNrZXQgaVxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IHJlbW92ZSB0IGQgPSBmaW5kX3NoYWRvdyB0IGQgKGZ1biB3IGkgLT4gc2V0IHcgaSBOb25lKSAoKVxuXG5cbiAgbGV0IG1lbSB0IGQgPSBmaW5kX3NoYWRvdyB0IGQgKGZ1biBfdyBfaSAtPiB0cnVlKSBmYWxzZVxuXG5cbiAgbGV0IGZpbmRfYWxsIHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgYWNjdSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYWNjdVxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiBsb29wIChpICsgMSkgKHYgOjogYWNjdSlcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpIGFjY3VcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgaW5cbiAgICBsb29wIDAgW11cblxuXG4gIGxldCBzdGF0cyB0ID1cbiAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbGVucyA9IEFycmF5Lm1hcCBsZW5ndGggdC50YWJsZSBpblxuICAgIEFycmF5LnNvcnQgY29tcGFyZSBsZW5zO1xuICAgIGxldCB0b3RsZW4gPSBBcnJheS5mb2xkX2xlZnQgKCArICkgMCBsZW5zIGluXG4gICAgKGxlbiwgY291bnQgdCwgdG90bGVuLCBsZW5zLigwKSwgbGVucy4obGVuLzIpLCBsZW5zLihsZW4tMSkpXG5cblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEEgcHJldHR5LXByaW50aW5nIGZhY2lsaXR5IGFuZCBkZWZpbml0aW9uIG9mIGZvcm1hdHRlcnMgZm9yICdwYXJhbGxlbCdcbiAgIChpLmUuIHVucmVsYXRlZCBvciBpbmRlcGVuZGVudCkgcHJldHR5LXByaW50aW5nIG9uIG11bHRpcGxlIG91dCBjaGFubmVscy4gKilcblxuKCpcbiAgIFRoZSBwcmV0dHktcHJpbnRpbmcgZW5naW5lIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiopXG5cbmxldCBpZCB4ID0geFxuXG4oKiBBIGRldm90ZWQgdHlwZSBmb3Igc2l6ZXMgdG8gYXZvaWQgY29uZnVzaW9uXG4gICBiZXR3ZWVuIHNpemVzIGFuZCBtZXJlIGludGVnZXJzLiAqKVxubW9kdWxlIFNpemUgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHRvX2ludCA6IHQgLT4gaW50XG4gIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICB2YWwgemVybyA6IHRcbiAgdmFsIHVua25vd24gOiB0XG4gIHZhbCBpc19rbm93biA6IHQgLT4gYm9vbFxuZW5kICA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgdG9faW50ID0gaWRcbiAgbGV0IG9mX2ludCA9IGlkXG4gIGxldCB6ZXJvID0gMFxuICBsZXQgdW5rbm93biA9IC0xXG4gIGxldCBpc19rbm93biBuID0gbiA+PSAwXG5lbmRcblxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgYm94ZXMgZGVmaW5pdGlvbjpcbiAgIGEgcHJldHR5LXByaW50aW5nIGJveCBpcyBlaXRoZXJcbiAgIC0gaGJveDogaG9yaXpvbnRhbCBib3ggKG5vIGxpbmUgc3BsaXR0aW5nKVxuICAgLSB2Ym94OiB2ZXJ0aWNhbCBib3ggKGV2ZXJ5IGJyZWFrIGhpbnQgc3BsaXRzIHRoZSBsaW5lKVxuICAgLSBodmJveDogaG9yaXpvbnRhbC92ZXJ0aWNhbCBib3hcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIGJveCBpZiBpdCBmaXRzIG9uXG4gICAgICB0aGUgY3VycmVudCBsaW5lLCBvdGhlcndpc2UgdGhlIGJveCBiZWhhdmVzIGFzIGEgdmVydGljYWwgYm94KVxuICAgLSBob3Zib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3hcbiAgICAgKHRoZSBib3ggaXMgY29tcGFjdGluZyBtYXRlcmlhbCwgcHJpbnRpbmcgYXMgbXVjaCBtYXRlcmlhbCBhcyBwb3NzaWJsZVxuICAgICAgb24gZXZlcnkgbGluZXMpXG4gICAtIGJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveCB3aXRoIGVuaGFuY2VkIGJveCBzdHJ1Y3R1cmVcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGJveCBidXQgYnJlYWsgaGludHMgc3BsaXRcbiAgICAgIHRoZSBsaW5lIGlmIHNwbGl0dGluZyB3b3VsZCBtb3ZlIHRvIHRoZSBsZWZ0KVxuKilcbnR5cGUgYm94X3R5cGUgPSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHNcblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIHRva2VucyBkZWZpbml0aW9uOlxuICAgYXJlIGVpdGhlciB0ZXh0IHRvIHByaW50IG9yIHByZXR0eSBwcmludGluZ1xuICAgZWxlbWVudHMgdGhhdCBkcml2ZSBpbmRlbnRhdGlvbiBhbmQgbGluZSBzcGxpdHRpbmcuICopXG50eXBlIHBwX3Rva2VuID1cbiAgfCBQcF90ZXh0IG9mIHN0cmluZyAgICAgICAgICAoKiBub3JtYWwgdGV4dCAqKVxuICB8IFBwX2JyZWFrIG9mIHsgICAgICAgICAgICAgICgqIGNvbXBsZXRlIGJyZWFrICopXG4gICAgICBmaXRzOiBzdHJpbmcgKiBpbnQgKiBzdHJpbmc7ICAgKCogbGluZSBpcyBub3Qgc3BsaXQgKilcbiAgICAgIGJyZWFrczogc3RyaW5nICogaW50ICogc3RyaW5nOyAoKiBsaW5lIGlzIHNwbGl0ICopXG4gICAgfVxuICB8IFBwX3RicmVhayBvZiBpbnQgKiBpbnQgICAgICgqIGdvIHRvIG5leHQgdGFidWxhdGlvbiAqKVxuICB8IFBwX3N0YWIgICAgICAgICAgICAgICAgICAgICgqIHNldCBhIHRhYnVsYXRpb24gKilcbiAgfCBQcF9iZWdpbiBvZiBpbnQgKiBib3hfdHlwZSAoKiBiZWdpbm5pbmcgb2YgYSBib3ggKilcbiAgfCBQcF9lbmQgICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSBib3ggKilcbiAgfCBQcF90YmVnaW4gb2YgdGJveCAgICAgICAgICAoKiBiZWdpbm5pbmcgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX3RlbmQgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfbmV3bGluZSAgICAgICAgICAgICAgICAgKCogdG8gZm9yY2UgYSBuZXdsaW5lIGluc2lkZSBhIGJveCAqKVxuICB8IFBwX2lmX25ld2xpbmUgICAgICAgICAgICAgICgqIHRvIGRvIHNvbWV0aGluZyBvbmx5IGlmIHRoaXMgdmVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgaGFzIGJlZW4gYnJva2VuICopXG4gIHwgUHBfb3Blbl90YWcgb2Ygc3RhZyAgICAgICAgICgqIG9wZW5pbmcgYSB0YWcgbmFtZSAqKVxuICB8IFBwX2Nsb3NlX3RhZyAgICAgICAgICAgICAgICgqIGNsb3NpbmcgdGhlIG1vc3QgcmVjZW50bHkgb3BlbiB0YWcgKilcblxuYW5kIHN0YWcgPSAuLlxuXG5hbmQgdGJveCA9IFBwX3Rib3ggb2YgaW50IGxpc3QgcmVmICAoKiBUYWJ1bGF0aW9uIGJveCAqKVxuXG50eXBlIHRhZyA9IHN0cmluZ1xudHlwZSBzdGFnICs9IFN0cmluZ190YWcgb2YgdGFnXG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlOlxuICAgcHJldHR5LXByaW50aW5nIG1hdGVyaWFsIGlzIG5vdCB3cml0dGVuIGluIHRoZSBvdXRwdXQgYXMgc29vbiBhcyBlbWl0dGVkO1xuICAgaW5zdGVhZCwgdGhlIG1hdGVyaWFsIGlzIHNpbXBseSByZWNvcmRlZCBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUsXG4gICB1bnRpbCB0aGUgZW5jbG9zaW5nIGJveCBoYXMgYSBrbm93biBjb21wdXRlZCBzaXplIGFuZCBwcm9wZXIgc3BsaXR0aW5nXG4gICBkZWNpc2lvbnMgY2FuIGJlIG1hZGUuXG5cbiAgIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBjb250YWlucyBmb3JtYXR0aW5nIGVsZW1lbnRzIHRvIGJlIHByaW50ZWQuXG4gICBFYWNoIGZvcm1hdHRpbmcgZWxlbWVudCBpcyBhIHR1cGxlIChzaXplLCB0b2tlbiwgbGVuZ3RoKSwgd2hlcmVcbiAgIC0gbGVuZ3RoIGlzIHRoZSBkZWNsYXJlZCBsZW5ndGggb2YgdGhlIHRva2VuLFxuICAgLSBzaXplIGlzIGVmZmVjdGl2ZSBzaXplIG9mIHRoZSB0b2tlbiB3aGVuIGl0IGlzIHByaW50ZWRcbiAgICAgKHNpemUgaXMgc2V0IHdoZW4gdGhlIHNpemUgb2YgdGhlIGJveCBpcyBrbm93biwgc28gdGhhdCBzaXplIG9mIGJyZWFrXG4gICAgICBoaW50cyBhcmUgZGVmaW5pdGl2ZSkuICopXG50eXBlIHBwX3F1ZXVlX2VsZW0gPSB7XG4gIG11dGFibGUgc2l6ZSA6IFNpemUudDtcbiAgdG9rZW4gOiBwcF90b2tlbjtcbiAgbGVuZ3RoIDogaW50O1xufVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9xdWV1ZSA9IHBwX3F1ZXVlX2VsZW0gUXVldWUudFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjazogc2Nhbm5pbmcgZWxlbWVudCBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9zY2FuX2VsZW0gPSB7XG4gIGxlZnRfdG90YWwgOiBpbnQ7ICgqIFZhbHVlIG9mIHBwX2xlZnRfdG90YWwgd2hlbiB0aGUgZWxlbWVudCB3YXMgZW5xdWV1ZWQuICopXG4gIHF1ZXVlX2VsZW0gOiBwcF9xdWV1ZV9lbGVtXG59XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOlxuICAgdGhlIGZvcm1hdHRpbmcgc3RhY2sgY29udGFpbnMgdGhlIGRlc2NyaXB0aW9uIG9mIGFsbCB0aGUgY3VycmVudGx5IGFjdGl2ZVxuICAgYm94ZXM7IHRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrIGlzIHVzZWQgdG8gc3BsaXQgdGhlIGxpbmVzXG4gICB3aGlsZSBwcmludGluZyB0b2tlbnMuICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOiBmb3JtYXR0aW5nIHN0YWNrIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIEVhY2ggc3RhY2sgZWxlbWVudCBkZXNjcmliZXMgYSBwcmV0dHktcHJpbnRpbmcgYm94LiAqKVxudHlwZSBwcF9mb3JtYXRfZWxlbSA9IHsgYm94X3R5cGUgOiBib3hfdHlwZTsgd2lkdGggOiBpbnQgfVxuXG4oKiBUaGUgZm9ybWF0dGVyIGRlZmluaXRpb24uXG4gICBFYWNoIGZvcm1hdHRlciB2YWx1ZSBpcyBhIHByZXR0eS1wcmludGVyIGluc3RhbmNlIHdpdGggYWxsIGl0c1xuICAgbWFjaGluZXJ5LiAqKVxudHlwZSBmb3JtYXR0ZXIgPSB7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcbiAgcHBfc2Nhbl9zdGFjayA6IHBwX3NjYW5fZWxlbSBTdGFjay50O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjay4gKilcbiAgcHBfZm9ybWF0X3N0YWNrIDogcHBfZm9ybWF0X2VsZW0gU3RhY2sudDtcbiAgcHBfdGJveF9zdGFjayA6IHRib3ggU3RhY2sudDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHNlbWFudGljcyB0YWcgc3RhY2suICopXG4gIHBwX3RhZ19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgcHBfbWFya19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgKCogVmFsdWUgb2YgcmlnaHQgbWFyZ2luLiAqKVxuICBtdXRhYmxlIHBwX21hcmdpbiA6IGludDtcbiAgKCogTWluaW1hbCBzcGFjZSBsZWZ0IGJlZm9yZSBtYXJnaW4sIHdoZW4gb3BlbmluZyBhIGJveC4gKilcbiAgbXV0YWJsZSBwcF9taW5fc3BhY2VfbGVmdCA6IGludDtcbiAgKCogTWF4aW11bSB2YWx1ZSBvZiBpbmRlbnRhdGlvbjpcbiAgICAgbm8gYm94IGNhbiBiZSBvcGVuZWQgZnVydGhlci4gKilcbiAgbXV0YWJsZSBwcF9tYXhfaW5kZW50IDogaW50O1xuICAoKiBTcGFjZSByZW1haW5pbmcgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbiAgbXV0YWJsZSBwcF9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBDdXJyZW50IHZhbHVlIG9mIGluZGVudGF0aW9uLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJlbnRfaW5kZW50IDogaW50O1xuICAoKiBUcnVlIHdoZW4gdGhlIGxpbmUgaGFzIGJlZW4gYnJva2VuIGJ5IHRoZSBwcmV0dHktcHJpbnRlci4gKilcbiAgbXV0YWJsZSBwcF9pc19uZXdfbGluZSA6IGJvb2w7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBhbHJlYWR5IHByaW50ZWQuICopXG4gIG11dGFibGUgcHBfbGVmdF90b3RhbCA6IGludDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGV2ZXIgcHV0IGluIHF1ZXVlLiAqKVxuICBtdXRhYmxlIHBwX3JpZ2h0X3RvdGFsIDogaW50O1xuICAoKiBDdXJyZW50IG51bWJlciBvZiBvcGVuIGJveGVzLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJfZGVwdGggOiBpbnQ7XG4gICgqIE1heGltdW0gbnVtYmVyIG9mIGJveGVzIHdoaWNoIGNhbiBiZSBzaW11bHRhbmVvdXNseSBvcGVuLiAqKVxuICBtdXRhYmxlIHBwX21heF9ib3hlcyA6IGludDtcbiAgKCogRWxsaXBzaXMgc3RyaW5nLiAqKVxuICBtdXRhYmxlIHBwX2VsbGlwc2lzIDogc3RyaW5nO1xuICAoKiBPdXRwdXQgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gICgqIEZsdXNoaW5nIGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGJyZWFrIGhpbnRzIHNwYWNlcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xuICAoKiBBcmUgdGFncyBwcmludGVkID8gKilcbiAgbXV0YWJsZSBwcF9wcmludF90YWdzIDogYm9vbDtcbiAgKCogQXJlIHRhZ3MgbWFya2VkID8gKilcbiAgbXV0YWJsZSBwcF9tYXJrX3RhZ3MgOiBib29sO1xuICAoKiBGaW5kIG9wZW5pbmcgYW5kIGNsb3NpbmcgbWFya2VycyBvZiB0YWdzLiAqKVxuICBtdXRhYmxlIHBwX21hcmtfb3Blbl90YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9tYXJrX2Nsb3NlX3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX3ByaW50X29wZW5fdGFnIDogc3RhZyAtPiB1bml0O1xuICBtdXRhYmxlIHBwX3ByaW50X2Nsb3NlX3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxuICBwcF9xdWV1ZSA6IHBwX3F1ZXVlO1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgc3BlY2lmaWMgdGFnIGhhbmRsaW5nIGZ1bmN0aW9ucy4gKilcbnR5cGUgZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fc3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3N0YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgcHJpbnRfb3Blbl9zdGFnIDogc3RhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV9zdGFnIDogc3RhZyAtPiB1bml0O1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb25zIHRvIG91dHB1dCBtYXRlcmlhbC4gKilcbnR5cGUgZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPSB7XG4gIG91dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICBvdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICBvdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gIG91dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbn1cblxuXG4oKlxuXG4gIEF1eGlsaWFyaWVzIGFuZCBiYXNpYyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEVudGVyIGEgdG9rZW4gaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2VucXVldWUgc3RhdGUgdG9rZW4gPVxuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBzdGF0ZS5wcF9yaWdodF90b3RhbCArIHRva2VuLmxlbmd0aDtcbiAgUXVldWUuYWRkIHRva2VuIHN0YXRlLnBwX3F1ZXVlXG5cblxubGV0IHBwX2NsZWFyX3F1ZXVlIHN0YXRlID1cbiAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSAxOyBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSAxO1xuICBRdWV1ZS5jbGVhciBzdGF0ZS5wcF9xdWV1ZVxuXG5cbigqIFBwX2luZmluaXR5OiBsYXJnZSB2YWx1ZSBmb3IgZGVmYXVsdCB0b2tlbnMgc2l6ZS5cblxuICAgUHBfaW5maW5pdHkgaXMgZG9jdW1lbnRlZCBhcyBiZWluZyBncmVhdGVyIHRoYW4gMWUxMDsgdG8gYXZvaWRcbiAgIGNvbmZ1c2lvbiBhYm91dCB0aGUgd29yZCAnZ3JlYXRlcicsIHdlIGNob29zZSBwcF9pbmZpbml0eSBncmVhdGVyXG4gICB0aGFuIDFlMTAgKyAxOyBmb3IgY29ycmVjdCBoYW5kbGluZyBvZiB0ZXN0cyBpbiB0aGUgYWxnb3JpdGhtLFxuICAgcHBfaW5maW5pdHkgbXVzdCBiZSBldmVuIG9uZSBtb3JlIHRoYW4gMWUxMCArIDE7IGxldCdzIHN0YW5kIG9uIHRoZVxuICAgc2FmZSBzaWRlIGJ5IGNob29zaW5nIDEuZTEwKzEwLlxuXG4gICBQcF9pbmZpbml0eSBjb3VsZCBwcm9iYWJseSBiZSAxMDczNzQxODIzIHRoYXQgaXMgMl4zMCAtIDEsIHRoYXQgaXNcbiAgIHRoZSBtaW5pbWFsIHVwcGVyIGJvdW5kIGZvciBpbnRlZ2Vyczsgbm93IHRoYXQgbWF4X2ludCBpcyBkZWZpbmVkLFxuICAgdGhpcyBsaW1pdCBjb3VsZCBhbHNvIGJlIGRlZmluZWQgYXMgbWF4X2ludCAtIDEuXG5cbiAgIEhvd2V2ZXIsIGJlZm9yZSBzZXR0aW5nIHBwX2luZmluaXR5IHRvIHNvbWV0aGluZyBhcm91bmQgbWF4X2ludCwgd2VcbiAgIG11c3QgY2FyZWZ1bGx5IGRvdWJsZS1jaGVjayBhbGwgdGhlIGludGVnZXIgYXJpdGhtZXRpYyBvcGVyYXRpb25zXG4gICB0aGF0IGludm9sdmUgcHBfaW5maW5pdHksIHNpbmNlIGFueSBvdmVyZmxvdyB3b3VsZCB3cmVjayBoYXZvYyB0aGVcbiAgIHByZXR0eS1wcmludGluZyBhbGdvcml0aG0ncyBpbnZhcmlhbnRzLiBHaXZlbiB0aGF0IHRoaXMgYXJpdGhtZXRpY1xuICAgY29ycmVjdG5lc3MgY2hlY2sgaXMgZGlmZmljdWx0IGFuZCBlcnJvciBwcm9uZSBhbmQgZ2l2ZW4gdGhhdCAxZTEwXG4gICArIDEgaXMgaW4gcHJhY3RpY2UgbGFyZ2UgZW5vdWdoLCB0aGVyZSBpcyBubyBuZWVkIHRvIGF0dGVtcHQgdG8gc2V0XG4gICBwcF9pbmZpbml0eSB0byB0aGUgdGhlb3JldGljYWxseSBtYXhpbXVtIGxpbWl0LiBJdCBpcyBub3Qgd29ydGggdGhlXG4gICBidXJkZW4gISAqKVxubGV0IHBwX2luZmluaXR5ID0gMTAwMDAwMDAxMFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIGZvciB0aGUgZm9ybWF0dGVyLiAqKVxubGV0IHBwX291dHB1dF9zdHJpbmcgc3RhdGUgcyA9IHN0YXRlLnBwX291dF9zdHJpbmcgcyAwIChTdHJpbmcubGVuZ3RoIHMpXG5hbmQgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZSAoKVxuYW5kIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9zcGFjZXMgblxuYW5kIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9pbmRlbnQgblxuXG4oKiBGb3JtYXQgYSB0ZXh0dWFsIHRva2VuICopXG5sZXQgZm9ybWF0X3BwX3RleHQgc3RhdGUgc2l6ZSB0ZXh0ID1cbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gc2l6ZTtcbiAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSB0ZXh0O1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSBmYWxzZVxuXG4oKiBGb3JtYXQgYSBzdHJpbmcgYnkgaXRzIGxlbmd0aCwgaWYgbm90IGVtcHR5ICopXG5sZXQgZm9ybWF0X3N0cmluZyBzdGF0ZSBzID1cbiAgaWYgcyA8PiBcIlwiIHRoZW4gZm9ybWF0X3BwX3RleHQgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG4oKiBUbyBmb3JtYXQgYSBicmVhaywgaW5kZW50aW5nIGEgbmV3IGxpbmUuICopXG5sZXQgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKGJlZm9yZSwgb2Zmc2V0LCBhZnRlcikgd2lkdGggPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIHRydWU7XG4gIGxldCBpbmRlbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZnNldCBpblxuICAoKiBEb24ndCBpbmRlbnQgbW9yZSB0aGFuIHBwX21heF9pbmRlbnQuICopXG4gIGxldCByZWFsX2luZGVudCA9IG1pbiBzdGF0ZS5wcF9tYXhfaW5kZW50IGluZGVudCBpblxuICBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA8LSByZWFsX2luZGVudDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudDtcbiAgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudDtcbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBhZnRlclxuXG5cbigqIFRvIGZvcmNlIGEgbGluZSBicmVhayBpbnNpZGUgYSBib3g6IG5vIG9mZnNldCBpcyBhZGRlZC4gKilcbmxldCBicmVha19saW5lIHN0YXRlIHdpZHRoID0gYnJlYWtfbmV3X2xpbmUgc3RhdGUgKFwiXCIsIDAsIFwiXCIpIHdpZHRoXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrIHRoYXQgZml0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAoYmVmb3JlLCB3aWR0aCwgYWZ0ZXIpID1cbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBiZWZvcmU7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIHdpZHRoO1xuICBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIHdpZHRoO1xuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGFmdGVyXG5cblxuKCogVG8gaW5kZW50IG5vIG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LCBpZiBvbmUgdHJpZXMgdG8gb3BlbiBhIGJveFxuICAgYmV5b25kIHBwX21heF9pbmRlbnQsIHRoZW4gdGhlIGJveCBpcyByZWplY3RlZCBvbiB0aGUgbGVmdFxuICAgYnkgc2ltdWxhdGluZyBhIGJyZWFrLiAqKVxubGV0IHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgPVxuICBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gIHwgTm9uZSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZVxuICB8IFNvbWUgeyBib3hfdHlwZTsgd2lkdGggfSAtPlxuICAgIGlmIHdpZHRoID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuXG4gICAgICBtYXRjaCBib3hfdHlwZSB3aXRoXG4gICAgICB8IFBwX2ZpdHMgfCBQcF9oYm94IC0+ICgpXG4gICAgICB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG5cblxuKCogVG8gc2tpcCBhIHRva2VuLCBpZiB0aGUgcHJldmlvdXMgbGluZSBoYXMgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfc2tpcF90b2tlbiBzdGF0ZSA9XG4gIG1hdGNoIFF1ZXVlLnRha2Vfb3B0IHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIHByaW50X2lmX25ld2xpbmUgbXVzdCBoYXZlIGJlZW4gdGhlIGxhc3QgcHJpbnRpbmcgY29tbWFuZCAqKVxuICB8IFNvbWUgeyBzaXplOyBsZW5ndGg7IF8gfSAtPlxuICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gc3RhdGUucHBfbGVmdF90b3RhbCAtIGxlbmd0aDtcbiAgICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgKyBTaXplLnRvX2ludCBzaXplXG5cblxuKCpcblxuICBUaGUgbWFpbiBwcmV0dHkgcHJpbnRpbmcgZnVuY3Rpb25zLlxuXG4qKVxuXG4oKiBGb3JtYXR0aW5nIGEgdG9rZW4gd2l0aCBhIGdpdmVuIHNpemUuICopXG5sZXQgZm9ybWF0X3BwX3Rva2VuIHN0YXRlIHNpemUgPSBmdW5jdGlvblxuXG4gIHwgUHBfdGV4dCBzIC0+XG4gICAgZm9ybWF0X3BwX3RleHQgc3RhdGUgc2l6ZSBzXG5cbiAgfCBQcF9iZWdpbiAob2ZmLCB0eSkgLT5cbiAgICBsZXQgaW5zZXJ0aW9uX3BvaW50ID0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCBpblxuICAgIGlmIGluc2VydGlvbl9wb2ludCA+IHN0YXRlLnBwX21heF9pbmRlbnQgdGhlblxuICAgICAgKCogY2FuIG5vdCBvcGVuIGEgYm94IHJpZ2h0IHRoZXJlLiAqKVxuICAgICAgYmVnaW4gcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSBlbmQ7XG4gICAgbGV0IHdpZHRoID0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIG9mZiBpblxuICAgIGxldCBib3hfdHlwZSA9XG4gICAgICBtYXRjaCB0eSB3aXRoXG4gICAgICB8IFBwX3Zib3ggLT4gUHBfdmJveFxuICAgICAgfCBQcF9oYm94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggfCBQcF9maXRzIC0+XG4gICAgICAgIGlmIHNpemUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gdHkgZWxzZSBQcF9maXRzIGluXG4gICAgU3RhY2sucHVzaCB7IGJveF90eXBlOyB3aWR0aCB9IHN0YXRlLnBwX2Zvcm1hdF9zdGFja1xuXG4gIHwgUHBfZW5kIC0+XG4gICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgfD4gaWdub3JlXG5cbiAgfCBQcF90YmVnaW4gKFBwX3Rib3ggXyBhcyB0Ym94KSAtPlxuICAgIFN0YWNrLnB1c2ggdGJveCBzdGF0ZS5wcF90Ym94X3N0YWNrXG5cbiAgfCBQcF90ZW5kIC0+XG4gICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHw+IGlnbm9yZVxuXG4gIHwgUHBfc3RhYiAtPlxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgfCBTb21lIChQcF90Ym94IHRhYnMpIC0+XG4gICAgICBsZXQgcmVjIGFkZF90YWIgbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgW10gLT4gW25dXG4gICAgICAgIHwgeCA6OiBsIGFzIGxzIC0+IGlmIG4gPCB4IHRoZW4gbiA6OiBscyBlbHNlIHggOjogYWRkX3RhYiBuIGwgaW5cbiAgICAgIHRhYnMgOj0gYWRkX3RhYiAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCkgIXRhYnNcbiAgICBlbmRcblxuICB8IFBwX3RicmVhayAobiwgb2ZmKSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICB8IFNvbWUgKFBwX3Rib3ggdGFicykgLT5cbiAgICAgIGxldCB0YWIgPVxuICAgICAgICBtYXRjaCAhdGFicyB3aXRoXG4gICAgICAgIHwgW10gLT4gaW5zZXJ0aW9uX3BvaW50XG4gICAgICAgIHwgZmlyc3QgOjogXyAtPlxuICAgICAgICAgIGxldCByZWMgZmluZCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGhlYWQgOjogdGFpbCAtPlxuICAgICAgICAgICAgICBpZiBoZWFkID49IGluc2VydGlvbl9wb2ludCB0aGVuIGhlYWQgZWxzZSBmaW5kIHRhaWxcbiAgICAgICAgICAgIHwgW10gLT4gZmlyc3QgaW5cbiAgICAgICAgICBmaW5kICF0YWJzIGluXG4gICAgICBsZXQgb2Zmc2V0ID0gdGFiIC0gaW5zZXJ0aW9uX3BvaW50IGluXG4gICAgICBpZiBvZmZzZXQgPj0gMFxuICAgICAgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgKFwiXCIsIG9mZnNldCArIG4sIFwiXCIpXG4gICAgICBlbHNlIGJyZWFrX25ld19saW5lIHN0YXRlIChcIlwiLCB0YWIgKyBvZmYsIFwiXCIpIHN0YXRlLnBwX21hcmdpblxuICAgIGVuZFxuXG4gIHwgUHBfbmV3bGluZSAtPlxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgKCogTm8gb3BlbiBib3guICopXG4gICAgfCBTb21lIHsgd2lkdGg7IF99IC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcbiAgICBlbmRcblxuICB8IFBwX2lmX25ld2xpbmUgLT5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCAhPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgdGhlbiBwcF9za2lwX3Rva2VuIHN0YXRlXG5cbiAgfCBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IC0+XG4gICAgbGV0IGJlZm9yZSwgb2ZmLCBfID0gYnJlYWtzIGluXG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIGJveC4gKilcbiAgICB8IFNvbWUgeyBib3hfdHlwZTsgd2lkdGggfSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggYm94X3R5cGUgd2l0aFxuICAgICAgfCBQcF9ob3Zib3ggLT5cbiAgICAgICAgaWYgc2l6ZSArIFN0cmluZy5sZW5ndGggYmVmb3JlID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX2JveCAtPlxuICAgICAgICAoKiBIYXZlIHRoZSBsaW5lIGp1c3QgYmVlbiBicm9rZW4gaGVyZSA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2lzX25ld19saW5lIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHMgZWxzZVxuICAgICAgICBpZiBzaXplICsgU3RyaW5nLmxlbmd0aCBiZWZvcmUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGggZWxzZVxuICAgICAgICAoKiBicmVhayB0aGUgbGluZSBoZXJlIGxlYWRzIHRvIG5ldyBpbmRlbnRhdGlvbiA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ID4gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF9odmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgIHwgUHBfZml0cyAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF92Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgfCBQcF9oYm94IC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgfCBQcF9vcGVuX3RhZyB0YWdfbmFtZSAtPlxuICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19vcGVuX3RhZyB0YWdfbmFtZSBpblxuICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlcjtcbiAgICAgU3RhY2sucHVzaCB0YWdfbmFtZSBzdGF0ZS5wcF9tYXJrX3N0YWNrXG5cbiAgIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgIGJlZ2luIG1hdGNoIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfbWFya19zdGFjayB3aXRoXG4gICAgIHwgTm9uZSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICAgfCBTb21lIHRhZ19uYW1lIC0+XG4gICAgICAgbGV0IG1hcmtlciA9IHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIHRhZ19uYW1lIGluXG4gICAgICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBtYXJrZXJcbiAgICAgZW5kXG5cblxuKCogUHJpbnQgaWYgdG9rZW4gc2l6ZSBpcyBrbm93biBlbHNlIHByaW50aW5nIGlzIGRlbGF5ZWQuXG4gICBQcmludGluZyBpcyBkZWxheWVkIHdoZW4gdGhlIHRleHQgd2FpdGluZyBpbiB0aGUgcXVldWUgcmVxdWlyZXNcbiAgIG1vcmUgcm9vbSB0byBmb3JtYXQgdGhhbiBleGlzdHMgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbmxldCByZWMgYWR2YW5jZV9sZWZ0IHN0YXRlID1cbiAgbWF0Y2ggUXVldWUucGVla19vcHQgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogTm8gdG9rZW5zIHRvIHByaW50ICopXG4gIHwgU29tZSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSAtPlxuICAgIGxldCBwZW5kaW5nX2NvdW50ID0gc3RhdGUucHBfcmlnaHRfdG90YWwgLSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIGluXG4gICAgaWYgU2l6ZS5pc19rbm93biBzaXplIHx8IHBlbmRpbmdfY291bnQgPj0gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIGJlZ2luXG4gICAgICBRdWV1ZS50YWtlIHN0YXRlLnBwX3F1ZXVlIHw+IGlnbm9yZTsgKCogTm90IGVtcHR5OiB3ZSBwZWVrIGludG8gaXQgKilcbiAgICAgIGxldCBzaXplID0gaWYgU2l6ZS5pc19rbm93biBzaXplIHRoZW4gU2l6ZS50b19pbnQgc2l6ZSBlbHNlIHBwX2luZmluaXR5IGluXG4gICAgICBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSB0b2tlbjtcbiAgICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gbGVuZ3RoICsgc3RhdGUucHBfbGVmdF90b3RhbDtcbiAgICAgIChhZHZhbmNlX2xlZnQgW0B0YWlsY2FsbF0pIHN0YXRlXG4gICAgZW5kXG5cblxuKCogVG8gZW5xdWV1ZSBhIHRva2VuIDogdHJ5IHRvIGFkdmFuY2UuICopXG5sZXQgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHRvayA9IHBwX2VucXVldWUgc3RhdGUgdG9rOyBhZHZhbmNlX2xlZnQgc3RhdGVcblxuXG4oKiBUbyBlbnF1ZXVlIHN0cmluZ3MuICopXG5sZXQgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzID1cbiAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZTsgdG9rZW4gPSBQcF90ZXh0IHM7IGxlbmd0aCA9IFNpemUudG9faW50IHNpemUgfVxuXG5cbmxldCBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzID1cbiAgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgKFNpemUub2ZfaW50IChTdHJpbmcubGVuZ3RoIHMpKSBzXG5cblxuKCogUm91dGluZXMgZm9yIHNjYW4gc3RhY2tcbiAgIGRldGVybWluZSBzaXplIG9mIGJveGVzLiAqKVxuXG4oKiBUaGUgc2Nhbl9zdGFjayBpcyBuZXZlciBlbXB0eS4gKilcbmxldCBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhY2sgPVxuICBTdGFjay5jbGVhciBzdGFjaztcbiAgbGV0IHF1ZXVlX2VsZW0gPSB7IHNpemUgPSBTaXplLnVua25vd247IHRva2VuID0gUHBfdGV4dCBcIlwiOyBsZW5ndGggPSAwIH0gaW5cbiAgU3RhY2sucHVzaCB7IGxlZnRfdG90YWwgPSAtMTsgcXVldWVfZWxlbSB9IHN0YWNrXG5cbigqIFNldHRpbmcgdGhlIHNpemUgb2YgYm94ZXMgb24gc2NhbiBzdGFjazpcbiAgIGlmIHR5ID0gdHJ1ZSB0aGVuIHNpemUgb2YgYnJlYWsgaXMgc2V0IGVsc2Ugc2l6ZSBvZiBib3ggaXMgc2V0O1xuICAgaW4gZWFjaCBjYXNlIHBwX3NjYW5fc3RhY2sgaXMgcG9wcGVkLlxuXG4gICBOb3RlOlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiBzY2FuIHN0YWNrIGlzIGV4aGF1c3RpdmUsIHNpbmNlIHNjYW5fc3RhY2sgaXMgbmV2ZXJcbiAgIGVtcHR5LlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiB0b2tlbiBpbiBzY2FuIHN0YWNrIGlzIGFsc28gZXhoYXVzdGl2ZSxcbiAgIHNpbmNlIHNjYW5fcHVzaCBpcyB1c2VkIG9uIGJyZWFrcyBhbmQgb3BlbmluZyBvZiBib3hlcy4gKilcbmxldCBzZXRfc2l6ZSBzdGF0ZSB0eSA9XG4gIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxuICB8IFNvbWUgeyBsZWZ0X3RvdGFsOyBxdWV1ZV9lbGVtIH0gLT5cbiAgICBsZXQgc2l6ZSA9IFNpemUudG9faW50IHF1ZXVlX2VsZW0uc2l6ZSBpblxuICAgICgqIHRlc3QgaWYgc2NhbiBzdGFjayBjb250YWlucyBhbnkgZGF0YSB0aGF0IGlzIG5vdCBvYnNvbGV0ZS4gKilcbiAgICBpZiBsZWZ0X3RvdGFsIDwgc3RhdGUucHBfbGVmdF90b3RhbCB0aGVuXG4gICAgICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhdGUucHBfc2Nhbl9zdGFja1xuICAgIGVsc2VcbiAgICAgIG1hdGNoIHF1ZXVlX2VsZW0udG9rZW4gd2l0aFxuICAgICAgfCBQcF9icmVhayBfIHwgUHBfdGJyZWFrIChfLCBfKSAtPlxuICAgICAgICBpZiB0eSB0aGVuIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5zaXplIDwtIFNpemUub2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB8PiBpZ25vcmVcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX2JlZ2luIChfLCBfKSAtPlxuICAgICAgICBpZiBub3QgdHkgdGhlbiBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uc2l6ZSA8LSBTaXplLm9mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgfD4gaWdub3JlXG4gICAgICAgIGVuZFxuICAgICAgfCBQcF90ZXh0IF8gfCBQcF9zdGFiIHwgUHBfdGJlZ2luIF8gfCBQcF90ZW5kIHwgUHBfZW5kXG4gICAgICB8IFBwX25ld2xpbmUgfCBQcF9pZl9uZXdsaW5lIHwgUHBfb3Blbl90YWcgXyB8IFBwX2Nsb3NlX3RhZyAtPlxuICAgICAgICAoKSAoKiBzY2FuX3B1c2ggaXMgb25seSB1c2VkIGZvciBicmVha3MgYW5kIGJveGVzLiAqKVxuXG5cbigqIFB1c2ggYSB0b2tlbiBvbiBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay5cbiAgIElmIGIgaXMgdHJ1ZSBzZXRfc2l6ZSBpcyBjYWxsZWQuICopXG5sZXQgc2Nhbl9wdXNoIHN0YXRlIGIgdG9rZW4gPVxuICBwcF9lbnF1ZXVlIHN0YXRlIHRva2VuO1xuICBpZiBiIHRoZW4gc2V0X3NpemUgc3RhdGUgdHJ1ZTtcbiAgbGV0IGVsZW0gPSB7IGxlZnRfdG90YWwgPSBzdGF0ZS5wcF9yaWdodF90b3RhbDsgcXVldWVfZWxlbSA9IHRva2VuIH0gaW5cbiAgU3RhY2sucHVzaCBlbGVtIHN0YXRlLnBwX3NjYW5fc3RhY2tcblxuXG4oKiBUbyBvcGVuIGEgbmV3IGJveCA6XG4gICB0aGUgdXNlciBtYXkgc2V0IHRoZSBkZXB0aCBib3VuZCBwcF9tYXhfYm94ZXNcbiAgIGFueSB0ZXh0IG5lc3RlZCBkZWVwZXIgaXMgcHJpbnRlZCBhcyB0aGUgZWxsaXBzaXMgc3RyaW5nLiAqKVxubGV0IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgYnJfdHkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX2JlZ2luIChpbmRlbnQsIGJyX3R5KTsgbGVuZ3RoID0gMCB9IGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIGZhbHNlIGVsZW0gZWxzZVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID0gc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmcgc3RhdGUgc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUaGUgYm94IHdoaWNoIGlzIGFsd2F5cyBvcGVuLiAqKVxubGV0IHBwX29wZW5fc3lzX2JveCBzdGF0ZSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hvdmJveFxuXG4oKiBDbG9zZSBhIGJveCwgc2V0dGluZyBzaXplcyBvZiBpdHMgc3ViIGJveGVzLiAqKVxubGV0IHBwX2Nsb3NlX2JveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBiZWdpblxuICAgICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfZW5kOyBsZW5ndGggPSAwIH07XG4gICAgICBzZXRfc2l6ZSBzdGF0ZSB0cnVlOyBzZXRfc2l6ZSBzdGF0ZSBmYWxzZVxuICAgIGVuZDtcbiAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxO1xuICBlbmRcblxuXG4oKiBPcGVuIGEgdGFnLCBwdXNoaW5nIGl0IG9uIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfb3Blbl9zdGFnIHN0YXRlIHRhZ19uYW1lID1cbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gIGJlZ2luXG4gICAgU3RhY2sucHVzaCB0YWdfbmFtZSBzdGF0ZS5wcF90YWdfc3RhY2s7XG4gICAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgdGFnX25hbWVcbiAgZW5kO1xuICBpZiBzdGF0ZS5wcF9tYXJrX3RhZ3MgdGhlblxuICAgIGxldCB0b2tlbiA9IFBwX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuOyBsZW5ndGggPSAwIH1cblxuXG4oKiBDbG9zZSBhIHRhZywgcG9wcGluZyBpdCBmcm9tIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfY2xvc2Vfc3RhZyBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfY2xvc2VfdGFnOyBsZW5ndGggPSAwIH07XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICAgIG1hdGNoIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfdGFnX3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gbW9yZSB0YWcgdG8gY2xvc2UuICopXG4gICAgfCBTb21lIHRhZ19uYW1lIC0+XG4gICAgICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgdGFnX25hbWVcblxubGV0IHBwX29wZW5fdGFnIHN0YXRlIHMgPSBwcF9vcGVuX3N0YWcgc3RhdGUgKFN0cmluZ190YWcgcylcbmxldCBwcF9jbG9zZV90YWcgc3RhdGUgKCkgPSBwcF9jbG9zZV9zdGFnIHN0YXRlICgpXG5cbmxldCBwcF9zZXRfcHJpbnRfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfcHJpbnRfdGFncyA8LSBiXG5sZXQgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfbWFya190YWdzIDwtIGJcbmxldCBwcF9nZXRfcHJpbnRfdGFncyBzdGF0ZSAoKSA9IHN0YXRlLnBwX3ByaW50X3RhZ3NcbmxldCBwcF9nZXRfbWFya190YWdzIHN0YXRlICgpID0gc3RhdGUucHBfbWFya190YWdzXG5sZXQgcHBfc2V0X3RhZ3Mgc3RhdGUgYiA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0YXRlIGI7IHBwX3NldF9tYXJrX3RhZ3Mgc3RhdGUgYlxuXG5cbigqIEhhbmRsaW5nIHRhZyBoYW5kbGluZyBmdW5jdGlvbnM6IGdldC9zZXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG1hcmtfb3Blbl9zdGFnID0gc3RhdGUucHBfbWFya19vcGVuX3RhZztcbiAgbWFya19jbG9zZV9zdGFnID0gc3RhdGUucHBfbWFya19jbG9zZV90YWc7XG4gIHByaW50X29wZW5fc3RhZyA9IHN0YXRlLnBwX3ByaW50X29wZW5fdGFnO1xuICBwcmludF9jbG9zZV9zdGFnID0gc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnO1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3N0YWcgPSBtb3Q7XG4gICAgIG1hcmtfY2xvc2Vfc3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl9zdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV9zdGFnID0gcGN0O1xuICB9ID1cbiAgc3RhdGUucHBfbWFya19vcGVuX3RhZyA8LSBtb3Q7XG4gIHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIDwtIG1jdDtcbiAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgPC0gcG90O1xuICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgPC0gcGN0XG5cblxuKCogSW5pdGlhbGl6ZSBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9yaW5pdCBzdGF0ZSA9XG4gIHBwX2NsZWFyX3F1ZXVlIHN0YXRlO1xuICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhdGUucHBfc2Nhbl9zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfZm9ybWF0X3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF90Ym94X3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF90YWdfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX21hcmtfc3RhY2s7XG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIDA7XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gMDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW47XG4gIHBwX29wZW5fc3lzX2JveCBzdGF0ZVxuXG5sZXQgY2xlYXJfdGFnX3N0YWNrIHN0YXRlID1cbiAgU3RhY2suaXRlciAoZnVuIF8gLT4gcHBfY2xvc2VfdGFnIHN0YXRlICgpKSBzdGF0ZS5wcF90YWdfc3RhY2tcblxuXG4oKiBGbHVzaGluZyBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBiID1cbiAgY2xlYXJfdGFnX3N0YWNrIHN0YXRlO1xuICB3aGlsZSBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSBkb1xuICAgIHBwX2Nsb3NlX2JveCBzdGF0ZSAoKVxuICBkb25lO1xuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBwcF9pbmZpbml0eTtcbiAgYWR2YW5jZV9sZWZ0IHN0YXRlO1xuICBpZiBiIHRoZW4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHBwX3Jpbml0IHN0YXRlXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBmb3JtYXQgdmFsdWVzIGFuZCB1c2UgYm94ZXMuXG5cbiopXG5cbigqIFRvIGZvcm1hdCBhIHN0cmluZy4gKilcbmxldCBwcF9wcmludF9hc19zaXplIHN0YXRlIHNpemUgcyA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHNcblxuXG5sZXQgcHBfcHJpbnRfYXMgc3RhdGUgaXNpemUgcyA9XG4gIHBwX3ByaW50X2FzX3NpemUgc3RhdGUgKFNpemUub2ZfaW50IGlzaXplKSBzXG5cblxubGV0IHBwX3ByaW50X3N0cmluZyBzdGF0ZSBzID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG5cbigqIFRvIGZvcm1hdCBhbiBpbnRlZ2VyLiAqKVxubGV0IHBwX3ByaW50X2ludCBzdGF0ZSBpID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChJbnQudG9fc3RyaW5nIGkpXG5cbigqIFRvIGZvcm1hdCBhIGZsb2F0LiAqKVxubGV0IHBwX3ByaW50X2Zsb2F0IHN0YXRlIGYgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9mbG9hdCBmKVxuXG4oKiBUbyBmb3JtYXQgYSBib29sZWFuLiAqKVxubGV0IHBwX3ByaW50X2Jvb2wgc3RhdGUgYiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Jvb2wgYilcblxuKCogVG8gZm9ybWF0IGEgY2hhci4gKilcbmxldCBwcF9wcmludF9jaGFyIHN0YXRlIGMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAxIChTdHJpbmcubWFrZSAxIGMpXG5cblxuKCogT3BlbmluZyBib3hlcy4gKilcbmxldCBwcF9vcGVuX2hib3ggc3RhdGUgKCkgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9oYm94XG5hbmQgcHBfb3Blbl92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfdmJveFxuXG5hbmQgcHBfb3Blbl9odmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2h2Ym94XG5hbmQgcHBfb3Blbl9ob3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ob3Zib3hcbmFuZCBwcF9vcGVuX2JveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2JveFxuXG5cbigqIFByaW50aW5nIHF1ZXVlZCB0ZXh0LlxuXG4gICBbcHBfcHJpbnRfZmx1c2hdIHByaW50cyBhbGwgcGVuZGluZyBpdGVtcyBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYW5kXG4gICB0aGVuIGZsdXNoZXMgdGhlIGxvdyBsZXZlbCBvdXRwdXQgZGV2aWNlIG9mIHRoZSBmb3JtYXR0ZXIgdG8gYWN0dWFsbHlcbiAgIGRpc3BsYXkgcHJpbnRpbmcgbWF0ZXJpYWwuXG5cbiAgIFtwcF9wcmludF9uZXdsaW5lXSBiZWhhdmVzIGFzIFtwcF9wcmludF9mbHVzaF0gYWZ0ZXIgcHJpbnRpbmcgYW4gYWRkaXRpb25hbFxuICAgbmV3IGxpbmUuICopXG5sZXQgcHBfcHJpbnRfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIHRydWU7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuYW5kIHBwX3ByaW50X2ZsdXNoIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgZmFsc2U7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuXG5cbigqIFRvIGdldCBhIG5ld2xpbmUgd2hlbiBvbmUgZG9lcyBub3Qgd2FudCB0byBjbG9zZSB0aGUgY3VycmVudCBib3guICopXG5sZXQgcHBfZm9yY2VfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfbmV3bGluZTsgbGVuZ3RoID0gMCB9XG5cblxuKCogVG8gZm9ybWF0IHNvbWV0aGluZywgb25seSBpbiBjYXNlIHRoZSBsaW5lIGhhcyBqdXN0IGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3ByaW50X2lmX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGVcbiAgICAgIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9pZl9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBHZW5lcmFsaXplZCBicmVhayBoaW50IHRoYXQgYWxsb3dzIHByaW50aW5nIHN0cmluZ3MgYmVmb3JlL2FmdGVyXG4gICBzYW1lLWxpbmUgb2Zmc2V0ICh3aWR0aCkgb3IgbmV3LWxpbmUgb2Zmc2V0ICopXG5sZXQgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlIH5maXRzIH5icmVha3MgPVxuICBsZXQgYmVmb3JlLCB3aWR0aCwgYWZ0ZXIgPSBmaXRzIGluXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IHRva2VuID0gUHBfYnJlYWsgeyBmaXRzOyBicmVha3MgfSBpblxuICAgIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoIGJlZm9yZSArIHdpZHRoICsgU3RyaW5nLmxlbmd0aCBhZnRlciBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbjsgbGVuZ3RoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cbigqIFByaW50aW5nIGJyZWFrIGhpbnRzOlxuICAgQSBicmVhayBoaW50IGluZGljYXRlcyB3aGVyZSBhIGJveCBtYXkgYmUgYnJva2VuLlxuICAgSWYgbGluZSBpcyBicm9rZW4gdGhlbiBvZmZzZXQgaXMgYWRkZWQgdG8gdGhlIGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50XG4gICBib3ggZWxzZSAodGhlIHZhbHVlIG9mKSB3aWR0aCBibGFua3MgYXJlIHByaW50ZWQuICopXG5sZXQgcHBfcHJpbnRfYnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlXG4gICAgfmZpdHM6KFwiXCIsIHdpZHRoLCBcIlwiKSB+YnJlYWtzOihcIlwiLCBvZmZzZXQsIFwiXCIpXG5cblxuKCogUHJpbnQgYSBzcGFjZSA6XG4gICBhIHNwYWNlIGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBhIHNpbmdsZSBzcGFjZSBpZiB0aGUgYnJlYWsgZG9lcyBub3RcbiAgIHNwbGl0IHRoZSBsaW5lO1xuICAgYSBjdXQgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIG5vdGhpbmcgaWYgdGhlIGJyZWFrIGRvZXMgbm90IHNwbGl0IHRoZVxuICAgbGluZS4gKilcbmxldCBwcF9wcmludF9zcGFjZSBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDEgMFxuYW5kIHBwX3ByaW50X2N1dCBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDAgMFxuXG5cbigqIFRhYnVsYXRpb24gYm94ZXMuICopXG5sZXQgcHBfb3Blbl90Ym94IHN0YXRlICgpID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLnplcm8gaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF90YmVnaW4gKFBwX3Rib3ggKHJlZiBbXSkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqIENsb3NlIGEgdGFidWxhdGlvbiBib3guICopXG5sZXQgcHBfY2xvc2VfdGJveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF90ZW5kOyBsZW5ndGggPSAwIH0gaW5cbiAgICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW07XG4gICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDFcbiAgZW5kXG5cblxuKCogUHJpbnQgYSB0YWJ1bGF0aW9uIGJyZWFrLiAqKVxubGV0IHBwX3ByaW50X3RicmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RicmVhayAod2lkdGgsIG9mZnNldCk7IGxlbmd0aCA9IHdpZHRoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cblxubGV0IHBwX3ByaW50X3RhYiBzdGF0ZSAoKSA9IHBwX3ByaW50X3RicmVhayBzdGF0ZSAwIDBcblxubGV0IHBwX3NldF90YWIgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9zdGFiOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBjb250cm9sIHRoZSBwcmV0dHktcHJpbnRlcnNcblxuKilcblxuKCogU2V0X21heF9ib3hlcy4gKilcbmxldCBwcF9zZXRfbWF4X2JveGVzIHN0YXRlIG4gPSBpZiBuID4gMSB0aGVuIHN0YXRlLnBwX21heF9ib3hlcyA8LSBuXG5cbigqIFRvIGtub3cgdGhlIGN1cnJlbnQgbWF4aW11bSBudW1iZXIgb2YgYm94ZXMgYWxsb3dlZC4gKilcbmxldCBwcF9nZXRfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbmxldCBwcF9vdmVyX21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxuKCogRWxsaXBzaXMuICopXG5sZXQgcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgcyA9IHN0YXRlLnBwX2VsbGlwc2lzIDwtIHNcbmFuZCBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSAoKSA9IHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVG8gc2V0IHRoZSBtYXJnaW4gb2YgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfbGltaXQgbiA9XG4gIGlmIG4gPCBwcF9pbmZpbml0eSB0aGVuIG4gZWxzZSBwcmVkIHBwX2luZmluaXR5XG5cblxuKCogSW50ZXJuYWwgcHJldHR5LXByaW50ZXIgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdCA8LSBuO1xuICAgIHN0YXRlLnBwX21heF9pbmRlbnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfcmluaXQgc3RhdGVcblxuXG4oKiBJbml0aWFsbHksIHdlIGhhdmUgOlxuICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0LCBhbmRcbiAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW4uICopXG5sZXQgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbiA9XG4gIGlmIG4gPiAxIHRoZW5cbiAgICBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgKHN0YXRlLnBwX21hcmdpbiAtIG4pXG5cblxubGV0IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2luZGVudFxuXG5sZXQgcHBfc2V0X21hcmdpbiBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9tYXJnaW4gPC0gbjtcbiAgICBsZXQgbmV3X21heF9pbmRlbnQgPVxuICAgICAgKCogVHJ5IHRvIG1haW50YWluIG1heF9pbmRlbnQgdG8gaXRzIGFjdHVhbCB2YWx1ZS4gKilcbiAgICAgIGlmIHN0YXRlLnBwX21heF9pbmRlbnQgPD0gc3RhdGUucHBfbWFyZ2luXG4gICAgICB0aGVuIHN0YXRlLnBwX21heF9pbmRlbnQgZWxzZVxuICAgICAgKCogSWYgcG9zc2libGUgbWFpbnRhaW4gcHBfbWluX3NwYWNlX2xlZnQgdG8gaXRzIGFjdHVhbCB2YWx1ZSxcbiAgICAgICAgIGlmIHRoaXMgbGVhZHMgdG8gYSB0b28gc21hbGwgbWF4X2luZGVudCwgdGFrZSBoYWxmIG9mIHRoZVxuICAgICAgICAgbmV3IG1hcmdpbiwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDEuICopXG4gICAgICAgbWF4IChtYXggKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0KVxuICAgICAgICAgICAgICAgIChzdGF0ZS5wcF9tYXJnaW4gLyAyKSkgMSBpblxuICAgICgqIFJlYnVpbGQgaW52YXJpYW50cy4gKilcbiAgICBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuZXdfbWF4X2luZGVudFxuXG5cbigqKiBHZW9tZXRyeSBmdW5jdGlvbnMgYW5kIHR5cGVzICopXG50eXBlIGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OmludDsgbWFyZ2luOiBpbnR9XG5cbmxldCB2YWxpZGF0ZV9nZW9tZXRyeSB7bWFyZ2luOyBtYXhfaW5kZW50fSA9XG4gIGlmIG1heF9pbmRlbnQgPCAyIHRoZW5cbiAgICBFcnJvciBcIm1heF9pbmRlbnQgPCAyXCJcbiAgZWxzZSBpZiBtYXJnaW4gPD0gbWF4X2luZGVudCB0aGVuXG4gICAgRXJyb3IgXCJtYXJnaW4gPD0gbWF4X2luZGVudFwiXG4gIGVsc2UgT2sgKClcblxubGV0IGNoZWNrX2dlb21ldHJ5IGdlb21ldHJ5ID1cbiAgbWF0Y2ggdmFsaWRhdGVfZ2VvbWV0cnkgZ2VvbWV0cnkgd2l0aFxuICB8IE9rICgpIC0+IHRydWVcbiAgfCBFcnJvciBfIC0+IGZhbHNlXG5cbmxldCBwcF9nZXRfbWFyZ2luIHN0YXRlICgpID0gc3RhdGUucHBfbWFyZ2luXG5cbmxldCBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSB7bWFyZ2luOyBtYXhfaW5kZW50fSA9XG4gIHBwX3NldF9tYXJnaW4gc3RhdGUgbWFyZ2luO1xuICBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBtYXhfaW5kZW50O1xuICAoKVxuXG5sZXQgcHBfc2V0X2dlb21ldHJ5IHN0YXRlIH5tYXhfaW5kZW50IH5tYXJnaW4gPVxuICBsZXQgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ7IG1hcmdpbiB9IGluXG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBFcnJvciBtc2cgLT5cbiAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCAoXCJGb3JtYXQucHBfc2V0X2dlb21ldHJ5OiBcIiBeIG1zZykpXG4gIHwgT2sgKCkgLT5cbiAgICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSBnZW9tZXRyeVxuXG5sZXQgcHBfc2FmZV9zZXRfZ2VvbWV0cnkgc3RhdGUgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIGxldCBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDsgbWFyZ2luIH0gaW5cbiAgbWF0Y2ggdmFsaWRhdGVfZ2VvbWV0cnkgZ2VvbWV0cnkgd2l0aFxuICB8IEVycm9yIF9tc2cgLT5cbiAgICAgKClcbiAgfCBPayAoKSAtPlxuICAgIHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIGdlb21ldHJ5XG5cbmxldCBwcF9nZXRfZ2VvbWV0cnkgc3RhdGUgKCkgPVxuICB7IG1hcmdpbiA9IHBwX2dldF9tYXJnaW4gc3RhdGUgKCk7IG1heF9pbmRlbnQgPSBwcF9nZXRfbWF4X2luZGVudCBzdGF0ZSAoKSB9XG5cbmxldCBwcF91cGRhdGVfZ2VvbWV0cnkgc3RhdGUgdXBkYXRlID1cbiAgbGV0IGdlb21ldHJ5ID0gcHBfZ2V0X2dlb21ldHJ5IHN0YXRlICgpIGluXG4gIHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlICh1cGRhdGUgZ2VvbWV0cnkpXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUge1xuICAgICAgb3V0X3N0cmluZyA9IGY7XG4gICAgICBvdXRfZmx1c2ggPSBnO1xuICAgICAgb3V0X25ld2xpbmUgPSBoO1xuICAgICAgb3V0X3NwYWNlcyA9IGk7XG4gICAgICBvdXRfaW5kZW50ID0gajtcbiAgICB9ID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpO1xuICBzdGF0ZS5wcF9vdXRfaW5kZW50IDwtIGpcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgb3V0X3N0cmluZyA9IHN0YXRlLnBwX291dF9zdHJpbmc7XG4gIG91dF9mbHVzaCA9IHN0YXRlLnBwX291dF9mbHVzaDtcbiAgb3V0X25ld2xpbmUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZTtcbiAgb3V0X3NwYWNlcyA9IHN0YXRlLnBwX291dF9zcGFjZXM7XG4gIG91dF9pbmRlbnQgPSBzdGF0ZS5wcF9vdXRfaW5kZW50O1xufVxuXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgc3RyaW5nIG91dHB1dCBhbmQgZmx1c2ggZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSBmIGcgPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7IHN0YXRlLnBwX291dF9mbHVzaCA8LSBnXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoKVxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9uZXdsaW5lIHN0YXRlICgpID0gc3RhdGUucHBfb3V0X3N0cmluZyBcIlxcblwiIDAgIDFcblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IHNwYWNlcy4gKilcbmxldCBibGFua19saW5lID0gU3RyaW5nLm1ha2UgODAgJyAnXG5sZXQgcmVjIGRpc3BsYXlfYmxhbmtzIHN0YXRlIG4gPVxuICBpZiBuID4gMCB0aGVuXG4gIGlmIG4gPD0gODAgdGhlbiBzdGF0ZS5wcF9vdXRfc3RyaW5nIGJsYW5rX2xpbmUgMCBuIGVsc2VcbiAgYmVnaW5cbiAgICBzdGF0ZS5wcF9vdXRfc3RyaW5nIGJsYW5rX2xpbmUgMCA4MDtcbiAgICBkaXNwbGF5X2JsYW5rcyBzdGF0ZSAobiAtIDgwKVxuICBlbmRcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgaW5kZW50YXRpb24gb2YgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfaW5kZW50ID0gZGlzcGxheV9ibGFua3NcblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zIGFzIHByaW50aW5nIHRvIGEgZ2l2ZW5cbiAgIFtQZXJ2YXNpdmUub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgc3RhdGUgb2MgPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIG91dHB1dF9zdWJzdHJpbmcgb2M7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSAoZnVuICgpIC0+IGZsdXNoIG9jKTtcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGRpc3BsYXlfYmxhbmtzIHN0YXRlO1xuICBzdGF0ZS5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHN0YXRlXG5cbigqXG5cbiAgRGVmaW5pbmcgc3BlY2lmaWMgZm9ybWF0dGVyc1xuXG4qKVxuXG5sZXQgZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnID0gZnVuY3Rpb25cbiAgfCBTdHJpbmdfdGFnIHMgLT4gXCI8XCIgXiBzIF4gXCI+XCJcbiAgfCBfIC0+IFwiXCJcbmxldCBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnID0gZnVuY3Rpb25cbiAgfCBTdHJpbmdfdGFnIHMgLT4gXCI8L1wiIF4gcyBeIFwiPlwiXG4gIHwgXyAtPiBcIlwiXG5cbmxldCBkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnID0gaWdub3JlXG5sZXQgZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWcgPSBpZ25vcmVcblxuKCogQnVpbGRpbmcgYSBmb3JtYXR0ZXIgZ2l2ZW4gaXRzIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMuXG4gICBPdGhlciBmaWVsZHMgZ2V0IHJlYXNvbmFibGUgZGVmYXVsdCB2YWx1ZXMuICopXG5sZXQgcHBfbWFrZV9mb3JtYXR0ZXIgZiBnIGggaSBqID1cbiAgKCogVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIGZvcm1hdHRlciBjb250YWlucyBhIGR1bW15IGJveC4gKilcbiAgbGV0IHBwX3F1ZXVlID0gUXVldWUuY3JlYXRlICgpIGluXG4gIGxldCBzeXNfdG9rID1cbiAgICB7IHNpemUgPSBTaXplLnVua25vd247IHRva2VuID0gUHBfYmVnaW4gKDAsIFBwX2hvdmJveCk7IGxlbmd0aCA9IDAgfSBpblxuICBRdWV1ZS5hZGQgc3lzX3RvayBwcF9xdWV1ZTtcbiAgbGV0IHNjYW5fc3RhY2sgPSBTdGFjay5jcmVhdGUgKCkgaW5cbiAgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHNjYW5fc3RhY2s7XG4gIFN0YWNrLnB1c2ggeyBsZWZ0X3RvdGFsID0gMTsgcXVldWVfZWxlbSA9IHN5c190b2sgfSBzY2FuX3N0YWNrO1xuICBsZXQgcHBfbWFyZ2luID0gNzhcbiAgYW5kIHBwX21pbl9zcGFjZV9sZWZ0ID0gMTAgaW5cbiAge1xuICAgIHBwX3NjYW5fc3RhY2sgPSBzY2FuX3N0YWNrO1xuICAgIHBwX2Zvcm1hdF9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF90Ym94X3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX3RhZ19zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF9tYXJrX3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX21hcmdpbiA9IHBwX21hcmdpbjtcbiAgICBwcF9taW5fc3BhY2VfbGVmdCA9IHBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX21heF9pbmRlbnQgPSBwcF9tYXJnaW4gLSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9zcGFjZV9sZWZ0ID0gcHBfbWFyZ2luO1xuICAgIHBwX2N1cnJlbnRfaW5kZW50ID0gMDtcbiAgICBwcF9pc19uZXdfbGluZSA9IHRydWU7XG4gICAgcHBfbGVmdF90b3RhbCA9IDE7XG4gICAgcHBfcmlnaHRfdG90YWwgPSAxO1xuICAgIHBwX2N1cnJfZGVwdGggPSAxO1xuICAgIHBwX21heF9ib3hlcyA9IG1heF9pbnQ7XG4gICAgcHBfZWxsaXBzaXMgPSBcIi5cIjtcbiAgICBwcF9vdXRfc3RyaW5nID0gZjtcbiAgICBwcF9vdXRfZmx1c2ggPSBnO1xuICAgIHBwX291dF9uZXdsaW5lID0gaDtcbiAgICBwcF9vdXRfc3BhY2VzID0gaTtcbiAgICBwcF9vdXRfaW5kZW50ID0gajtcbiAgICBwcF9wcmludF90YWdzID0gZmFsc2U7XG4gICAgcHBfbWFya190YWdzID0gZmFsc2U7XG4gICAgcHBfbWFya19vcGVuX3RhZyA9IGRlZmF1bHRfcHBfbWFya19vcGVuX3RhZztcbiAgICBwcF9tYXJrX2Nsb3NlX3RhZyA9IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWc7XG4gICAgcHBfcHJpbnRfb3Blbl90YWcgPSBkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnO1xuICAgIHBwX3ByaW50X2Nsb3NlX3RhZyA9IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnO1xuICAgIHBwX3F1ZXVlID0gcHBfcXVldWU7XG4gIH1cblxuXG4oKiBCdWlsZCBhIGZvcm1hdHRlciBvdXQgb2YgaXRzIG91dCBmdW5jdGlvbnMuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9mdW5jdGlvbnMgb3V0X2Z1bnMgPVxuICBwcF9tYWtlX2Zvcm1hdHRlclxuICAgIG91dF9mdW5zLm91dF9zdHJpbmdcbiAgICBvdXRfZnVucy5vdXRfZmx1c2hcbiAgICBvdXRfZnVucy5vdXRfbmV3bGluZVxuICAgIG91dF9mdW5zLm91dF9zcGFjZXNcbiAgICBvdXRfZnVucy5vdXRfaW5kZW50XG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3aXRoIGRlZmF1bHQgZnVuY3Rpb25zIHRvIG91dHB1dCBzcGFjZXMsXG4gIGluZGVudGF0aW9uLCBhbmQgbmV3IGxpbmVzLiAqKVxubGV0IG1ha2VfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCA9XG4gIGxldCBwcGYgPSBwcF9tYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggaWdub3JlIGlnbm9yZSBpZ25vcmUgaW5cbiAgcHBmLnBwX291dF9uZXdsaW5lIDwtIGRpc3BsYXlfbmV3bGluZSBwcGY7XG4gIHBwZi5wcF9vdXRfc3BhY2VzIDwtIGRpc3BsYXlfYmxhbmtzIHBwZjtcbiAgcHBmLnBwX291dF9pbmRlbnQgPC0gZGlzcGxheV9pbmRlbnQgcHBmO1xuICBwcGZcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdyaXRpbmcgdG8gYSBnaXZlbiBbUGVydmFzaXZlLm91dF9jaGFubmVsXSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgb2MgPVxuICBtYWtlX2Zvcm1hdHRlciAob3V0cHV0X3N1YnN0cmluZyBvYykgKGZ1biAoKSAtPiBmbHVzaCBvYylcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdyaXRpbmcgdG8gYSBnaXZlbiBbQnVmZmVyLnRdIHZhbHVlLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9idWZmZXIgYiA9XG4gIG1ha2VfZm9ybWF0dGVyIChCdWZmZXIuYWRkX3N1YnN0cmluZyBiKSBpZ25vcmVcblxuXG4oKiBBbGxvY2F0aW5nIGJ1ZmZlciBmb3IgcHJldHR5LXByaW50aW5nIHB1cnBvc2VzLlxuICAgRGVmYXVsdCBidWZmZXIgc2l6ZSBpcyBwcF9idWZmZXJfc2l6ZSBvciA1MTIuXG4qKVxubGV0IHBwX2J1ZmZlcl9zaXplID0gNTEyXG5sZXQgcHBfbWFrZV9idWZmZXIgKCkgPSBCdWZmZXIuY3JlYXRlIHBwX2J1ZmZlcl9zaXplXG5cbigqIFRoZSBzdGFuZGFyZCAoc2hhcmVkKSBidWZmZXIuICopXG5sZXQgc3RkYnVmID0gcHBfbWFrZV9idWZmZXIgKClcblxuKCogUHJlZGVmaW5lZCBmb3JtYXR0ZXJzIHN0YW5kYXJkIGZvcm1hdHRlciB0byBwcmludFxuICAgdG8gW1N0ZGxpYi5zdGRvdXRdLCBbU3RkbGliLnN0ZGVycl0sIGFuZCB7IXN0ZGJ1Zn0uICopXG5sZXQgc3RkX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBTdGRsaWIuc3Rkb3V0XG5hbmQgZXJyX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBTdGRsaWIuc3RkZXJyXG5hbmQgc3RyX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9idWZmZXIgc3RkYnVmXG5cblxuKCogW2ZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYnVmIHBwZl0gZmx1c2hlcyBmb3JtYXR0ZXIgW3BwZl0sXG4gICB0aGVuIHJldHVybnMgdGhlIGNvbnRlbnRzIG9mIGJ1ZmZlciBbYnVmXSB0aGF0IGlzIHJlc2V0LlxuICAgRm9ybWF0dGVyIFtwcGZdIGlzIHN1cHBvc2VkIHRvIHByaW50IHRvIGJ1ZmZlciBbYnVmXSwgb3RoZXJ3aXNlIHRoaXNcbiAgIGZ1bmN0aW9uIGlzIG5vdCByZWFsbHkgdXNlZnVsLiAqKVxubGV0IGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYnVmIHBwZiA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHBwZiBmYWxzZTtcbiAgbGV0IHMgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gIEJ1ZmZlci5yZXNldCBidWY7XG4gIHNcblxuXG4oKiBGbHVzaCBbc3RyX2Zvcm1hdHRlcl0gYW5kIGdldCB0aGUgY29udGVudHMgb2YgW3N0ZGJ1Zl0uICopXG5sZXQgZmx1c2hfc3RyX2Zvcm1hdHRlciAoKSA9IGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgc3RkYnVmIHN0cl9mb3JtYXR0ZXJcblxuKCpcbiAgU3ltYm9saWMgcHJldHR5LXByaW50aW5nXG4qKVxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmcgaXMgcHJldHR5LXByaW50aW5nIHdpdGggbm8gbG93IGxldmVsIG91dHB1dC5cblxuICBXaGVuIHVzaW5nIGEgc3ltYm9saWMgZm9ybWF0dGVyLCBhbGwgcmVndWxhciBwcmV0dHktcHJpbnRpbmcgYWN0aXZpdGllc1xuICBvY2N1ciBidXQgb3V0cHV0IG1hdGVyaWFsIGlzIHN5bWJvbGljIGFuZCBzdG9yZWQgaW4gYSBidWZmZXIgb2Ygb3V0cHV0XG4gIGl0ZW1zLiBBdCB0aGUgZW5kIG9mIHByZXR0eS1wcmludGluZywgZmx1c2hpbmcgdGhlIG91dHB1dCBidWZmZXIgYWxsb3dzXG4gIHBvc3QtcHJvY2Vzc2luZyBvZiBzeW1ib2xpYyBvdXRwdXQgYmVmb3JlIGxvdyBsZXZlbCBvdXRwdXQgb3BlcmF0aW9ucy5cbiopXG5cbnR5cGUgc3ltYm9saWNfb3V0cHV0X2l0ZW0gPVxuICB8IE91dHB1dF9mbHVzaFxuICB8IE91dHB1dF9uZXdsaW5lXG4gIHwgT3V0cHV0X3N0cmluZyBvZiBzdHJpbmdcbiAgfCBPdXRwdXRfc3BhY2VzIG9mIGludFxuICB8IE91dHB1dF9pbmRlbnQgb2YgaW50XG5cbnR5cGUgc3ltYm9saWNfb3V0cHV0X2J1ZmZlciA9IHtcbiAgbXV0YWJsZSBzeW1ib2xpY19vdXRwdXRfY29udGVudHMgOiBzeW1ib2xpY19vdXRwdXRfaXRlbSBsaXN0O1xufVxuXG5sZXQgbWFrZV9zeW1ib2xpY19vdXRwdXRfYnVmZmVyICgpID1cbiAgeyBzeW1ib2xpY19vdXRwdXRfY29udGVudHMgPSBbXSB9XG5cbmxldCBjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHMgPC0gW11cblxubGV0IGdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIExpc3QucmV2IHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHNcblxubGV0IGZsdXNoX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IGl0ZW1zID0gZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iIGluXG4gIGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iO1xuICBpdGVtc1xuXG5sZXQgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBpdGVtID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBpdGVtIDo6IHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHNcblxubGV0IGZvcm1hdHRlcl9vZl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIGxldCBzeW1ib2xpY19mbHVzaCBzb2IgKCkgPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgT3V0cHV0X2ZsdXNoXG4gIGFuZCBzeW1ib2xpY19uZXdsaW5lIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfbmV3bGluZVxuICBhbmQgc3ltYm9saWNfc3RyaW5nIHNvYiBzIGkgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3N0cmluZyAoU3RyaW5nLnN1YiBzIGkgbikpXG4gIGFuZCBzeW1ib2xpY19zcGFjZXMgc29iIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9zcGFjZXMgbilcbiAgYW5kIHN5bWJvbGljX2luZGVudCBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X2luZGVudCBuKSBpblxuXG4gIGxldCBmID0gc3ltYm9saWNfc3RyaW5nIHNvYlxuICBhbmQgZyA9IHN5bWJvbGljX2ZsdXNoIHNvYlxuICBhbmQgaCA9IHN5bWJvbGljX25ld2xpbmUgc29iXG4gIGFuZCBpID0gc3ltYm9saWNfc3BhY2VzIHNvYlxuICBhbmQgaiA9IHN5bWJvbGljX2luZGVudCBzb2IgaW5cbiAgcHBfbWFrZV9mb3JtYXR0ZXIgZiBnIGggaSBqXG5cbigqXG5cbiAgQmFzaWMgZnVuY3Rpb25zIG9uIHRoZSAnc3RhbmRhcmQnIGZvcm1hdHRlclxuICAodGhlIGZvcm1hdHRlciB0aGF0IHByaW50cyB0byBbU3RkbGliLnN0ZG91dF0pLlxuXG4qKVxuXG5sZXQgb3Blbl9oYm94ID0gcHBfb3Blbl9oYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3Zib3ggPSBwcF9vcGVuX3Zib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5faHZib3ggPSBwcF9vcGVuX2h2Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2hvdmJveCA9IHBwX29wZW5faG92Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2JveCA9IHBwX29wZW5fYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV9ib3ggPSBwcF9jbG9zZV9ib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fdGFnID0gcHBfb3Blbl90YWcgc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3RhZyA9IHBwX2Nsb3NlX3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9zdGFnID0gcHBfb3Blbl9zdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV9zdGFnID0gcHBfY2xvc2Vfc3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYXMgPSBwcF9wcmludF9hcyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfc3RyaW5nID0gcHBfcHJpbnRfc3RyaW5nIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9pbnQgPSBwcF9wcmludF9pbnQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2Zsb2F0ID0gcHBfcHJpbnRfZmxvYXQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2NoYXIgPSBwcF9wcmludF9jaGFyIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9ib29sID0gcHBfcHJpbnRfYm9vbCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYnJlYWsgPSBwcF9wcmludF9icmVhayBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfY3V0ID0gcHBfcHJpbnRfY3V0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9zcGFjZSA9IHBwX3ByaW50X3NwYWNlIHN0ZF9mb3JtYXR0ZXJcbmFuZCBmb3JjZV9uZXdsaW5lID0gcHBfZm9yY2VfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfZmx1c2ggPSBwcF9wcmludF9mbHVzaCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfbmV3bGluZSA9IHBwX3ByaW50X25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2lmX25ld2xpbmUgPSBwcF9wcmludF9pZl9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIG9wZW5fdGJveCA9IHBwX29wZW5fdGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfdGJveCA9IHBwX2Nsb3NlX3Rib3ggc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3RicmVhayA9IHBwX3ByaW50X3RicmVhayBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfdGFiID0gcHBfc2V0X3RhYiBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfdGFiID0gcHBfcHJpbnRfdGFiIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXJnaW4gPSBwcF9zZXRfbWFyZ2luIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFyZ2luID0gcHBfZ2V0X21hcmdpbiBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2luZGVudCA9IHBwX3NldF9tYXhfaW5kZW50IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWF4X2luZGVudCA9IHBwX2dldF9tYXhfaW5kZW50IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9nZW9tZXRyeSA9IHBwX3NldF9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5hbmQgc2FmZV9zZXRfZ2VvbWV0cnkgPSBwcF9zYWZlX3NldF9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2dlb21ldHJ5ID0gcHBfZ2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCB1cGRhdGVfZ2VvbWV0cnkgPSBwcF91cGRhdGVfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21heF9ib3hlcyA9IHBwX3NldF9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXhfYm94ZXMgPSBwcF9nZXRfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBvdmVyX21heF9ib3hlcyA9IHBwX292ZXJfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9lbGxpcHNpc190ZXh0ID0gcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9lbGxpcHNpc190ZXh0ID0gcHBfZ2V0X2VsbGlwc2lzX3RleHQgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfcHJpbnRfdGFncyA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfcHJpbnRfdGFncyA9XG4gIHBwX2dldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfbWFya190YWdzID1cbiAgcHBfc2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21hcmtfdGFncyA9XG4gIHBwX2dldF9tYXJrX3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF90YWdzID1cbiAgcHBfc2V0X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuXG5cbigqIENvbnZlbmllbmNlIGZ1bmN0aW9ucyAqKVxuXG4oKiBUbyBmb3JtYXQgYSBsaXN0ICopXG5sZXQgcmVjIHBwX3ByaW50X2xpc3QgPyhwcF9zZXAgPSBwcF9wcmludF9jdXQpIHBwX3YgcHBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAoKVxuICB8IFt2XSAtPiBwcF92IHBwZiB2XG4gIHwgdiA6OiB2cyAtPlxuICAgIHBwX3YgcHBmIHY7XG4gICAgcHBfc2VwIHBwZiAoKTtcbiAgICBwcF9wcmludF9saXN0IH5wcF9zZXAgcHBfdiBwcGYgdnNcblxuKCogVG8gZm9ybWF0IGEgc2VxdWVuY2UgKilcbmxldCByZWMgcHBfcHJpbnRfc2VxX2luIH5wcF9zZXAgcHBfdiBwcGYgc2VxID1cbiAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgfCBTZXEuTmlsIC0+ICgpXG4gIHwgU2VxLkNvbnMgKHYsIHNlcSkgLT5cbiAgICBwcF9zZXAgcHBmICgpO1xuICAgIHBwX3YgcHBmIHY7XG4gICAgcHBfcHJpbnRfc2VxX2luIH5wcF9zZXAgcHBfdiBwcGYgc2VxXG5cbmxldCBwcF9wcmludF9zZXEgPyhwcF9zZXAgPSBwcF9wcmludF9jdXQpIHBwX3YgcHBmIHNlcSA9XG4gIG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgU2VxLk5pbCAtPiAoKVxuICB8IFNlcS5Db25zICh2LCBzZXEpIC0+XG4gICAgcHBfdiBwcGYgdjtcbiAgICBwcF9wcmludF9zZXFfaW4gfnBwX3NlcCBwcF92IHBwZiBzZXFcblxuKCogVG8gZm9ybWF0IGZyZWUtZmxvd2luZyB0ZXh0ICopXG5sZXQgcHBfcHJpbnRfdGV4dCBwcGYgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGxlZnQgPSByZWYgMCBpblxuICBsZXQgcmlnaHQgPSByZWYgMCBpblxuICBsZXQgZmx1c2ggKCkgPVxuICAgIHBwX3ByaW50X3N0cmluZyBwcGYgKFN0cmluZy5zdWIgcyAhbGVmdCAoIXJpZ2h0IC0gIWxlZnQpKTtcbiAgICBpbmNyIHJpZ2h0OyBsZWZ0IDo9ICFyaWdodDtcbiAgaW5cbiAgd2hpbGUgKCFyaWdodCA8PiBsZW4pIGRvXG4gICAgbWF0Y2ggcy5bIXJpZ2h0XSB3aXRoXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgIGZsdXNoICgpO1xuICAgICAgICBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgZmx1c2ggKCk7IHBwX3ByaW50X3NwYWNlIHBwZiAoKVxuICAgICAgKCogdGhlcmUgaXMgbm8gc3BlY2lmaWMgc3VwcG9ydCBmb3IgJ1xcdCdcbiAgICAgICAgIGFzIGl0IGlzIHVuY2xlYXIgd2hhdCBhIHJpZ2h0IHNlbWFudGljcyB3b3VsZCBiZSAqKVxuICAgICAgfCBfIC0+IGluY3IgcmlnaHRcbiAgZG9uZTtcbiAgaWYgIWxlZnQgPD4gbGVuIHRoZW4gZmx1c2ggKClcblxubGV0IHBwX3ByaW50X29wdGlvbiA/KG5vbmUgPSBmdW4gXyAoKSAtPiAoKSkgcHBfdiBwcGYgPSBmdW5jdGlvblxufCBOb25lIC0+IG5vbmUgcHBmICgpXG58IFNvbWUgdiAtPiBwcF92IHBwZiB2XG5cbmxldCBwcF9wcmludF9yZXN1bHQgfm9rIH5lcnJvciBwcGYgPSBmdW5jdGlvblxufCBPayB2IC0+IG9rIHBwZiB2XG58IEVycm9yIGUgLT4gZXJyb3IgcHBmIGVcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGNvbXB1dGVfdGFnIG91dHB1dCB0YWdfYWNjID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gIG91dHB1dCBwcGYgdGFnX2FjYztcbiAgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgZWxzZSBCdWZmZXIuc3ViIGJ1ZiAxIChsZW4gLSAyKVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgRGVmaW5pbmcgY29udGludWF0aW9ucyB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIG9mXG4gIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIEludGVycHJldCBhIGZvcm1hdHRpbmcgZW50aXR5IG9uIGEgZm9ybWF0dGVyLiAqKVxubGV0IG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZm10aW5nX2xpdCA9IG1hdGNoIGZtdGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfYm94IHBwZiAoKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfdGFnIHBwZiAoKVxuICB8IEJyZWFrIChfLCB3aWR0aCwgb2Zmc2V0KSAgLT4gcHBfcHJpbnRfYnJlYWsgcHBmIHdpZHRoIG9mZnNldFxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfZmx1c2ggcHBmICgpXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfcHJpbnRfbmV3bGluZSBwcGYgKClcbiAgfCBNYWdpY19zaXplIChfLCBfKSAgICAgICAgIC0+ICgpXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCdcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICclJ1xuICB8IFNjYW5faW5kaWMgYyAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnOyBwcF9wcmludF9jaGFyIHBwZiBjXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5vdXRwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IGYgcHBmO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5idWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2RlbGF5IChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoZiAoKSk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgKGYgKCkpO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCpcblxuICBEZWZpbmluZyBbZnByaW50Zl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbZnByaW50Zl0uXG5cbiopXG5cbmxldCBrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBwcGYgYWNjOyBrIHBwZilcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5hbmQgaWtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgcHBmIGZtdFxuXG5sZXQgaWZwcmludGYgX3BwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBpZ25vcmUgKCkgZm10XG5cbmxldCBmcHJpbnRmIHBwZiA9IGtmcHJpbnRmIGlnbm9yZSBwcGZcbmxldCBwcmludGYgZm10ID0gZnByaW50ZiBzdGRfZm9ybWF0dGVyIGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBlcnJfZm9ybWF0dGVyIGZtdFxuXG5sZXQga2RwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gayAoZnVuIHBwZiAtPiBvdXRwdXRfYWNjIHBwZiBhY2MpKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmxldCBkcHJpbnRmIGZtdCA9IGtkcHJpbnRmIChmdW4gaSAtPiBpKSBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBzdHJwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIGlkIGZtdFxuXG5sZXQga2FzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBvdXRwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBhc3ByaW50ZiBmbXQgPSBrYXNwcmludGYgaWQgZm10XG5cbigqIEZsdXNoaW5nIHN0YW5kYXJkIGZvcm1hdHRlcnMgYXQgZW5kIG9mIGV4ZWN1dGlvbi4gKilcblxubGV0IGZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnMgKCkgPVxuICBwcF9wcmludF9mbHVzaCBzdGRfZm9ybWF0dGVyICgpO1xuICBwcF9wcmludF9mbHVzaCBlcnJfZm9ybWF0dGVyICgpXG5cbmxldCAoKSA9IGF0X2V4aXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVyc1xuXG4oKlxuXG4gIERlcHJlY2F0ZWQgc3R1ZmYuXG5cbiopXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlXG4gICAgfm91dDpmIH5mbHVzaDpnIH5uZXdsaW5lOmggfnNwYWNlczppID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaCxcbiAgIHN0YXRlLnBwX291dF9uZXdsaW5lLCBzdGF0ZS5wcF9vdXRfc3BhY2VzKVxuXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBzZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IGdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogZXJyb3IgcHJvbmUgZnVuY3Rpb24sIGRvIG5vdCB1c2UgaXQuXG4gICBUaGlzIGZ1bmN0aW9uIGlzIG5laXRoZXIgY29tcG9zaXRpb25hbCBub3IgaW5jcmVtZW50YWwsIHNpbmNlIGl0IGZsdXNoZXNcbiAgIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhdCBlYWNoIGNhbGwuXG4gICBUbyBnZXQgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSwgZGVmaW5lIGEgZm9ybWF0dGVyIG9mIHlvdXIgb3duIHdyaXRpbmcgdG9cbiAgIHRoZSBidWZmZXIgYXJndW1lbnQsIGFzIGluXG4gICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiXG4gICB0aGVuIHVzZSB7IWZwcmludGYgcHBmfSBhcyB1c3VhbC4gKilcbmxldCBicHJpbnRmIGIgKEZvcm1hdCAoZm10LCBfKSA6ICgnYSwgZm9ybWF0dGVyLCB1bml0KSBmb3JtYXQpID1cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPSBvdXRwdXRfYWNjIHBwZiBhY2M7IHBwX2ZsdXNoX3F1ZXVlIHBwZiBmYWxzZSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxuKCogRGVwcmVjYXRlZCA6IGFsaWFzIGZvciBrc3ByaW50Zi4gKilcbmxldCBrcHJpbnRmID0ga3NwcmludGZcblxuXG5cbigqIERlcHJlY2F0ZWQgdGFnIGZ1bmN0aW9ucyAqKVxuXG50eXBlIGZvcm1hdHRlcl90YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fdGFnIDogdGFnIC0+IHN0cmluZztcbiAgbWFya19jbG9zZV90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3RhZyA6IHRhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV90YWcgOiB0YWcgLT4gdW5pdDtcbn1cblxuXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV90YWcgPSBtY3Q7XG4gICAgIHByaW50X29wZW5fdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV90YWcgPSBwY3Q7XG4gICB9ID1cbiAgbGV0IHN0cmluZ2lmeSBmIGUgPSBmdW5jdGlvbiBTdHJpbmdfdGFnIHMgLT4gZiBzIHwgXyAtPiBlIGluXG4gIHN0YXRlLnBwX21hcmtfb3Blbl90YWcgPC0gc3RyaW5naWZ5IG1vdCBcIlwiO1xuICBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgbWN0IFwiXCI7XG4gIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIDwtIHN0cmluZ2lmeSBwb3QgKCk7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgcGN0ICgpXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgZm10ICgpID1cbiAgbGV0IGZ1bnMgPSBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIGZtdCAoKSBpblxuICBsZXQgbWFya19vcGVuX3RhZyBzID0gZnVucy5tYXJrX29wZW5fc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgbWFya19jbG9zZV90YWcgcyA9IGZ1bnMubWFya19jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBwcmludF9vcGVuX3RhZyBzID0gZnVucy5wcmludF9vcGVuX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IHByaW50X2Nsb3NlX3RhZyBzID0gZnVucy5wcmludF9jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIHttYXJrX29wZW5fdGFnOyBtYXJrX2Nsb3NlX3RhZzsgcHJpbnRfb3Blbl90YWc7IHByaW50X2Nsb3NlX3RhZ31cblxubGV0IHNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIGFsaWFzIHRvIGF2b2lkIHdhcm5pbmcgZm9yIGFtYmlndWl0eSBiZXR3ZWVuXG4gICBTdGRsaWIuZm9ybWF0NlxuICAgYW5kIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG5cbiAgICh0aGUgZm9ybWVyIGlzIGluIGZhY3QgYW4gYWxpYXMgZm9yIHRoZSBsYXR0ZXIsXG4gICAgYnV0IHRoZSBhbWJpZ3VpdHkgd2FybmluZyBkb2Vzbid0IGNhcmUpXG4qKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBTdGRsaWIuZm9ybWF0NlxuXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FubmVycy4gKilcblxuKCogU2Nhbm5pbmcgYnVmZmVycy4gKilcbm1vZHVsZSB0eXBlIFNDQU5OSU5HID0gc2lnXG5cbiAgdHlwZSBpbl9jaGFubmVsXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdmFsIHN0ZGluIDogaW5fY2hhbm5lbFxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXS5cbiAgICAgW3N0ZGliXSBpcyBlcXVpdmFsZW50IHRvIFtTY2FubmluZy5mcm9tX2NoYW5uZWwgU3RkbGliLnN0ZGluXS4gKilcblxuICB2YWwgc3RkaWIgOiBpbl9jaGFubmVsXG4gICgqIEFuIGFsaWFzIGZvciBbU2NhbmYuc3RkaW5dLCB0aGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbVxuICAgICBbU3RkbGliLnN0ZGluXS4gKilcblxuICB2YWwgbmV4dF9jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5uZXh0X2NoYXIgaWJdIGFkdmFuY2UgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3Rlci5cbiAgICAgSWYgbm8gbW9yZSBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYSBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXSBtYXJrIHRoZSBjdXJyZW50X2NoYXIgYXMgYWxyZWFkeVxuICAgICBzY2FubmVkLiAqKVxuXG4gIHZhbCBwZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLnBlZWtfY2hhciBpYl0gcmV0dXJucyB0aGUgY3VycmVudCBjaGFyIGF2YWlsYWJsZSBpblxuICAgICB0aGUgYnVmZmVyIG9yIHJlYWRzIG9uZSBpZiBuZWNlc3NhcnkgKHdoZW4gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzXG4gICAgIGFscmVhZHkgc2Nhbm5lZCkuXG4gICAgIElmIG5vIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhbiBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgY2hlY2tlZF9wZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogU2FtZSBhcyBbU2Nhbm5pbmcucGVla19jaGFyXSBhYm92ZSBidXQgYWx3YXlzIHJldHVybnMgYSB2YWxpZCBjaGFyIG9yXG4gICAgIGZhaWxzOiBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG51bGwgY2hhciB3aGVuIHRoZSByZWFkaW5nIG1ldGhvZCBvZiB0aGVcbiAgICAgaW5wdXQgYnVmZmVyIGhhcyByZWFjaGVkIGFuIGVuZCBvZiBmaWxlLCB0aGUgZnVuY3Rpb24gcmFpc2VzIGV4Y2VwdGlvblxuICAgICBbRW5kX29mX2ZpbGVdLiAqKVxuXG4gIHZhbCBzdG9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gY2hhciAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnN0b3JlX2NoYXIgbGltIGliIGNdIGFkZHMgW2NdIHRvIHRoZSB0b2tlbiBidWZmZXJcbiAgICAgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlciBbaWJdLiBJdCBhbHNvIGFkdmFuY2VzIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIgYW5kIHJldHVybnMgW2xpbSAtIDFdLCBpbmRpY2F0aW5nIHRoZSBuZXcgbGltaXQgZm9yIHRoZVxuICAgICBsZW5ndGggb2YgdGhlIGN1cnJlbnQgdG9rZW4uICopXG5cbiAgdmFsIHNraXBfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc2tpcF9jaGFyIGxpbSBpYl0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuICopXG5cbiAgdmFsIGlnbm9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5pZ25vcmVfY2hhciBpYiBsaW1dIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGFuZFxuICAgICBkZWNyZW1lbnRzIHRoZSBsaW1pdC4gKilcblxuICB2YWwgdG9rZW4gOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcudG9rZW4gaWJdIHJldHVybnMgdGhlIHN0cmluZyBzdG9yZWQgaW50byB0aGUgdG9rZW5cbiAgICAgYnVmZmVyIG9mIHRoZSBzY2FubmluZyBidWZmZXI6IGl0IHJldHVybnMgdGhlIHRva2VuIG1hdGNoZWQgYnkgdGhlXG4gICAgIGZvcm1hdC4gKilcblxuICB2YWwgcmVzZXRfdG9rZW4gOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLnJlc2V0X3Rva2VuIGliXSByZXNldHMgdGhlIHRva2VuIGJ1ZmZlciBvZlxuICAgICB0aGUgZ2l2ZW4gc2Nhbm5pbmcgYnVmZmVyLiAqKVxuXG4gIHZhbCBjaGFyX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmNoYXJfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbGluZV9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5saW5lX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbmV3IGxpbmVcbiAgICAgY2hhcmFjdGVycyByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIHRva2VuX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnRva2VuX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgdG9rZW5zIHJlYWRcbiAgICAgc28gZmFyIGZyb20gW2liXS4gKilcblxuICB2YWwgZW9mIDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lb2YgaWJdIHJldHVybnMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgZW5kX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIgKGlmIG5vIGNoYXIgaGFzIGV2ZXIgYmVlbiByZWFkLCBhbiBhdHRlbXB0IHRvXG4gICAgIHJlYWQgb25lIGlzIHBlcmZvcm1lZCkuICopXG5cbiAgdmFsIGJlZ2lubmluZ19vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuYmVnaW5uaW5nX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgYmVnaW5uaW5nIG9mIGlucHV0XG4gICAgIGNvbmRpdGlvbiBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBuYW1lX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLm5hbWVfb2ZfaW5wdXQgaWJdIHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNoYXJhY3RlclxuICAgICBzb3VyY2UgZm9yIGlucHV0IGJ1ZmZlciBbaWJdLiAqKVxuXG4gIHZhbCBvcGVuX2luIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIG9wZW5faW5fYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZSA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGVfYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fc3RyaW5nIDogc3RyaW5nIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZnVuY3Rpb24gOiAodW5pdCAtPiBjaGFyKSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2NoYW5uZWwgOiBTdGRsaWIuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG5cbiAgdmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0XG5cbiAgdmFsIG1lbW9fZnJvbV9jaGFubmVsIDogU3RkbGliLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuICAoKiBPYnNvbGV0ZS4gKilcblxuZW5kXG5cblxubW9kdWxlIFNjYW5uaW5nIDogU0NBTk5JTkcgPSBzdHJ1Y3RcblxuICAoKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2NhbmYuICopXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB0eXBlIGluX2NoYW5uZWxfbmFtZSA9XG4gICAgfCBGcm9tX2NoYW5uZWwgb2YgU3RkbGliLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZmlsZSBvZiBmaWxlX25hbWUgKiBTdGRsaWIuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9mdW5jdGlvblxuICAgIHwgRnJvbV9zdHJpbmdcblxuXG4gIHR5cGUgaW5fY2hhbm5lbCA9IHtcbiAgICBtdXRhYmxlIGljX2VvZiA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXIgOiBjaGFyO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2NoYXJfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY19saW5lX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfdG9rZW5fY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY19nZXRfbmV4dF9jaGFyIDogdW5pdCAtPiBjaGFyO1xuICAgIGljX3Rva2VuX2J1ZmZlciA6IEJ1ZmZlci50O1xuICAgIGljX2lucHV0X25hbWUgOiBpbl9jaGFubmVsX25hbWU7XG4gIH1cblxuXG4gIHR5cGUgc2NhbmJ1ZiA9IGluX2NoYW5uZWxcblxuICBsZXQgbnVsbF9jaGFyID0gJ1xcMDAwJ1xuXG4gICgqIFJlYWRzIGEgbmV3IGNoYXJhY3RlciBmcm9tIGlucHV0IGJ1ZmZlci5cbiAgICAgTmV4dF9jaGFyIG5ldmVyIGZhaWxzLCBldmVuIGluIGNhc2Ugb2YgZW5kIG9mIGlucHV0OlxuICAgICBpdCB0aGVuIHNpbXBseSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24uICopXG4gIGxldCBuZXh0X2NoYXIgaWIgPVxuICAgIHRyeVxuICAgICAgbGV0IGMgPSBpYi5pY19nZXRfbmV4dF9jaGFyICgpIGluXG4gICAgICBpYi5pY19jdXJyZW50X2NoYXIgPC0gYztcbiAgICAgIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSB0cnVlO1xuICAgICAgaWIuaWNfY2hhcl9jb3VudCA8LSBzdWNjIGliLmljX2NoYXJfY291bnQ7XG4gICAgICBpZiBjID0gJ1xcbicgdGhlbiBpYi5pY19saW5lX2NvdW50IDwtIHN1Y2MgaWIuaWNfbGluZV9jb3VudDtcbiAgICAgIGMgd2l0aFxuICAgIHwgRW5kX29mX2ZpbGUgLT5cbiAgICAgIGxldCBjID0gbnVsbF9jaGFyIGluXG4gICAgICBpYi5pY19jdXJyZW50X2NoYXIgPC0gYztcbiAgICAgIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZTtcbiAgICAgIGliLmljX2VvZiA8LSB0cnVlO1xuICAgICAgY1xuXG5cbiAgbGV0IHBlZWtfY2hhciBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jdXJyZW50X2NoYXJcbiAgICBlbHNlIG5leHRfY2hhciBpYlxuXG5cbiAgKCogUmV0dXJucyBhIHZhbGlkIGN1cnJlbnQgY2hhciBmb3IgdGhlIGlucHV0IGJ1ZmZlci4gSW4gcGFydGljdWxhclxuICAgICBubyBpcnJlbGV2YW50IG51bGwgY2hhcmFjdGVyIChhcyBzZXQgYnkgW25leHRfY2hhcl0gaW4gY2FzZSBvZiBlbmRcbiAgICAgb2YgaW5wdXQpIGlzIHJldHVybmVkLCBzaW5jZSBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuXG4gICAgIFtuZXh0X2NoYXJdIHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiB3aGlsZSB0cnlpbmcgdG8gcmVhZCBhXG4gICAgIG5ldyBjaGFyYWN0ZXIuICopXG4gIGxldCBjaGVja2VkX3BlZWtfY2hhciBpYiA9XG4gICAgbGV0IGMgPSBwZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpYi5pY19lb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZTtcbiAgICBjXG5cblxuICBsZXQgZW5kX29mX2lucHV0IGliID1cbiAgICBpZ25vcmUgKHBlZWtfY2hhciBpYik7XG4gICAgaWIuaWNfZW9mXG5cblxuICBsZXQgZW9mIGliID0gaWIuaWNfZW9mXG5cbiAgbGV0IGJlZ2lubmluZ19vZl9pbnB1dCBpYiA9IGliLmljX2NoYXJfY291bnQgPSAwXG5cbiAgbGV0IG5hbWVfb2ZfaW5wdXQgaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIF9pYyAtPiBcInVubmFtZWQgU3RkbGliIGlucHV0IGNoYW5uZWxcIlxuICAgIHwgRnJvbV9maWxlIChmbmFtZSwgX2ljKSAtPiBmbmFtZVxuICAgIHwgRnJvbV9mdW5jdGlvbiAtPiBcInVubmFtZWQgZnVuY3Rpb25cIlxuICAgIHwgRnJvbV9zdHJpbmcgLT4gXCJ1bm5hbWVkIGNoYXJhY3RlciBzdHJpbmdcIlxuXG5cbiAgbGV0IGNoYXJfY291bnQgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY2hhcl9jb3VudCAtIDFcbiAgICBlbHNlIGliLmljX2NoYXJfY291bnRcblxuXG4gIGxldCBsaW5lX2NvdW50IGliID0gaWIuaWNfbGluZV9jb3VudFxuXG4gIGxldCByZXNldF90b2tlbiBpYiA9IEJ1ZmZlci5yZXNldCBpYi5pY190b2tlbl9idWZmZXJcblxuICBsZXQgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWIgPSBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2VcblxuICBsZXQgdG9rZW4gaWIgPVxuICAgIGxldCB0b2tlbl9idWZmZXIgPSBpYi5pY190b2tlbl9idWZmZXIgaW5cbiAgICBsZXQgdG9rID0gQnVmZmVyLmNvbnRlbnRzIHRva2VuX2J1ZmZlciBpblxuICAgIEJ1ZmZlci5jbGVhciB0b2tlbl9idWZmZXI7XG4gICAgaWIuaWNfdG9rZW5fY291bnQgPC0gc3VjYyBpYi5pY190b2tlbl9jb3VudDtcbiAgICB0b2tcblxuXG4gIGxldCB0b2tlbl9jb3VudCBpYiA9IGliLmljX3Rva2VuX2NvdW50XG5cbiAgbGV0IHNraXBfY2hhciB3aWR0aCBpYiA9XG4gICAgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7XG4gICAgd2lkdGhcblxuXG4gIGxldCBpZ25vcmVfY2hhciB3aWR0aCBpYiA9IHNraXBfY2hhciAod2lkdGggLSAxKSBpYlxuXG4gIGxldCBzdG9yZV9jaGFyIHdpZHRoIGliIGMgPVxuICAgIEJ1ZmZlci5hZGRfY2hhciBpYi5pY190b2tlbl9idWZmZXIgYztcbiAgICBpZ25vcmVfY2hhciB3aWR0aCBpYlxuXG5cbiAgbGV0IGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUgPSAxMDI0XG5cbiAgbGV0IGNyZWF0ZSBpbmFtZSBuZXh0ID0ge1xuICAgIGljX2VvZiA9IGZhbHNlO1xuICAgIGljX2N1cnJlbnRfY2hhciA9IG51bGxfY2hhcjtcbiAgICBpY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPSBmYWxzZTtcbiAgICBpY19jaGFyX2NvdW50ID0gMDtcbiAgICBpY19saW5lX2NvdW50ID0gMDtcbiAgICBpY190b2tlbl9jb3VudCA9IDA7XG4gICAgaWNfZ2V0X25leHRfY2hhciA9IG5leHQ7XG4gICAgaWNfdG9rZW5fYnVmZmVyID0gQnVmZmVyLmNyZWF0ZSBkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplO1xuICAgIGljX2lucHV0X25hbWUgPSBpbmFtZTtcbiAgfVxuXG5cbiAgbGV0IGZyb21fc3RyaW5nIHMgPVxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IG5leHQgKCkgPVxuICAgICAgaWYgIWkgPj0gbGVuIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZVxuICAgICAgbGV0IGMgPSBzLlshaV0gaW5cbiAgICAgIGluY3IgaTtcbiAgICAgIGMgaW5cbiAgICBjcmVhdGUgRnJvbV9zdHJpbmcgbmV4dFxuXG5cbiAgbGV0IGZyb21fZnVuY3Rpb24gPSBjcmVhdGUgRnJvbV9mdW5jdGlvblxuXG4gICgqIFNjYW5uaW5nIGZyb20gYW4gaW5wdXQgY2hhbm5lbC4gKilcblxuICAoKiBQb3NpdGlvbiBvZiB0aGUgcHJvYmxlbTpcblxuICAgICBXZSBjYW5ub3QgcHJldmVudCB0aGUgc2Nhbm5pbmcgbWVjaGFuaXNtIHRvIHVzZSBvbmUgbG9va2FoZWFkIGNoYXJhY3RlcixcbiAgICAgaWYgbmVlZGVkIGJ5IHRoZSBzZW1hbnRpY3Mgb2YgdGhlIGZvcm1hdCBzdHJpbmcgc3BlY2lmaWNhdGlvbnMgKGUuZy4gYVxuICAgICB0cmFpbGluZyAnc2tpcCBzcGFjZScgc3BlY2lmaWNhdGlvbiBpbiB0aGUgZm9ybWF0IHN0cmluZyk7IGluIHRoaXMgY2FzZSxcbiAgICAgdGhlIG1hbmRhdG9yeSBsb29rYWhlYWQgY2hhcmFjdGVyIGlzIGluZGVlZCByZWFkIGZyb20gdGhlIGlucHV0IGFuZCBub3RcbiAgICAgdXNlZCB0byByZXR1cm4gdGhlIHRva2VuIHJlYWQuIEl0IGlzIHRodXMgbWFuZGF0b3J5IHRvIGJlIGFibGUgdG8gc3RvcmVcbiAgICAgYW4gdW51c2VkIGxvb2thaGVhZCBjaGFyYWN0ZXIgc29tZXdoZXJlIHRvIGdldCBpdCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gICAgIG9mIHRoZSBuZXh0IHNjYW4uXG5cbiAgICAgVG8gY2lyY3VtdmVudCB0aGlzIHByb2JsZW0sIGFsbCB0aGUgc2Nhbm5pbmcgZnVuY3Rpb25zIGdldCBhIGxvdyBsZXZlbFxuICAgICBpbnB1dCBidWZmZXIgYXJndW1lbnQgd2hlcmUgdGhleSBzdG9yZSB0aGUgbG9va2FoZWFkIGNoYXJhY3RlciB3aGVuXG4gICAgIG5lZWRlZDsgYWRkaXRpb25hbGx5LCB0aGUgaW5wdXQgYnVmZmVyIGlzIHRoZSBvbmx5IHNvdXJjZSBvZiBjaGFyYWN0ZXIgb2ZcbiAgICAgYSBzY2FubmVyLiBUaGUgW3NjYW5idWZdIGlucHV0IGJ1ZmZlcnMgYXJlIGRlZmluZWQgaW4gbW9kdWxlIHshU2Nhbm5pbmd9LlxuXG4gICAgIE5vdyB3ZSB1bmRlcnN0YW5kIHRoYXQgaXQgaXMgZXh0cmVtZWx5IGltcG9ydGFudCB0aGF0IHJlbGF0ZWQgYW5kXG4gICAgIHN1Y2Nlc3NpdmUgY2FsbHMgdG8gc2Nhbm5lcnMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgc2FtZSBpbnB1dCBidWZmZXIuXG4gICAgIEluIGVmZmVjdCwgaWYgYSBzY2FubmVyIFtzY2FuMV0gaXMgcmVhZGluZyBmcm9tIFtpYjFdIGFuZCBzdG9yZXMgYW5cbiAgICAgdW51c2VkIGxvb2thaGVhZCBjaGFyYWN0ZXIgW2MxXSBpbnRvIGl0cyBpbnB1dCBidWZmZXIgW2liMV0sIHRoZW5cbiAgICAgYW5vdGhlciBzY2FubmVyIFtzY2FuMl0gbm90IHJlYWRpbmcgZnJvbSB0aGUgc2FtZSBidWZmZXIgW2liMV0gd2lsbCBtaXNzXG4gICAgIHRoZSBjaGFyYWN0ZXIgW2MxXSwgc2VlbWluZ2x5IHZhbmlzaGVkIGluIHRoZSBhaXIgZnJvbSB0aGUgcG9pbnQgb2Ygdmlld1xuICAgICBvZiBbc2NhbjJdLlxuXG4gICAgIFRoaXMgbWVjaGFuaXNtIHdvcmtzIHBlcmZlY3RseSB0byByZWFkIGZyb20gc3RyaW5ncywgZnJvbSBmaWxlcywgYW5kIGZyb21cbiAgICAgZnVuY3Rpb25zLCBzaW5jZSBpbiB0aG9zZSBjYXNlcywgYWxsb2NhdGluZyB0d28gYnVmZmVycyByZWFkaW5nIGZyb20gdGhlXG4gICAgIHNhbWUgc291cmNlIGlzIHVubmF0dXJhbC5cblxuICAgICBTdGlsbCwgdGhlcmUgaXMgYSBkaWZmaWN1bHR5IGluIHRoZSBjYXNlIG9mIHNjYW5uaW5nIGZyb20gYW4gaW5wdXRcbiAgICAgY2hhbm5lbC4gSW4gZWZmZWN0LCB3aGVuIHNjYW5uaW5nIGZyb20gYW4gaW5wdXQgY2hhbm5lbCBbaWNdLCB0aGlzIGNoYW5uZWxcbiAgICAgbWF5IG5vdCBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gd2l0aGluIHRoaXMgbGlicmFyeS4gSGVuY2UsIGl0IG1heSBiZVxuICAgICBzaGFyZWQgKHR3byBmdW5jdGlvbnMgb2YgdGhlIHVzZXIncyBwcm9ncmFtIG1heSBzdWNjZXNzaXZlbHkgcmVhZCBmcm9tXG4gICAgIFtpY10pLiBUaGlzIGlzIGhpZ2hseSBlcnJvciBwcm9uZSBzaW5jZSwgb25lIG9mIHRoZSBmdW5jdGlvbiBtYXkgc2VlayB0aGVcbiAgICAgaW5wdXQgY2hhbm5lbCwgd2hpbGUgdGhlIG90aGVyIGZ1bmN0aW9uIGhhcyBzdGlsbCBhbiB1bnVzZWQgbG9va2FoZWFkXG4gICAgIGNoYXJhY3RlciBpbiBpdHMgaW5wdXQgYnVmZmVyLiBJbiBjb25jbHVzaW9uLCB5b3Ugc2hvdWxkIG5ldmVyIG1peCBkaXJlY3RcbiAgICAgbG93IGxldmVsIHJlYWRpbmcgYW5kIGhpZ2ggbGV2ZWwgc2Nhbm5pbmcgZnJvbSB0aGUgc2FtZSBpbnB1dCBjaGFubmVsLlxuXG4gICopXG5cbiAgKCogUGVyZm9ybSBidWZmZXJpemVkIGlucHV0IHRvIGltcHJvdmUgZWZmaWNpZW5jeS4gKilcbiAgbGV0IGZpbGVfYnVmZmVyX3NpemUgPSByZWYgMTAyNFxuXG4gICgqIFRoZSBzY2FubmVyIGNsb3NlcyB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQuICopXG4gIGxldCBzY2FuX2Nsb3NlX2F0X2VuZCBpYyA9IFN0ZGxpYi5jbG9zZV9pbiBpYzsgcmFpc2UgRW5kX29mX2ZpbGVcblxuICAoKiBUaGUgc2Nhbm5lciBkb2VzIG5vdCBjbG9zZSB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IGp1c3QgcmFpc2VzIFtFbmRfb2ZfZmlsZV0uICopXG4gIGxldCBzY2FuX3JhaXNlX2F0X2VuZCBfaWMgPSByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gIGxldCBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgaW5hbWUgaWMgPVxuICAgIGxldCBsZW4gPSAhZmlsZV9idWZmZXJfc2l6ZSBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsaW0gPSByZWYgMCBpblxuICAgIGxldCBlb2YgPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA8ICFsaW0gdGhlbiBiZWdpbiBsZXQgYyA9IEJ5dGVzLmdldCBidWYgIWkgaW4gaW5jciBpOyBjIGVuZCBlbHNlXG4gICAgICBpZiAhZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZSBiZWdpblxuICAgICAgICBsaW0gOj0gaW5wdXQgaWMgYnVmIDAgbGVuO1xuICAgICAgICBpZiAhbGltID0gMCB0aGVuIGJlZ2luIGVvZiA6PSB0cnVlOyBzY2FuX2Nsb3NlX2ljIGljIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgaSA6PSAxO1xuICAgICAgICAgIEJ5dGVzLmdldCBidWYgMFxuICAgICAgICBlbmRcbiAgICAgIGVuZCBpblxuICAgIGNyZWF0ZSBpbmFtZSBuZXh0XG5cblxuICBsZXQgZnJvbV9pY19jbG9zZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fY2xvc2VfYXRfZW5kXG4gIGxldCBmcm9tX2ljX3JhaXNlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcblxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXS5cbiAgICAgT25lIGNvdWxkIHRyeSB0byBkZWZpbmUgW3N0ZGliXSBhcyBhIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGEgY2hhcmFjdGVyXG4gICAgIGF0IGEgdGltZSAobm8gYnVmZmVyaXphdGlvbiBhdCBhbGwpLCBidXQgdW5mb3J0dW5hdGVseSB0aGUgdG9wLWxldmVsXG4gICAgIGludGVyYWN0aW9uIHdvdWxkIGJlIHdyb25nLiBUaGlzIGlzIGR1ZSB0byBzb21lIGtpbmQgb2ZcbiAgICAgJ3JhY2UgY29uZGl0aW9uJyB3aGVuIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXSxcbiAgICAgc2luY2UgdGhlIGludGVyYWN0aXZlIGNvbXBpbGVyIGFuZCBbU2NhbmYuc2NhbmZdIHdpbGwgc2ltdWx0YW5lb3VzbHlcbiAgICAgcmVhZCB0aGUgbWF0ZXJpYWwgdGhleSBuZWVkIGZyb20gW1N0ZGxpYi5zdGRpbl07IHRoZW4sIGNvbmZ1c2lvblxuICAgICB3aWxsIHJlc3VsdCBmcm9tIHdoYXQgc2hvdWxkIGJlIHJlYWQgYnkgdGhlIHRvcC1sZXZlbCBhbmQgd2hhdCBzaG91bGQgYmVcbiAgICAgcmVhZCBieSBbU2NhbmYuc2NhbmZdLlxuICAgICBUaGlzIGlzIGV2ZW4gbW9yZSBjb21wbGljYXRlZCBieSB0aGUgb25lIGNoYXJhY3RlciBsb29rYWhlYWQgdGhhdFxuICAgICBbU2NhbmYuc2NhbmZdIGlzIHNvbWV0aW1lcyBvYmxpZ2VkIHRvIG1haW50YWluOiB0aGUgbG9va2FoZWFkIGNoYXJhY3RlclxuICAgICB3aWxsIGJlIGF2YWlsYWJsZSBmb3IgdGhlIG5leHQgW1NjYW5mLnNjYW5mXSBlbnRyeSwgc2VlbWluZ2x5IGNvbWluZyBmcm9tXG4gICAgIG5vd2hlcmUuXG4gICAgIEFsc28gbm8gW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlbiByZWFkaW5nIGZyb20gc3RkaW46IGlmIG5vdCBlbm91Z2hcbiAgICAgY2hhcmFjdGVycyBoYXZlIGJlZW4gcmVhZCwgd2Ugc2ltcGx5IGFzayB0byByZWFkIG1vcmUuICopXG4gIGxldCBzdGRpbiA9XG4gICAgZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuICAgICAgKEZyb21fZmlsZSAoXCItXCIsIFN0ZGxpYi5zdGRpbikpIFN0ZGxpYi5zdGRpblxuXG5cbiAgbGV0IHN0ZGliID0gc3RkaW5cblxuICBsZXQgb3Blbl9pbl9maWxlIG9wZW5faW4gZm5hbWUgPVxuICAgIG1hdGNoIGZuYW1lIHdpdGhcbiAgICB8IFwiLVwiIC0+IHN0ZGluXG4gICAgfCBmbmFtZSAtPlxuICAgICAgbGV0IGljID0gb3Blbl9pbiBmbmFtZSBpblxuICAgICAgZnJvbV9pY19jbG9zZV9hdF9lbmQgKEZyb21fZmlsZSAoZm5hbWUsIGljKSkgaWNcblxuXG4gIGxldCBvcGVuX2luID0gb3Blbl9pbl9maWxlIFN0ZGxpYi5vcGVuX2luXG4gIGxldCBvcGVuX2luX2JpbiA9IG9wZW5faW5fZmlsZSBTdGRsaWIub3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9maWxlID0gb3Blbl9pblxuICBsZXQgZnJvbV9maWxlX2JpbiA9IG9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fY2hhbm5lbCBpYyA9XG4gICAgZnJvbV9pY19yYWlzZV9hdF9lbmQgKEZyb21fY2hhbm5lbCBpYykgaWNcblxuXG4gIGxldCBjbG9zZV9pbiBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgaWMgLT5cbiAgICAgIFN0ZGxpYi5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9maWxlIChfZm5hbWUsIGljKSAtPiBTdGRsaWIuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZnVuY3Rpb24gfCBGcm9tX3N0cmluZyAtPiAoKVxuXG5cbiAgKCpcbiAgICAgT2Jzb2xldGU6IGEgbWVtbyBbZnJvbV9jaGFubmVsXSB2ZXJzaW9uIHRvIGJ1aWxkIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdXG4gICAgIHNjYW5uaW5nIGJ1ZmZlciBvdXQgb2YgYSBbU3RkbGliLmluX2NoYW5uZWxdLlxuICAgICBUaGlzIGZ1bmN0aW9uIHdhcyB1c2VkIHRvIHRyeSB0byBwcmVzZXJ2ZSB0aGUgc2Nhbm5pbmdcbiAgICAgc2VtYW50aWNzIGZvciB0aGUgKG5vdyBvYnNvbGV0ZSkgZnVuY3Rpb24gW2ZzY2FuZl0uXG4gICAgIEdpdmVuIHRoYXQgYWxsIHNjYW5uZXIgbXVzdCByZWFkIGZyb20gYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF0gc2Nhbm5pbmdcbiAgICAgYnVmZmVyLCBbZnNjYW5mXSBtdXN0IHJlYWQgZnJvbSBvbmUhXG4gICAgIE1vcmUgcHJlY2lzZWx5LCBnaXZlbiBbaWNdLCBhbGwgc3VjY2Vzc2l2ZSBjYWxscyBbZnNjYW5mIGljXSBtdXN0IHJlYWRcbiAgICAgZnJvbSB0aGUgc2FtZSBzY2FubmluZyBidWZmZXIuXG4gICAgIFRoaXMgb2JsaWdlZCB0aGlzIGxpYnJhcnkgdG8gYWxsb2NhdGVkIHNjYW5uaW5nIGJ1ZmZlcnMgdGhhdCB3ZXJlXG4gICAgIG5vdCBwcm9wZXJseSBnYXJiYWdlIGNvbGxlY3RhYmxlLCBoZW5jZSBsZWFkaW5nIHRvIG1lbW9yeSBsZWFrcy5cbiAgICAgSWYgeW91IG5lZWQgdG8gcmVhZCBmcm9tIGEgW1N0ZGxpYi5pbl9jaGFubmVsXSBpbnB1dCBjaGFubmVsXG4gICAgIFtpY10sIHNpbXBseSBkZWZpbmUgYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF0gZm9ybWF0dGVkIGlucHV0IGNoYW5uZWwgYXMgaW5cbiAgICAgW2xldCBpYiA9IFNjYW5uaW5nLmZyb21fY2hhbm5lbCBpY10sIHRoZW4gdXNlIFtTY2FuZi5ic2NhbmYgaWJdIGFzIHVzdWFsLlxuICAqKVxuICBsZXQgbWVtb19mcm9tX2ljID1cbiAgICBsZXQgbWVtbyA9IHJlZiBbXSBpblxuICAgIChmdW4gc2Nhbl9jbG9zZV9pYyBpYyAtPlxuICAgICB0cnkgTGlzdC5hc3NxIGljICFtZW1vIHdpdGhcbiAgICAgfCBOb3RfZm91bmQgLT5cbiAgICAgICBsZXQgaWIgPVxuICAgICAgICAgZnJvbV9pYyBzY2FuX2Nsb3NlX2ljIChGcm9tX2NoYW5uZWwgaWMpIGljIGluXG4gICAgICAgbWVtbyA6PSAoaWMsIGliKSA6OiAhbWVtbztcbiAgICAgICBpYilcblxuXG4gICgqIE9ic29sZXRlOiBzZWUgeyFtZW1vX2Zyb21faWN9IGFib3ZlLiAqKVxuICBsZXQgbWVtb19mcm9tX2NoYW5uZWwgPSBtZW1vX2Zyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcblxuZW5kXG5cblxuKCogRm9ybWF0dGVkIGlucHV0IGZ1bmN0aW9ucy4gKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIHNjYW5uZXIgPVxuICAgICAoJ2EsIFNjYW5uaW5nLmluX2NoYW5uZWwsICdiLCAnYywgJ2EgLT4gJ2QsICdkKSBmb3JtYXQ2IC0+ICdjXG5cblxuKCogUmVwb3J0aW5nIGVycm9ycy4gKilcbmV4Y2VwdGlvbiBTY2FuX2ZhaWx1cmUgb2Ygc3RyaW5nXG5cbmxldCBiYWRfaW5wdXQgcyA9IHJhaXNlIChTY2FuX2ZhaWx1cmUgcylcblxubGV0IGJhZF9pbnB1dF9lc2NhcGUgYyA9XG4gIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJpbGxlZ2FsIGVzY2FwZSBjaGFyYWN0ZXIgJUNcIiBjKVxuXG5cbmxldCBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgPVxuICBiYWRfaW5wdXRcbiAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICBcInNjYW5uaW5nIG9mICVzIGZhaWxlZDogXFxcbiAgICAgICAgdGhlIHNwZWNpZmllZCBsZW5ndGggd2FzIHRvbyBzaG9ydCBmb3IgdG9rZW5cIlxuICAgICAgIG1lc3NhZ2UpXG5cblxubGV0IGJhZF9lbmRfb2ZfaW5wdXQgbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICBwcmVtYXR1cmUgZW5kIG9mIGZpbGUgb2NjdXJyZWQgYmVmb3JlIGVuZCBvZiB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2Zsb2F0ICgpID1cbiAgYmFkX2lucHV0IFwibm8gZG90IG9yIGV4cG9uZW50IHBhcnQgZm91bmQgaW4gZmxvYXQgdG9rZW5cIlxuXG5cbmxldCBiYWRfaGV4X2Zsb2F0ICgpID1cbiAgYmFkX2lucHV0IFwibm90IGEgdmFsaWQgZmxvYXQgaW4gaGV4YWRlY2ltYWwgbm90YXRpb25cIlxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2hfZXJyIGMgY2kgPVxuICBQcmludGYuc3ByaW50ZiBcImxvb2tpbmcgZm9yICVDLCBmb3VuZCAlQ1wiIGMgY2lcblxuXG5sZXQgY2hhcmFjdGVyX21pc21hdGNoIGMgY2kgPVxuICBiYWRfaW5wdXQgKGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSlcblxuXG5sZXQgcmVjIHNraXBfd2hpdGVzIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW4gYmVnaW5cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPlxuICAgICAgU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IHNraXBfd2hpdGVzIGliXG4gICAgfCBfIC0+ICgpXG4gIGVuZFxuXG5cbigqIENoZWNraW5nIHRoYXQgW2NdIGlzIGluZGVlZCBpbiB0aGUgaW5wdXQsIHRoZW4gc2tpcHMgaXQuXG4gICBJbiB0aGlzIGNhc2UsIHRoZSBjaGFyYWN0ZXIgW2NdIGhhcyBiZWVuIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZVxuICAgZm9ybWF0IGFzIGJlaW5nIG1hbmRhdG9yeSBpbiB0aGUgaW5wdXQ7IGhlbmNlIHdlIHNob3VsZCBmYWlsIHdpdGhcbiAgIFtFbmRfb2ZfZmlsZV0gaW4gY2FzZSBvZiBlbmRfb2ZfaW5wdXQuXG4gICAoUmVtZW1iZXIgdGhhdCBbU2Nhbl9mYWlsdXJlXSBpcyByYWlzZWQgb25seSB3aGVuICh3ZSBjYW4gcHJvdmUgYnlcbiAgIGV2aWRlbmNlKSB0aGF0IHRoZSBpbnB1dCBkb2VzIG5vdCBtYXRjaCB0aGUgZm9ybWF0IHN0cmluZyBnaXZlbi4gV2UgbXVzdFxuICAgdGh1cyBkaWZmZXJlbnRpYXRlIFtFbmRfb2ZfZmlsZV0gYXMgYW4gZXJyb3IgZHVlIHRvIGxhY2sgb2YgaW5wdXQsIGFuZFxuICAgW1NjYW5fZmFpbHVyZV0gd2hpY2ggaXMgZHVlIHRvIHByb3ZhYmx5IHdyb25nIGlucHV0LiBJIGFtIG5vdCBzdXJlIHRoaXMgaXNcbiAgIHdvcnRoIHRoZSBidXJkZW46IGl0IGlzIGNvbXBsZXggYW5kIHNvbWVob3cgc3VibGltaW5hbDsgc2hvdWxkIGJlIGNsZWFyZXJcbiAgIHRvIGZhaWwgd2l0aCBTY2FuX2ZhaWx1cmUgXCJOb3QgZW5vdWdoIGlucHV0IHRvIGNvbXBsZXRlIHNjYW5uaW5nXCIhKVxuXG4gICBUaGF0J3Mgd2h5LCB3YWl0aW5nIGZvciBhIGJldHRlciBzb2x1dGlvbiwgd2UgdXNlIGNoZWNrZWRfcGVla19jaGFyIGhlcmUuXG4gICBXZSBhcmUgYWxzbyBjYXJlZnVsIHRvIHRyZWF0IFwiXFxyXFxuXCIgaW4gdGhlIGlucHV0IGFzIGFuIGVuZCBvZiBsaW5lIG1hcmtlcjpcbiAgIGl0IGFsd2F5cyBtYXRjaGVzIGEgJ1xcbicgc3BlY2lmaWNhdGlvbiBpbiB0aGUgaW5wdXQgZm9ybWF0IHN0cmluZy4gKilcbmxldCByZWMgY2hlY2tfY2hhciBpYiBjID1cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJyAnIC0+IHNraXBfd2hpdGVzIGliXG4gIHwgJ1xcbicgLT4gY2hlY2tfbmV3bGluZSBpYlxuICB8IGMgLT4gY2hlY2tfdGhpc19jaGFyIGliIGNcblxuYW5kIGNoZWNrX3RoaXNfY2hhciBpYiBjID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgY2kgPSBjIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWIgZWxzZVxuICBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaVxuXG5hbmQgY2hlY2tfbmV3bGluZSBpYiA9XG4gIGxldCBjaSA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGNpIHdpdGhcbiAgfCAnXFxuJyAtPiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYlxuICB8ICdcXHInIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliOyBjaGVja190aGlzX2NoYXIgaWIgJ1xcbidcbiAgfCBfIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxuJyBjaVxuXG5cbigqIEV4dHJhY3RpbmcgdG9rZW5zIGZyb20gdGhlIG91dHB1dCB0b2tlbiBidWZmZXIuICopXG5cbmxldCB0b2tlbl9jaGFyIGliID0gKFNjYW5uaW5nLnRva2VuIGliKS5bMF1cblxubGV0IHRva2VuX3N0cmluZyA9IFNjYW5uaW5nLnRva2VuXG5cbmxldCB0b2tlbl9ib29sIGliID1cbiAgbWF0Y2ggU2Nhbm5pbmcudG9rZW4gaWIgd2l0aFxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBzIC0+IGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJpbnZhbGlkIGJvb2xlYW4gJyVzJ1wiIHMpXG5cblxuKCogVGhlIHR5cGUgb2YgaW50ZWdlciBjb252ZXJzaW9ucy4gKilcbnR5cGUgaW50ZWdlcl9jb252ZXJzaW9uID1cbiAgfCBCX2NvbnZlcnNpb24gKCogVW5zaWduZWQgYmluYXJ5IGNvbnZlcnNpb24gKilcbiAgfCBEX2NvbnZlcnNpb24gKCogU2lnbmVkIGRlY2ltYWwgY29udmVyc2lvbiAqKVxuICB8IElfY29udmVyc2lvbiAoKiBTaWduZWQgaW50ZWdlciBjb252ZXJzaW9uICopXG4gIHwgT19jb252ZXJzaW9uICgqIFVuc2lnbmVkIG9jdGFsIGNvbnZlcnNpb24gKilcbiAgfCBVX2NvbnZlcnNpb24gKCogVW5zaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgWF9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGhleGFkZWNpbWFsIGNvbnZlcnNpb24gKilcblxuXG5sZXQgaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgPSBmdW5jdGlvblxuICB8ICdiJyAtPiBCX2NvbnZlcnNpb25cbiAgfCAnZCcgLT4gRF9jb252ZXJzaW9uXG4gIHwgJ2knIC0+IElfY29udmVyc2lvblxuICB8ICdvJyAtPiBPX2NvbnZlcnNpb25cbiAgfCAndScgLT4gVV9jb252ZXJzaW9uXG4gIHwgJ3gnIHwgJ1gnIC0+IFhfY29udmVyc2lvblxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cblxuKCogRXh0cmFjdCBhbiBpbnRlZ2VyIGxpdGVyYWwgdG9rZW4uXG4gICBTaW5jZSB0aGUgZnVuY3Rpb25zIFN0ZGxpYi4qaW50Kl9vZl9zdHJpbmcgZG8gbm90IGFjY2VwdCBhIGxlYWRpbmcgKyxcbiAgIHdlIHNraXAgaXQgaWYgbmVjZXNzYXJ5LiAqKVxubGV0IHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIgPVxuICBsZXQgdG9rID1cbiAgICBtYXRjaCBjb252IHdpdGhcbiAgICB8IERfY29udmVyc2lvbiB8IElfY29udmVyc2lvbiAtPiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgVV9jb252ZXJzaW9uIC0+IFwiMHVcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBPX2NvbnZlcnNpb24gLT4gXCIwb1wiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFhfY29udmVyc2lvbiAtPiBcIjB4XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgQl9jb252ZXJzaW9uIC0+IFwiMGJcIiBeIFNjYW5uaW5nLnRva2VuIGliIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCB0b2sgaW5cbiAgaWYgbCA9IDAgfHwgdG9rLlswXSA8PiAnKycgdGhlbiB0b2sgZWxzZSBTdHJpbmcuc3ViIHRvayAxIChsIC0gMSlcblxuXG4oKiBBbGwgdGhlIGZ1bmN0aW9ucyB0aGF0IGNvbnZlcnQgYSBzdHJpbmcgdG8gYSBudW1iZXIgcmFpc2UgdGhlIGV4Y2VwdGlvblxuICAgRmFpbHVyZSB3aGVuIHRoZSBjb252ZXJzaW9uIGlzIG5vdCBwb3NzaWJsZS5cbiAgIFRoaXMgZXhjZXB0aW9uIGlzIHRoZW4gdHJhcHBlZCBpbiBba3NjYW5mXS4gKilcbmxldCB0b2tlbl9pbnQgY29udiBpYiA9IGludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbmxldCB0b2tlbl9mbG9hdCBpYiA9IGZsb2F0X29mX3N0cmluZyAoU2Nhbm5pbmcudG9rZW4gaWIpXG5cbigqIFRvIHNjYW4gbmF0aXZlIGludHMsIGludDMyIGFuZCBpbnQ2NCBpbnRlZ2Vycy5cbiAgIFdlIGNhbm5vdCBhY2Nlc3MgdG8gY29udmVyc2lvbnMgdG8vZnJvbSBzdHJpbmdzIGZvciB0aG9zZSB0eXBlcyxcbiAgIE5hdGl2ZWludC5vZl9zdHJpbmcsIEludDMyLm9mX3N0cmluZywgYW5kIEludDY0Lm9mX3N0cmluZyxcbiAgIHNpbmNlIHRob3NlIG1vZHVsZXMgYXJlIG5vdCBhdmFpbGFibGUgdG8gW1NjYW5mXS5cbiAgIEhvd2V2ZXIsIHdlIGNhbiBiaW5kIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmcgcHJpbWl0aXZlcyB0aGF0IGFyZVxuICAgYXZhaWxhYmxlIGluIHRoZSBydW50aW1lLiAqKVxuZXh0ZXJuYWwgbmF0aXZlaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDMyX29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQ2NF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxuXG5sZXQgdG9rZW5fbmF0aXZlaW50IGNvbnYgaWIgPSBuYXRpdmVpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDMyIGNvbnYgaWIgPSBpbnQzMl9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50NjQgY29udiBpYiA9IGludDY0X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxuKCogU2Nhbm5pbmcgbnVtYmVycy4gKilcblxuKCogRGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzdXBwb3NlIHRoYXQgb25lIGNoYXJhY3RlciBoYXMgYmVlbiBjaGVja2VkIGFuZFxuICAgaXMgYXZhaWxhYmxlLCBzaW5jZSB0aGV5IHJldHVybiBhdCBlbmQgb2YgZmlsZSB3aXRoIHRoZSBjdXJyZW50bHkgZm91bmRcbiAgIHRva2VuIHNlbGVjdGVkLlxuXG4gICBQdXQgaXQgaW4gYW5vdGhlciB3YXksIHRoZSBkaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHNjYW4gZm9yIGEgcG9zc2libHlcbiAgIGVtcHR5IHNlcXVlbmNlIG9mIGRpZ2l0cywgKGhlbmNlLCBhIHN1Y2Nlc3NmdWwgc2Nhbm5pbmcgZnJvbSBvbmUgb2YgdGhvc2VcbiAgIGZ1bmN0aW9ucyBkb2VzIG5vdCBpbXBseSB0aGF0IHRoZSB0b2tlbiBpcyBhIHdlbGwtZm9ybWVkIG51bWJlcjogdG8gZ2V0IGFcbiAgIHRydWUgbnVtYmVyLCBpdCBpcyBtYW5kYXRvcnkgdG8gY2hlY2sgdGhhdCBhdCBsZWFzdCBvbmUgdmFsaWQgZGlnaXQgaXNcbiAgIGF2YWlsYWJsZSBiZWZvcmUgY2FsbGluZyBvbmUgb2YgdGhlIGRpZ2l0IHNjYW5uaW5nIGZ1bmN0aW9ucykuICopXG5cbigqIFRoZSBkZWNpbWFsIGNhc2UgaXMgdHJlYXRlZCBlc3BlY2lhbGx5IGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMuICopXG5sZXQgcmVjIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgJ18nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXMgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGVjaW1hbCBkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgZGVjaW1hbCBkaWdpdFwiIGMpXG5cblxuKCogVG8gc2NhbiBudW1iZXJzIGZyb20gb3RoZXIgYmFzZXMsIHdlIHVzZSBhIHByZWRpY2F0ZSBhcmd1bWVudCB0b1xuICAgc2NhbiBkaWdpdHMuICopXG5sZXQgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9kaWdpdHMgd2lkdGggaWIgPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8IGMgd2hlbiBkaWdpdHAgYyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgJ18nIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8IF8gLT4gd2lkdGggaW5cbiAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9kaWdpdF9wbHVzIGJhc2lzIGRpZ2l0cCB3aWR0aCBpYiA9XG4gICgqIEVuc3VyZSB3ZSBoYXZlIGdvdCBlbm91Z2ggd2lkdGggbGVmdCxcbiAgICAgYW5kIHJlYWQgYXQgbGVhc3Qgb25lIGRpZ2l0LiAqKVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGRpZ2l0cCBjIHRoZW5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliXG4gIGVsc2VcbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIHZhbGlkICVzIGRpZ2l0XCIgYyBiYXNpcylcblxuXG5sZXQgaXNfYmluYXJ5X2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzEnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fYmluYXJ5X2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImJpbmFyeVwiIGlzX2JpbmFyeV9kaWdpdFxuXG5sZXQgaXNfb2N0YWxfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnNycgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9vY3RhbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJvY3RhbFwiIGlzX29jdGFsX2RpZ2l0XG5cbmxldCBpc19oZXhhX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9oZXhhZGVjaW1hbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJoZXhhZGVjaW1hbFwiIGlzX2hleGFfZGlnaXRcblxuKCogU2NhbiBhIGRlY2ltYWwgaW50ZWdlci4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50ID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXNcblxubGV0IHNjYW5fc2lnbiB3aWR0aCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJysnIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8ICctJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW4gYW4gdW5zaWduZWQgaW50ZWdlciB0aGF0IGNvdWxkIGJlIGdpdmVuIGluIGFueSAoY29tbW9uKSBiYXNpcy5cbiAgIElmIGRpZ2l0cyBhcmUgcHJlZml4ZWQgYnkgb25lIG9mIDB4LCAwWCwgMG8sIG9yIDBiLCB0aGUgbnVtYmVyIGlzXG4gICBhc3N1bWVkIHRvIGJlIHdyaXR0ZW4gcmVzcGVjdGl2ZWx5IGluIGhleGFkZWNpbWFsLCBoZXhhZGVjaW1hbCxcbiAgIG9jdGFsLCBvciBiaW5hcnkuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgYmVnaW4gbWF0Y2ggYyB3aXRoXG4gICAgfCAneCcgfCAnWCcgLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdvJyAtPiBzY2FuX29jdGFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ2InIC0+IHNjYW5fYmluYXJ5X2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgXyAtPiBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBlbmRcbiAgfCBfIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9pbnRfY29udmVyc2lvbiBjb252IHdpZHRoIGliID1cbiAgbWF0Y2ggY29udiB3aXRoXG4gIHwgQl9jb252ZXJzaW9uIC0+IHNjYW5fYmluYXJ5X2ludCB3aWR0aCBpYlxuICB8IERfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgSV9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliXG4gIHwgT19jb252ZXJzaW9uIC0+IHNjYW5fb2N0YWxfaW50IHdpZHRoIGliXG4gIHwgVV9jb252ZXJzaW9uIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBYX2NvbnZlcnNpb24gLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FubmluZyBmbG9hdGluZyBwb2ludCBudW1iZXJzLiAqKVxuXG4oKiBGcmFjdGlvbmFsIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIEV4cCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJ2UnIHwgJ0UnIGFzIGMgLT5cbiAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIFNjYW4gdGhlIGludGVnZXIgcGFydCBvZiBhIGZsb2F0aW5nIHBvaW50IG51bWJlciwgKG5vdCB1c2luZyB0aGVcbiAgIE9DYW1sIGxleGljYWwgY29udmVudGlvbiBzaW5jZSB0aGUgaW50ZWdlciBwYXJ0IGNhbiBiZSBlbXB0eSk6XG4gICBhbiBvcHRpb25hbCBzaWduLCBmb2xsb3dlZCBieSBhIHBvc3NpYmx5IGVtcHR5IHNlcXVlbmNlIG9mIGRlY2ltYWxcbiAgIGRpZ2l0cyAoZS5nLiAtLjEpLiAqKVxubGV0IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG5cblxuKCpcbiAgIEZvciB0aGUgdGltZSBiZWluZyB3ZSBoYXZlIChhcyBmb3VuZCBpbiBzY2FuZi5tbGkpOlxuICAgdGhlIGZpZWxkIHdpZHRoIGlzIGNvbXBvc2VkIG9mIGFuIG9wdGlvbmFsIGludGVnZXIgbGl0ZXJhbFxuICAgaW5kaWNhdGluZyB0aGUgbWF4aW1hbCB3aWR0aCBvZiB0aGUgdG9rZW4gdG8gcmVhZC5cbiAgIFVuZm9ydHVuYXRlbHksIHRoZSB0eXBlLWNoZWNrZXIgbGV0IHRoZSB1c2VyIHdyaXRlIGFuIG9wdGlvbmFsIHByZWNpc2lvbixcbiAgIHNpbmNlIHRoaXMgaXMgdmFsaWQgZm9yIHByaW50ZiBmb3JtYXQgc3RyaW5ncy5cblxuICAgVGh1cywgdGhlIG5leHQgc3RlcCBmb3IgU2NhbmYgaXMgdG8gc3VwcG9ydCBhIGZ1bGwgd2lkdGggYW5kIHByZWNpc2lvblxuICAgaW5kaWNhdGlvbiwgbW9yZSBvciBsZXNzIHNpbWlsYXIgdG8gdGhlIG9uZSBmb3IgcHJpbnRmLCBwb3NzaWJseSBleHRlbmRlZFxuICAgdG8gdGhlIHNwZWNpZmljYXRpb24gb2YgYSBbbWF4LCBtaW5dIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWRcbiAgIGZvciBzdHJpbmdzLiBTb21ldGhpbmcgbGlrZSB0aGUgZm9sbG93aW5nIHNwZWMgZm9yIHNjYW5mLm1saTpcblxuICAgVGhlIG9wdGlvbmFsIFt3aWR0aF0gaXMgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsXG4gICB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC4gRm9yIGluc3RhbmNlLCBbJTZkXSByZWFkcyBhbiBpbnRlZ2VyLFxuICAgaGF2aW5nIGF0IG1vc3QgNiBjaGFyYWN0ZXJzLlxuXG4gICBUaGUgb3B0aW9uYWwgW3ByZWNpc2lvbl0gaXMgYSBkb3QgWy5dIGZvbGxvd2VkIGJ5IGFuIGludGVnZXI6XG5cbiAgIC0gaW4gdGhlIGZsb2F0aW5nIHBvaW50IG51bWJlciBjb252ZXJzaW9ucyAoWyVmXSwgWyVlXSwgWyVnXSwgWyVGXSwgWyVFXSxcbiAgIGFuZCBbJUZdIGNvbnZlcnNpb25zLCB0aGUgW3ByZWNpc2lvbl0gaW5kaWNhdGVzIHRoZSBtYXhpbXVtIG51bWJlciBvZlxuICAgZGlnaXRzIHRoYXQgbWF5IGZvbGxvdyB0aGUgZGVjaW1hbCBwb2ludC4gRm9yIGluc3RhbmNlLCBbJS40Zl0gcmVhZHMgYVxuICAgW2Zsb2F0XSB3aXRoIGF0IG1vc3QgNCBmcmFjdGlvbmFsIGRpZ2l0cyxcblxuICAgLSBpbiB0aGUgc3RyaW5nIGNvbnZlcnNpb25zIChbJXNdLCBbJVNdLCBbJVxcWyByYW5nZSBcXF1dKSwgYW5kIGluIHRoZVxuICAgaW50ZWdlciBudW1iZXIgY29udmVyc2lvbnMgKFslaV0sIFslZF0sIFsldV0sIFsleF0sIFslb10sIGFuZCB0aGVpclxuICAgW2ludDMyXSwgW2ludDY0XSwgYW5kIFtuYXRpdmVfaW50XSBjb3JyZXNwb25kZW50KSwgdGhlIFtwcmVjaXNpb25dXG4gICBpbmRpY2F0ZXMgdGhlIHJlcXVpcmVkIG1pbmltdW0gd2lkdGggb2YgdGhlIHRva2VuIHJlYWQsXG5cbiAgIC0gb24gYWxsIG90aGVyIGNvbnZlcnNpb25zLCB0aGUgd2lkdGggYW5kIHByZWNpc2lvbiBzcGVjaWZ5IHRoZSBbbWF4LCBtaW5dXG4gICByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLlxuKilcbmxldCBzY2FuX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIpIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cbiAgfCBfIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cblxuXG5sZXQgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgZXJyb3Igc3RyID1cbiAgbGV0IGxvd2VyY2FzZSBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICdBJyAuLiAnWicgLT5cbiAgICAgIGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICsgaW50X29mX2NoYXIgJ2EnKVxuICAgIHwgXyAtPiBjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGggPSByZWYgd2lkdGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGxvd2VyY2FzZSBjIDw+IGxvd2VyY2FzZSBzdHIuW2ldIHRoZW4gZXJyb3IgKCk7XG4gICAgaWYgIXdpZHRoID0gMCB0aGVuIGVycm9yICgpO1xuICAgIHdpZHRoIDo9IFNjYW5uaW5nLnN0b3JlX2NoYXIgIXdpZHRoIGliIGM7XG4gIGRvbmU7XG4gICF3aWR0aFxuXG5cbmxldCBzY2FuX2hleF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBsZXQgd2lkdGggPSBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwieFwiIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgICAgKVxuICAgICAgICAgIHwgXyAtPiB3aWR0aCBpblxuICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgICB8IF8gLT4gd2lkdGhcbiAgKVxuICB8ICduJyB8ICdOJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcImFuXCJcbiAgfCAnaScgfCAnSScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJuZmluaXR5XCJcbiAgfCBfIC0+IGJhZF9oZXhfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgKCogVGhlIGVmZmVjdGl2ZSB3aWR0aCBhdmFpbGFibGUgZm9yIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgaXNcbiAgICAgICB0aGUgbWluaW11bSBvZiBkZWNsYXJlZCBwcmVjaXNpb24gYW5kIHdpZHRoIGxlZnQuICopXG4gICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAoKiBBZnRlciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHdpdGggW3ByZWNpc2lvbl0gcHJvdmlzaW9uYWwgd2lkdGgsXG4gICAgICAgW3dpZHRoX3ByZWNpc2lvbl0gaXMgbGVmdC4gKilcbiAgICBsZXQgd2lkdGhfcHJlY2lzaW9uID0gc2Nhbl9mcmFjdGlvbmFsX3BhcnQgcHJlY2lzaW9uIGliIGluXG4gICAgKCogSGVuY2UsIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgdG9vayBleGFjdGx5XG4gICAgICAgW3ByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbl0gY2hhcnMuICopXG4gICAgbGV0IGZyYWNfd2lkdGggPSBwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb24gaW5cbiAgICAoKiBBbmQgbmV3IHByb3Zpc2lvbmFsIHdpZHRoIGlzIFt3aWR0aCAtIHdpZHRoX3ByZWNpc2lvbi4gKilcbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIGZyYWNfd2lkdGggaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCAnZScgfCAnRScgLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICB8ICd4JyB8ICdYJyBhcyBjIC0+IChcbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgYXMgYyAtPiAoXG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSBtaW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgKVxuICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gYmFkX2Zsb2F0ICgpIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICB8IF8gLT4gd2lkdGhcbiAgICApXG4gICAgfCBfIC0+XG4gICAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbiAgKVxuICB8ICcxJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4oKiBTcGVjaWFsIGNhc2Ugb2YgbmFuIGFuZCBpbmZpbml0eTpcbiAgfCAnaScgLT5cbiAgfCAnbicgLT5cbiopXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG4oKiBTY2FuIGEgcmVndWxhciBzdHJpbmc6XG4gICBzdG9wcyB3aGVuIGVuY291bnRlcmluZyBhIHNwYWNlLCBpZiBubyBzY2FubmluZyBpbmRpY2F0aW9uIGhhcyBiZWVuIGdpdmVuO1xuICAgb3RoZXJ3aXNlLCBzdG9wcyB3aGVuIGVuY291bnRlcmluZyB0aGUgY2hhcmFjdGVycyBpbiB0aGUgc2Nhbm5pbmdcbiAgIGluZGljYXRpb24gW3N0cF0uXG4gICBJdCBhbHNvIHN0b3BzIGF0IGVuZCBvZiBmaWxlIG9yIHdoZW4gdGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaGFzXG4gICBiZWVuIHJlYWQuICopXG5sZXQgc2Nhbl9zdHJpbmcgc3RwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBsb29wIHdpZHRoID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBtYXRjaCBzdHAgd2l0aFxuICAgICAgfCBTb21lIGMnIHdoZW4gYyA9IGMnIC0+IFNjYW5uaW5nLnNraXBfY2hhciB3aWR0aCBpYlxuICAgICAgfCBTb21lIF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpblxuICBsb29wIHdpZHRoXG5cblxuKCogU2NhbiBhIGNoYXI6IHBlZWsgc3RyaWN0bHkgb25lIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQsIHdoYXRzb2V2ZXIuICopXG5sZXQgc2Nhbl9jaGFyIHdpZHRoIGliID1cbiAgKCogVGhlIGNhc2Ugd2lkdGggPSAwIGNvdWxkIG5vdCBoYXBwZW4gaGVyZSwgc2luY2UgaXQgaXMgdGVzdGVkIGJlZm9yZVxuICAgICBjYWxsaW5nIHNjYW5fY2hhciwgaW4gdGhlIG1haW4gc2Nhbm5pbmcgZnVuY3Rpb24uXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImEgY2hhcmFjdGVyXCIgZWxzZSAqKVxuICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYilcblxuXG5sZXQgY2hhcl9mb3JfYmFja3NsYXNoID0gZnVuY3Rpb25cbiAgfCAnbicgLT4gJ1xcMDEwJ1xuICB8ICdyJyAtPiAnXFwwMTMnXG4gIHwgJ2InIC0+ICdcXDAwOCdcbiAgfCAndCcgLT4gJ1xcMDA5J1xuICB8IGMgLT4gY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9IGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCdcblxubGV0IGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxMDAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzAgK1xuICAgICAxMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICAgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICBcImJhZCBjaGFyYWN0ZXIgZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlYyVjXCIgYzAgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBoZXhhZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID1cbiAgbGV0IGQgPSBpbnRfb2ZfY2hhciBjIGluXG4gICgqIENvdWxkIGFsc28gYmU6XG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnOScgdGhlbiBkIC0gaW50X29mX2NoYXIgJzAnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdGJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdBJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnZicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnYScgZWxzZSBhc3NlcnQgZmFsc2VcbiAgKilcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnYScgdGhlblxuICAgIGQgLSA4NyAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnYScgKikgZWxzZVxuICBpZiBkID49IGludF9vZl9jaGFyICdBJyB0aGVuXG4gICAgZCAtIDU1ICAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKikgZWxzZVxuICAgIGQgLSBpbnRfb2ZfY2hhciAnMCdcblxuXG5sZXQgY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxNiAqIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZiBcImJhZCBjaGFyYWN0ZXIgaGV4YWRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWNcIiBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogQ2FsbGVkIGluIHBhcnRpY3VsYXIgd2hlbiBlbmNvdW50ZXJpbmcgJ1xcXFwnIGFzIHN0YXJ0ZXIgb2YgYSBjaGFyLlxuICAgU3RvcHMgYmVmb3JlIHRoZSBjb3JyZXNwb25kaW5nICdcXCcnLiAqKVxubGV0IGNoZWNrX25leHRfY2hhciBtZXNzYWdlIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlIGVsc2VcbiAgY1xuXG5cbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgPSBjaGVja19uZXh0X2NoYXIgXCJhIENoYXJcIlxubGV0IGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBTdHJpbmdcIlxuXG5sZXQgc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYiA9XG4gIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gIHwgJ1xcXFwnIHwgJ1xcJycgfCAnXFxcIicgfCAnbicgfCAndCcgfCAnYicgfCAncicgYXMgYyAtPlxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKGNoYXJfZm9yX2JhY2tzbGFzaCBjKVxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMCA9IGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIpXG4gIHwgJ3gnIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyKVxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXRfZXNjYXBlIGNcblxuXG4oKiBTY2FuIGEgY2hhcmFjdGVyIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX2NoYXIgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gZmluZF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGNcblxuICBhbmQgZmluZF9jaGFyIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXFwnIC0+XG4gICAgICBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKSBpYilcbiAgICB8IGMgLT5cbiAgICAgIGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgYyBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgZGVsaW1pdGVkIHN0cmluZyAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxcIicgY1xuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgJ1xcXFwnIC0+IHNjYW5fYmFja3NsYXNoIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIHNjYW5fYmFja3NsYXNoIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxyJyAtPiBza2lwX25ld2xpbmUgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIpXG5cbiAgYW5kIHNraXBfbmV3bGluZSB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgJ1xccicpXG5cbiAgYW5kIHNraXBfc3BhY2VzIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnICcgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3Agd2lkdGggaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGJvb2xlYW4gKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2Jvb2wgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGxldCBtID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICd0JyAtPiA0XG4gICAgfCAnZicgLT4gNVxuICAgIHwgYyAtPlxuICAgICAgYmFkX2lucHV0XG4gICAgICAgIChQcmludGYuc3ByaW50ZiBcInRoZSBjaGFyYWN0ZXIgJUMgY2Fubm90IHN0YXJ0IGEgYm9vbGVhblwiIGMpIGluXG4gIHNjYW5fc3RyaW5nIE5vbmUgbSBpYlxuXG5cbigqIFNjYW4gYSBzdHJpbmcgY29udGFpbmluZyBlbGVtZW50cyBpbiBjaGFyX3NldCBhbmQgdGVybWluYXRlZCBieSBzY2FuX2luZGljXG4gICBpZiBwcm92aWRlZC4gKilcbmxldCBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IHNjYW5faW5kaWMgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fY2hhcnMgaSBzdHAgPVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgaSA+IDAgJiYgbm90IChTY2FubmluZy5lb2YgaWIpICYmXG4gICAgICAgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyAmJlxuICAgICAgIGludF9vZl9jaGFyIGMgPD4gc3RwIHRoZW5cbiAgICAgIGxldCBfID0gU2Nhbm5pbmcuc3RvcmVfY2hhciBtYXhfaW50IGliIGMgaW5cbiAgICAgIHNjYW5fY2hhcnMgKGkgLSAxKSBzdHAgaW5cbiAgbWF0Y2ggc2Nhbl9pbmRpYyB3aXRoXG4gIHwgTm9uZSAtPiBzY2FuX2NoYXJzIHdpZHRoICgtMSk7XG4gIHwgU29tZSBjIC0+XG4gICAgc2Nhbl9jaGFycyB3aWR0aCAoaW50X29mX2NoYXIgYyk7XG4gICAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW5cbiAgICAgIGxldCBjaSA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgICAgaWYgYyA9IGNpXG4gICAgICB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gICAgICBlbHNlIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cblxuKCogVGhlIGdsb2JhbCBlcnJvciByZXBvcnQgZnVuY3Rpb24gZm9yIFtTY2FuZl0uICopXG5sZXQgc2NhbmZfYmFkX2lucHV0IGliID0gZnVuY3Rpb25cbiAgfCBTY2FuX2ZhaWx1cmUgcyB8IEZhaWx1cmUgcyAtPlxuICAgIGxldCBpID0gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYiBpblxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJzY2FuZjogYmFkIGlucHV0IGF0IGNoYXIgbnVtYmVyICVpOiAlc1wiIGkgcylcbiAgfCB4IC0+IHJhaXNlIHhcblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgYSBjb3VudGVyIGZyb20gYW4gaW5wdXQgYnVmZmVyLiAqKVxubGV0IGdldF9jb3VudGVyIGliIGNvdW50ZXIgPVxuICBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgLT4gU2Nhbm5pbmcubGluZV9jb3VudCBpYlxuICB8IENoYXJfY291bnRlciAtPiBTY2FubmluZy5jaGFyX2NvdW50IGliXG4gIHwgVG9rZW5fY291bnRlciAtPiBTY2FubmluZy50b2tlbl9jb3VudCBpYlxuXG5cbigqIENvbXB1dGUgdGhlIHdpZHRoIG9mIGEgcGFkZGluZyBvcHRpb24gKHNlZSBcIiU0MntcIiBhbmQgXCIlMTIzKFwiKS4gKilcbmxldCB3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IG1heF9pbnRcbiAgfCBTb21lIHdpZHRoIC0+IHdpZHRoXG5cblxubGV0IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nID1cbiAgaWYgZm10aW5nID0gRXNjYXBlZF9wZXJjZW50IHRoZW4gJyUnLCBcIlwiIGVsc2VcbiAgICBsZXQgc3RyID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyBpblxuICAgIGxldCBzdHAgPSBzdHIuWzFdIGluXG4gICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciAyIChTdHJpbmcubGVuZ3RoIHN0ciAtIDIpIGluXG4gICAgc3RwLCBzdWJfc3RyXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFJlYWRlciBtYW5hZ2VtZW50ICopXG5cbigqIEEgY2FsbCB0byB0YWtlX2Zvcm1hdF9yZWFkZXJzIG9uIGEgZm9ybWF0IGlzIGV2YWx1YXRlZCBpbnRvIGZ1bmN0aW9uc1xuICAgdGFraW5nIHJlYWRlcnMgYXMgYXJndW1lbnRzIGFuZCBhZ2dyZWdhdGUgdGhlbSBpbnRvIGFuIGhldGVyb2dlbmVvdXMgbGlzdCAqKVxuKCogV2hlbiBhbGwgcmVhZGVycyBhcmUgdGFrZW4sIGZpbmFsbHkgcGFzcyB0aGUgbGlzdCBvZiB0aGUgcmVhZGVycyB0byB0aGVcbiAgIGNvbnRpbnVhdGlvbiBrLiAqKVxubGV0IHJlYyB0YWtlX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgZCA9XG5mdW4gayBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdFxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfc3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQzMiAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IE5hdGl2ZWludCAoXywgXywgXywgcmVzdCkgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50NjQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbG9hdCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEJvb2wgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEN1c3RvbSAoXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgICAgLT5cbiAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKSByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgICAgICAgLT4gdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIGsgaWduIHJlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgICAgICAgIC0+IGsgTmlsXG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGZtdHR5IGNvbWluZyBmcm9tIGEgRm9ybWF0X3N1YnN0IFwiJSguLi4lKVwiLiAqKVxuYW5kIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgZm10dHkgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFJlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGlnbm9yZWQgcGFyYW1ldGVyLiAqKVxuYW5kIHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBpZ25vcmVkIC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10XG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgZm10dHkgZm10XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgc2Nhbm5pbmcgKilcblxuKCogTWFrZSBhIGdlbmVyaWMgc2Nhbm5pbmcgZnVuY3Rpb24uICopXG4oKiBTY2FuIGEgc3RyZWFtIGFjY29yZGluZyB0byBhIGZvcm1hdCBhbmQgcmVhZGVycyBvYnRhaW5lZCBieVxuICAgdGFrZV9mb3JtYXRfcmVhZGVycywgYW5kIGFnZ3JlZ2F0ZSBzY2FubmVkIHZhbHVlcyBpbnRvIGFuXG4gICBoZXRlcm9nZW5lb3VzIGxpc3QuICopXG4oKiBSZXR1cm4gdGhlIGhldGVyb2dlbmVvdXMgbGlzdCBvZiBzY2FubmVkIHZhbHVlcy4gKilcbmxldCByZWMgbWFrZV9zY2FuZiA6IHR5cGUgYSBjIGQgZSBmLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKGEsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSBzdHApIHdpZHRoIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICd7Jykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAnWycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyBOb25lIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcblxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50IGMpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDMyIGMpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9uYXRpdmVpbnQgYylcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50NjQgYylcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9GIHwgRmxvYXRfQ0YpKSwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2NhbWxfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRykpLFxuICAgICAgICAgICBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9oIHwgRmxvYXRfSCkpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5faGV4X2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIF8gXyBpYiA9IHNjYW5fYm9vbCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fYm9vbFxuICB8IEFscGhhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJWFcXFwiXCJcbiAgfCBUaGV0YSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiV0XFxcIlwiXG4gIHwgQ3VzdG9tIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJT9cXFwiIChjdXN0b20gY29udmVydGVyKVwiXG4gIHwgUmVhZGVyIGZtdF9yZXN0IC0+XG4gICAgYmVnaW4gbWF0Y2ggcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkgLT5cbiAgICAgICAgbGV0IHggPSByZWFkZXIgaWIgaW5cbiAgICAgICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXRfcmVzdCByZWFkZXJzX3Jlc3QpXG4gICAgfCBOaWwgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgXCJzY2FuZjogbWlzc2luZyByZWFkZXJcIlxuICAgIGVuZFxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBpZiBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICAgIGVsc2UgYmFkX2lucHV0IFwiZW5kIG9mIGlucHV0IG5vdCBmb3VuZFwiXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSBzdHI7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliIGNocjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10ID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHMgZm10dHlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoZm10LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyAod2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0KSBpYiBpblxuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCwgZm10JyA9XG4gICAgICB0cnlcbiAgICAgICAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICBsZXQgRm10X0VCQiBmbXQnID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICAoKiBUT0RPOiBmaW5kIGEgd2F5IHRvIGF2b2lkIHJlcGFyc2luZyB0d2ljZSAqKVxuXG4gICAgICAgICgqIFRPRE86IHRoZXNlIHR5cGUtY2hlY2tzIGJlbG93ICpjYW4qIGZhaWwgYmVjYXVzZSBvZiB0eXBlXG4gICAgICAgICAgIGFtYmlndWl0eSBpbiBwcmVzZW5jZSBvZiBpZ25vcmVkLXJlYWRlcnM6IFwiJV9yJWRcIiBhbmQgXCIlZCVfclwiXG4gICAgICAgICAgIGFyZSB0eXBlZCBpbiB0aGUgc2FtZSB3YXkuXG5cbiAgICAgICAgICAgIyBTY2FuZi5zc2NhbmYgXCJcXFwiJV9yJWRcXFwiM1wiIFwiJSglZCVfciUpXCIgaWdub3JlXG4gICAgICAgICAgICAgKGZ1biBmbXQgbiAtPiBzdHJpbmdfb2ZfZm9ybWF0IGZtdCwgbilcbiAgICAgICAgICAgRXhjZXB0aW9uOiBDYW1saW50ZXJuYWxGb3JtYXQuVHlwZV9taXNtYXRjaC5cblxuICAgICAgICAgICBXZSBzaG91bGQgcHJvcGVybHkgY2F0Y2ggdGhpcyBleGNlcHRpb24uXG4gICAgICAgICopXG4gICAgICAgIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIGZtdHR5KSxcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10JyAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoRm9ybWF0IChmbXQsIHMpLFxuICAgICAgICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCAoU29tZSBzdHApIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBDb25zIChzLCBtYWtlX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBsZXQgd2lkdGggPSB3aWR0aF9vZl9wYWRfb3B0IHdpZHRoX29wdCBpblxuICAgIHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgTm9uZSB3aWR0aCBpYjtcbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgbGV0IGNvdW50ID0gZ2V0X2NvdW50ZXIgaWIgY291bnRlciBpblxuICAgIENvbnMgKGNvdW50LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0KTtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiAnQCc7IGNoZWNrX2NoYXIgaWIgJ3snO1xuICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAnWyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcblxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgYmVnaW4gbWF0Y2ggbWFrZV9zY2FuZiBpYiBmbXQnIHJlYWRlcnMgd2l0aFxuICAgIHwgQ29ucyAoXywgYXJnX3Jlc3QpIC0+IGFyZ19yZXN0XG4gICAgfCBOaWwgLT4gYXNzZXJ0IGZhbHNlXG4gICAgZW5kXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgTmlsXG5cbigqIENhc2UgYW5hbHlzaXMgb24gcGFkZGluZyBhbmQgcHJlY2lzaW9uLiAqKVxuKCogUmVqZWN0IGZvcm1hdHMgY29udGFpbmluZyBcIiUqXCIgb3IgXCIlLipcIi4gKilcbigqIFBhc3MgcGFkZGluZyBhbmQgcHJlY2lzaW9uIHRvIHRoZSBnZW5lcmljIHNjYW5uZXIgYHNjYW4nLiAqKVxuYW5kIHBhZF9wcmVjX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYgeCB5IHogdCAuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT5cbiAgICAgIChpbnQgLT4gaW50IC0+IFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gdCkgLT5cbiAgICAgIChTY2FubmluZy5pbl9jaGFubmVsIC0+IHopIC0+XG4gICAgICAoeCwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgcGFkIHByZWMgc2NhbiB0b2tlbiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gbWF4X2ludCBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiB3IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgcCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nIChMZWZ0LCBfKSwgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlLVxcXCJcIlxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIF8pLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgQXJnX3BhZGRpbmcgXywgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICgqIERlZmluaW5nIFtzY2FuZl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbc2NhbmZdICopXG5cbnR5cGUgJ2Ega3NjYW5mX3Jlc3VsdCA9IEFyZ3Mgb2YgJ2EgfCBFeGMgb2YgZXhuXG5cbmxldCBrc2NhbmYgaWIgZWYgKEZvcm1hdCAoZm10LCBzdHIpKSA9XG4gIGxldCByZWMgYXBwbHkgOiB0eXBlIGEgYiAuIGEgLT4gKGEsIGIpIGhldGVyX2xpc3QgLT4gYiA9XG4gICAgZnVuIGYgYXJncyAtPiBtYXRjaCBhcmdzIHdpdGhcbiAgICB8IENvbnMgKHgsIHIpIC0+IGFwcGx5IChmIHgpIHJcbiAgICB8IE5pbCAtPiBmXG4gIGluXG4gIGxldCBrIHJlYWRlcnMgZiA9XG4gICAgU2Nhbm5pbmcucmVzZXRfdG9rZW4gaWI7XG4gICAgbWF0Y2ggdHJ5IEFyZ3MgKG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpIHdpdGhcbiAgICAgIHwgKFNjYW5fZmFpbHVyZSBfIHwgRmFpbHVyZSBfIHwgRW5kX29mX2ZpbGUpIGFzIGV4YyAtPiBFeGMgZXhjXG4gICAgICB8IEludmFsaWRfYXJndW1lbnQgbXNnIC0+XG4gICAgICAgIGludmFsaWRfYXJnIChtc2cgXiBcIiBpbiBmb3JtYXQgXFxcIlwiIF4gU3RyaW5nLmVzY2FwZWQgc3RyIF4gXCJcXFwiXCIpXG4gICAgd2l0aFxuICAgICAgfCBBcmdzIGFyZ3MgLT4gYXBwbHkgZiBhcmdzXG4gICAgICB8IEV4YyBleGMgLT4gZWYgaWIgZXhjXG4gIGluXG4gIHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKilcblxubGV0IGtic2NhbmYgPSBrc2NhbmZcbmxldCBic2NhbmYgaWIgZm10ID0ga2JzY2FuZiBpYiBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBrc3NjYW5mIHMgZWYgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZWYgZm10XG5sZXQgc3NjYW5mIHMgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG5sZXQgc2NhbmYgZm10ID0ga3NjYW5mIFNjYW5uaW5nLnN0ZGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxuKCoqKilcblxuKCogU2Nhbm5pbmcgZm9ybWF0IHN0cmluZ3MuICopXG5sZXQgYnNjYW5mX2Zvcm1hdCA6XG4gIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICdnKSAtPiAnZyA9XG4gIGZ1biBpYiBmb3JtYXQgZiAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyBtYXhfaW50IGliIGluXG4gICAgbGV0IHN0ciA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQnID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgZm9ybWF0XG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2cgaW5cbiAgICBmIGZtdCdcblxuXG5sZXQgc3NjYW5mX2Zvcm1hdCA6XG4gIHN0cmluZyAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIHMgZm9ybWF0IGYgLT4gYnNjYW5mX2Zvcm1hdCAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZm9ybWF0IGZcblxuXG5sZXQgZm9ybWF0X2Zyb21fc3RyaW5nIHMgZm10ID1cbiAgc3NjYW5mX2Zvcm1hdCAoXCJcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzIF4gXCJcXFwiXCIpIGZtdCAoZnVuIHggLT4geClcblxuXG5sZXQgdW5lc2NhcGVkIHMgPVxuICBzc2NhbmYgKFwiXFxcIlwiIF4gcyBeIFwiXFxcIlwiKSBcIiVTJSFcIiAoZnVuIHggLT4geClcblxuXG4oKiBEZXByZWNhdGVkICopXG5sZXQga2ZzY2FuZiBpYyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5tZW1vX2Zyb21fY2hhbm5lbCBpYykgZWYgZm10XG5sZXQgZnNjYW5mIGljIGZtdCA9IGtzY2FuZiAoU2Nhbm5pbmcubWVtb19mcm9tX2NoYW5uZWwgaWMpIHNjYW5mX2JhZF9pbnB1dCBmbXRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUmVnaXN0ZXJpbmcgT0NhbWwgdmFsdWVzIHdpdGggdGhlIEMgcnVudGltZSBmb3IgbGF0ZXIgY2FsbGJhY2tzICopXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+IE9iai50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0IHJlZ2lzdGVyIG5hbWUgdiA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgKE9iai5yZXByIHYpXG5cbmxldCByZWdpc3Rlcl9leGNlcHRpb24gbmFtZSAoZXhuIDogZXhuKSA9XG4gIGxldCBleG4gPSBPYmoucmVwciBleG4gaW5cbiAgbGV0IHNsb3QgPSBpZiBPYmoudGFnIGV4biA9IE9iai5vYmplY3RfdGFnIHRoZW4gZXhuIGVsc2UgT2JqLmZpZWxkIGV4biAwIGluXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgc2xvdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgSmVyb21lIFZvdWlsbG9uLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIE9ialxuXG4oKioqKiBPYmplY3QgcmVwcmVzZW50YXRpb24gKioqKilcblxuZXh0ZXJuYWwgc2V0X2lkOiAnYSAtPiAnYSA9IFwiY2FtbF9zZXRfb29faWRcIiBbQEBub2FsbG9jXVxuXG4oKioqKiBPYmplY3QgY29weSAqKioqKVxuXG5sZXQgY29weSBvID1cbiAgbGV0IG8gPSAoT2JqLm9iaiAoT2JqLmR1cCAoT2JqLnJlcHIgbykpKSBpblxuICBzZXRfaWQgb1xuXG4oKioqKiBDb21wcmVzc2lvbiBvcHRpb25zICoqKiopXG4oKiBQYXJhbWV0ZXJzICopXG50eXBlIHBhcmFtcyA9IHtcbiAgICBtdXRhYmxlIGNvbXBhY3RfdGFibGUgOiBib29sO1xuICAgIG11dGFibGUgY29weV9wYXJlbnQgOiBib29sO1xuICAgIG11dGFibGUgY2xlYW5fd2hlbl9jb3B5aW5nIDogYm9vbDtcbiAgICBtdXRhYmxlIHJldHJ5X2NvdW50IDogaW50O1xuICAgIG11dGFibGUgYnVja2V0X3NtYWxsX3NpemUgOiBpbnRcbiAgfVxuXG5sZXQgcGFyYW1zID0ge1xuICBjb21wYWN0X3RhYmxlID0gdHJ1ZTtcbiAgY29weV9wYXJlbnQgPSB0cnVlO1xuICBjbGVhbl93aGVuX2NvcHlpbmcgPSB0cnVlO1xuICByZXRyeV9jb3VudCA9IDM7XG4gIGJ1Y2tldF9zbWFsbF9zaXplID0gMTZcbn1cblxuKCoqKiogUGFyYW1ldGVycyAqKioqKVxuXG5sZXQgaW5pdGlhbF9vYmplY3Rfc2l6ZSA9IDJcblxuKCoqKiogSXRlbXMgKioqKilcblxudHlwZSBpdGVtID0gRHVtbXlBIHwgRHVtbXlCIHwgRHVtbXlDIG9mIGludFxubGV0IF8gPSBbRHVtbXlBOyBEdW1teUI7IER1bW15QyAwXSAoKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxuXG5sZXQgZHVtbXlfaXRlbSA9IChtYWdpYyAoKSA6IGl0ZW0pXG5cbigqKioqIFR5cGVzICoqKiopXG5cbnR5cGUgdGFnXG50eXBlIGxhYmVsID0gaW50XG50eXBlIGNsb3N1cmUgPSBpdGVtXG50eXBlIHQgPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbnR5cGUgb2JqID0gdCBhcnJheVxuZXh0ZXJuYWwgcmV0IDogKG9iaiAtPiAnYSkgLT4gY2xvc3VyZSA9IFwiJWlkZW50aXR5XCJcblxuKCoqKiogTGFiZWxzICoqKiopXG5cbmxldCBwdWJsaWNfbWV0aG9kX2xhYmVsIHMgOiB0YWcgPVxuICBsZXQgYWNjdSA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgYWNjdSA6PSAyMjMgKiAhYWNjdSArIENoYXIuY29kZSBzLltpXVxuICBkb25lO1xuICAoKiByZWR1Y2UgdG8gMzEgYml0cyAqKVxuICBhY2N1IDo9ICFhY2N1IGxhbmQgKDEgbHNsIDMxIC0gMSk7XG4gICgqIG1ha2UgaXQgc2lnbmVkIGZvciA2NCBiaXRzIGFyY2hpdGVjdHVyZXMgKilcbiAgbGV0IHRhZyA9IGlmICFhY2N1ID4gMHgzRkZGRkZGRiB0aGVuICFhY2N1IC0gKDEgbHNsIDMxKSBlbHNlICFhY2N1IGluXG4gICgqIFByaW50Zi5lcHJpbnRmIFwiJXMgPSAlZFxcblwiIHMgdGFnOyBmbHVzaCBzdGRlcnI7ICopXG4gIG1hZ2ljIHRhZ1xuXG4oKioqKiBTcGFyc2UgYXJyYXkgKioqKilcblxubW9kdWxlIFZhcnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIHZhcnMgPSBpbnQgVmFycy50XG5cbm1vZHVsZSBNZXRocyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbWV0aHMgPSBsYWJlbCBNZXRocy50XG5tb2R1bGUgTGFicyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBsYWJlbCBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBsYWJzID0gYm9vbCBMYWJzLnRcblxuKCogVGhlIGNvbXBpbGVyIGFzc3VtZXMgdGhhdCB0aGUgZmlyc3QgZmllbGQgb2YgdGhpcyBzdHJ1Y3R1cmUgaXMgW3NpemVdLiAqKVxudHlwZSB0YWJsZSA9XG4geyBtdXRhYmxlIHNpemU6IGludDtcbiAgIG11dGFibGUgbWV0aG9kczogY2xvc3VyZSBhcnJheTtcbiAgIG11dGFibGUgbWV0aG9kc19ieV9uYW1lOiBtZXRocztcbiAgIG11dGFibGUgbWV0aG9kc19ieV9sYWJlbDogbGFicztcbiAgIG11dGFibGUgcHJldmlvdXNfc3RhdGVzOlxuICAgICAobWV0aHMgKiBsYWJzICogKGxhYmVsICogaXRlbSkgbGlzdCAqIHZhcnMgKlxuICAgICAgbGFiZWwgbGlzdCAqIHN0cmluZyBsaXN0KSBsaXN0O1xuICAgbXV0YWJsZSBoaWRkZW5fbWV0aHM6IChsYWJlbCAqIGl0ZW0pIGxpc3Q7XG4gICBtdXRhYmxlIHZhcnM6IHZhcnM7XG4gICBtdXRhYmxlIGluaXRpYWxpemVyczogKG9iaiAtPiB1bml0KSBsaXN0IH1cblxubGV0IGR1bW15X3RhYmxlID1cbiAgeyBtZXRob2RzID0gW3wgZHVtbXlfaXRlbSB8XTtcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gMCB9XG5cbmxldCB0YWJsZV9jb3VudCA9IHJlZiAwXG5cbigqIGR1bW15X21ldCBzaG91bGQgYmUgYSBwb2ludGVyLCBzbyB1c2UgYW4gYXRvbSAqKVxubGV0IGR1bW15X21ldCA6IGl0ZW0gPSBvYmogKE9iai5uZXdfYmxvY2sgMCAwKVxuKCogaWYgZGVidWdnaW5nIGlzIG5lZWRlZCwgdGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYTogKilcbigqIGxldCBkdW1teV9tZXQgKCkgPSBmYWlsd2l0aCBcIlVuZGVmaW5lZCBtZXRob2RcIiAqKVxuXG5sZXQgcmVjIGZpdF9zaXplIG4gPVxuICBpZiBuIDw9IDIgdGhlbiBuIGVsc2VcbiAgZml0X3NpemUgKChuKzEpLzIpICogMlxuXG5sZXQgbmV3X3RhYmxlIHB1Yl9sYWJlbHMgPVxuICBpbmNyIHRhYmxlX2NvdW50O1xuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHB1Yl9sYWJlbHMgaW5cbiAgbGV0IG1ldGhvZHMgPSBBcnJheS5tYWtlIChsZW4qMisyKSBkdW1teV9tZXQgaW5cbiAgbWV0aG9kcy4oMCkgPC0gbWFnaWMgbGVuO1xuICBtZXRob2RzLigxKSA8LSBtYWdpYyAoZml0X3NpemUgbGVuICogU3lzLndvcmRfc2l6ZSAvIDggLSAxKTtcbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG8gbWV0aG9kcy4oaSoyKzMpIDwtIG1hZ2ljIHB1Yl9sYWJlbHMuKGkpIGRvbmU7XG4gIHsgbWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IGluaXRpYWxfb2JqZWN0X3NpemUgfVxuXG5sZXQgcmVzaXplIGFycmF5IG5ld19zaXplID1cbiAgbGV0IG9sZF9zaXplID0gQXJyYXkubGVuZ3RoIGFycmF5Lm1ldGhvZHMgaW5cbiAgaWYgbmV3X3NpemUgPiBvbGRfc2l6ZSB0aGVuIGJlZ2luXG4gICAgbGV0IG5ld19idWNrID0gQXJyYXkubWFrZSBuZXdfc2l6ZSBkdW1teV9tZXQgaW5cbiAgICBBcnJheS5ibGl0IGFycmF5Lm1ldGhvZHMgMCBuZXdfYnVjayAwIG9sZF9zaXplO1xuICAgIGFycmF5Lm1ldGhvZHMgPC0gbmV3X2J1Y2tcbiBlbmRcblxubGV0IHB1dCBhcnJheSBsYWJlbCBlbGVtZW50ID1cbiAgcmVzaXplIGFycmF5IChsYWJlbCArIDEpO1xuICBhcnJheS5tZXRob2RzLihsYWJlbCkgPC0gZWxlbWVudFxuXG4oKioqKiBDbGFzc2VzICoqKiopXG5cbmxldCBtZXRob2RfY291bnQgPSByZWYgMFxubGV0IGluc3RfdmFyX2NvdW50ID0gcmVmIDBcblxuKCogdHlwZSB0ICopXG50eXBlIG1ldGggPSBpdGVtXG5cbmxldCBuZXdfbWV0aG9kIHRhYmxlID1cbiAgbGV0IGluZGV4ID0gQXJyYXkubGVuZ3RoIHRhYmxlLm1ldGhvZHMgaW5cbiAgcmVzaXplIHRhYmxlIChpbmRleCArIDEpO1xuICBpbmRleFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBuYW1lID1cbiAgdHJ5XG4gICAgTWV0aHMuZmluZCBuYW1lIHRhYmxlLm1ldGhvZHNfYnlfbmFtZVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBsYWJlbCA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gTWV0aHMuYWRkIG5hbWUgbGFiZWwgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiZWwgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsO1xuICAgIGxhYmVsXG5cbmxldCBnZXRfbWV0aG9kX2xhYmVscyB0YWJsZSBuYW1lcyA9XG4gIEFycmF5Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgbmFtZXNcblxubGV0IHNldF9tZXRob2QgdGFibGUgbGFiZWwgZWxlbWVudCA9XG4gIGluY3IgbWV0aG9kX2NvdW50O1xuICBpZiBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB0aGVuXG4gICAgcHV0IHRhYmxlIGxhYmVsIGVsZW1lbnRcbiAgZWxzZVxuICAgIHRhYmxlLmhpZGRlbl9tZXRocyA8LSAobGFiZWwsIGVsZW1lbnQpIDo6IHRhYmxlLmhpZGRlbl9tZXRoc1xuXG5sZXQgZ2V0X21ldGhvZCB0YWJsZSBsYWJlbCA9XG4gIHRyeSBMaXN0LmFzc29jIGxhYmVsIHRhYmxlLmhpZGRlbl9tZXRoc1xuICB3aXRoIE5vdF9mb3VuZCAtPiB0YWJsZS5tZXRob2RzLihsYWJlbClcblxubGV0IHRvX2xpc3QgYXJyID1cbiAgaWYgYXJyID09IG1hZ2ljIDAgdGhlbiBbXSBlbHNlIEFycmF5LnRvX2xpc3QgYXJyXG5cbmxldCBuYXJyb3cgdGFibGUgdmFycyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzID1cbiAgbGV0IHZhcnMgPSB0b19saXN0IHZhcnNcbiAgYW5kIHZpcnRfbWV0aHMgPSB0b19saXN0IHZpcnRfbWV0aHNcbiAgYW5kIGNvbmNyX21ldGhzID0gdG9fbGlzdCBjb25jcl9tZXRocyBpblxuICBsZXQgdmlydF9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgdmlydF9tZXRocyBpblxuICBsZXQgY29uY3JfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIGNvbmNyX21ldGhzIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LVxuICAgICAodGFibGUubWV0aG9kc19ieV9uYW1lLCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsLCB0YWJsZS5oaWRkZW5fbWV0aHMsXG4gICAgICB0YWJsZS52YXJzLCB2aXJ0X21ldGhfbGFicywgdmFycylcbiAgICAgOjogdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgVmFycy5mb2xkXG4gICAgICAoZnVuIGxhYiBpbmZvIHR2YXJzIC0+XG4gICAgICAgIGlmIExpc3QubWVtIGxhYiB2YXJzIHRoZW4gVmFycy5hZGQgbGFiIGluZm8gdHZhcnMgZWxzZSB0dmFycylcbiAgICAgIHRhYmxlLnZhcnMgVmFycy5lbXB0eTtcbiAgbGV0IGJ5X25hbWUgPSByZWYgTWV0aHMuZW1wdHkgaW5cbiAgbGV0IGJ5X2xhYmVsID0gcmVmIExhYnMuZW1wdHkgaW5cbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9XG4gICAgICAgICAgTGFicy5hZGQgbGFiZWxcbiAgICAgICAgICAgICh0cnkgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgd2l0aCBOb3RfZm91bmQgLT4gdHJ1ZSlcbiAgICAgICAgICAgICFieV9sYWJlbClcbiAgICBjb25jcl9tZXRocyBjb25jcl9tZXRoX2xhYnM7XG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PSBMYWJzLmFkZCBsYWJlbCBmYWxzZSAhYnlfbGFiZWwpXG4gICAgdmlydF9tZXRocyB2aXJ0X21ldGhfbGFicztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtICFieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtICFieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRoX2xhYnMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgW11cblxubGV0IHdpZGVuIHRhYmxlID1cbiAgbGV0IChieV9uYW1lLCBieV9sYWJlbCwgc2F2ZWRfaGlkZGVuX21ldGhzLCBzYXZlZF92YXJzLCB2aXJ0X21ldGhzLCB2YXJzKSA9XG4gICAgTGlzdC5oZCB0YWJsZS5wcmV2aW91c19zdGF0ZXNcbiAgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtIExpc3QudGwgdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgKGZ1biBzIHYgLT4gVmFycy5hZGQgdiAoVmFycy5maW5kIHYgdGFibGUudmFycykgcylcbiAgICAgICBzYXZlZF92YXJzIHZhcnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIGJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIHNhdmVkX2hpZGRlbl9tZXRoc1xuXG5sZXQgbmV3X3Nsb3QgdGFibGUgPVxuICBsZXQgaW5kZXggPSB0YWJsZS5zaXplIGluXG4gIHRhYmxlLnNpemUgPC0gaW5kZXggKyAxO1xuICBpbmRleFxuXG5sZXQgbmV3X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFyc1xuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBpbmRleCA9IG5ld19zbG90IHRhYmxlIGluXG4gICAgaWYgbmFtZSA8PiBcIlwiIHRoZW4gdGFibGUudmFycyA8LSBWYXJzLmFkZCBuYW1lIGluZGV4IHRhYmxlLnZhcnM7XG4gICAgaW5kZXhcblxubGV0IHRvX2FycmF5IGFyciA9XG4gIGlmIGFyciA9IE9iai5tYWdpYyAwIHRoZW4gW3x8XSBlbHNlIGFyclxuXG5sZXQgbmV3X21ldGhvZHNfdmFyaWFibGVzIHRhYmxlIG1ldGhzIHZhbHMgPVxuICBsZXQgbWV0aHMgPSB0b19hcnJheSBtZXRocyBpblxuICBsZXQgbm1ldGhzID0gQXJyYXkubGVuZ3RoIG1ldGhzIGFuZCBudmFscyA9IEFycmF5Lmxlbmd0aCB2YWxzIGluXG4gIGxldCByZXMgPSBBcnJheS5tYWtlIChubWV0aHMgKyBudmFscykgMCBpblxuICBmb3IgaSA9IDAgdG8gbm1ldGhzIC0gMSBkb1xuICAgIHJlcy4oaSkgPC0gZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBtZXRocy4oaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAwIHRvIG52YWxzIC0gMSBkb1xuICAgIHJlcy4oaStubWV0aHMpIDwtIG5ld192YXJpYWJsZSB0YWJsZSB2YWxzLihpKVxuICBkb25lO1xuICByZXNcblxubGV0IGdldF92YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnMgd2l0aCBOb3RfZm91bmQgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBnZXRfdmFyaWFibGVzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfdmFyaWFibGUgdGFibGUpIG5hbWVzXG5cbmxldCBhZGRfaW5pdGlhbGl6ZXIgdGFibGUgZiA9XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBmOjp0YWJsZS5pbml0aWFsaXplcnNcblxuKCpcbm1vZHVsZSBLZXlzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHRhZyBhcnJheSBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxubGV0IGtleV9tYXAgPSByZWYgS2V5cy5lbXB0eVxubGV0IGdldF9rZXkgdGFncyA6IGl0ZW0gPVxuICB0cnkgbWFnaWMgKEtleXMuZmluZCB0YWdzICFrZXlfbWFwIDogdGFnIGFycmF5KVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGtleV9tYXAgOj0gS2V5cy5hZGQgdGFncyB0YWdzICFrZXlfbWFwO1xuICAgIG1hZ2ljIHRhZ3NcbiopXG5cbmxldCBjcmVhdGVfdGFibGUgcHVibGljX21ldGhvZHMgPVxuICBpZiBwdWJsaWNfbWV0aG9kcyA9PSBtYWdpYyAwIHRoZW4gbmV3X3RhYmxlIFt8fF0gZWxzZVxuICAoKiBbcHVibGljX21ldGhvZHNdIG11c3QgYmUgaW4gYXNjZW5kaW5nIG9yZGVyIGZvciBieXRlY29kZSAqKVxuICBsZXQgdGFncyA9IEFycmF5Lm1hcCBwdWJsaWNfbWV0aG9kX2xhYmVsIHB1YmxpY19tZXRob2RzIGluXG4gIGxldCB0YWJsZSA9IG5ld190YWJsZSB0YWdzIGluXG4gIEFycmF5Lml0ZXJpXG4gICAgKGZ1biBpIG1ldCAtPlxuICAgICAgbGV0IGxhYiA9IGkqMisyIGluXG4gICAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgIDwtIE1ldGhzLmFkZCBtZXQgbGFiIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbClcbiAgICBwdWJsaWNfbWV0aG9kcztcbiAgdGFibGVcblxubGV0IGluaXRfY2xhc3MgdGFibGUgPVxuICBpbnN0X3Zhcl9jb3VudCA6PSAhaW5zdF92YXJfY291bnQgKyB0YWJsZS5zaXplIC0gMTtcbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIExpc3QucmV2IHRhYmxlLmluaXRpYWxpemVycztcbiAgcmVzaXplIHRhYmxlICgzICsgbWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemUpXG5cbmxldCBpbmhlcml0cyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzIChfLCBzdXBlciwgXywgZW52KSB0b3AgPVxuICBuYXJyb3cgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocztcbiAgbGV0IGluaXQgPVxuICAgIGlmIHRvcCB0aGVuIHN1cGVyIGNsYSBlbnYgZWxzZSBPYmoucmVwciAoc3VwZXIgY2xhKSBpblxuICB3aWRlbiBjbGE7XG4gIEFycmF5LmNvbmNhdFxuICAgIFtbfCByZXByIGluaXQgfF07XG4gICAgIG1hZ2ljIChBcnJheS5tYXAgKGdldF92YXJpYWJsZSBjbGEpICh0b19hcnJheSB2YWxzKSA6IGludCBhcnJheSk7XG4gICAgIEFycmF5Lm1hcFxuICAgICAgIChmdW4gbm0gLT4gcmVwciAoZ2V0X21ldGhvZCBjbGEgKGdldF9tZXRob2RfbGFiZWwgY2xhIG5tKSA6IGNsb3N1cmUpKVxuICAgICAgICh0b19hcnJheSBjb25jcl9tZXRocykgXVxuXG5sZXQgbWFrZV9jbGFzcyBwdWJfbWV0aHMgY2xhc3NfaW5pdCA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICAoZW52X2luaXQgKE9iai5yZXByIDApLCBjbGFzc19pbml0LCBlbnZfaW5pdCwgT2JqLnJlcHIgMClcblxudHlwZSBpbml0X3RhYmxlID0geyBtdXRhYmxlIGVudl9pbml0OiB0OyBtdXRhYmxlIGNsYXNzX2luaXQ6IHRhYmxlIC0+IHQgfVxuXG5sZXQgbWFrZV9jbGFzc19zdG9yZSBwdWJfbWV0aHMgY2xhc3NfaW5pdCBpbml0X3RhYmxlID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIGluaXRfdGFibGUuY2xhc3NfaW5pdCA8LSBjbGFzc19pbml0O1xuICBpbml0X3RhYmxlLmVudl9pbml0IDwtIGVudl9pbml0XG5cbmxldCBkdW1teV9jbGFzcyBsb2MgPVxuICBsZXQgdW5kZWYgPSBmdW4gXyAtPiByYWlzZSAoVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgbG9jKSBpblxuICAoT2JqLm1hZ2ljIHVuZGVmLCB1bmRlZiwgdW5kZWYsIE9iai5yZXByIDApXG5cbigqKioqIE9iamVjdHMgKioqKilcblxubGV0IGNyZWF0ZV9vYmplY3QgdGFibGUgPVxuICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICBPYmoub2JqIChzZXRfaWQgb2JqKVxuXG5sZXQgY3JlYXRlX29iamVjdF9vcHQgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgICBPYmoub2JqIChzZXRfaWQgb2JqKVxuICBlbmRcblxubGV0IHJlYyBpdGVyX2Ygb2JqID1cbiAgZnVuY3Rpb25cbiAgICBbXSAgIC0+ICgpXG4gIHwgZjo6bCAtPiBmIG9iajsgaXRlcl9mIG9iaiBsXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZSA9XG4gIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICBpZiBpbml0cyA8PiBbXSB0aGVuXG4gICAgaXRlcl9mIG9iaiBpbml0c1xuXG5sZXQgcnVuX2luaXRpYWxpemVyc19vcHQgb2JqXzAgb2JqIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqIGVsc2UgYmVnaW5cbiAgICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgICBpZiBpbml0cyA8PiBbXSB0aGVuIGl0ZXJfZiBvYmogaW5pdHM7XG4gICAgb2JqXG4gIGVuZFxuXG5sZXQgY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpemVycyBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICBsZXQgb2JqID0gY3JlYXRlX29iamVjdCB0YWJsZSBpblxuICAgIHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlO1xuICAgIG9ialxuICBlbmRcblxuKCogRXF1aXZhbGVudCBwcmltaXRpdmUgYmVsb3dcbmxldCBzZW5kc2VsZiBvYmogbGFiID1cbiAgKG1hZ2ljIG9iaiA6IChvYmogLT4gdCkgYXJyYXkgYXJyYXkpLigwKS4obGFiKSBvYmpcbiopXG5leHRlcm5hbCBzZW5kIDogb2JqIC0+IHRhZyAtPiAnYSA9IFwiJXNlbmRcIlxuZXh0ZXJuYWwgc2VuZGNhY2hlIDogb2JqIC0+IHRhZyAtPiB0IC0+IGludCAtPiAnYSA9IFwiJXNlbmRjYWNoZVwiXG5leHRlcm5hbCBzZW5kc2VsZiA6IG9iaiAtPiBsYWJlbCAtPiAnYSA9IFwiJXNlbmRzZWxmXCJcbmV4dGVybmFsIGdldF9wdWJsaWNfbWV0aG9kIDogb2JqIC0+IHRhZyAtPiBjbG9zdXJlXG4gICAgPSBcImNhbWxfZ2V0X3B1YmxpY19tZXRob2RcIiBbQEBub2FsbG9jXVxuXG4oKioqKiB0YWJsZSBjb2xsZWN0aW9uIGFjY2VzcyAqKioqKVxuXG50eXBlIHRhYmxlcyA9XG4gIHwgRW1wdHlcbiAgfCBDb25zIG9mIHtrZXkgOiBjbG9zdXJlOyBtdXRhYmxlIGRhdGE6IHRhYmxlczsgbXV0YWJsZSBuZXh0OiB0YWJsZXN9XG5cbmxldCBzZXRfZGF0YSB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGEgPC0gdlxubGV0IHNldF9uZXh0IHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dCA8LSB2XG5sZXQgZ2V0X2tleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmtleVxubGV0IGdldF9kYXRhID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YVxubGV0IGdldF9uZXh0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dFxuXG5sZXQgYnVpbGRfcGF0aCBuIGtleXMgdGFibGVzID1cbiAgbGV0IHJlcyA9IENvbnMge2tleSA9IE9iai5tYWdpYyAwOyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgbGV0IHIgPSByZWYgcmVzIGluXG4gIGZvciBpID0gMCB0byBuIGRvXG4gICAgciA6PSBDb25zIHtrZXkgPSBrZXlzLihpKTsgZGF0YSA9ICFyOyBuZXh0ID0gRW1wdHl9XG4gIGRvbmU7XG4gIHNldF9kYXRhIHRhYmxlcyAhcjtcbiAgcmVzXG5cbmxldCByZWMgbG9va3VwX2tleXMgaSBrZXlzIHRhYmxlcyA9XG4gIGlmIGkgPCAwIHRoZW4gdGFibGVzIGVsc2VcbiAgbGV0IGtleSA9IGtleXMuKGkpIGluXG4gIGxldCByZWMgbG9va3VwX2tleSAodGFibGVzOnRhYmxlcykgPVxuICAgIGlmIGdldF9rZXkgdGFibGVzID09IGtleSB0aGVuXG4gICAgICBtYXRjaCBnZXRfZGF0YSB0YWJsZXMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgQ29ucyBfIGFzIHRhYmxlc19kYXRhIC0+XG4gICAgICAgICAgbG9va3VwX2tleXMgKGktMSkga2V5cyB0YWJsZXNfZGF0YVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGdldF9uZXh0IHRhYmxlcyB3aXRoXG4gICAgICB8IENvbnMgXyBhcyBuZXh0IC0+IGxvb2t1cF9rZXkgbmV4dFxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGxldCBuZXh0IDogdGFibGVzID0gQ29ucyB7a2V5OyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgICAgICAgICBzZXRfbmV4dCB0YWJsZXMgbmV4dDtcbiAgICAgICAgICBidWlsZF9wYXRoIChpLTEpIGtleXMgbmV4dFxuICBpblxuICBsb29rdXBfa2V5IHRhYmxlc1xuXG5sZXQgbG9va3VwX3RhYmxlcyByb290IGtleXMgPVxuICBtYXRjaCBnZXRfZGF0YSByb290IHdpdGhcbiAgfCBDb25zIF8gYXMgcm9vdF9kYXRhIC0+XG4gICAgbG9va3VwX2tleXMgKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290X2RhdGFcbiAgfCBFbXB0eSAtPlxuICAgIGJ1aWxkX3BhdGggKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290XG5cbigqKioqIGJ1aWx0aW4gbWV0aG9kcyAqKioqKVxuXG5sZXQgZ2V0X2NvbnN0IHggPSByZXQgKGZ1biBfb2JqIC0+IHgpXG5sZXQgZ2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogLT4gQXJyYXkudW5zYWZlX2dldCBvYmogbilcbmxldCBnZXRfZW52IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pXG5sZXQgZ2V0X21ldGggbiAgPSByZXQgKGZ1biBvYmogLT4gc2VuZHNlbGYgb2JqIG4pXG5sZXQgc2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogeCAtPiBBcnJheS51bnNhZmVfc2V0IG9iaiBuIHgpXG5sZXQgYXBwX2NvbnN0IGYgeCA9IHJldCAoZnVuIF9vYmogLT4gZiB4KVxubGV0IGFwcF92YXIgZiBuICAgPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2VudiBmIGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9tZXRoIGYgbiAgPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9jb25zdCBmIHggeSA9IHJldCAoZnVuIF9vYmogLT4gZiB4IHkpXG5sZXQgYXBwX2NvbnN0X3ZhciBmIHggbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2NvbnN0X21ldGggZiB4IG4gPSByZXQgKGZ1biBvYmogLT4gZiB4IChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX3Zhcl9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSB4KVxubGV0IGFwcF9tZXRoX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSB4KVxubGV0IGFwcF9jb25zdF9lbnYgZiB4IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgeCAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX2Vudl9jb25zdCBmIGUgbiB4ID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgeClcbmxldCBtZXRoX2FwcF9jb25zdCBuIHggPSByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSB4KVxubGV0IG1ldGhfYXBwX3ZhciBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoQXJyYXkudW5zYWZlX2dldCBvYmogbSkpXG5sZXQgbWV0aF9hcHBfZW52IG4gZSBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXylcbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBtKSlcbmxldCBtZXRoX2FwcF9tZXRoIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChzZW5kc2VsZiBvYmogbSkpXG5sZXQgc2VuZF9jb25zdCBtIHggYyA9XG4gIHJldCAoZnVuIG9iaiAtPiBzZW5kY2FjaGUgeCBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfdmFyIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIDogb2JqKSBtXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX2VudiBtIGUgbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlXG4gICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0XG4gICAgICAgICAgICAgICAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSA6IG9iailcbiAgICAgIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9tZXRoIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChzZW5kc2VsZiBvYmogbikgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBuZXdfY2FjaGUgdGFibGUgPVxuICBsZXQgbiA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgbGV0IG4gPVxuICAgIGlmIG4gbW9kIDIgPSAwIHx8IG4gPiAyICsgbWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemVcbiAgICB0aGVuIG4gZWxzZSBuZXdfbWV0aG9kIHRhYmxlXG4gIGluXG4gIHRhYmxlLm1ldGhvZHMuKG4pIDwtIE9iai5tYWdpYyAwO1xuICBuXG5cbnR5cGUgaW1wbCA9XG4gICAgR2V0Q29uc3RcbiAgfCBHZXRWYXJcbiAgfCBHZXRFbnZcbiAgfCBHZXRNZXRoXG4gIHwgU2V0VmFyXG4gIHwgQXBwQ29uc3RcbiAgfCBBcHBWYXJcbiAgfCBBcHBFbnZcbiAgfCBBcHBNZXRoXG4gIHwgQXBwQ29uc3RDb25zdFxuICB8IEFwcENvbnN0VmFyXG4gIHwgQXBwQ29uc3RFbnZcbiAgfCBBcHBDb25zdE1ldGhcbiAgfCBBcHBWYXJDb25zdFxuICB8IEFwcEVudkNvbnN0XG4gIHwgQXBwTWV0aENvbnN0XG4gIHwgTWV0aEFwcENvbnN0XG4gIHwgTWV0aEFwcFZhclxuICB8IE1ldGhBcHBFbnZcbiAgfCBNZXRoQXBwTWV0aFxuICB8IFNlbmRDb25zdFxuICB8IFNlbmRWYXJcbiAgfCBTZW5kRW52XG4gIHwgU2VuZE1ldGhcbiAgfCBDbG9zdXJlIG9mIGNsb3N1cmVcblxubGV0IG1ldGhvZF9pbXBsIHRhYmxlIGkgYXJyID1cbiAgbGV0IG5leHQgKCkgPSBpbmNyIGk7IG1hZ2ljIGFyci4oIWkpIGluXG4gIG1hdGNoIG5leHQoKSB3aXRoXG4gICAgR2V0Q29uc3QgLT4gbGV0IHggOiB0ID0gbmV4dCgpIGluIGdldF9jb25zdCB4XG4gIHwgR2V0VmFyICAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X3ZhciBuXG4gIHwgR2V0RW52ICAgLT4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X2VudiBlIG5cbiAgfCBHZXRNZXRoICAtPiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfbWV0aCBuXG4gIHwgU2V0VmFyICAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gc2V0X3ZhciBuXG4gIHwgQXBwQ29uc3QgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gYXBwX2NvbnN0IGYgeFxuICB8IEFwcFZhciAgIC0+IGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBhcHBfdmFyIGYgblxuICB8IEFwcEVudiAgIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiAgbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnYgZiBlIG5cbiAgfCBBcHBNZXRoICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX21ldGggZiBuXG4gIHwgQXBwQ29uc3RDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IHkgPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9jb25zdCBmIHggeVxuICB8IEFwcENvbnN0VmFyIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X3ZhciBmIHggblxuICB8IEFwcENvbnN0RW52IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9lbnYgZiB4IGUgblxuICB8IEFwcENvbnN0TWV0aCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9tZXRoIGYgeCBuXG4gIHwgQXBwVmFyQ29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfdmFyX2NvbnN0IGYgbiB4XG4gIHwgQXBwRW52Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCAoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX2Vudl9jb25zdCBmIGUgbiB4XG4gIHwgQXBwTWV0aENvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX21ldGhfY29uc3QgZiBuIHhcbiAgfCBNZXRoQXBwQ29uc3QgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIG1ldGhfYXBwX2NvbnN0IG4geFxuICB8IE1ldGhBcHBWYXIgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluIG1ldGhfYXBwX3ZhciBuIG1cbiAgfCBNZXRoQXBwRW52IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpblxuICAgICAgbWV0aF9hcHBfZW52IG4gZSBtXG4gIHwgTWV0aEFwcE1ldGggLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluIG1ldGhfYXBwX21ldGggbiBtXG4gIHwgU2VuZENvbnN0IC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBzZW5kX2NvbnN0IG0geCAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRWYXIgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX3ZhciBtIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kRW52IC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgc2VuZF9lbnYgbSBlIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kTWV0aCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIHNlbmRfbWV0aCBtIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBDbG9zdXJlIF8gYXMgY2xvIC0+IG1hZ2ljIGNsb1xuXG5sZXQgc2V0X21ldGhvZHMgdGFibGUgbWV0aG9kcyA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggbWV0aG9kcyBpbiBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuIGRvXG4gICAgbGV0IGxhYmVsID0gbWV0aG9kcy4oIWkpIGluIGxldCBjbG8gPSBtZXRob2RfaW1wbCB0YWJsZSBpIG1ldGhvZHMgaW5cbiAgICBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGNsbztcbiAgICBpbmNyIGlcbiAgZG9uZVxuXG4oKioqKiBTdGF0aXN0aWNzICoqKiopXG5cbnR5cGUgc3RhdHMgPVxuICB7IGNsYXNzZXM6IGludDsgbWV0aG9kczogaW50OyBpbnN0X3ZhcnM6IGludDsgfVxuXG5sZXQgc3RhdHMgKCkgPVxuICB7IGNsYXNzZXMgPSAhdGFibGVfY291bnQ7XG4gICAgbWV0aG9kcyA9ICFtZXRob2RfY291bnQ7IGluc3RfdmFycyA9ICFpbnN0X3Zhcl9jb3VudDsgfVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHRva2VuID1cbiAgICBLd2Qgb2Ygc3RyaW5nXG4gIHwgSWRlbnQgb2Ygc3RyaW5nXG4gIHwgSW50IG9mIGludFxuICB8IEZsb2F0IG9mIGZsb2F0XG4gIHwgU3RyaW5nIG9mIHN0cmluZ1xuICB8IENoYXIgb2YgY2hhclxuXG4oKiBUaGUgc3RyaW5nIGJ1ZmZlcmluZyBtYWNoaW5lcnkgKilcblxubGV0IGluaXRpYWxfYnVmZmVyID0gQnl0ZXMuY3JlYXRlIDMyXG5cbmxldCBidWZmZXIgPSByZWYgaW5pdGlhbF9idWZmZXJcbmxldCBidWZwb3MgPSByZWYgMFxuXG5sZXQgcmVzZXRfYnVmZmVyICgpID0gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBidWZwb3MgOj0gMFxuXG5sZXQgc3RvcmUgYyA9XG4gIGlmICFidWZwb3MgPj0gQnl0ZXMubGVuZ3RoICFidWZmZXIgdGhlbiBiZWdpblxuICAgIGxldCBuZXdidWZmZXIgPSBCeXRlcy5jcmVhdGUgKDIgKiAhYnVmcG9zKSBpblxuICAgIEJ5dGVzLmJsaXQgIWJ1ZmZlciAwIG5ld2J1ZmZlciAwICFidWZwb3M7XG4gICAgYnVmZmVyIDo9IG5ld2J1ZmZlclxuICBlbmQ7XG4gIEJ5dGVzLnNldCAhYnVmZmVyICFidWZwb3MgYztcbiAgaW5jciBidWZwb3NcblxubGV0IGdldF9zdHJpbmcgKCkgPVxuICBsZXQgcyA9IEJ5dGVzLnN1Yl9zdHJpbmcgIWJ1ZmZlciAwICFidWZwb3MgaW4gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBzXG5cbigqIFRoZSBsZXhlciAqKVxuXG5sZXQgbWFrZV9sZXhlciBrZXl3b3JkcyA9XG4gIGxldCBrd2RfdGFibGUgPSBIYXNodGJsLmNyZWF0ZSAxNyBpblxuICBMaXN0Lml0ZXIgKGZ1biBzIC0+IEhhc2h0YmwuYWRkIGt3ZF90YWJsZSBzIChLd2QgcykpIGtleXdvcmRzO1xuICBsZXQgaWRlbnRfb3Jfa2V5d29yZCBpZCA9XG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgaWQgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IElkZW50IGlkXG4gIGFuZCBrZXl3b3JkX29yX2Vycm9yIGMgPVxuICAgIGxldCBzID0gU3RyaW5nLm1ha2UgMSBjIGluXG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgcyB3aXRoXG4gICAgICBOb3RfZm91bmQgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciAoXCJJbGxlZ2FsIGNoYXJhY3RlciBcIiBeIHMpKVxuICBpblxuICBsZXQgcmVjIG5leHRfdG9rZW4gKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJyAnIHwgJ1xcMDEwJyB8ICdcXDAxMycgfCAnXFwwMDknIHwgJ1xcMDI2JyB8ICdcXDAxMicpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbmV4dF90b2tlbiBzdHJtX19cbiAgICB8IFNvbWUgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXycgfCAnXFwxOTInLi4nXFwyNTUnIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBTb21lXG4gICAgICAgICgnIScgfCAnJScgfCAnJicgfCAnJCcgfCAnIycgfCAnKycgfCAnLycgfCAnOicgfCAnPCcgfCAnPScgfCAnPicgfFxuICAgICAgICAgJz8nIHwgJ0AnIHwgJ1xcXFwnIHwgJ34nIHwgJ14nIHwgJ3wnIHwgJyonIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICdcXCcnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBjaGFyIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAnXFwnJyAtPiBTdHJlYW0uanVuayBzdHJtX187IFNvbWUgKENoYXIgYylcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lICdcXFwiJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgU29tZSAoU3RyaW5nIChzdHJpbmcgcykpXG4gICAgfCBTb21lICctJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG5lZ19udW1iZXIgc3RybV9fXG4gICAgfCBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChrZXl3b3JkX29yX2Vycm9yIGMpXG4gICAgfCBfIC0+IE5vbmVcbiAgYW5kIGlkZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXFwxOTInLi4nXFwyNTUnIHwgJzAnLi4nOScgfCAnXycgfCAnXFwnJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50IHNcbiAgICB8IF8gLT4gU29tZSAoaWRlbnRfb3Jfa2V5d29yZCAoZ2V0X3N0cmluZyAoKSkpXG4gIGFuZCBpZGVudDIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy0nIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHxcbiAgICAgICAgICc+JyB8ICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50MiBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgbmVnX251bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgJy0nOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgXyAtPiBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgaWRlbnQyIHNcbiAgYW5kIG51bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICcuJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICcuJzsgZGVjaW1hbF9wYXJ0IHNcbiAgICB8IFNvbWUgKCdlJyB8ICdFJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnRSc7IGV4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChJbnQgKGludF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGRlY2ltYWxfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoRmxvYXQgKGZsb2F0X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgZXhwb25lbnRfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnKycgfCAnLScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IGVuZF9leHBvbmVudF9wYXJ0IHN0cm1fX1xuICBhbmQgZW5kX2V4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIHN0cmluZyAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFwiJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGdldF9zdHJpbmcgKClcbiAgICB8IFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgc3RyaW5nIHNcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBjaGFyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gdHJ5IGVzY2FwZSBzdHJtX18gd2l0aFxuICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBlc2NhcGUgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnbicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxuJ1xuICAgIHwgU29tZSAncicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxyJ1xuICAgIHwgU29tZSAndCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFx0J1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYzEpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMikgLT5cbiAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMzKSAtPlxuICAgICAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgICAgICBDaGFyLmNoclxuICAgICAgICAgICAgICAgICAgKChDaGFyLmNvZGUgYzEgLSA0OCkgKiAxMDAgKyAoQ2hhci5jb2RlIGMyIC0gNDgpICogMTAgK1xuICAgICAgICAgICAgICAgICAgICAgKENoYXIuY29kZSBjMyAtIDQ4KSlcbiAgICAgICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBuZXh0X3Rva2VuIHNcbiAgICB8IF8gLT4gU29tZSAoa2V5d29yZF9vcl9lcnJvciAnKCcpXG4gIGFuZCBjb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJygnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfbmVzdGVkX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX25lc3RlZF9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBjb21tZW50IHNcbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9lbmRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcpJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICgpXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgaW5cbiAgZnVuIGlucHV0IC0+IFN0cmVhbS5mcm9tIChmdW4gX2NvdW50IC0+IG5leHRfdG9rZW4gaW5wdXQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSB0eXBlIFNlZWRlZFMgPSBzaWdcbiAgaW5jbHVkZSBIYXNodGJsLlNlZWRlZFNcbiAgdmFsIGNsZWFuOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHN0YXRzX2FsaXZlOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICAgICgqKiBzYW1lIGFzIHshc3RhdHN9IGJ1dCBvbmx5IGNvdW50IHRoZSBhbGl2ZSBiaW5kaW5ncyAqKVxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgaW5jbHVkZSBIYXNodGJsLlNcbiAgdmFsIGNsZWFuOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHN0YXRzX2FsaXZlOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICAgICgqKiBzYW1lIGFzIHshc3RhdHN9IGJ1dCBvbmx5IGNvdW50IHRoZSBhbGl2ZSBiaW5kaW5ncyAqKVxuZW5kXG5cbm1vZHVsZSBHZW5IYXNoVGFibGUgPSBzdHJ1Y3RcblxuICB0eXBlIGVxdWFsID1cbiAgfCBFVHJ1ZSB8IEVGYWxzZVxuICB8IEVEZWFkICgqKiB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IgcmVjbGFpbWVkIHRoZSBkYXRhICopXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQoSDogc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSAnYSBjb250YWluZXJcbiAgICB2YWwgY3JlYXRlOiB0IC0+ICdhIC0+ICdhIGNvbnRhaW5lclxuICAgIHZhbCBoYXNoOiBpbnQgLT4gdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6ICdhIGNvbnRhaW5lciAtPiB0IC0+IGVxdWFsXG4gICAgdmFsIGdldF9kYXRhOiAnYSBjb250YWluZXIgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGdldF9rZXk6ICdhIGNvbnRhaW5lciAtPiB0IG9wdGlvblxuICAgIHZhbCBzZXRfa2V5X2RhdGE6ICdhIGNvbnRhaW5lciAtPiB0IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgY2hlY2tfa2V5OiAnYSBjb250YWluZXIgLT4gYm9vbFxuICBlbmQpIDogU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50XG4gID0gc3RydWN0XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgICAgICBtdXRhYmxlIGRhdGE6ICdhIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgICAgICBtdXRhYmxlIHNlZWQ6IGludDsgICAgICAgICAgICAgICAgICAoKiBmb3IgcmFuZG9taXphdGlvbiAqKVxuICAgICAgICBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgICAgIH1cblxuICAgIGFuZCAnYSBidWNrZXRsaXN0ID1cbiAgICB8IEVtcHR5XG4gICAgfCBDb25zIG9mIGludCAoKiBoYXNoIG9mIHRoZSBrZXkgKikgKiAnYSBILmNvbnRhaW5lciAqICdhIGJ1Y2tldGxpc3RcblxuICAgICgqKiB0aGUgaGFzaCBvZiB0aGUga2V5IGlzIGtlcHQgaW4gb3JkZXIgdG8gdGVzdCB0aGUgZXF1YWxpdHkgb2YgdGhlIGhhc2hcbiAgICAgIGJlZm9yZSB0aGUga2V5LiBTYW1lIHJlYXNvbiBhcyBmb3IgV2Vhay5NYWtlICopXG5cbiAgICB0eXBlIGtleSA9IEgudFxuXG4gICAgbGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gICAgICBpZiB4ID49IG4gdGhlbiB4XG4gICAgICBlbHNlIGlmIHggKiAyID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiB4XG4gICAgICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbiAgICBsZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCgpKVxuXG4gICAgbGV0IGNyZWF0ZSA/KHJhbmRvbSA9IChIYXNodGJsLmlzX3JhbmRvbWl6ZWQgKCkpKSBpbml0aWFsX3NpemUgPVxuICAgICAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICAgICAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgICAgIHsgaW5pdGlhbF9zaXplID0gczsgc2l6ZSA9IDA7IHNlZWQgPSBzZWVkOyBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5IH1cblxuICAgIGxldCBjbGVhciBoID1cbiAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIGRvbmVcblxuICAgIGxldCByZXNldCBoID1cbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBpZiBsZW4gPSBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgICAgIGNsZWFyIGhcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIDA7XG4gICAgICAgIGguZGF0YSA8LSBBcnJheS5tYWtlIGguaW5pdGlhbF9zaXplIEVtcHR5XG4gICAgICBlbmRcblxuICAgIGxldCBjb3B5IGggPSB7IGggd2l0aCBkYXRhID0gQXJyYXkuY29weSBoLmRhdGEgfVxuXG4gICAgbGV0IGtleV9pbmRleCBoIGhrZXkgPVxuICAgICAgaGtleSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBjbGVhbiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgRW1wdHlcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIHdoZW4gbm90IChILmNoZWNrX2tleSBjKSAtPlxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICB8IENvbnMoaGtleSwgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIENvbnMoaGtleSwgYywgZG9fYnVja2V0IHJlc3QpXG4gICAgICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZC4oaSkgPC0gZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICAoKiogcmVzaXplIGlzIHRoZSBvbmx5IGZ1bmN0aW9uIHRvIGRvIHRoZSBhY3R1YWwgY2xlYW5pbmcgb2YgZGVhZCBrZXlzXG4gICAgICAgIChyZW1vdmUgZG9lcyBpdCBqdXN0IGJlY2F1c2UgaXQgY291bGQpLlxuXG4gICAgICAgIFRoZSBnb2FsIGlzIHRvOlxuXG4gICAgICAgIC0gbm90IHJlc2l6ZSBpbmZpbml0ZWx5IHdoZW4gdGhlIGFjdHVhbCBudW1iZXIgb2YgYWxpdmUga2V5cyBpc1xuICAgICAgICBib3VuZGVkIGJ1dCBrZXlzIGFyZSBjb250aW51b3VzbHkgYWRkZWQuIFRoYXQgd291bGQgaGFwcGVuIGlmXG4gICAgICAgIHRoaXMgZnVuY3Rpb24gYWx3YXlzIHJlc2l6ZS5cbiAgICAgICAgLSBub3QgY2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIGVhY2ggYWRkaXRpb24sIHRoYXQgd291bGQgaGFwcGVuIGlmIHRoaXNcbiAgICAgICAgZnVuY3Rpb24gZG9uJ3QgcmVzaXplIGV2ZW4gd2hlbiBvbmx5IG9uZSBrZXkgaXMgZGVhZC5cblxuICAgICAgICBTbyB0aGUgYWxnb3JpdGhtOlxuICAgICAgICAtIGNsZWFuIHRoZSBrZXlzIGJlZm9yZSByZXNpemluZ1xuICAgICAgICAtIGlmIHRoZSBudW1iZXIgb2YgcmVtYWluaW5nIGtleXMgaXMgbGVzcyB0aGFuIGhhbGYgdGhlIHNpemUgb2YgdGhlXG4gICAgICAgIGFycmF5LCBkb24ndCByZXNpemUuXG4gICAgICAgIC0gaWYgaXQgaXMgbW9yZSwgcmVzaXplLlxuXG4gICAgICAgIFRoZSBzZWNvbmQgcHJvYmxlbSByZW1haW5zIGlmIHRoZSB0YWJsZSByZWFjaGVzIHshU3lzLm1heF9hcnJheV9sZW5ndGh9LlxuXG4gICAgKilcbiAgICBsZXQgcmVzaXplIGggPVxuICAgICAgbGV0IG9kYXRhID0gaC5kYXRhIGluXG4gICAgICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgICAgIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICAgICAgY2xlYW4gaDtcbiAgICAgIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggJiYgaC5zaXplID49IG9zaXplIGxzciAxIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5kYXRhID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgICAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICgqIHNvIHRoYXQga2V5X2luZGV4IHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICAgICAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICAgICAgfCBDb25zKGhrZXksIGRhdGEsIHJlc3QpIC0+XG4gICAgICAgICAgICAgIGluc2VydF9idWNrZXQgcmVzdDsgKCogcHJlc2VydmUgb3JpZ2luYWwgb3JkZXIgb2YgZWxlbWVudHMgKilcbiAgICAgICAgICAgICAgbGV0IG5pZHggPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICAgICAgICAgIG5kYXRhLihuaWR4KSA8LSBDb25zKGhrZXksIGRhdGEsIG5kYXRhLihuaWR4KSkgaW5cbiAgICAgICAgZm9yIGkgPSAwIHRvIG9zaXplIC0gMSBkb1xuICAgICAgICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gICAgICAgIGRvbmVcbiAgICAgIGVuZFxuXG4gICAgbGV0IGFkZCBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgbGV0IGNvbnRhaW5lciA9IEguY3JlYXRlIGtleSBpbmZvIGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29ucyhoa2V5LCBjb250YWluZXIsIGguZGF0YS4oaSkpIGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBoXG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgICAgfCBDb25zKGhrLCBjLCBuZXh0KSB3aGVuIGhrZXkgPSBoayAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgICB8IEVUcnVlIC0+IGguc2l6ZSA8LSBoLnNpemUgLSAxOyBuZXh0XG4gICAgICAgICAgICB8IEVGYWxzZSAtPiBDb25zKGhrLCBjLCByZW1vdmVfYnVja2V0IG5leHQpXG4gICAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgICAgKCogVGhlIGRlYWQga2V5IGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC4gSXQgaXMgYWNjZXB0YWJsZVxuICAgICAgICAgICAgICAgICAgICBmb3IgdGhpcyBmdW5jdGlvbiBzaW5jZSBpdCBhbHJlYWR5IHJlbW92ZXMgYSBiaW5kaW5nICopXG4gICAgICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgcmVtb3ZlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKGhrLGMsbmV4dCkgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KSBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIHJlbW92ZV9idWNrZXQgaC5kYXRhLihpKVxuXG4gICAgKCoqIHshZmluZH0gZG9uJ3QgcmVtb3ZlIGRlYWQga2V5cyBiZWNhdXNlIGl0IHdvdWxkIGJlIHN1cnByaXNpbmcgZm9yXG4gICAgICAgIHRoZSB1c2VyIHRoYXQgYSByZWFkLW9ubHkgZnVuY3Rpb24gbXV0YXRlcyB0aGUgc3RhdGUgKGVnLiBjb25jdXJyZW50XG4gICAgICAgIGFjY2VzcykuIFNhbWUgZm9yIHshaXRlcn0sIHshZm9sZH0sIHshbWVtfS5cbiAgICAqKVxuICAgIGxldCByZWMgZmluZF9yZWMga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+XG4gICAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgKCogVGhpcyBjYXNlIGlzIG5vdCBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdjIGNhbiBydW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgIEguZXF1YWwgYW5kIEguZ2V0X2RhdGEgKilcbiAgICAgICAgICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjIGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgXyBhcyBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgICgqIFRPRE8gaW5saW5lIDMgaXRlcmF0aW9ucyAqKVxuICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBbXVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+IGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgZCAtPiBkOjpmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpXG5cblxuICAgIGxldCByZXBsYWNlIGgga2V5IGluZm8gPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyByZXBsYWNlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBILnNldF9rZXlfZGF0YSBjIGtleSBpbmZvXG4gICAgICAgICAgICB8IEVGYWxzZSB8IEVEZWFkIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IENvbnMoXyxfLG5leHQpIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgdHJ5XG4gICAgICAgIHJlcGxhY2VfYnVja2V0IGxcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnMoaGtleSwgY29udGFpbmVyLCBsKTtcbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGsgPSBoa2V5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiB0cnVlXG4gICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiBtZW1faW5fYnVja2V0IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfaGssIF9jLCByZXN0KSAtPiBtZW1faW5fYnVja2V0IHJlc3QgaW5cbiAgICAgIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG4gICAgbGV0IGl0ZXIgZiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgKClcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gKClcbiAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT4gZiBrIGRcbiAgICAgICAgICAgIGVuZDsgZG9fYnVja2V0IHJlc3QgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgbGV0IGZvbGQgZiBoIGluaXQgPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgYiBhY2N1ID1cbiAgICAgICAgbWF0Y2ggYiB3aXRoXG4gICAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAgIGFjY3VcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBsZXQgYWNjdSA9IGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IGFjY3VcbiAgICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPiBmIGsgZCBhY2N1XG4gICAgICAgICAgICBlbmQgaW5cbiAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0IGFjY3UgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgICAgZG9uZTtcbiAgICAgICFhY2N1XG5cbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPlxuICAgICAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+XG4gICAgICAgICAgICAgICAgbWF0Y2ggZiBrIGQgd2l0aFxuICAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICAgICAgICAgIHwgU29tZSBuZXdfZCAtPlxuICAgICAgICAgICAgICAgICAgICBILnNldF9rZXlfZGF0YSBjIGsgbmV3X2Q7XG4gICAgICAgICAgICAgICAgICAgIENvbnMoaGssIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgbGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoIChhY2N1ICsgMSkgcmVzdFxuXG4gICAgbGV0IHN0YXRzIGggPVxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBtYXggbSAoYnVja2V0X2xlbmd0aCAwIGIpKSAwIGguZGF0YSBpblxuICAgICAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICAgICAgQXJyYXkuaXRlclxuICAgICAgICAoZnVuIGIgLT5cbiAgICAgICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICAgICAgaC5kYXRhO1xuICAgICAgeyBIYXNodGJsLm51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICAgICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgICAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICAgICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuICAgIGxldCByZWMgYnVja2V0X2xlbmd0aF9hbGl2ZSBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIHdoZW4gSC5jaGVja19rZXkgYyAtPlxuICAgICAgICAgIGJ1Y2tldF9sZW5ndGhfYWxpdmUgKGFjY3UgKyAxKSByZXN0XG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT4gYnVja2V0X2xlbmd0aF9hbGl2ZSBhY2N1IHJlc3RcblxuICAgIGxldCBzdGF0c19hbGl2ZSBoID1cbiAgICAgIGxldCBzaXplID0gcmVmIDAgaW5cbiAgICAgIGxldCBtYmwgPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gbWF4IG0gKGJ1Y2tldF9sZW5ndGhfYWxpdmUgMCBiKSkgMCBoLmRhdGEgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aF9hbGl2ZSAwIGIgaW5cbiAgICAgICAgICAgc2l6ZSA6PSAhc2l6ZSArIGw7XG4gICAgICAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgICAgICBoLmRhdGE7XG4gICAgICB7IEhhc2h0YmwubnVtX2JpbmRpbmdzID0gIXNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgdG9fc2VxIHRibCA9XG4gICAgICAoKiBjYXB0dXJlIGN1cnJlbnQgYXJyYXksIHNvIHRoYXQgZXZlbiBpZiB0aGUgdGFibGUgaXMgcmVzaXplZCB3ZVxuICAgICAgICAga2VlcCBpdGVyYXRpbmcgb24gdGhlIHNhbWUgYXJyYXkgKilcbiAgICAgIGxldCB0YmxfZGF0YSA9IHRibC5kYXRhIGluXG4gICAgICAoKiBzdGF0ZTogaW5kZXggKiBuZXh0IGJ1Y2tldCB0byB0cmF2ZXJzZSAqKVxuICAgICAgbGV0IHJlYyBhdXggaSBidWNrICgpID0gbWF0Y2ggYnVjayB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdGJsX2RhdGFcbiAgICAgICAgICAgIHRoZW4gU2VxLk5pbFxuICAgICAgICAgICAgZWxzZSBhdXgoaSsxKSB0YmxfZGF0YS4oaSkgKClcbiAgICAgICAgfCBDb25zIChfLCBjLCBuZXh0KSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gYXV4IGkgbmV4dCAoKVxuICAgICAgICAgICAgICB8IFNvbWUga2V5LCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgICAgICAgIFNlcS5Db25zICgoa2V5LCBkYXRhKSwgYXV4IGkgbmV4dClcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIGF1eCAwIEVtcHR5XG5cbiAgICBsZXQgdG9fc2VxX2tleXMgbSA9IFNlcS5tYXAgZnN0ICh0b19zZXEgbSlcblxuICAgIGxldCB0b19zZXFfdmFsdWVzIG0gPSBTZXEubWFwIHNuZCAodG9fc2VxIG0pXG5cbiAgICBsZXQgYWRkX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbiAgICBsZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBPYmpFcGggPSBPYmouRXBoZW1lcm9uXG5cbmxldCBfb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPlxuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHhcbiAgfCBTb21lIHYgLT4gU29tZSAoT2JqLm9iaiB2KVxuXG4oKiogVGhlIHByZXZpb3VzIGZ1bmN0aW9uIGlzIHR5cGVkIHNvIHRoaXMgb25lIGlzIGFsc28gY29ycmVjdCAqKVxubGV0IG9ial9vcHQgOiBPYmoudCBvcHRpb24gLT4gJ2Egb3B0aW9uID0gZnVuIHggLT4gT2JqLm1hZ2ljIHhcblxuXG5tb2R1bGUgSzEgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIDFcblxuICBsZXQgZ2V0X2tleSAodDooJ2ssJ2QpIHQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgZ2V0X2tleV9jb3B5ICh0OignaywnZCkgdCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMClcbiAgbGV0IHNldF9rZXkgKHQ6KCdrLCdkKSB0KSAoazonaykgOiB1bml0ID0gT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5ICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDBcbiAgbGV0IGNoZWNrX2tleSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGJsaXRfa2V5ICh0MTooJ2ssJ2QpIHQpICh0MjooJ2ssJ2QpIHQpOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDFcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignaywnZCkgdCkgKGQ6J2QpIDogdW5pdCA9IE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLCdkKSB0KSAodDI6KF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoID0gSC5oYXNoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgKCogeyFnZXRfa2V5X2NvcHl9IGlzIG5vdCB1c2VkIGJlY2F1c2UgdGhlIGVxdWFsaXR5IG9mIHRoZSB1c2VyIGNhbiBiZVxuICAgICAgICAgICAgdGhlIHBoeXNpY2FsIGVxdWFsaXR5ICopXG4gICAgICAgIG1hdGNoIGdldF9rZXkgYyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsnIC0+XG4gICAgICAgICAgICBpZiBILmVxdWFsIGsgaycgdGhlbiBHZW5IYXNoVGFibGUuRVRydWUgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgPSBnZXRfa2V5XG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5ID0gY2hlY2tfa2V5XG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEsyID0gc3RydWN0XG4gIHR5cGUgKCdrMSwgJ2syLCAnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnazEsJ2syLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSAyXG5cbiAgbGV0IGdldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSA6ICdrMSBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBnZXRfa2V5MV9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdrMSBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAwKVxuICBsZXQgc2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMSkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMFxuICBsZXQgY2hlY2tfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgZ2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2syIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMSlcbiAgbGV0IGdldF9rZXkyX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2syIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDEpXG4gIGxldCBzZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgKGs6J2syKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgMSAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAxXG4gIGxldCBjaGVja19rZXkyICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMVxuXG5cbiAgbGV0IGJsaXRfa2V5MSAodDE6KCdrMSxfLF8pIHQpICh0MjooJ2sxLF8sXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDFcbiAgbGV0IGJsaXRfa2V5MiAodDE6KF8sJ2syLF8pIHQpICh0MjooXywnazIsXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMSB0MiAxIDFcbiAgbGV0IGJsaXRfa2V5MTIgKHQxOignazEsJ2syLF8pIHQpICh0MjooJ2sxLCdrMixfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMlxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2Qgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIChkOidkKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXyxfLCdkKSB0KSAodDI6KF8sXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkXG4gICAgICAoSDE6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKVxuICAgICAgKEgyOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSDEudCxIMi50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBIMS50ICogSDIudFxuICAgICAgbGV0IGNyZWF0ZSAoazEsazIpIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoIHNlZWQgKGsxLGsyKSA9XG4gICAgICAgIEgxLmhhc2ggc2VlZCBrMSArIEgyLmhhc2ggc2VlZCBrMiAqIDY1NTk5XG4gICAgICBsZXQgZXF1YWwgYyAoazEsazIpID1cbiAgICAgICAgbWF0Y2ggZ2V0X2tleTEgYywgZ2V0X2tleTIgYyB3aXRoXG4gICAgICAgIHwgTm9uZSwgXyB8IF8gLCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICB8IFNvbWUgazEnLCBTb21lIGsyJyAtPlxuICAgICAgICAgICAgaWYgSDEuZXF1YWwgazEgazEnICYmIEgyLmVxdWFsIGsyIGsyJ1xuICAgICAgICAgICAgdGhlbiBHZW5IYXNoVGFibGUuRVRydWUgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgYyA9XG4gICAgICAgIG1hdGNoIGdldF9rZXkxIGMsIGdldF9rZXkyIGMgd2l0aFxuICAgICAgICB8IE5vbmUsIF8gfCBfICwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSBrMScsIFNvbWUgazInIC0+IFNvbWUgKGsxJywgazInKVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIChrMSxrMikgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgc2V0X2tleTEgYyBrMTsgc2V0X2tleTIgYyBrMjtcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5IGMgPSBjaGVja19rZXkxIGMgJiYgY2hlY2tfa2V5MiBjXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEgxOiBIYXNodGJsLkhhc2hlZFR5cGUpKEgyOiBIYXNodGJsLkhhc2hlZFR5cGUpOlxuICAgIChTIHdpdGggdHlwZSBrZXkgPSBIMS50ICogSDIudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWRcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIHR5cGUgdCA9IEgxLnRcbiAgICAgICAgICBsZXQgZXF1YWwgPSBIMS5lcXVhbFxuICAgICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSDEuaGFzaCB4XG4gICAgICAgIGVuZClcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIHR5cGUgdCA9IEgyLnRcbiAgICAgICAgICBsZXQgZXF1YWwgPSBIMi5lcXVhbFxuICAgICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSDIuaGFzaCB4XG4gICAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbmVuZFxuXG5tb2R1bGUgS24gPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgbiA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgblxuICBsZXQgbGVuZ3RoIChrOignaywnZCkgdCkgOiBpbnQgPSBPYmpFcGgubGVuZ3RoIGtcblxuICBsZXQgZ2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IG4pXG4gIGxldCBnZXRfa2V5X2NvcHkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogJ2sgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgbilcbiAgbGV0IHNldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIChrOidrKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgbiAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IG5cbiAgbGV0IGNoZWNrX2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IG5cblxuICBsZXQgYmxpdF9rZXkgKHQxOignaywnZCkgdCkgKG8xOmludCkgKHQyOignaywnZCkgdCkgKG8yOmludCkgKGw6aW50KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSBvMSB0MiBvMiBsXG5cbiAgbGV0IGdldF9kYXRhICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2ssJ2QpIHQpIChkOidkKSA6IHVuaXQgPSBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXywnZCkgdCkgKHQyOihfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudCBhcnJheVxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoQXJyYXkubGVuZ3RoIGspIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCBzZWVkIGsgPVxuICAgICAgICBsZXQgaCA9IHJlZiAwIGluXG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBoIDo9IEguaGFzaCBzZWVkIGsuKGkpICogNjU1OTkgKyAhaDtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgIWhcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICBsZXQgbGVuICA9IEFycmF5Lmxlbmd0aCBrIGluXG4gICAgICAgIGxldCBsZW4nID0gbGVuZ3RoIGMgaW5cbiAgICAgICAgaWYgbGVuICE9IGxlbicgdGhlbiBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgcmVjIGVxdWFsX2FycmF5IGsgYyBpID1cbiAgICAgICAgICAgIGlmIGkgPCAwIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyBpIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICAgICAgICB8IFNvbWUga2kgLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwgay4oaSkga2lcbiAgICAgICAgICAgICAgICAgIHRoZW4gZXF1YWxfYXJyYXkgayBjIChpLTEpXG4gICAgICAgICAgICAgICAgICBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgICBpblxuICAgICAgICAgIGVxdWFsX2FycmF5IGsgYyAobGVuLTEpXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgYyA9XG4gICAgICAgIGxldCBsZW4gPSBsZW5ndGggYyBpblxuICAgICAgICBpZiBsZW4gPSAwIHRoZW4gU29tZSBbfHxdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgMCB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICB8IFNvbWUgazAgLT5cbiAgICAgICAgICAgICAgbGV0IHJlYyBmaWxsIGEgaSA9XG4gICAgICAgICAgICAgICAgaWYgaSA8IDEgdGhlbiBTb21lIGFcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgaSB3aXRoXG4gICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgICAgICAgICAgfCBTb21lIGtpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgYS4oaSkgPC0ga2k7XG4gICAgICAgICAgICAgICAgICAgICAgZmlsbCBhIChpLTEpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIGxldCBhID0gQXJyYXkubWFrZSBsZW4gazAgaW5cbiAgICAgICAgICAgICAgZmlsbCBhIChsZW4tMSlcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5IGMgPVxuICAgICAgICBsZXQgcmVjIGNoZWNrIGMgaSA9XG4gICAgICAgICAgaSA8IDAgfHwgKGNoZWNrX2tleSBjIGkgJiYgY2hlY2sgYyAoaS0xKSkgaW5cbiAgICAgICAgY2hlY2sgYyAobGVuZ3RoIGMgLSAxKVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50IGFycmF5KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIE1hbnVlbCBTZXJyYW5vIGV0IFhhdmllciBMZXJveSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0JpZ2FycmF5XTogbGFyZ2UsIG11bHRpLWRpbWVuc2lvbmFsLCBudW1lcmljYWwgYXJyYXlzICopXG5cbigqIFRoZXNlIHR5cGVzIGluIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIHRhYmxlcyBpblxuICAgLi4vdHlwaW5nL3R5cGVvcHQubWwgKilcblxudHlwZSBmbG9hdDMyX2VsdCA9IEZsb2F0MzJfZWx0XG50eXBlIGZsb2F0NjRfZWx0ID0gRmxvYXQ2NF9lbHRcbnR5cGUgaW50OF9zaWduZWRfZWx0ID0gSW50OF9zaWduZWRfZWx0XG50eXBlIGludDhfdW5zaWduZWRfZWx0ID0gSW50OF91bnNpZ25lZF9lbHRcbnR5cGUgaW50MTZfc2lnbmVkX2VsdCA9IEludDE2X3NpZ25lZF9lbHRcbnR5cGUgaW50MTZfdW5zaWduZWRfZWx0ID0gSW50MTZfdW5zaWduZWRfZWx0XG50eXBlIGludDMyX2VsdCA9IEludDMyX2VsdFxudHlwZSBpbnQ2NF9lbHQgPSBJbnQ2NF9lbHRcbnR5cGUgaW50X2VsdCA9IEludF9lbHRcbnR5cGUgbmF0aXZlaW50X2VsdCA9IE5hdGl2ZWludF9lbHRcbnR5cGUgY29tcGxleDMyX2VsdCA9IENvbXBsZXgzMl9lbHRcbnR5cGUgY29tcGxleDY0X2VsdCA9IENvbXBsZXg2NF9lbHRcblxudHlwZSAoJ2EsICdiKSBraW5kID1cbiAgICBGbG9hdDMyIDogKGZsb2F0LCBmbG9hdDMyX2VsdCkga2luZFxuICB8IEZsb2F0NjQgOiAoZmxvYXQsIGZsb2F0NjRfZWx0KSBraW5kXG4gIHwgSW50OF9zaWduZWQgOiAoaW50LCBpbnQ4X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3Vuc2lnbmVkIDogKGludCwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl9zaWduZWQgOiAoaW50LCBpbnQxNl9zaWduZWRfZWx0KSBraW5kXG4gIHwgSW50MTZfdW5zaWduZWQgOiAoaW50LCBpbnQxNl91bnNpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQzMiA6IChpbnQzMiwgaW50MzJfZWx0KSBraW5kXG4gIHwgSW50NjQgOiAoaW50NjQsIGludDY0X2VsdCkga2luZFxuICB8IEludCA6IChpbnQsIGludF9lbHQpIGtpbmRcbiAgfCBOYXRpdmVpbnQgOiAobmF0aXZlaW50LCBuYXRpdmVpbnRfZWx0KSBraW5kXG4gIHwgQ29tcGxleDMyIDogKENvbXBsZXgudCwgY29tcGxleDMyX2VsdCkga2luZFxuICB8IENvbXBsZXg2NCA6IChDb21wbGV4LnQsIGNvbXBsZXg2NF9lbHQpIGtpbmRcbiAgfCBDaGFyIDogKGNoYXIsIGludDhfdW5zaWduZWRfZWx0KSBraW5kXG5cbnR5cGUgY19sYXlvdXQgPSBDX2xheW91dF90eXBcbnR5cGUgZm9ydHJhbl9sYXlvdXQgPSBGb3J0cmFuX2xheW91dF90eXAgKCoqKVxuXG50eXBlICdhIGxheW91dCA9XG4gICAgQ19sYXlvdXQ6IGNfbGF5b3V0IGxheW91dFxuICB8IEZvcnRyYW5fbGF5b3V0OiBmb3J0cmFuX2xheW91dCBsYXlvdXRcblxuKCogS2VlcCB0aG9zZSBjb25zdGFudHMgaW4gc3luYyB3aXRoIHRoZSBjYW1sX2JhX2tpbmQgZW51bWVyYXRpb25cbiAgIGluIGJpZ2FycmF5LmggKilcblxubGV0IGZsb2F0MzIgPSBGbG9hdDMyXG5sZXQgZmxvYXQ2NCA9IEZsb2F0NjRcbmxldCBpbnQ4X3NpZ25lZCA9IEludDhfc2lnbmVkXG5sZXQgaW50OF91bnNpZ25lZCA9IEludDhfdW5zaWduZWRcbmxldCBpbnQxNl9zaWduZWQgPSBJbnQxNl9zaWduZWRcbmxldCBpbnQxNl91bnNpZ25lZCA9IEludDE2X3Vuc2lnbmVkXG5sZXQgaW50MzIgPSBJbnQzMlxubGV0IGludDY0ID0gSW50NjRcbmxldCBpbnQgPSBJbnRcbmxldCBuYXRpdmVpbnQgPSBOYXRpdmVpbnRcbmxldCBjb21wbGV4MzIgPSBDb21wbGV4MzJcbmxldCBjb21wbGV4NjQgPSBDb21wbGV4NjRcbmxldCBjaGFyID0gQ2hhclxuXG5sZXQga2luZF9zaXplX2luX2J5dGVzIDogdHlwZSBhIGIuIChhLCBiKSBraW5kIC0+IGludCA9IGZ1bmN0aW9uXG4gIHwgRmxvYXQzMiAtPiA0XG4gIHwgRmxvYXQ2NCAtPiA4XG4gIHwgSW50OF9zaWduZWQgLT4gMVxuICB8IEludDhfdW5zaWduZWQgLT4gMVxuICB8IEludDE2X3NpZ25lZCAtPiAyXG4gIHwgSW50MTZfdW5zaWduZWQgLT4gMlxuICB8IEludDMyIC0+IDRcbiAgfCBJbnQ2NCAtPiA4XG4gIHwgSW50IC0+IFN5cy53b3JkX3NpemUgLyA4XG4gIHwgTmF0aXZlaW50IC0+IFN5cy53b3JkX3NpemUgLyA4XG4gIHwgQ29tcGxleDMyIC0+IDhcbiAgfCBDb21wbGV4NjQgLT4gMTZcbiAgfCBDaGFyIC0+IDFcblxuKCogS2VlcCB0aG9zZSBjb25zdGFudHMgaW4gc3luYyB3aXRoIHRoZSBjYW1sX2JhX2xheW91dCBlbnVtZXJhdGlvblxuICAgaW4gYmlnYXJyYXkuaCAqKVxuXG5sZXQgY19sYXlvdXQgPSBDX2xheW91dFxubGV0IGZvcnRyYW5fbGF5b3V0ID0gRm9ydHJhbl9sYXlvdXRcblxubW9kdWxlIEdlbmFycmF5ID0gc3RydWN0XG4gIHR5cGUgKCEnYSwgISdiLCAhJ2MpIHRcbiAgZXh0ZXJuYWwgY3JlYXRlOiAoJ2EsICdiKSBraW5kIC0+ICdjIGxheW91dCAtPiBpbnQgYXJyYXkgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgPSBcImNhbWxfYmFfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgYXJyYXkgLT4gJ2FcbiAgICAgPSBcImNhbWxfYmFfZ2V0X2dlbmVyaWNcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCBhcnJheSAtPiAnYSAtPiB1bml0XG4gICAgID0gXCJjYW1sX2JhX3NldF9nZW5lcmljXCJcblxuICBsZXQgcmVjIGNsb29wIGFyciBpZHggZiBjb2wgbWF4ID1cbiAgICBpZiBjb2wgPSBBcnJheS5sZW5ndGggaWR4IHRoZW4gc2V0IGFyciBpZHggKGYgaWR4KVxuICAgIGVsc2UgZm9yIGogPSAwIHRvIHByZWQgbWF4Lihjb2wpIGRvXG4gICAgICAgICAgIGlkeC4oY29sKSA8LSBqO1xuICAgICAgICAgICBjbG9vcCBhcnIgaWR4IGYgKHN1Y2MgY29sKSBtYXhcbiAgICAgICAgIGRvbmVcbiAgbGV0IHJlYyBmbG9vcCBhcnIgaWR4IGYgY29sIG1heCA9XG4gICAgaWYgY29sIDwgMCB0aGVuIHNldCBhcnIgaWR4IChmIGlkeClcbiAgICBlbHNlIGZvciBqID0gMSB0byBtYXguKGNvbCkgZG9cbiAgICAgICAgICAgaWR4Lihjb2wpIDwtIGo7XG4gICAgICAgICAgIGZsb29wIGFyciBpZHggZiAocHJlZCBjb2wpIG1heFxuICAgICAgICAgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltcyBmID1cbiAgICBsZXQgYXJyID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbXMgaW5cbiAgICBtYXRjaCBBcnJheS5sZW5ndGggZGltcywgbGF5b3V0IHdpdGhcbiAgICB8IDAsIF8gLT4gYXJyXG4gICAgfCBkbGVuLCBDX2xheW91dCAtPiBjbG9vcCBhcnIgKEFycmF5Lm1ha2UgZGxlbiAwKSBmIDAgZGltczsgYXJyXG4gICAgfCBkbGVuLCBGb3J0cmFuX2xheW91dCAtPiBmbG9vcCBhcnIgKEFycmF5Lm1ha2UgZGxlbiAxKSBmIChwcmVkIGRsZW4pIGRpbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJcblxuICBleHRlcm5hbCBudW1fZGltczogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCJjYW1sX2JhX251bV9kaW1zXCJcbiAgZXh0ZXJuYWwgbnRoX2RpbTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCA9IFwiY2FtbF9iYV9kaW1cIlxuICBsZXQgZGltcyBhID1cbiAgICBsZXQgbiA9IG51bV9kaW1zIGEgaW5cbiAgICBsZXQgZCA9IEFycmF5Lm1ha2UgbiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIG4tMSBkbyBkLihpKSA8LSBudGhfZGltIGEgaSBkb25lO1xuICAgIGRcblxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKEFycmF5LmZvbGRfbGVmdCAoICogKSAxIChkaW1zIGFycikpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHNsaWNlX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCBhcnJheSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zbGljZVwiXG4gIGV4dGVybmFsIHNsaWNlX3JpZ2h0OiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgYXJyYXkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc2xpY2VcIlxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuZW5kXG5cbm1vZHVsZSBBcnJheTAgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfHxdXG4gIGxldCBnZXQgYXJyID0gR2VuYXJyYXkuZ2V0IGFyciBbfHxdXG4gIGxldCBzZXQgYXJyID0gR2VuYXJyYXkuc2V0IGFyciBbfHxdXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID0ga2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycilcblxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuXG4gIGxldCBvZl92YWx1ZSBraW5kIGxheW91dCB2ID1cbiAgICBsZXQgYSA9IGNyZWF0ZSBraW5kIGxheW91dCBpblxuICAgIHNldCBhIHY7XG4gICAgYVxuICBsZXQgaW5pdCA9IG9mX3ZhbHVlXG5lbmRcblxubW9kdWxlIEFycmF5MSA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0gPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbXxdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMVwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVjYW1sX2JhX3NldF8xXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzFcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8xXCJcbiAgZXh0ZXJuYWwgZGltOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltIGFycilcblxuICBleHRlcm5hbCBzdWI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgJ2MpIHQgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlICh0eXBlIHQpIChhIDogKF8sIF8sIHQpIEdlbmFycmF5LnQpIG4gPVxuICAgIG1hdGNoIGxheW91dCBhIHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF0gOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IChHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdOiAoXywgXywgdCkgR2VuYXJyYXkudClcbiAgZXh0ZXJuYWwgYmxpdDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIHQgLT4gdW5pdCA9IFwiY2FtbF9iYV9ibGl0XCJcbiAgZXh0ZXJuYWwgZmlsbDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9iYV9maWxsXCJcbiAgbGV0IGNfaW5pdCBhcnIgZGltIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbSBkbyB1bnNhZmVfc2V0IGFyciBpIChmIGkpIGRvbmVcbiAgbGV0IGZvcnRyYW5faW5pdCBhcnIgZGltIGYgPVxuICAgIGZvciBpID0gMSB0byBkaW0gZG8gdW5zYWZlX3NldCBhcnIgaSAoZiBpKSBkb25lXG4gIGxldCBpbml0ICh0eXBlIHQpIGtpbmQgKGxheW91dCA6IHQgbGF5b3V0KSBkaW0gZiA9XG4gICAgbGV0IGFyciA9IGNyZWF0ZSBraW5kIGxheW91dCBkaW0gaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0gZjsgYXJyXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiBmb3J0cmFuX2luaXQgYXJyIGRpbSBmOyBhcnJcbiAgbGV0IG9mX2FycmF5ICh0eXBlIHQpIGtpbmQgKGxheW91dDogdCBsYXlvdXQpIGRhdGEgPVxuICAgIGxldCBiYSA9IGNyZWF0ZSBraW5kIGxheW91dCAoQXJyYXkubGVuZ3RoIGRhdGEpIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZGF0YSAtIDEgZG8gdW5zYWZlX3NldCBiYSAoaSArIG9mcykgZGF0YS4oaSkgZG9uZTtcbiAgICBiYVxuZW5kXG5cbm1vZHVsZSBBcnJheTIgPSBzdHJ1Y3RcbiAgdHlwZSAoISdhLCAhJ2IsICEnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW0xOyBkaW0yfF1cbiAgZXh0ZXJuYWwgZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfMlwiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlY2FtbF9iYV9zZXRfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2FcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9yZWZfMlwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8yXCJcbiAgZXh0ZXJuYWwgZGltMTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGRpbTI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzJcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OlxuICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlX2xlZnQgYSBuID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdXG4gIGxldCBzbGljZV9yaWdodCBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBjX2luaXQgYXJyIGRpbTEgZGltMiBmID1cbiAgICBmb3IgaSA9IDAgdG8gcHJlZCBkaW0xIGRvXG4gICAgICBmb3IgaiA9IDAgdG8gcHJlZCBkaW0yIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiAoZiBpIGopXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZiA9XG4gICAgZm9yIGogPSAxIHRvIGRpbTIgZG9cbiAgICAgIGZvciBpID0gMSB0byBkaW0xIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiAoZiBpIGopXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgaW5pdCAodHlwZSB0KSBraW5kIChsYXlvdXQgOiB0IGxheW91dCkgZGltMSBkaW0yIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGluXG4gICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICB8IENfbGF5b3V0IC0+IGNfaW5pdCBhcnIgZGltMSBkaW0yIGY7IGFyclxuICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZjsgYXJyXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBkaW0xIC0gMSBkb1xuICAgICAgbGV0IHJvdyA9IGRhdGEuKGkpIGluXG4gICAgICBpZiBBcnJheS5sZW5ndGggcm93IDw+IGRpbTIgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5Mi5vZl9hcnJheTogbm9uLXJlY3Rhbmd1bGFyIGRhdGFcIik7XG4gICAgICBmb3IgaiA9IDAgdG8gZGltMiAtIDEgZG9cbiAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIHJvdy4oailcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxubW9kdWxlIEFycmF5MyA9IHN0cnVjdFxuICB0eXBlICghJ2EsICEnYiwgISdjKSB0ID0gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgbGV0IGNyZWF0ZSBraW5kIGxheW91dCBkaW0xIGRpbTIgZGltMyA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltMTsgZGltMjsgZGltM3xdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgPSBcIiVjYW1sX2JhX3JlZl8zXCJcbiAgZXh0ZXJuYWwgc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV9zZXRfM1wiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhXG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzNcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYSAtPiB1bml0XG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfc2V0XzNcIlxuICBleHRlcm5hbCBkaW0xOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8xXCJcbiAgZXh0ZXJuYWwgZGltMjogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMlwiXG4gIGV4dGVybmFsIGRpbTM6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzNcIlxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuXG4gIGV4dGVybmFsIGNoYW5nZV9sYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdkIGxheW91dCAtPiAoJ2EsICdiLCAnZCkgdFxuICAgID0gXCJjYW1sX2JhX2NoYW5nZV9sYXlvdXRcIlxuXG4gIGxldCBzaXplX2luX2J5dGVzIGFyciA9XG4gICAgKGtpbmRfc2l6ZV9pbl9ieXRlcyAoa2luZCBhcnIpKSAqIChkaW0xIGFycikgKiAoZGltMiBhcnIpICogKGRpbTMgYXJyKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDpcbiAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBsZXQgc2xpY2VfbGVmdF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bjsgbXxdXG4gIGxldCBzbGljZV9yaWdodF8xIGEgbiBtID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG47IG18XVxuICBsZXQgc2xpY2VfbGVmdF8yIGEgbiA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XVxuICBsZXQgc2xpY2VfcmlnaHRfMiBhIG4gPSBHZW5hcnJheS5zbGljZV9yaWdodCBhIFt8bnxdXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBjX2luaXQgYXJyIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGZvciBpID0gMCB0byBwcmVkIGRpbTEgZG9cbiAgICAgIGZvciBqID0gMCB0byBwcmVkIGRpbTIgZG9cbiAgICAgICAgZm9yIGsgPSAwIHRvIHByZWQgZGltMyBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYXJyIGkgaiBrIChmIGkgaiBrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZVxuICBsZXQgZm9ydHJhbl9pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmID1cbiAgICBmb3IgayA9IDEgdG8gZGltMyBkb1xuICAgICAgZm9yIGogPSAxIHRvIGRpbTIgZG9cbiAgICAgICAgZm9yIGkgPSAxIHRvIGRpbTEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IGFyciBpIGogayAoZiBpIGogaylcbiAgICAgICAgZG9uZVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgbGV0IGluaXQgKHR5cGUgdCkga2luZCAobGF5b3V0IDogdCBsYXlvdXQpIGRpbTEgZGltMiBkaW0zIGYgPVxuICAgIGxldCBhcnIgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgaW5cbiAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgIHwgQ19sYXlvdXQgLT4gY19pbml0IGFyciBkaW0xIGRpbTIgZGltMyBmOyBhcnJcbiAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IGZvcnRyYW5faW5pdCBhcnIgZGltMSBkaW0yIGRpbTMgZjsgYXJyXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgZGltMSA9IEFycmF5Lmxlbmd0aCBkYXRhIGluXG4gICAgbGV0IGRpbTIgPSBpZiBkaW0xID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkgaW5cbiAgICBsZXQgZGltMyA9IGlmIGRpbTIgPSAwIHRoZW4gMCBlbHNlIEFycmF5Lmxlbmd0aCBkYXRhLigwKS4oMCkgaW5cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgaW5cbiAgICBsZXQgb2ZzID1cbiAgICAgIG1hdGNoIGxheW91dCB3aXRoXG4gICAgICAgIENfbGF5b3V0IC0+IDBcbiAgICAgIHwgRm9ydHJhbl9sYXlvdXQgLT4gMVxuICAgIGluXG4gICAgZm9yIGkgPSAwIHRvIGRpbTEgLSAxIGRvXG4gICAgICBsZXQgcm93ID0gZGF0YS4oaSkgaW5cbiAgICAgIGlmIEFycmF5Lmxlbmd0aCByb3cgPD4gZGltMiB0aGVuXG4gICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgIGZvciBqID0gMCB0byBkaW0yIC0gMSBkb1xuICAgICAgICBsZXQgY29sID0gcm93LihqKSBpblxuICAgICAgICBpZiBBcnJheS5sZW5ndGggY29sIDw+IGRpbTMgdGhlblxuICAgICAgICAgIGludmFsaWRfYXJnKFwiQmlnYXJyYXkuQXJyYXkzLm9mX2FycmF5OiBub24tY3ViaWMgZGF0YVwiKTtcbiAgICAgICAgZm9yIGsgPSAwIHRvIGRpbTMgLSAxIGRvXG4gICAgICAgICAgdW5zYWZlX3NldCBiYSAoaSArIG9mcykgKGogKyBvZnMpIChrICsgb2ZzKSBjb2wuKGspXG4gICAgICAgIGRvbmVcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIGJhXG5lbmRcblxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkwOiAoJ2EsICdiLCAnYykgQXJyYXkwLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkxOiAoJ2EsICdiLCAnYykgQXJyYXkxLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkyOiAoJ2EsICdiLCAnYykgQXJyYXkyLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgZ2VuYXJyYXlfb2ZfYXJyYXkzOiAoJ2EsICdiLCAnYykgQXJyYXkzLnQgLT4gKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnRcbiAgID0gXCIlaWRlbnRpdHlcIlxubGV0IGFycmF5MF9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDAgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTBfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5MV9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDEgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTFfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5Ml9vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDIgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTJfb2ZfZ2VuYXJyYXlcIlxubGV0IGFycmF5M19vZl9nZW5hcnJheSBhID1cbiAgaWYgR2VuYXJyYXkubnVtX2RpbXMgYSA9IDMgdGhlbiBhXG4gIGVsc2UgaW52YWxpZF9hcmcgXCJCaWdhcnJheS5hcnJheTNfb2ZfZ2VuYXJyYXlcIlxuXG5leHRlcm5hbCByZXNoYXBlOlxuICAgKCdhLCAnYiwgJ2MpIEdlbmFycmF5LnQgLT4gaW50IGFycmF5IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiY2FtbF9iYV9yZXNoYXBlXCJcbmxldCByZXNoYXBlXzAgYSA9IHJlc2hhcGUgYSBbfHxdXG5sZXQgcmVzaGFwZV8xIGEgZGltMSA9IHJlc2hhcGUgYSBbfGRpbTF8XVxubGV0IHJlc2hhcGVfMiBhIGRpbTEgZGltMiA9IHJlc2hhcGUgYSBbfGRpbTE7ZGltMnxdXG5sZXQgcmVzaGFwZV8zIGEgZGltMSBkaW0yIGRpbTMgPSByZXNoYXBlIGEgW3xkaW0xO2RpbTI7ZGltM3xdXG5cbigqIEZvcmNlIGNhbWxfYmFfZ2V0X3sxLDIsMyxOfSB0byBiZSBsaW5rZWQgaW4sIHNpbmNlIHdlIGRvbid0IHJlZmVyXG4gICB0byB0aG9zZSBwcmltaXRpdmVzIGRpcmVjdGx5IGluIHRoaXMgZmlsZSAqKVxuXG5sZXQgXyA9XG4gIGxldCBfID0gR2VuYXJyYXkuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkxLmdldCBpblxuICBsZXQgXyA9IEFycmF5Mi5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTMuZ2V0IGluXG4gICgpXG5cbltAQEBvY2FtbC53YXJuaW5nIFwiLTMyXCJdXG5leHRlcm5hbCBnZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzFcIlxuZXh0ZXJuYWwgZ2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8yXCJcbmV4dGVybmFsIGdldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfM1wiXG5leHRlcm5hbCBzZXQxOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzFcIlxuZXh0ZXJuYWwgc2V0MjogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8yXCJcbmV4dGVybmFsIHNldDM6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfM1wiXG4iLCJcbnR5cGUgcGttbl9jaGFyID0gVW51c2VkIHwgVW5yZWFkYWJsZSBvZiBzdHJpbmdcbiAgICAgICAgICAgICAgIHwgVW5hdmFpbGFibGUgb2Ygc3RyaW5nIHwgQXZhaWxhYmxlIG9mIHN0cmluZ1xuXG5sZXQgY2hhcnNldF9lbmcgPVxuICBbfFxuICAoKiAweDAuICopXG4gIEF2YWlsYWJsZSAgIFwiX1wiIDsgVW5hdmFpbGFibGUgXCLDgFwiIDsgVW5hdmFpbGFibGUgXCLDgVwiIDsgVW5hdmFpbGFibGUgXCLDglwiIDtcbiAgVW5hdmFpbGFibGUgXCLDh1wiIDsgVW5hdmFpbGFibGUgXCLDiFwiIDsgVW5hdmFpbGFibGUgXCLDiVwiIDsgVW5hdmFpbGFibGUgXCLDilwiIDtcbiAgVW5hdmFpbGFibGUgXCLDi1wiIDsgVW5hdmFpbGFibGUgXCLDjFwiIDsgVW51c2VkICAgICAgICAgIDsgVW5hdmFpbGFibGUgXCLDjlwiIDtcbiAgVW5hdmFpbGFibGUgXCLDj1wiIDsgVW5hdmFpbGFibGUgXCLDklwiIDsgVW5hdmFpbGFibGUgXCLDk1wiIDsgVW5hdmFpbGFibGUgXCLDlFwiIDtcbiAgKCogMHgxLiAqKVxuICBVbmF2YWlsYWJsZSBcIsWSXCIgOyBVbmF2YWlsYWJsZSBcIsOZXCIgOyBVbmF2YWlsYWJsZSBcIsOaXCIgOyBVbmF2YWlsYWJsZSBcIsObXCIgO1xuICBVbmF2YWlsYWJsZSBcIsORXCIgOyBVbmF2YWlsYWJsZSBcIsOfXCIgOyBVbmF2YWlsYWJsZSBcIsOgXCIgOyBVbmF2YWlsYWJsZSBcIsOhXCIgO1xuICBVbnVzZWQgICAgICAgICAgOyBVbmF2YWlsYWJsZSBcIsOnXCIgOyBVbmF2YWlsYWJsZSBcIsOoXCIgOyBVbmF2YWlsYWJsZSBcIsOpXCIgO1xuICBVbmF2YWlsYWJsZSBcIsOqXCIgOyBVbmF2YWlsYWJsZSBcIsOrXCIgOyBVbmF2YWlsYWJsZSBcIsOsXCIgOyBVbnVzZWQgICAgICAgICAgO1xuICAoKiAweDIuICopXG4gIFVuYXZhaWxhYmxlIFwiw65cIiAgOyBVbmF2YWlsYWJsZSBcIsOvXCIgOyBVbmF2YWlsYWJsZSBcIsOyXCIgOyBVbmF2YWlsYWJsZSBcIsOzXCIgO1xuICBVbmF2YWlsYWJsZSBcIsO0XCIgIDsgVW5hdmFpbGFibGUgXCLFk1wiIDsgVW5hdmFpbGFibGUgXCLDuVwiIDsgVW5hdmFpbGFibGUgXCLDulwiIDtcbiAgVW5hdmFpbGFibGUgXCLDu1wiICA7IFVuYXZhaWxhYmxlIFwiw7FcIiA7IFVuYXZhaWxhYmxlIFwiwrpcIiA7IFVuYXZhaWxhYmxlIFwiwqpcIiA7XG4gIFVuYXZhaWxhYmxlIFwi4bWJyrNcIiA7IFVuYXZhaWxhYmxlIFwiJlwiIDsgVW5hdmFpbGFibGUgXCIrXCIgOyBVbnVzZWQgICAgICAgICAgO1xuICAoKiAweDMuICopXG4gIFVudXNlZCAgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbmF2YWlsYWJsZSBcIkx2XCIgOyBVbmF2YWlsYWJsZSBcIj1cIiA7IFVuYXZhaWxhYmxlIFwiO1wiIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICAoKiAweDQuICopXG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gIFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7IFVudXNlZCAgICAgICAgICA7XG4gICgqIDB4NS4gKilcbiAgVW5hdmFpbGFibGUgXCLilq9cIiAgIDsgVW5hdmFpbGFibGUgXCLCv1wiICAgIDsgVW5hdmFpbGFibGUgXCLCoVwiICA7IFVuYXZhaWxhYmxlIFwiUEtcIiAgIDtcbiAgVW5hdmFpbGFibGUgXCJNTlwiICAgOyBVbmF2YWlsYWJsZSBcIlBPXCIgICA7IFVuYXZhaWxhYmxlIFwiS8OpXCIgOyBVbnJlYWRhYmxlIFwiMHg1N1wiICA7XG4gIFVucmVhZGFibGUgIFwiMHg1OFwiIDsgVW5yZWFkYWJsZSBcIjB4NTlcIiAgOyBVbmF2YWlsYWJsZSBcIsONXCIgIDsgVW5hdmFpbGFibGUgXCIlXCIgICAgO1xuICBVbmF2YWlsYWJsZSBcIihcIiAgICA7IFVuYXZhaWxhYmxlIFwiKVwiICAgIDsgVW51c2VkICAgICAgICAgICA7IFVudXNlZCAgICAgICAgICAgICA7XG4gICgqIDB4Ni4gKilcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW5hdmFpbGFibGUgXCLDolwiIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW5hdmFpbGFibGUgXCLDrVwiIDtcbiAgKCogMHg3LiAqKVxuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgOyBVbmF2YWlsYWJsZSBcIuKshlwiIDsgVW5hdmFpbGFibGUgXCLirIdcIiA7IFVuYXZhaWxhYmxlIFwi4qyFXCIgO1xuICBVbmF2YWlsYWJsZSBcIuKeoVwiIDsgVW5hdmFpbGFibGUgXCIqXCIgOyBVbmF2YWlsYWJsZSBcIipcIiA7IFVuYXZhaWxhYmxlIFwiKlwiIDtcbiAgKCogMHg4LiAqKVxuICBVbmF2YWlsYWJsZSBcIipcIiA7IFVuYXZhaWxhYmxlIFwiKlwiIDsgVW5hdmFpbGFibGUgXCIqXCIgOyBVbmF2YWlsYWJsZSBcIipcIiA7XG4gIFVuYXZhaWxhYmxlIFwi4bWJXCIgOyBVbmF2YWlsYWJsZSBcIjxcIiA7IFVuYXZhaWxhYmxlIFwiPlwiIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDsgVW51c2VkICAgICAgICAgIDtcbiAgKCogMHg5LiAqKVxuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgOyBVbnVzZWQgICAgICAgICAgO1xuICAoKiAweEEuICopXG4gIFVuYXZhaWxhYmxlIFwiyrPhtYlcIiA7IEF2YWlsYWJsZSBcIjBcIiAgIDsgQXZhaWxhYmxlIFwiMVwiIDsgQXZhaWxhYmxlIFwiMlwiICAgIDtcbiAgQXZhaWxhYmxlIFwiM1wiICAgIDsgQXZhaWxhYmxlIFwiNFwiICAgOyBBdmFpbGFibGUgXCI1XCIgOyBBdmFpbGFibGUgXCI2XCIgICAgO1xuICBBdmFpbGFibGUgXCI3XCIgICAgOyBBdmFpbGFibGUgXCI4XCIgICA7IEF2YWlsYWJsZSBcIjlcIiA7IEF2YWlsYWJsZSBcIiFcIiAgICA7XG4gIEF2YWlsYWJsZSBcIj9cIiAgICA7IEF2YWlsYWJsZSBcIi5cIiAgIDsgQXZhaWxhYmxlIFwi4oCTXCIgOyBVbmF2YWlsYWJsZSBcIuODu1wiIDtcbiAgKCogMHhCLiAqKVxuICBBdmFpbGFibGUgXCLigKZcIiAgICA7IEF2YWlsYWJsZSBcIuKAnFwiICAgOyBBdmFpbGFibGUgXCLigJ1cIiA7IEF2YWlsYWJsZSBcIuKAmFwiICAgICA7XG4gIEF2YWlsYWJsZSBcIuKAmVwiICAgIDsgQXZhaWxhYmxlIFwi4pmCXCIgICA7IEF2YWlsYWJsZSBcIuKZgFwiIDsgVW5hdmFpbGFibGUgXCJQayRcIiA7XG4gIEF2YWlsYWJsZSBcIixcIiAgICA7IFVuYXZhaWxhYmxlIFwiw5dcIiA7IEF2YWlsYWJsZSBcIi9cIiA7IEF2YWlsYWJsZSBcIkFcIiAgICAgO1xuICBBdmFpbGFibGUgXCJCXCIgICAgOyBBdmFpbGFibGUgXCJDXCIgICA7IEF2YWlsYWJsZSBcIkRcIiA7IEF2YWlsYWJsZSBcIkVcIiAgICAgO1xuICAoKiAweEMuICopXG4gIEF2YWlsYWJsZSBcIkZcIiAgICA7IEF2YWlsYWJsZSBcIkdcIiAgIDsgQXZhaWxhYmxlIFwiSFwiIDsgQXZhaWxhYmxlIFwiSVwiICAgICA7XG4gIEF2YWlsYWJsZSBcIkpcIiAgICA7IEF2YWlsYWJsZSBcIktcIiAgIDsgQXZhaWxhYmxlIFwiTFwiIDsgQXZhaWxhYmxlIFwiTVwiICAgICA7XG4gIEF2YWlsYWJsZSBcIk5cIiAgICA7IEF2YWlsYWJsZSBcIk9cIiAgIDsgQXZhaWxhYmxlIFwiUFwiIDsgQXZhaWxhYmxlIFwiUVwiICAgICA7XG4gIEF2YWlsYWJsZSBcIlJcIiAgICA7IEF2YWlsYWJsZSBcIlNcIiAgIDsgQXZhaWxhYmxlIFwiVFwiIDsgQXZhaWxhYmxlIFwiVVwiICAgICA7XG4gICgqIDB4RC4gKilcbiAgQXZhaWxhYmxlIFwiVlwiICAgIDsgQXZhaWxhYmxlIFwiV1wiICAgOyBBdmFpbGFibGUgXCJYXCIgOyBBdmFpbGFibGUgXCJZXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiWlwiICAgIDsgQXZhaWxhYmxlIFwiYVwiICAgOyBBdmFpbGFibGUgXCJiXCIgOyBBdmFpbGFibGUgXCJjXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiZFwiICAgIDsgQXZhaWxhYmxlIFwiZVwiICAgOyBBdmFpbGFibGUgXCJmXCIgOyBBdmFpbGFibGUgXCJnXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiaFwiICAgIDsgQXZhaWxhYmxlIFwiaVwiICAgOyBBdmFpbGFibGUgXCJqXCIgOyBBdmFpbGFibGUgXCJrXCIgICAgIDtcbiAgKCogMHhFLiAqKVxuICBBdmFpbGFibGUgXCJsXCIgICAgOyBBdmFpbGFibGUgXCJtXCIgICA7IEF2YWlsYWJsZSBcIm5cIiA7IEF2YWlsYWJsZSBcIm9cIiAgICAgO1xuICBBdmFpbGFibGUgXCJwXCIgICAgOyBBdmFpbGFibGUgXCJxXCIgICA7IEF2YWlsYWJsZSBcInJcIiA7IEF2YWlsYWJsZSBcInNcIiAgICAgO1xuICBBdmFpbGFibGUgXCJ0XCIgICAgOyBBdmFpbGFibGUgXCJ1XCIgICA7IEF2YWlsYWJsZSBcInZcIiA7IEF2YWlsYWJsZSBcIndcIiAgICAgO1xuICBBdmFpbGFibGUgXCJ4XCIgICAgOyBBdmFpbGFibGUgXCJ5XCIgICA7IEF2YWlsYWJsZSBcInpcIiA7IFVuYXZhaWxhYmxlIFwi4pa2XCIgIDtcbiAgKCogMHhGLiAqKVxuICBVbmF2YWlsYWJsZSBcIjpcIiAgIDsgVW5hdmFpbGFibGUgXCLDhFwiICAgOyBVbmF2YWlsYWJsZSBcIsOWXCIgICA7IFVuYXZhaWxhYmxlIFwiw5xcIiAgIDtcbiAgVW5hdmFpbGFibGUgXCLDpFwiICAgOyBVbmF2YWlsYWJsZSBcIsO2XCIgICA7IFVuYXZhaWxhYmxlIFwiw7xcIiAgIDsgVW51c2VkICAgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgICA7IFVudXNlZCAgICAgICAgICAgIDsgVW5yZWFkYWJsZSBcIjB4RkFcIiA7IFVucmVhZGFibGUgXCIweEZCXCIgO1xuICBVbnJlYWRhYmxlIFwiMHhGQ1wiIDsgVW5yZWFkYWJsZSBcIjB4RkRcIiA7IFVucmVhZGFibGUgXCIweEZFXCIgOyBVbnJlYWRhYmxlIFwiMHhGRlwiIDtcbiAgfF1cblxubGV0IGNoYXJzZXRfaXRhID0gQXJyYXkuY29weSBjaGFyc2V0X2VuZ1xubGV0IGNoYXJzZXRfc3BhID0gQXJyYXkuY29weSBjaGFyc2V0X2VuZ1xubGV0IGNoYXJzZXRfZ2VyID1cbiAgbGV0IGNzID0gQXJyYXkuY29weSBjaGFyc2V0X2VuZyBpblxuICBjcy4oMHhCMSkgPC0gQXZhaWxhYmxlIFwi4oCeXCIgO1xuICBjcy4oMHhCMikgPC0gQXZhaWxhYmxlIFwi4oCcXCIgO1xuICBmb3IgaT0weEYxIHRvIDB4RjYgZG9cbiAgICBjcy4oaSkgPC0gbWF0Y2ggY3MuKGkpIHdpdGhcbiAgICAgIHwgVW5hdmFpbGFibGUgYyAtPiBBdmFpbGFibGUgY1xuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICBkb25lIDtcbiAgY3NcbmxldCBjaGFyc2V0X2ZyYSA9XG4gIGxldCBjcyA9IEFycmF5LmNvcHkgY2hhcnNldF9lbmcgaW5cbiAgY3MuKDB4QjEpIDwtIEF2YWlsYWJsZSBcIsKrXCIgO1xuICBjcy4oMHhCMikgPC0gQXZhaWxhYmxlIFwiwrtcIiA7XG4gIGNzXG5cbmxldCBjaGFyc2V0X2phcCA9XG4gIFt8XG4gICgqIDB4MC4gKilcbiAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIuOBglwiIDsgQXZhaWxhYmxlIFwi44GEXCIgOyBBdmFpbGFibGUgXCLjgYZcIiA7XG4gIEF2YWlsYWJsZSBcIuOBiFwiIDsgQXZhaWxhYmxlIFwi44GKXCIgOyBBdmFpbGFibGUgXCLjgYtcIiA7IEF2YWlsYWJsZSBcIuOBjVwiIDtcbiAgQXZhaWxhYmxlIFwi44GPXCIgOyBBdmFpbGFibGUgXCLjgZFcIiA7IEF2YWlsYWJsZSBcIuOBk1wiIDsgQXZhaWxhYmxlIFwi44GVXCIgO1xuICBBdmFpbGFibGUgXCLjgZdcIiA7IEF2YWlsYWJsZSBcIuOBmVwiIDsgQXZhaWxhYmxlIFwi44GbXCIgOyBBdmFpbGFibGUgXCLjgZ1cIiA7XG4gICgqIDB4MS4gKilcbiAgQXZhaWxhYmxlIFwi44GfXCIgOyBBdmFpbGFibGUgXCLjgaFcIiA7IEF2YWlsYWJsZSBcIuOBpFwiIDsgQXZhaWxhYmxlIFwi44GmXCIgO1xuICBBdmFpbGFibGUgXCLjgahcIiA7IEF2YWlsYWJsZSBcIuOBqlwiIDsgQXZhaWxhYmxlIFwi44GrXCIgOyBBdmFpbGFibGUgXCLjgaxcIiA7XG4gIEF2YWlsYWJsZSBcIuOBrVwiIDsgQXZhaWxhYmxlIFwi44GuXCIgOyBBdmFpbGFibGUgXCLjga9cIiA7IEF2YWlsYWJsZSBcIuOBslwiIDtcbiAgQXZhaWxhYmxlIFwi44G1XCIgOyBBdmFpbGFibGUgXCLjgbhcIiA7IEF2YWlsYWJsZSBcIuOBu1wiIDsgQXZhaWxhYmxlIFwi44G+XCIgO1xuICAoKiAweDIuICopXG4gIEF2YWlsYWJsZSBcIuOBv1wiIDsgQXZhaWxhYmxlIFwi44KAXCIgOyBBdmFpbGFibGUgXCLjgoFcIiA7IEF2YWlsYWJsZSBcIuOCglwiIDtcbiAgQXZhaWxhYmxlIFwi44KEXCIgOyBBdmFpbGFibGUgXCLjgoZcIiA7IEF2YWlsYWJsZSBcIuOCiFwiIDsgQXZhaWxhYmxlIFwi44KJXCIgO1xuICBBdmFpbGFibGUgXCLjgopcIiA7IEF2YWlsYWJsZSBcIuOCi1wiIDsgQXZhaWxhYmxlIFwi44KMXCIgOyBBdmFpbGFibGUgXCLjgo1cIiA7XG4gIEF2YWlsYWJsZSBcIuOCj1wiIDsgQXZhaWxhYmxlIFwi44KSXCIgOyBBdmFpbGFibGUgXCLjgpNcIiA7IEF2YWlsYWJsZSBcIuOBgVwiIDtcbiAgKCogMHgzLiAqKVxuICBBdmFpbGFibGUgXCLjgYNcIiA7IEF2YWlsYWJsZSBcIuOBhVwiIDsgQXZhaWxhYmxlIFwi44GHXCIgOyBBdmFpbGFibGUgXCLjgYlcIiA7XG4gIEF2YWlsYWJsZSBcIuOCg1wiIDsgQXZhaWxhYmxlIFwi44KFXCIgOyBBdmFpbGFibGUgXCLjgodcIiA7IEF2YWlsYWJsZSBcIuOBjFwiIDtcbiAgQXZhaWxhYmxlIFwi44GOXCIgOyBBdmFpbGFibGUgXCLjgZBcIiA7IEF2YWlsYWJsZSBcIuOBklwiIDsgQXZhaWxhYmxlIFwi44GUXCIgO1xuICBBdmFpbGFibGUgXCLjgZZcIiA7IEF2YWlsYWJsZSBcIuOBmFwiIDsgQXZhaWxhYmxlIFwi44GaXCIgOyBBdmFpbGFibGUgXCLjgZxcIiA7XG4gICgqIDB4NC4gKilcbiAgQXZhaWxhYmxlIFwi44GeXCIgOyBBdmFpbGFibGUgXCLjgaBcIiA7IEF2YWlsYWJsZSBcIuOBolwiIDsgQXZhaWxhYmxlIFwi44GlXCIgO1xuICBBdmFpbGFibGUgXCLjgadcIiA7IEF2YWlsYWJsZSBcIuOBqVwiIDsgQXZhaWxhYmxlIFwi44GwXCIgOyBBdmFpbGFibGUgXCLjgbNcIiA7XG4gIEF2YWlsYWJsZSBcIuOBtlwiIDsgQXZhaWxhYmxlIFwi44G5XCIgOyBBdmFpbGFibGUgXCLjgbxcIiA7IEF2YWlsYWJsZSBcIuOBsVwiIDtcbiAgQXZhaWxhYmxlIFwi44G0XCIgOyBBdmFpbGFibGUgXCLjgbdcIiA7IEF2YWlsYWJsZSBcIuOBulwiIDsgQXZhaWxhYmxlIFwi44G9XCIgO1xuICAoKiAweDUuICopXG4gIEF2YWlsYWJsZSBcIuOBo1wiIDsgQXZhaWxhYmxlIFwi44KiXCIgOyBBdmFpbGFibGUgXCLjgqRcIiA7IEF2YWlsYWJsZSBcIuOCplwiIDtcbiAgQXZhaWxhYmxlIFwi44KoXCIgOyBBdmFpbGFibGUgXCLjgqpcIiA7IEF2YWlsYWJsZSBcIuOCq1wiIDsgQXZhaWxhYmxlIFwi44KtXCIgO1xuICBBdmFpbGFibGUgXCLjgq9cIiA7IEF2YWlsYWJsZSBcIuOCsVwiIDsgQXZhaWxhYmxlIFwi44KzXCIgOyBBdmFpbGFibGUgXCLjgrVcIiA7XG4gIEF2YWlsYWJsZSBcIuOCt1wiIDsgQXZhaWxhYmxlIFwi44K5XCIgOyBBdmFpbGFibGUgXCLjgrtcIiA7IEF2YWlsYWJsZSBcIuOCvVwiIDtcbiAgKCogMHg2LiAqKVxuICBBdmFpbGFibGUgXCLjgr9cIiA7IEF2YWlsYWJsZSBcIuODgVwiIDsgQXZhaWxhYmxlIFwi44OEXCIgOyBBdmFpbGFibGUgXCLjg4ZcIiA7XG4gIEF2YWlsYWJsZSBcIuODiFwiIDsgQXZhaWxhYmxlIFwi44OKXCIgOyBBdmFpbGFibGUgXCLjg4tcIiA7IEF2YWlsYWJsZSBcIuODjFwiIDtcbiAgQXZhaWxhYmxlIFwi44ONXCIgOyBBdmFpbGFibGUgXCLjg45cIiA7IEF2YWlsYWJsZSBcIuODj1wiIDsgQXZhaWxhYmxlIFwi44OSXCIgO1xuICBBdmFpbGFibGUgXCLjg5VcIiA7IEF2YWlsYWJsZSBcIuODmFwiIDsgQXZhaWxhYmxlIFwi44ObXCIgOyBBdmFpbGFibGUgXCLjg55cIiA7XG4gICgqIDB4Ny4gKilcbiAgQXZhaWxhYmxlIFwi44OfXCIgOyBBdmFpbGFibGUgXCLjg6BcIiA7IEF2YWlsYWJsZSBcIuODoVwiIDsgQXZhaWxhYmxlIFwi44OiXCIgO1xuICBBdmFpbGFibGUgXCLjg6RcIiA7IEF2YWlsYWJsZSBcIuODplwiIDsgQXZhaWxhYmxlIFwi44OoXCIgOyBBdmFpbGFibGUgXCLjg6lcIiA7XG4gIEF2YWlsYWJsZSBcIuODqlwiIDsgQXZhaWxhYmxlIFwi44OrXCIgOyBBdmFpbGFibGUgXCLjg6xcIiA7IEF2YWlsYWJsZSBcIuODrVwiIDtcbiAgQXZhaWxhYmxlIFwi44OvXCIgOyBBdmFpbGFibGUgXCLjg7JcIiA7IEF2YWlsYWJsZSBcIuODs1wiIDsgQXZhaWxhYmxlIFwi44KhXCIgO1xuICAoKiAweDguICopXG4gIEF2YWlsYWJsZSBcIuOCo1wiIDsgQXZhaWxhYmxlIFwi44KlXCIgOyBBdmFpbGFibGUgXCLjgqdcIiA7IEF2YWlsYWJsZSBcIuOCqVwiIDtcbiAgQXZhaWxhYmxlIFwi44OjXCIgOyBBdmFpbGFibGUgXCLjg6VcIiA7IEF2YWlsYWJsZSBcIuODp1wiIDsgQXZhaWxhYmxlIFwi44KsXCIgO1xuICBBdmFpbGFibGUgXCLjgq5cIiA7IEF2YWlsYWJsZSBcIuOCsFwiIDsgQXZhaWxhYmxlIFwi44KyXCIgOyBBdmFpbGFibGUgXCLjgrRcIiA7XG4gIEF2YWlsYWJsZSBcIuOCtlwiIDsgQXZhaWxhYmxlIFwi44K4XCIgOyBBdmFpbGFibGUgXCLjgrpcIiA7IEF2YWlsYWJsZSBcIuOCvFwiIDtcbiAgKCogMHg5LiAqKVxuICBBdmFpbGFibGUgXCLjgr5cIiA7IEF2YWlsYWJsZSBcIuODgFwiIDsgQXZhaWxhYmxlIFwi44OCXCIgOyBBdmFpbGFibGUgXCLjg4VcIiA7XG4gIEF2YWlsYWJsZSBcIuODh1wiIDsgQXZhaWxhYmxlIFwi44OJXCIgOyBBdmFpbGFibGUgXCLjg5BcIiA7IEF2YWlsYWJsZSBcIuODk1wiIDtcbiAgQXZhaWxhYmxlIFwi44OWXCIgOyBBdmFpbGFibGUgXCLjg5lcIiA7IEF2YWlsYWJsZSBcIuODnFwiIDsgQXZhaWxhYmxlIFwi44ORXCIgO1xuICBBdmFpbGFibGUgXCLjg5RcIiA7IEF2YWlsYWJsZSBcIuODl1wiIDsgQXZhaWxhYmxlIFwi44OaXCIgOyBBdmFpbGFibGUgXCLjg51cIiA7XG4gICgqIDB4QS4gKilcbiAgQXZhaWxhYmxlIFwi44ODXCIgICA7IEF2YWlsYWJsZSBcIjBcIiAgIDsgQXZhaWxhYmxlIFwiMVwiIDsgQXZhaWxhYmxlIFwiMlwiICAgIDtcbiAgQXZhaWxhYmxlIFwiM1wiICAgIDsgQXZhaWxhYmxlIFwiNFwiICAgOyBBdmFpbGFibGUgXCI1XCIgOyBBdmFpbGFibGUgXCI2XCIgICAgO1xuICBBdmFpbGFibGUgXCI3XCIgICAgOyBBdmFpbGFibGUgXCI4XCIgICA7IEF2YWlsYWJsZSBcIjlcIiA7IEF2YWlsYWJsZSBcIu+8gVwiICAgO1xuICBBdmFpbGFibGUgXCLvvJ9cIiAgIDsgQXZhaWxhYmxlIFwi44CCXCIgIDsgQXZhaWxhYmxlIFwi44O8XCI7IEF2YWlsYWJsZSBcIuODu1wiICAgIDtcbiAgKCogMHhCLiAqKVxuICBBdmFpbGFibGUgXCLigKVcIiAgICA7IEF2YWlsYWJsZSBcIuOAjlwiICA7IEF2YWlsYWJsZSBcIuOAj1wiOyBBdmFpbGFibGUgXCLjgIxcIiAgICA7XG4gIEF2YWlsYWJsZSBcIuOAjVwiICAgOyBBdmFpbGFibGUgXCLimYJcIiAgIDsgQXZhaWxhYmxlIFwi4pmAXCIgOyBVbmF2YWlsYWJsZSBcIuWGhlwiICA7XG4gIFVuYXZhaWxhYmxlIFwiLlwiICA7IFVuYXZhaWxhYmxlIFwiw5dcIiA7IEF2YWlsYWJsZSBcIi9cIiA7IEF2YWlsYWJsZSBcIkFcIiAgICAgO1xuICBBdmFpbGFibGUgXCJCXCIgICAgOyBBdmFpbGFibGUgXCJDXCIgICA7IEF2YWlsYWJsZSBcIkRcIiA7IEF2YWlsYWJsZSBcIkVcIiAgICAgO1xuICAoKiAweEMuICopXG4gIEF2YWlsYWJsZSBcIkZcIiAgICA7IEF2YWlsYWJsZSBcIkdcIiAgIDsgQXZhaWxhYmxlIFwiSFwiIDsgQXZhaWxhYmxlIFwiSVwiICAgICA7XG4gIEF2YWlsYWJsZSBcIkpcIiAgICA7IEF2YWlsYWJsZSBcIktcIiAgIDsgQXZhaWxhYmxlIFwiTFwiIDsgQXZhaWxhYmxlIFwiTVwiICAgICA7XG4gIEF2YWlsYWJsZSBcIk5cIiAgICA7IEF2YWlsYWJsZSBcIk9cIiAgIDsgQXZhaWxhYmxlIFwiUFwiIDsgQXZhaWxhYmxlIFwiUVwiICAgICA7XG4gIEF2YWlsYWJsZSBcIlJcIiAgICA7IEF2YWlsYWJsZSBcIlNcIiAgIDsgQXZhaWxhYmxlIFwiVFwiIDsgQXZhaWxhYmxlIFwiVVwiICAgICA7XG4gICgqIDB4RC4gKilcbiAgQXZhaWxhYmxlIFwiVlwiICAgIDsgQXZhaWxhYmxlIFwiV1wiICAgOyBBdmFpbGFibGUgXCJYXCIgOyBBdmFpbGFibGUgXCJZXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiWlwiICAgIDsgQXZhaWxhYmxlIFwiYVwiICAgOyBBdmFpbGFibGUgXCJiXCIgOyBBdmFpbGFibGUgXCJjXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiZFwiICAgIDsgQXZhaWxhYmxlIFwiZVwiICAgOyBBdmFpbGFibGUgXCJmXCIgOyBBdmFpbGFibGUgXCJnXCIgICAgIDtcbiAgQXZhaWxhYmxlIFwiaFwiICAgIDsgQXZhaWxhYmxlIFwiaVwiICAgOyBBdmFpbGFibGUgXCJqXCIgOyBBdmFpbGFibGUgXCJrXCIgICAgIDtcbiAgKCogMHhFLiAqKVxuICBBdmFpbGFibGUgXCJsXCIgICAgOyBBdmFpbGFibGUgXCJtXCIgICA7IEF2YWlsYWJsZSBcIm5cIiA7IEF2YWlsYWJsZSBcIm9cIiAgICAgO1xuICBBdmFpbGFibGUgXCJwXCIgICAgOyBBdmFpbGFibGUgXCJxXCIgICA7IEF2YWlsYWJsZSBcInJcIiA7IEF2YWlsYWJsZSBcInNcIiAgICAgO1xuICBBdmFpbGFibGUgXCJ0XCIgICAgOyBBdmFpbGFibGUgXCJ1XCIgICA7IEF2YWlsYWJsZSBcInZcIiA7IEF2YWlsYWJsZSBcIndcIiAgICAgO1xuICBBdmFpbGFibGUgXCJ4XCIgICAgOyBBdmFpbGFibGUgXCJ5XCIgICA7IEF2YWlsYWJsZSBcInpcIiA7IFVuYXZhaWxhYmxlIFwi4pa2XCIgIDtcbiAgKCogMHhGLiAqKVxuICBVbmF2YWlsYWJsZSBcIjpcIiAgIDsgVW5hdmFpbGFibGUgXCLDhFwiICAgOyBVbmF2YWlsYWJsZSBcIsOWXCIgICA7IFVuYXZhaWxhYmxlIFwiw5xcIiAgIDtcbiAgVW5hdmFpbGFibGUgXCLDpFwiICAgOyBVbmF2YWlsYWJsZSBcIsO2XCIgICA7IFVuYXZhaWxhYmxlIFwiw7xcIiAgIDsgVW51c2VkICAgICAgICAgICAgO1xuICBVbnVzZWQgICAgICAgICAgICA7IFVudXNlZCAgICAgICAgICAgIDsgVW5yZWFkYWJsZSBcIjB4RkFcIiA7IFVucmVhZGFibGUgXCIweEZCXCIgO1xuICBVbnJlYWRhYmxlIFwiMHhGQ1wiIDsgVW5yZWFkYWJsZSBcIjB4RkRcIiA7IFVucmVhZGFibGUgXCIweEZFXCIgOyBVbnJlYWRhYmxlIFwiMHhGRlwiIDtcbiAgfF1cblxuICBsZXQgY2hhcnNldF9mdWxsID1cbiAgICBbfFxuICAgICgqIDB4MC4gKilcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICAoKiAweDEuICopXG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgKCogMHgyLiAqKVxuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgICgqIDB4My4gKilcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICAoKiAweDQuICopXG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgKCogMHg1LiAqKVxuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgICgqIDB4Ni4gKilcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICAoKiAweDcuICopXG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgKCogMHg4LiAqKVxuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgICgqIDB4OS4gKilcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICAoKiAweEEuICopXG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIjBcIiAgIDsgQXZhaWxhYmxlIFwiMVwiIDsgQXZhaWxhYmxlIFwiMlwiICA7XG4gICAgQXZhaWxhYmxlIFwiM1wiICA7IEF2YWlsYWJsZSBcIjRcIiAgIDsgQXZhaWxhYmxlIFwiNVwiIDsgQXZhaWxhYmxlIFwiNlwiICA7XG4gICAgQXZhaWxhYmxlIFwiN1wiICA7IEF2YWlsYWJsZSBcIjhcIiAgIDsgQXZhaWxhYmxlIFwiOVwiIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgKCogMHhCLiAqKVxuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIkFcIiAgO1xuICAgIEF2YWlsYWJsZSBcIkJcIiAgOyBBdmFpbGFibGUgXCJDXCIgIDsgQXZhaWxhYmxlIFwiRFwiICA7IEF2YWlsYWJsZSBcIkVcIiAgO1xuICAgICgqIDB4Qy4gKilcbiAgICBBdmFpbGFibGUgXCJGXCIgIDsgQXZhaWxhYmxlIFwiR1wiICA7IEF2YWlsYWJsZSBcIkhcIiAgOyBBdmFpbGFibGUgXCJJXCIgIDtcbiAgICBBdmFpbGFibGUgXCJKXCIgIDsgQXZhaWxhYmxlIFwiS1wiICA7IEF2YWlsYWJsZSBcIkxcIiAgOyBBdmFpbGFibGUgXCJNXCIgIDtcbiAgICBBdmFpbGFibGUgXCJOXCIgIDsgQXZhaWxhYmxlIFwiT1wiICA7IEF2YWlsYWJsZSBcIlBcIiAgOyBBdmFpbGFibGUgXCJRXCIgIDtcbiAgICBBdmFpbGFibGUgXCJSXCIgIDsgQXZhaWxhYmxlIFwiU1wiICA7IEF2YWlsYWJsZSBcIlRcIiAgOyBBdmFpbGFibGUgXCJVXCIgIDtcbiAgICAoKiAweEQuICopXG4gICAgQXZhaWxhYmxlIFwiVlwiICA7IEF2YWlsYWJsZSBcIldcIiAgOyBBdmFpbGFibGUgXCJYXCIgIDsgQXZhaWxhYmxlIFwiWVwiICA7XG4gICAgQXZhaWxhYmxlIFwiWlwiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7XG4gICAgKCogMHhFLiAqKVxuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgIEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgO1xuICAgICgqIDB4Ri4gKilcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICBBdmFpbGFibGUgXCJfXCIgIDsgQXZhaWxhYmxlIFwiX1wiICA7IEF2YWlsYWJsZSBcIl9cIiAgOyBBdmFpbGFibGUgXCJfXCIgIDtcbiAgICB8XVxuXG5sZXQgY2hhcnNldCAoKSA9XG4gIG1hdGNoICFTZXR0aW5ncy5sYW5nIHdpdGhcbiAgfCBFTkcgLT4gY2hhcnNldF9lbmdcbiAgfCBGUkEgLT4gY2hhcnNldF9mcmFcbiAgfCBJVEEgLT4gY2hhcnNldF9pdGFcbiAgfCBTUEEgLT4gY2hhcnNldF9zcGFcbiAgfCBHRVIgLT4gY2hhcnNldF9nZXJcbiAgfCBKQVAgLT4gY2hhcnNldF9qYXBcbiAgfCBBQkMgLT4gY2hhcnNldF9mdWxsXG5cbmxldCBpc19jb2RlX2F2YWlsYWJsZSBjb2RlID1cbiAgbWF0Y2ggKGNoYXJzZXQgKCkpLihjb2RlKSB3aXRoXG4gIHwgQXZhaWxhYmxlIF8gLT4gdHJ1ZVxuICB8IFVuYXZhaWxhYmxlIF8gfCBVbnJlYWRhYmxlIF8gfCBVbnVzZWQgLT4gZmFsc2VcblxubGV0IGlzX2NvZGVfcmVhZGFibGUgY29kZSA9XG4gIG1hdGNoIChjaGFyc2V0ICgpKS4oY29kZSkgd2l0aFxuICB8IEF2YWlsYWJsZSBfIHwgVW5hdmFpbGFibGUgXyAtPiB0cnVlXG4gIHwgVW5yZWFkYWJsZSBfIHwgVW51c2VkIC0+IGZhbHNlXG5cbmxldCBpc19jb2RlX3VzZWQgY29kZSA9XG4gIG1hdGNoIChjaGFyc2V0ICgpKS4oY29kZSkgd2l0aFxuICB8IEF2YWlsYWJsZSBfIHwgVW5hdmFpbGFibGUgXyB8IFVucmVhZGFibGUgXyAtPiB0cnVlXG4gIHwgVW51c2VkIC0+IGZhbHNlXG5cbmxldCBzcGFjaW5nX2NoYXIgPSBcIl9cIlxubGV0IGludmFsaWRfY2hhciA9IFwi4pyWXCJcblxubGV0IGNoYXJfYXQgY29kZSA9XG4gIG1hdGNoIChjaGFyc2V0ICgpKS4oY29kZSkgd2l0aFxuICB8IEF2YWlsYWJsZSBzdHIgfCBVbmF2YWlsYWJsZSBzdHIgfCBVbnJlYWRhYmxlIHN0ciAtPiBzdHJcbiAgfCBVbnVzZWQgLT4gaW52YWxpZF9jaGFyXG5cbmxldCByZWFkYWJsZV9jaGFyX2F0IGNvZGUgPVxuICBtYXRjaCAoY2hhcnNldCAoKSkuKGNvZGUpIHdpdGhcbiAgfCBBdmFpbGFibGUgc3RyIHwgVW5hdmFpbGFibGUgc3RyIC0+IHN0clxuICB8IFVucmVhZGFibGUgXyB8IFVudXNlZCAtPiBpbnZhbGlkX2NoYXJcblxubGV0IHdyaXRhYmxlX2NoYXJfYXQgY29kZSA9XG4gIG1hdGNoIChjaGFyc2V0ICgpKS4oY29kZSkgd2l0aFxuICB8IEF2YWlsYWJsZSBzdHIgLT4gc3RyXG4gIHwgVW5hdmFpbGFibGUgXyB8IFVucmVhZGFibGUgXyB8IFVudXNlZCAtPiBpbnZhbGlkX2NoYXJcblxubGV0IGFsbF93cml0YWJsZV9jaGFycyA9XG4gIGxldCByZWMgYXV4IGFjYyBpID1cbiAgICBpZiBpIDwgMCB0aGVuIGFjY1xuICAgIGVsc2VcbiAgICAgIG1hdGNoIChjaGFyc2V0ICgpKS4oaSkgd2l0aFxuICAgICAgfCBBdmFpbGFibGUgc3RyIC0+IGF1eCAoc3RyOjphY2MpIChpLTEpXG4gICAgICB8IFVuYXZhaWxhYmxlIF8gfCBVbnJlYWRhYmxlIF8gfCBVbnVzZWQgLT4gYXV4IGFjYyAoaS0xKVxuICBpblxuICBhdXggW10gMHhGRlxuXG5sZXQgZW5jb2RlX3dyaXRhYmxlX2NoYXIgc3RyID1cbiAgbGV0IHJlYyBhdXggaSA9XG4gICAgaWYgaSA8IDAgdGhlbiByYWlzZSBOb3RfZm91bmRcbiAgICBlbHNlXG4gICAgICBtYXRjaCAoY2hhcnNldCAoKSkuKGkpIHdpdGhcbiAgICAgIHwgQXZhaWxhYmxlIHN0cicgd2hlbiBTdHJpbmcuZXF1YWwgc3RyIHN0cicgLT4gaVxuICAgICAgfCBBdmFpbGFibGUgXyB8IFVuYXZhaWxhYmxlIF8gfCBVbnJlYWRhYmxlIF8gfCBVbnVzZWQgLT4gYXV4IChpLTEpXG4gIGluXG4gIGF1eCAweEZGXG4iLCJvcGVuIEFybVxuXG50eXBlIHVucHJvY2Vzc2VkX2ludDMyID0gQ29uc3RJbnQzMiBvZiBpbnQzMiB8IE1ldGFFeHByIG9mIFByZXByb2Nlc3MubWV0YV9leHByXG5cbnR5cGUgb2Zmc2V0ID1cbiAgfCBPSW1tZWRpYXRlIG9mIEFybS5zaWduICogdW5wcm9jZXNzZWRfaW50MzJcbiAgfCBPUmVnaXN0ZXIgb2YgQXJtLnNpZ24gKiBzdHJpbmdcblxudHlwZSBhcmdzID1cbiAgfCBSZWdpc3RlciBvZiBzdHJpbmdcbiAgfCBJbW1lZGlhdGUgb2YgdW5wcm9jZXNzZWRfaW50MzJcbiAgfCBPZmZzZXQgb2Ygc3RyaW5nICgqIHJlZ2lzdGVyICopICogb2Zmc2V0ICogQXJtLmFkZHJlc3NpbmdfdHlwZVxuXG50eXBlIGNvbW1hbmQgPVxuICB8IEFTTSBvZiBMZXhpbmcucG9zaXRpb24gKiBzdHJpbmcgKiBhcmdzIGxpc3QgKiBPcHRpbWl6ZXIudHdlYWtpbmdfc2V0dGluZ3NcbiAgfCBCSU4gb2YgTGV4aW5nLnBvc2l0aW9uICogdW5wcm9jZXNzZWRfaW50MzJcblxudHlwZSBhc3QgPSBjb21tYW5kIGxpc3RcblxuZXhjZXB0aW9uIENvbW1hbmRFcnJvciBvZiBMZXhpbmcucG9zaXRpb25cblxuZXhjZXB0aW9uIFN0cnVjdEVycm9yXG5cbmxldCBwcmVwcm9jZXNzIGVudiB1aSA9XG4gIG1hdGNoIHVpIHdpdGhcbiAgfCBDb25zdEludDMyIGkgLT4gaVxuICB8IE1ldGFFeHByIGUgLT4gUHJlcHJvY2Vzcy5ldmFsX21ldGFfZXhwciBlbnYgZVxuXG5sZXQgcmVjb2duaXplX2NvbmRpdGlvbiBzdHIgaSA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHN0ciA9IFN0cmluZy5zdWIgc3RyIGkgKG1pbiAyIChuLWkpKSBpblxuICBtYXRjaCBzdHIgd2l0aFxuICB8IFwiRVFcIiAtPiAoU29tZSBFUSwgaSsyKVxuICB8IFwiTkVcIiAtPiAoU29tZSBORSwgaSsyKVxuICB8IFwiQ1NcIiAtPiAoU29tZSBDUywgaSsyKVxuICB8IFwiSFNcIiAtPiAoU29tZSBIUywgaSsyKVxuICB8IFwiQ0NcIiAtPiAoU29tZSBDQywgaSsyKVxuICB8IFwiTE9cIiAtPiAoU29tZSBMTywgaSsyKVxuICB8IFwiTUlcIiAtPiAoU29tZSBNSSwgaSsyKVxuICB8IFwiUExcIiAtPiAoU29tZSBQTCwgaSsyKVxuICB8IFwiVlNcIiAtPiAoU29tZSBWUywgaSsyKVxuICB8IFwiVkNcIiAtPiAoU29tZSBWQywgaSsyKVxuICB8IFwiSElcIiAtPiAoU29tZSBISSwgaSsyKVxuICB8IFwiTFNcIiAtPiAoU29tZSBMUywgaSsyKVxuICB8IFwiR0VcIiAtPiAoU29tZSBHRSwgaSsyKVxuICB8IFwiTFRcIiAtPiAoU29tZSBMVCwgaSsyKVxuICB8IFwiR1RcIiAtPiAoU29tZSBHVCwgaSsyKVxuICB8IFwiTEVcIiAtPiAoU29tZSBMRSwgaSsyKVxuICB8IFwiQUxcIiAtPiAoU29tZSBBTCwgaSsyKVxuICB8IF8gLT4gKE5vbmUsIGkpXG5cbmxldCByZWNvZ25pemVfbGRyX3N0cl90eXBlIHN0ciBpID1cbiAgbGV0IG4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgc3RyID0gU3RyaW5nLnN1YiBzdHIgaSAobWluIDIgKG4taSkpIGluXG4gIG1hdGNoIHN0ciB3aXRoXG4gIHwgXCJTQlwiIC0+IChTb21lIFNCLCBpKzIpXG4gIHwgXCJTSFwiIC0+IChTb21lIFNILCBpKzIpXG4gIHwgXCJCVFwiIC0+IChTb21lIEJULCBpKzIpXG4gIHwgXyAtPlxuICBiZWdpblxuICAgIGxldCBzdHIgPSBTdHJpbmcuc3ViIHN0ciAwIChtaW4gMSAobi1pKSkgaW5cbiAgICBtYXRjaCBzdHIgd2l0aFxuICAgIHwgXCJCXCIgLT4gKFNvbWUgQiwgaSsxKVxuICAgIHwgXCJIXCIgLT4gKFNvbWUgSCwgaSsxKVxuICAgIHwgXCJXXCIgLT4gKFNvbWUgVywgaSsxKVxuICAgIHwgXCJUXCIgLT4gKFNvbWUgVCwgaSsxKVxuICAgIHwgXyAtPiAoTm9uZSwgaSlcbiAgZW5kXG5cbmxldCByZWNvZ25pemVfMSBzdHIgaSA9XG4gIGxldCBuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHN0ciA9IFN0cmluZy5zdWIgc3RyIGkgKG1pbiAxIChuLWkpKSBpblxuICBtYXRjaCBzdHIgd2l0aFxuICB8IFwiU1wiIC0+IChTb21lIFwiU1wiLCBpKzEpXG4gIHwgXCJMXCIgLT4gKFNvbWUgXCJMXCIsIGkrMSlcbiAgfCBcIlhcIiAtPiAoU29tZSBcIlhcIiwgaSsxKVxuICB8IF8gLT4gKE5vbmUsIGkpXG5cbmxldCBjb21iaW5lX29wdCBvMSBvMiA9XG4gIG1hdGNoIG8xLCBvMiB3aXRoXG4gIHwgTm9uZSwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBzLCBOb25lIHwgTm9uZSwgU29tZSBzIC0+IFNvbWUgc1xuICB8IFNvbWUgXywgU29tZSBfIC0+IHJhaXNlIFN0cnVjdEVycm9yXG5cbmxldCBjb21iaW5lX2Jvb2wgYjEgYjIgPVxuICBtYXRjaCBiMSwgYjIgd2l0aFxuICB8IGZhbHNlLCBmYWxzZSAtPiBmYWxzZVxuICB8IHRydWUsIGZhbHNlIHwgZmFsc2UsIHRydWUgLT4gdHJ1ZVxuICB8IHRydWUsIHRydWUgLT4gcmFpc2UgU3RydWN0RXJyb3JcblxubGV0IGNvbWJpbmVfbW9kaWZpZXJzIChjb25kLCBsc3QsIHMsIGwsIHgpIChjb25kJywgbHN0JywgcycsIGwnLCB4JykgPVxuICBsZXQgY29uZCA9IGNvbWJpbmVfb3B0IGNvbmQgY29uZCcgaW5cbiAgbGV0IGxzdCA9IGNvbWJpbmVfb3B0IGxzdCBsc3QnIGluXG4gIGxldCBzID0gY29tYmluZV9ib29sIHMgcycgaW5cbiAgbGV0IGwgPSBjb21iaW5lX2Jvb2wgbCBsJyBpblxuICBsZXQgeCA9IGNvbWJpbmVfYm9vbCB4IHgnIGluXG4gIChjb25kLCBsc3QsIHMsIGwsIHgpXG5cbmxldCByZWNvZ25pemVfbW9kaWZpZXJzIHN0ciBpID1cbiAgbGV0IG4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVjIGF1eCBtb2RzIGkgPVxuICAgIGlmIGkgPj0gbiB0aGVuIG1vZHNcbiAgICBlbHNlXG4gICAgICBsZXQgKG5tb2RzLCBpKSA9XG4gICAgICAgIG1hdGNoIHJlY29nbml6ZV9jb25kaXRpb24gc3RyIGkgd2l0aFxuICAgICAgICB8IChTb21lIGMsIGkpIC0+ICgoU29tZSBjLCBOb25lLCBmYWxzZSwgZmFsc2UsIGZhbHNlKSwgaSlcbiAgICAgICAgfCAoTm9uZSwgaSkgLT5cbiAgICAgICAgICBtYXRjaCByZWNvZ25pemVfbGRyX3N0cl90eXBlIHN0ciBpIHdpdGhcbiAgICAgICAgICB8IChTb21lIGxzdCwgaSkgLT4gKChOb25lLCBTb21lIGxzdCwgZmFsc2UsIGZhbHNlLCBmYWxzZSksIGkpXG4gICAgICAgICAgfCAoTm9uZSwgaSkgLT5cbiAgICAgICAgICAgIG1hdGNoIHJlY29nbml6ZV8xIHN0ciBpIHdpdGhcbiAgICAgICAgICAgIHwgKFNvbWUgXCJTXCIsIGkpIC0+ICgoTm9uZSwgTm9uZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlKSwgaSlcbiAgICAgICAgICAgIHwgKFNvbWUgXCJMXCIsIGkpIC0+ICgoTm9uZSwgTm9uZSwgZmFsc2UsIHRydWUsIGZhbHNlKSwgaSlcbiAgICAgICAgICAgIHwgKFNvbWUgXCJYXCIsIGkpIC0+ICgoTm9uZSwgTm9uZSwgZmFsc2UsIGZhbHNlLCB0cnVlKSwgaSlcbiAgICAgICAgICAgIHwgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuICAgICAgaW5cbiAgICAgIGxldCBtb2RzID0gY29tYmluZV9tb2RpZmllcnMgbW9kcyBubW9kcyBpblxuICAgICAgYXV4IG1vZHMgaVxuICBpblxuICBhdXggKE5vbmUsIE5vbmUsIGZhbHNlLCBmYWxzZSwgZmFsc2UpIGlcblxubGV0IHJlZ2lzdGVyX29mX3N0ciBzdHIgPVxuICBsZXQgc3RyID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzdHIgaW5cbiAgbWF0Y2ggc3RyIHdpdGhcbiAgfCBcInIwXCIgLT4gMCAgIHwgXCJyMVwiIC0+IDEgICB8IFwicjJcIiAtPiAyICAgfCBcInIzXCIgLT4gMyAgIHwgXCJyNFwiIC0+IDRcbiAgfCBcInI1XCIgLT4gNSAgIHwgXCJyNlwiIC0+IDYgICB8IFwicjdcIiAtPiA3ICAgfCBcInI4XCIgLT4gOCAgIHwgXCJyOVwiIC0+IDkgXG4gIHwgXCJyMTBcIiAtPiAxMCB8IFwicjExXCIgLT4gMTEgfCBcInIxMlwiIC0+IDEyIHwgXCJyMTNcIiAtPiAxMyB8IFwicjE0XCIgLT4gMTQgXG4gIHwgXCJyMTVcIiAtPiAxNSB8IFwic2JcIiAtPiBzYiAgfCBcInNsXCIgLT4gc2wgIHwgXCJmcFwiIC0+IGZwICB8IFwiaXBcIiAtPiBpcFxuICB8IFwic3BcIiAtPiBzcCAgfCBcImxyXCIgLT4gbHIgIHwgXCJwY1wiIC0+IHBjICB8IF8gLT4gcmFpc2UgU3RydWN0RXJyb3JcblxubGV0IGdldF9yZWdpc3RlciBhcmcgPVxuICBtYXRjaCBhcmcgd2l0aFxuICB8IFJlZ2lzdGVyIHN0ciAtPiByZWdpc3Rlcl9vZl9zdHIgc3RyXG4gIHwgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuXG5sZXQgZ2V0X3JkIGFyZ3MgPSBnZXRfcmVnaXN0ZXIgKExpc3QuaGQgYXJncylcblxubGV0IGdldF9ybiBhcmdzID1cbiAgbGV0IG4gPSBMaXN0Lmxlbmd0aCBhcmdzIGluXG4gIGdldF9yZWdpc3RlciAoTGlzdC5udGggYXJncyAobi0yKSlcblxubGV0IGdldF9ybSA9IGdldF9yZFxuXG5sZXQgZ2V0X2ltbWVkaWF0ZSBlbnYgYXJnID1cbiAgbWF0Y2ggYXJnIHdpdGhcbiAgfCBJbW1lZGlhdGUgaSAtPiBwcmVwcm9jZXNzIGVudiBpXG4gIHwgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuXG5sZXQgZ2V0X29wZXJhbmQgZW52IGFyZyA9XG4gIG1hdGNoIGFyZyB3aXRoXG4gIHwgSW1tZWRpYXRlIGkgLT4gQXJtLkltbWVkaWF0ZSAocHJlcHJvY2VzcyBlbnYgaSlcbiAgfCBSZWdpc3RlciBzdHIgLT4gQXJtLlJlZ2lzdGVyIChyZWdpc3Rlcl9vZl9zdHIgc3RyKVxuICB8IF8gLT4gcmFpc2UgU3RydWN0RXJyb3JcblxubGV0IGdldF9vcDIgZW52IGFyZ3MgPVxuICBsZXQgbiA9IExpc3QubGVuZ3RoIGFyZ3MgaW5cbiAgZ2V0X29wZXJhbmQgZW52IChMaXN0Lm50aCBhcmdzIChuLTEpKVxuXG5sZXQgZ2V0X3JzID0gZ2V0X29wMlxuXG5sZXQgZ2V0X3JvIGVudiBhcmdzID1cbiAgbGV0IG4gPSBMaXN0Lmxlbmd0aCBhcmdzIGluXG4gIG1hdGNoIExpc3QubnRoIGFyZ3MgKG4tMSkgd2l0aFxuICB8IE9mZnNldCAoc3RyLCBvZmZzZXQsIGFkZHJfdHlwKSAtPiBiZWdpblxuICAgIGxldCByID0gcmVnaXN0ZXJfb2Zfc3RyIHN0ciBpblxuICAgIGxldCBybyA9IG1hdGNoIG9mZnNldCB3aXRoXG4gICAgfCBPSW1tZWRpYXRlIChzaWduLCBpKSAtPiBBcm0uT0ltbWVkaWF0ZSAociwgc2lnbiwgcHJlcHJvY2VzcyBlbnYgaSlcbiAgICB8IE9SZWdpc3RlciAoc2lnbiwgc3RyKSAtPiBBcm0uT1JlZ2lzdGVyIChyLCBzaWduLCByZWdpc3Rlcl9vZl9zdHIgc3RyKVxuICAgIGluXG4gICAgKHJvLCBhZGRyX3R5cClcbiAgICBlbmRcbiAgfCBfIC0+IHJhaXNlIFN0cnVjdEVycm9yXG5cbmxldCBnZXRfdGFyZ2V0IGVudiBhcmdzID1cbiAgZ2V0X2ltbWVkaWF0ZSBlbnYgKExpc3QuaGQgYXJncylcblxubGV0IGFzbV9jbWQzX3RvX2FybSBlbnYgY21kIGFyZ3MgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGNtZCA8IDMgdGhlbiByYWlzZSBTdHJ1Y3RFcnJvciA7XG4gIGxldCBjbWQgPSBTdHJpbmcudXBwZXJjYXNlX2FzY2lpIGNtZCBpblxuICBsZXQgKGNvbmQsIHR5cCwgcywgXywgXykgPSByZWNvZ25pemVfbW9kaWZpZXJzIGNtZCAzIGluXG4gIGxldCBjb25kID0gbWF0Y2ggY29uZCB3aXRoIE5vbmUgLT4gQUwgfCBTb21lIGMgLT4gYyBpblxuICBsZXQgdHlwID0gbWF0Y2ggdHlwIHdpdGggTm9uZSAtPiBXIHwgU29tZSB0eXAgLT4gdHlwIGluXG5cbiAgdHJ5IG1hdGNoIFN0cmluZy5zdWIgY21kIDAgMyB3aXRoXG4gIHwgXCJMRFJcIiAtPiBNZW0geyBpbnN0cj1MRFIgOyB0eXAgOyBjb25kIDsgcmQ9Z2V0X3JkIGFyZ3MgOyBybz1nZXRfcm8gZW52IGFyZ3MgfVxuICB8IFwiU1RSXCIgLT4gTWVtIHsgaW5zdHI9U1RSIDsgdHlwIDsgY29uZCA7IHJkPWdldF9yZCBhcmdzIDsgcm89Z2V0X3JvIGVudiBhcmdzIH1cbiAgfCBcIk1PVlwiIC0+IE1vdiB7IGluc3RyPU1PViA7IHMgOyBjb25kIDsgcmQ9Z2V0X3JkIGFyZ3MgOyBycz1nZXRfcnMgZW52IGFyZ3MgfVxuICB8IFwiTVZOXCIgLT4gTW92IHsgaW5zdHI9TVZOOyBzIDsgY29uZCA7IHJkPWdldF9yZCBhcmdzIDsgcnM9Z2V0X3JzIGVudiBhcmdzIH1cbiAgfCBcIkFEQ1wiIC0+IERhdGFQcm9jIHsgaW5zdHI9QURDIDsgcyA7IGNvbmQgOyByZD1nZXRfcmQgYXJncyA7IHJuPWdldF9ybiBhcmdzIDsgb3AyPWdldF9vcDIgZW52IGFyZ3MgfVxuICB8IFwiU0JDXCIgLT4gRGF0YVByb2MgeyBpbnN0cj1TQkMgOyBzIDsgY29uZCA7IHJkPWdldF9yZCBhcmdzIDsgcm49Z2V0X3JuIGFyZ3MgOyBvcDI9Z2V0X29wMiBlbnYgYXJncyB9XG4gIHwgXCJCSUNcIiAtPiBEYXRhUHJvYyB7IGluc3RyPUJJQyA7IHMgOyBjb25kIDsgcmQ9Z2V0X3JkIGFyZ3MgOyBybj1nZXRfcm4gYXJncyA7IG9wMj1nZXRfb3AyIGVudiBhcmdzIH1cbiAgfCBcIkFORFwiIC0+IERhdGFQcm9jIHsgaW5zdHI9QU5EIDsgcyA7IGNvbmQgOyByZD1nZXRfcmQgYXJncyA7IHJuPWdldF9ybiBhcmdzIDsgb3AyPWdldF9vcDIgZW52IGFyZ3MgfVxuICB8IFwiQUREXCIgLT4gRGF0YVByb2MgeyBpbnN0cj1BREQgOyBzIDsgY29uZCA7IHJkPWdldF9yZCBhcmdzIDsgcm49Z2V0X3JuIGFyZ3MgOyBvcDI9Z2V0X29wMiBlbnYgYXJncyB9XG4gIHwgXCJTVUJcIiAtPiBEYXRhUHJvYyB7IGluc3RyPVNVQiA7IHMgOyBjb25kIDsgcmQ9Z2V0X3JkIGFyZ3MgOyBybj1nZXRfcm4gYXJncyA7IG9wMj1nZXRfb3AyIGVudiBhcmdzIH1cbiAgfCBcIk9SUlwiIC0+IERhdGFQcm9jIHsgaW5zdHI9T1JSIDsgcyA7IGNvbmQgOyByZD1nZXRfcmQgYXJncyA7IHJuPWdldF9ybiBhcmdzIDsgb3AyPWdldF9vcDIgZW52IGFyZ3MgfVxuICB8IFwiRU9SXCIgLT4gRGF0YVByb2MgeyBpbnN0cj1FT1IgOyBzIDsgY29uZCA7IHJkPWdldF9yZCBhcmdzIDsgcm49Z2V0X3JuIGFyZ3MgOyBvcDI9Z2V0X29wMiBlbnYgYXJncyB9XG4gIHwgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuICB3aXRoIEZhaWx1cmUgXyB8IEludmFsaWRfYXJndW1lbnQgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuXG5sZXQgYXNtX2NtZDFfdG9fYXJtIGVudiBjbWQgYXJncyA9XG4gIGlmIFN0cmluZy5sZW5ndGggY21kIDwgMSB0aGVuIHJhaXNlIFN0cnVjdEVycm9yIDtcbiAgbGV0IGNtZCA9IFN0cmluZy51cHBlcmNhc2VfYXNjaWkgY21kIGluXG4gIGxldCAoY29uZCwgXywgXywgbCwgeCkgPSByZWNvZ25pemVfbW9kaWZpZXJzIGNtZCAxIGluXG4gIGxldCBjb25kID0gbWF0Y2ggY29uZCB3aXRoIE5vbmUgLT4gQUwgfCBTb21lIGMgLT4gYyBpblxuXG4gIHRyeSBtYXRjaCBTdHJpbmcuc3ViIGNtZCAwIDEgd2l0aFxuICB8IFwiQlwiIHdoZW4geCAtPiBCcmFuY2hYIHsgbCA7IGNvbmQgOyBybT1nZXRfcm0gYXJncyB9XG4gIHwgXCJCXCIgLT4gQnJhbmNoIHsgbCA7IGNvbmQgOyB0YXJnZXQ9Z2V0X3RhcmdldCBlbnYgYXJncyB9XG4gIHwgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuICB3aXRoIEZhaWx1cmUgXyB8IEludmFsaWRfYXJndW1lbnQgXyAtPiByYWlzZSBTdHJ1Y3RFcnJvclxuXG5sZXQgYXNtX2NtZF90b19hcm0gZW52IGNtZCBhcmdzID1cbiAgdHJ5IChhc21fY21kM190b19hcm0gZW52IGNtZCBhcmdzKVxuICB3aXRoIFN0cnVjdEVycm9yIC0+IChhc21fY21kMV90b19hcm0gZW52IGNtZCBhcmdzKVxuXG5sZXQgY21kX3RvX2FybSBlbnYgY21kID1cbiAgbWF0Y2ggY21kIHdpdGhcbiAgfCBBU00gKHBvcywgY21kLCBhcmdzLCBvcHRpbWl6ZSkgLT5cbiAgICBiZWdpbiB0cnkgKGFzbV9jbWRfdG9fYXJtIGVudiBjbWQgYXJncywgb3B0aW1pemUpXG4gICAgd2l0aCBTdHJ1Y3RFcnJvciAtPiByYWlzZSAoQ29tbWFuZEVycm9yIHBvcykgZW5kXG4gIHwgQklOIChfLCBpKSAtPiAoQ3VzdG9tIChwcmVwcm9jZXNzIGVudiBpKSwgT3B0aW1pemVyLk5vVHdlYWtpbmcpXG5cbmxldCB0b19hcm0gZW52IGFzdCA9IExpc3QubWFwIChjbWRfdG9fYXJtIGVudikgYXN0XG4iLCIjIDEgXCJJTy9sZXhlci5tbGxcIlxuIFxub3BlbiBMZXhpbmdcbm9wZW4gUGFyc2VyXG5cbmV4Y2VwdGlvbiBTeW50YXhFcnJvciBvZiBzdHJpbmdcblxubGV0IG5leHRfbGluZSBsZXhidWYgPVxuICBsZXQgcG9zID0gbGV4YnVmLmxleF9jdXJyX3AgaW5cbiAgbGV4YnVmLmxleF9jdXJyX3AgPC1cbiAgICB7IHBvcyB3aXRoIHBvc19ib2wgPSBsZXhidWYubGV4X2N1cnJfcG9zO1xuICAgICAgICAgICAgICAgcG9zX2xudW0gPSBwb3MucG9zX2xudW0gKyAxXG4gICAgfVxuXG5sZXQgZW9mX3JlYWNoZWQgbGV4YnVmID1cbiAgbGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlXG5cbiMgMTkgXCJJTy9sZXhlci5tbFwiXG5sZXQgX19vY2FtbF9sZXhfdGFibGVzID0ge1xuICBMZXhpbmcubGV4X2Jhc2UgPVxuICAgXCJcXDAwMFxcMDAwXFwyMTVcXDI1NVxcMjE2XFwyNTVcXDIxN1xcMjU1XFwyMThcXDI1NVxcMjIzXFwyNTVcXDIyNFxcMjU1XFwyMjVcXDI1NVxcXG4gICAgXFwyMjZcXDI1NVxcMjI3XFwyNTVcXDIyOFxcMjU1XFwyMjlcXDI1NVxcMjMxXFwyNTVcXDIzMlxcMjU1XFwyMzNcXDI1NVxcMjM0XFwyNTVcXFxuICAgIFxcMjM1XFwyNTVcXDIzNlxcMjU1XFwyMzhcXDI1NVxcMDc5XFwwMDBcXDE1NFxcMDAwXFwxNjRcXDAwMFxcMjQxXFwyNTVcXDAwMVxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDdcXDAwMFxcMDQ5XFwwMDBcXDI0NFxcMjU1XFwwMDlcXDAwMFxcMDk5XFwwMDBcXDAxNFxcMDAwXFwwNzhcXDAwMFxcXG4gICAgXFwwNzhcXDAwMFxcMDgxXFwwMDBcXDIzN1xcMDAwXFwwNTZcXDAwMVxcMTMxXFwwMDFcXDA3OFxcMDAwXFwwODJcXDAwMFxcMTA5XFwwMDBcXFxuICAgIFxcMTEwXFwwMDBcXDExMVxcMDAwXFwxMTJcXDAwMFxcMjU0XFwyNTVcXDIwNlxcMDAxXFwwMjVcXDAwMlxcMTAwXFwwMDJcXDE3NVxcMDAyXFxcbiAgICBcXDI1MFxcMDAyXFwwNjlcXDAwM1xcMTQ0XFwwMDNcXDIxOVxcMDAzXFwwMzhcXDAwNFxcMTEzXFwwMDRcXDI1MFxcMjU1XFwyNDlcXDI1NVxcXG4gICAgXFwyNDdcXDI1NVxcMjQ2XFwyNTVcXDI0NVxcMjU1XFwyNDJcXDI1NVxcMDA0XFwwMDBcXDE3NFxcMDAwXFwxODNcXDAwMFxcMTg4XFwwMDRcXFxuICAgIFxcMTg1XFwwMDBcXDIxMVxcMDA0XFwxOTZcXDAwMFxcMjE1XFwwMDBcXDIzNlxcMDA0XFwyNDVcXDI1NVxcMjQ2XFwyNTVcXDAwN1xcMDAwXFxcbiAgICBcXDIzN1xcMDA0XFwyMDRcXDAwNFxcMjU1XFwyNTVcXDI0OFxcMjU1XFwyNDlcXDI1NVxcMjUwXFwyNTVcXDI1MVxcMjU1XFwyNTJcXDI1NVxcXG4gICAgXFwyNTNcXDI1NVxcMjU0XFwyNTVcXDAxNVxcMDAwXFwyNTNcXDI1NVxcMjU0XFwyNTVcXDI1NVxcMjU1XFwwMDhcXDAwMFwiO1xuICBMZXhpbmcubGV4X2JhY2t0cmsgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDE2XFwwMDBcXDAxNVxcMDAwXFwwMTVcXDAwMFxcMjU1XFwyNTVcXDAxNFxcMDAwXFxcbiAgICBcXDA0MFxcMDAwXFwwMTJcXDAwMFxcMDMzXFwwMDBcXDI1NVxcMjU1XFwwMzRcXDAwMFxcMDM1XFwwMDBcXDAzNlxcMDAwXFwwMjVcXDAwMFxcXG4gICAgXFwwNDBcXDAwMFxcMDQwXFwwMDBcXDAxNlxcMDAwXFwwMTZcXDAwMFxcMDE2XFwwMDBcXDAxMVxcMDAwXFwwMThcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAxNlxcMDAwXFwwMTZcXDAwMFxcMDAyXFwwMDBcXDAxNlxcMDAwXFxcbiAgICBcXDAxNlxcMDAwXFwwMDNcXDAwMFxcMDE2XFwwMDBcXDAxNlxcMDAwXFwwMTZcXDAwMFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDEzXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDAxNVxcMDAwXFwwMTVcXDAwMFxcMDE1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwOVxcMDAwXFxcbiAgICBcXDAwOFxcMDAwXFwwMTFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDBcXDAwMFwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHQgPVxuICAgXCJcXDAwMVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3MlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDA3MlxcMDAwXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA4M1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwyNTVcXDI1NVwiO1xuICBMZXhpbmcubGV4X3RyYW5zID1cbiAgIFwiXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAyNVxcMDAwXFwwMjJcXDAwMFxcMDIyXFwwMDBcXDA1OVxcMDAwXFwwMjNcXDAwMFxcMDU5XFwwMDBcXDA2MFxcMDAwXFxcbiAgICBcXDAyNVxcMDAwXFwwNzBcXDAwMFxcMDg1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDg1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDg2XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDI1XFwwMDBcXDAzMVxcMDAwXFwwMThcXDAwMFxcMDE3XFwwMDBcXDAwMFxcMDAwXFwwMjhcXDAwMFxcMDI5XFwwMDBcXDAyNVxcMDAwXFxcbiAgICBcXDAwOVxcMDAwXFwwMDhcXDAwMFxcMDA1XFwwMDBcXDAwN1xcMDAwXFwwMTJcXDAwMFxcMDA2XFwwMDBcXDAyN1xcMDAwXFwwMjZcXDAwMFxcXG4gICAgXFwwMjFcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMTBcXDAwMFxcMDI3XFwwMDBcXDAzM1xcMDAwXFwwMzhcXDAwMFxcMDMyXFwwMDBcXDAxMVxcMDAwXFxcbiAgICBcXDAzN1xcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxNlxcMDAwXFwwMjRcXDAwMFxcMDE1XFwwMDBcXDAwNFxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMjdcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMzRcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDM2XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMzVcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTRcXDAwMFxcMDMwXFwwMDBcXDAxM1xcMDAwXFwwMDNcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwNThcXDAwMFxcMDU3XFwwMDBcXDA1NlxcMDAwXFwwNTVcXDAwMFxcMDU0XFwwMDBcXDA0M1xcMDAwXFwwMzlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDA0MFxcMDAwXFwwNDFcXDAwMFxcMDQyXFwwMDBcXDA0MlxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFxcbiAgICBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXFxuICAgIFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDYyXFwwMDBcXDA2NlxcMDAwXFxcbiAgICBcXDA2NlxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcXG4gICAgXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwNjFcXDAwMFxcMDY2XFwwMDBcXDA2NlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDA2NFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA2M1xcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA2MlxcMDAwXFwwNjdcXDAwMFxcXG4gICAgXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDg0XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDYxXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwNjRcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNjNcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDA1MFxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDQ3XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwNDRcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDQ1XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDQ2XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDA0OFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwNDlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDA1MVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDA1MlxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMDBcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDUzXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFxcbiAgICBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA3MFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMDcxXFwwMDBcXDI1NVxcMjU1XFwwODFcXDAwMFxcMDAwXFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXFxuICAgIFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFxcbiAgICBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDAwXFwwMDBcXDA3NFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXFxuICAgIFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFxcbiAgICBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwODBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNzlcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwNzhcXDAwMFxcMDAwXFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFxcbiAgICBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDc3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDA3NlxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwNzVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDczXFwwMDBcXDI1NVxcMjU1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDY5XFwwMDBcXDI1NVxcMjU1XCI7XG4gIExleGluZy5sZXhfY2hlY2sgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMjNcXDAwMFxcMDI0XFwwMDBcXDAwMFxcMDAwXFwwNjBcXDAwMFxcMDI0XFwwMDBcXFxuICAgIFxcMDI1XFwwMDBcXDA3MVxcMDAwXFwwODZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwwODJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwODJcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMjU1XFwyNTVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDI1XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDI4XFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAyNlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAyOVxcMDAwXFwwMzBcXDAwMFxcMDMxXFwwMDBcXDAzMlxcMDAwXFwwMzNcXDAwMFxcMDM3XFwwMDBcXDAzOFxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDM5XFwwMDBcXDA0MFxcMDAwXFwwNDFcXDAwMFxcMDQyXFwwMDBcXDAxOVxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXFxuICAgIFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFxcbiAgICBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAxOVxcMDAwXFwwMTlcXDAwMFxcXG4gICAgXFwwMTlcXDAwMFxcMDE5XFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXFxuICAgIFxcMDIwXFwwMDBcXDAyMFxcMDAwXFwwMjBcXDAwMFxcMDIwXFwwMDBcXDAyMVxcMDAwXFwwMjFcXDAwMFxcMDIxXFwwMDBcXDAyMVxcMDAwXFxcbiAgICBcXDAyMVxcMDAwXFwwMjFcXDAwMFxcMDIxXFwwMDBcXDAyMVxcMDAwXFwwMjFcXDAwMFxcMDIxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcXG4gICAgXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwNjFcXDAwMFxcMDYxXFwwMDBcXDA2MVxcMDAwXFwwMjFcXDAwMFxcMDYyXFwwMDBcXFxuICAgIFxcMDYyXFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDA2NFxcMDAwXFxcbiAgICBcXDA2NFxcMDAwXFwwNjRcXDAwMFxcMDY0XFwwMDBcXDAyMVxcMDAwXFwwNjZcXDAwMFxcMDY2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMDIxXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDIxXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDIxXFwwMDBcXDA2N1xcMDAwXFxcbiAgICBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwNjdcXDAwMFxcMDY3XFwwMDBcXDA2N1xcMDAwXFwwODJcXDAwMFxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMjFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDAyMVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAyMVxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFxcbiAgICBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMzRcXDAwMFxcMDM0XFwwMDBcXFxuICAgIFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFxcbiAgICBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcXG4gICAgXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAzNFxcMDAwXFwyNTVcXDI1NVxcMDM0XFwwMDBcXDAzNFxcMDAwXFxcbiAgICBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcXG4gICAgXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXFxuICAgIFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFwwMzRcXDAwMFxcMDM0XFwwMDBcXDAzNFxcMDAwXFxcbiAgICBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcXG4gICAgXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFxcbiAgICBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcXG4gICAgXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXFxuICAgIFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAzNVxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcXG4gICAgXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXFxuICAgIFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNVxcMDAwXFxcbiAgICBcXDAzNVxcMDAwXFwwMzVcXDAwMFxcMDM1XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcXG4gICAgXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFxcbiAgICBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcXG4gICAgXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXFxuICAgIFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDM2XFwwMDBcXDI1NVxcMjU1XFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcXG4gICAgXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXFxuICAgIFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFxcbiAgICBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDAzNlxcMDAwXFwwMzZcXDAwMFxcMDM2XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcXG4gICAgXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0NFxcMDAwXFxcbiAgICBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcXG4gICAgXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXFxuICAgIFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFxcbiAgICBcXDA0NFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ0XFwwMDBcXDI1NVxcMjU1XFwwNDRcXDAwMFxcXG4gICAgXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXFxuICAgIFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFxcbiAgICBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcMDQ0XFwwMDBcXDA0NFxcMDAwXFwwNDRcXDAwMFxcXG4gICAgXFwwNDRcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXFxuICAgIFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcXG4gICAgXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXFxuICAgIFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFxcbiAgICBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwNDVcXDAwMFxcMjU1XFwyNTVcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXFxuICAgIFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFxcbiAgICBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcXG4gICAgXFwwNDVcXDAwMFxcMDQ1XFwwMDBcXDA0NVxcMDAwXFwwNDVcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXFxuICAgIFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcXG4gICAgXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXFxuICAgIFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFxcbiAgICBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDZcXDAwMFxcMjU1XFwyNTVcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXFxuICAgIFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFxcbiAgICBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcXG4gICAgXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ2XFwwMDBcXDA0NlxcMDAwXFwwNDZcXDAwMFxcMDQ3XFwwMDBcXFxuICAgIFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFxcbiAgICBcXDA0N1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXFxuICAgIFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDdcXDAwMFxcMjU1XFwyNTVcXFxuICAgIFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFxcbiAgICBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcXG4gICAgXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDdcXDAwMFxcMDQ3XFwwMDBcXFxuICAgIFxcMDQ3XFwwMDBcXDA0N1xcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFxcbiAgICBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXFxuICAgIFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFxcbiAgICBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcXG4gICAgXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA0OFxcMDAwXFwyNTVcXDI1NVxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFxcbiAgICBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcXG4gICAgXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXFxuICAgIFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDhcXDAwMFxcMDQ4XFwwMDBcXDA0OFxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFxcbiAgICBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNDlcXDAwMFxcMDQ5XFwwMDBcXFxuICAgIFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFxcbiAgICBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcXG4gICAgXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA0OVxcMDAwXFwyNTVcXDI1NVxcMDQ5XFwwMDBcXDA0OVxcMDAwXFxcbiAgICBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcXG4gICAgXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXFxuICAgIFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFwwNDlcXDAwMFxcMDQ5XFwwMDBcXDA0OVxcMDAwXFxcbiAgICBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcXG4gICAgXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFxcbiAgICBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcXG4gICAgXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXFxuICAgIFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1MFxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcXG4gICAgXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXFxuICAgIFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MFxcMDAwXFxcbiAgICBcXDA1MFxcMDAwXFwwNTBcXDAwMFxcMDUwXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcXG4gICAgXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFxcbiAgICBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcXG4gICAgXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXFxuICAgIFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDUxXFwwMDBcXDI1NVxcMjU1XFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcXG4gICAgXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXFxuICAgIFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFxcbiAgICBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MVxcMDAwXFwwNTFcXDAwMFxcMDUxXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcXG4gICAgXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA1MlxcMDAwXFxcbiAgICBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcXG4gICAgXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXFxuICAgIFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFxcbiAgICBcXDA1MlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDUyXFwwMDBcXDI1NVxcMjU1XFwwNTJcXDAwMFxcXG4gICAgXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXFxuICAgIFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFxcbiAgICBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcMDUyXFwwMDBcXDA1MlxcMDAwXFwwNTJcXDAwMFxcXG4gICAgXFwwNTJcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXFxuICAgIFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcXG4gICAgXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXFxuICAgIFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFxcbiAgICBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwNTNcXDAwMFxcMjU1XFwyNTVcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXFxuICAgIFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFxcbiAgICBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcXG4gICAgXFwwNTNcXDAwMFxcMDUzXFwwMDBcXDA1M1xcMDAwXFwwNTNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXFxuICAgIFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDY4XFwwMDBcXDA3MlxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwwNjhcXDAwMFxcMDcyXFwwMDBcXDA3M1xcMDAwXFwyNTVcXDI1NVxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcXG4gICAgXFwwNjNcXDAwMFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXFxuICAgIFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwyNTVcXDI1NVxcMDY4XFwwMDBcXDA3MlxcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjVcXDAwMFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcXG4gICAgXFwwNjVcXDAwMFxcMDY1XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMDYzXFwwMDBcXFxuICAgIFxcMDYzXFwwMDBcXDA2M1xcMDAwXFwwNjNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDA3M1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3M1xcMDAwXFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDA3M1xcMDAwXFwyNTVcXDI1NVxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNjVcXDAwMFxcMDY1XFwwMDBcXFxuICAgIFxcMDY1XFwwMDBcXDA2NVxcMDAwXFwwNzNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDczXFwwMDBcXDI1NVxcMjU1XFxcbiAgICBcXDA3M1xcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwNjhcXDAwMFxcMDcyXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwNjhcXDAwMFxcMDcyXFwwMDBcIjtcbiAgTGV4aW5nLmxleF9iYXNlX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9kZWZhdWx0X2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF90cmFuc19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY2hlY2tfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2NvZGUgPVxuICAgXCJcIjtcbn1cblxubGV0IHJlYyByZWFkIGxleGJ1ZiA9XG4gICBfX29jYW1sX2xleF9yZWFkX3JlYyBsZXhidWYgMFxuYW5kIF9fb2NhbWxfbGV4X3JlYWRfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZSA9XG4gIG1hdGNoIExleGluZy5lbmdpbmUgX19vY2FtbF9sZXhfdGFibGVzIF9fb2NhbWxfbGV4X3N0YXRlIGxleGJ1ZiB3aXRoXG4gICAgICB8IDAgLT5cbiMgNDQgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICggRU9GIClcbiMgNDYwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMSAtPlxuIyA0NSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggSEVBREVSIClcbiMgNDY1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMiAtPlxuIyA0NiBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggTlVMTCApXG4jIDQ3MCBcIklPL2xleGVyLm1sXCJcblxuICB8IDMgLT5cbiMgNDcgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEJPT0wgdHJ1ZSApXG4jIDQ3NSBcIklPL2xleGVyLm1sXCJcblxuICB8IDQgLT5cbiMgNDggXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEJPT0wgZmFsc2UgKVxuIyA0ODAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCA1IC0+XG4jIDQ5IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBMU0hJRlQgKVxuIyA0ODUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCA2IC0+XG4jIDUwIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBSU0hJRlQgKVxuIyA0OTAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCA3IC0+XG4jIDUxIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBFUSApXG4jIDQ5NSBcIklPL2xleGVyLm1sXCJcblxuICB8IDggLT5cbiMgNTIgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIE5FUSApXG4jIDUwMCBcIklPL2xleGVyLm1sXCJcblxuICB8IDkgLT5cbiMgNTMgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEJPUiApXG4jIDUwNSBcIklPL2xleGVyLm1sXCJcblxuICB8IDEwIC0+XG4jIDU0IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBCQU5EIClcbiMgNTEwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMTEgLT5cbiMgNTUgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIHJlYWRfY29tbWVudCBsZXhidWYgKVxuIyA1MTUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxMiAtPlxuIyA1NiBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggcmVhZCBsZXhidWYgKVxuIyA1MjAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxMyAtPlxuIyA1NyBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICggbmV4dF9saW5lIGxleGJ1ZiA7IHJlYWQgbGV4YnVmIClcbiMgNTI1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMTQgLT5cbiMgNTggXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIG5leHRfbGluZSBsZXhidWYgOyBFT0wgKVxuIyA1MzAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxNSAtPlxuIyA1OSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggTlVNQkVSIChVdGlscy51aW50MzJfb2Zfc3RyIChMZXhpbmcubGV4ZW1lIGxleGJ1ZikpIClcbiMgNTM1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMTYgLT5cbiMgNjAgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIElEIChMZXhpbmcubGV4ZW1lIGxleGJ1ZikgKVxuIyA1NDAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxNyAtPlxuIyA2MSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggcmVhZF9zdHJpbmcgKEJ1ZmZlci5jcmVhdGUgMTcpIGxleGJ1ZiApXG4jIDU0NSBcIklPL2xleGVyLm1sXCJcblxuICB8IDE4IC0+XG4jIDYyIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBFUVVBTCApXG4jIDU1MCBcIklPL2xleGVyLm1sXCJcblxuICB8IDE5IC0+XG4jIDYzIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBIQVNIIClcbiMgNTU1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMjAgLT5cbiMgNjQgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIExFRlRfQlJBQ0sgKVxuIyA1NjAgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAyMSAtPlxuIyA2NSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggUklHSFRfQlJBQ0sgKVxuIyA1NjUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAyMiAtPlxuIyA2NiBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggTEVGVF9CUkFDRSApXG4jIDU3MCBcIklPL2xleGVyLm1sXCJcblxuICB8IDIzIC0+XG4jIDY3IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBSSUdIVF9CUkFDRSApXG4jIDU3NSBcIklPL2xleGVyLm1sXCJcblxuICB8IDI0IC0+XG4jIDY4IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBDT01NQSApXG4jIDU4MCBcIklPL2xleGVyLm1sXCJcblxuICB8IDI1IC0+XG4jIDY5IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBFWENMQU1fTUFSSyApXG4jIDU4NSBcIklPL2xleGVyLm1sXCJcblxuICB8IDI2IC0+XG4jIDcwIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBJTlRFUlJPR19NQVJLIClcbiMgNTkwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMjcgLT5cbiMgNzEgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIENPTE9OIClcbiMgNTk1IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMjggLT5cbiMgNzIgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIExQQVJFTiApXG4jIDYwMCBcIklPL2xleGVyLm1sXCJcblxuICB8IDI5IC0+XG4jIDczIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBSUEFSRU4gKVxuIyA2MDUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAzMCAtPlxuIyA3NCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggUExVUyApXG4jIDYxMCBcIklPL2xleGVyLm1sXCJcblxuICB8IDMxIC0+XG4jIDc1IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBNSU5VUyApXG4jIDYxNSBcIklPL2xleGVyLm1sXCJcblxuICB8IDMyIC0+XG4jIDc2IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBUSU1FUyApXG4jIDYyMCBcIklPL2xleGVyLm1sXCJcblxuICB8IDMzIC0+XG4jIDc3IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBESVYgKVxuIyA2MjUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAzNCAtPlxuIyA3OCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggTU9EIClcbiMgNjMwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMzUgLT5cbiMgNzkgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEFORCApXG4jIDYzNSBcIklPL2xleGVyLm1sXCJcblxuICB8IDM2IC0+XG4jIDgwIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBPUiApXG4jIDY0MCBcIklPL2xleGVyLm1sXCJcblxuICB8IDM3IC0+XG4jIDgxIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBYT1IgKVxuIyA2NDUgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAzOCAtPlxuIyA4MiBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggTk9UIClcbiMgNjUwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMzkgLT5cbiMgODMgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIGVvZl9yZWFjaGVkIGxleGJ1ZiA7IEVPRiApXG4jIDY1NSBcIklPL2xleGVyLm1sXCJcblxuICB8IDQwIC0+XG4jIDg0IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICggcmFpc2UgKFN5bnRheEVycm9yIChcIlVuZXhwZWN0ZWQgY2hhcjogXCIgXiBMZXhpbmcubGV4ZW1lIGxleGJ1ZikpIClcbiMgNjYwIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF9yZWFkX3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGVcblxuYW5kIHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgPVxuICAgX19vY2FtbF9sZXhfcmVhZF9zdHJpbmdfcmVjIGJ1ZiBsZXhidWYgNjhcbmFuZCBfX29jYW1sX2xleF9yZWFkX3N0cmluZ19yZWMgYnVmIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZSA9XG4gIG1hdGNoIExleGluZy5lbmdpbmUgX19vY2FtbF9sZXhfdGFibGVzIF9fb2NhbWxfbGV4X3N0YXRlIGxleGJ1ZiB3aXRoXG4gICAgICB8IDAgLT5cbiMgODcgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIFNUUklORyAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgKVxuIyA2NzIgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxIC0+XG4jIDg4IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBCdWZmZXIuYWRkX2NoYXIgYnVmICcvJzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiApXG4jIDY3NyBcIklPL2xleGVyLm1sXCJcblxuICB8IDIgLT5cbiMgODkgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xcXFwnOyByZWFkX3N0cmluZyBidWYgbGV4YnVmIClcbiMgNjgyIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMyAtPlxuIyA5MCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFxiJzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiApXG4jIDY4NyBcIklPL2xleGVyLm1sXCJcblxuICB8IDQgLT5cbiMgOTEgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xcMDEyJzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiApXG4jIDY5MiBcIklPL2xleGVyLm1sXCJcblxuICB8IDUgLT5cbiMgOTIgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAoIEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xcbic7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgKVxuIyA2OTcgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCA2IC0+XG4jIDkzIFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgKCBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXHInOyByZWFkX3N0cmluZyBidWYgbGV4YnVmIClcbiMgNzAyIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgNyAtPlxuIyA5NCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICggQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFx0JzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiApXG4jIDcwNyBcIklPL2xleGVyLm1sXCJcblxuICB8IDggLT5cbiMgOTYgXCJJTy9sZXhlci5tbGxcIlxuICAgICggQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChMZXhpbmcubGV4ZW1lIGxleGJ1Zik7XG4gICAgICByZWFkX3N0cmluZyBidWYgbGV4YnVmXG4gICAgKVxuIyA3MTQgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCA5IC0+XG4jIDk5IFwiSU8vbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICggcmFpc2UgKFN5bnRheEVycm9yIChcIlN0cmluZyBjYW5ub3QgYmUgbXVsdGlsaW5lXCIpKSApXG4jIDcxOSBcIklPL2xleGVyLm1sXCJcblxuICB8IDEwIC0+XG4jIDEwMCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICggcmFpc2UgKFN5bnRheEVycm9yIChcIlN0cmluZyBpcyBub3QgdGVybWluYXRlZFwiKSkgKVxuIyA3MjQgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxMSAtPlxuIyAxMDEgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgKCByYWlzZSAoU3ludGF4RXJyb3IgKFwiSWxsZWdhbCBzdHJpbmcgY2hhcmFjdGVyOiBcIiBeIExleGluZy5sZXhlbWUgbGV4YnVmKSkgKVxuIyA3MjkgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCBfX29jYW1sX2xleF9zdGF0ZSAtPiBsZXhidWYuTGV4aW5nLnJlZmlsbF9idWZmIGxleGJ1ZjtcbiAgICAgIF9fb2NhbWxfbGV4X3JlYWRfc3RyaW5nX3JlYyBidWYgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlXG5cbmFuZCByZWFkX2NvbW1lbnQgbGV4YnVmID1cbiAgIF9fb2NhbWxfbGV4X3JlYWRfY29tbWVudF9yZWMgbGV4YnVmIDgyXG5hbmQgX19vY2FtbF9sZXhfcmVhZF9jb21tZW50X3JlYyBsZXhidWYgX19vY2FtbF9sZXhfc3RhdGUgPVxuICBtYXRjaCBMZXhpbmcuZW5naW5lIF9fb2NhbWxfbGV4X3RhYmxlcyBfX29jYW1sX2xleF9zdGF0ZSBsZXhidWYgd2l0aFxuICAgICAgfCAwIC0+XG4jIDEwNCBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICAgICAoIG5leHRfbGluZSBsZXhidWYgOyBFT0wgKVxuIyA3NDEgXCJJTy9sZXhlci5tbFwiXG5cbiAgfCAxIC0+XG4jIDEwNSBcIklPL2xleGVyLm1sbFwiXG4gICAgICAgICggZW9mX3JlYWNoZWQgbGV4YnVmIDsgRU9GIClcbiMgNzQ2IFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgMiAtPlxuIyAxMDYgXCJJTy9sZXhlci5tbGxcIlxuICAgICAgKCByZWFkX2NvbW1lbnQgbGV4YnVmIClcbiMgNzUxIFwiSU8vbGV4ZXIubWxcIlxuXG4gIHwgX19vY2FtbF9sZXhfc3RhdGUgLT4gbGV4YnVmLkxleGluZy5yZWZpbGxfYnVmZiBsZXhidWY7XG4gICAgICBfX29jYW1sX2xleF9yZWFkX2NvbW1lbnRfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZVxuXG47O1xuXG4iLCJcbmxldCBlbnVtZXJhdGVfZmlsZXMgZGlybmFtZSBleHQgPVxuICBTeXMucmVhZGRpciBkaXJuYW1lXG4gIHw+IEFycmF5LnRvX2xpc3RcbiAgfD4gTGlzdC5maWx0ZXIgKGZ1biB4IC0+IEZpbGVuYW1lLmV4dGVuc2lvbiB4ID0gZXh0KVxuXG5sZXQgdWludDMyX29mX3N0ciBzdHIgPVxuICBsZXQgc3RyID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzdHIgaW5cbiAgKCogSXNzdWUgd2l0aCBqc19vZl9vY2FtbC4uLiAqKVxuICAoKlxuICBpZiBTdHIuc3RyaW5nX21hdGNoIChTdHIucmVnZXhwIFwiWzAtOV0rJFwiKSBzdHIgMFxuICB0aGVuIEludDMyLm9mX3N0cmluZyAoXCIwdVwiXnN0cilcbiAgZWxzZSBJbnQzMi5vZl9zdHJpbmcgc3RyXG4gICopXG4gIGxldCBpNjQgPSBJbnQ2NC5vZl9zdHJpbmcgc3RyIGluXG4gIGlmIEludDY0LmxvZ2FuZCAweEZGRkZGRkZGMDAwMDAwMDBMIGk2NCB8PiBJbnQ2NC5lcXVhbCBJbnQ2NC56ZXJvXG4gIHRoZW4gSW50NjQudG9faW50MzIgaTY0XG4gIGVsc2UgcmFpc2UgKEZhaWx1cmUgXCJOb3QgYSB2YWxpZCBpbnQzMi5cIilcblxubGV0IHVpbnQzMl90b19pbnQgdiA9XG4gIG1hdGNoIEludDMyLnVuc2lnbmVkX3RvX2ludCB2IHdpdGggTm9uZSAtPiBhc3NlcnQgZmFsc2UgfCBTb21lIGkgLT4gaVxuXG5sZXQgaW50NjRfb2ZfdWludDMyIHggPVxuICBJbnQ2NC5vZl9pbnQzMiB4IHw+IEludDY0LmxvZ2FuZCAweEZGRkZGRkZGTFxuXG5sZXQgZHVtbXlfZm10ID1cbiAgRm9ybWF0Lm1ha2VfZm9ybWF0dGVyIChmdW4gXyBfIF8gLT4gKCkpIChmdW4gXyAtPiAoKSlcblxubGV0IGNvbmNhdF9zdHJpbmdzIGxzdCA9XG4gIGxldCBwcCBmbXQgbHN0ID1cbiAgICBsc3QgfD4gTGlzdC5pdGVyIChmdW4gc3RyIC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVzXCIgc3RyKVxuICBpblxuICBGb3JtYXQuYXNwcmludGYgXCIlYVwiIHBwIGxzdCIsIm9wZW4gSW50MzJcblxudHlwZSBwb2tlbW9uID0geyBwaWQ6aW50MzIgOyBvdGlkOmludDMyIH1cblxubGV0IGludDMyX2Zyb21fbG93X2hpZ2ggbCBoID1cbiAgbG9nb3IgbCAoc2hpZnRfbGVmdCBoIDE2KVxuXG5sZXQgbWFzazE2ID0gMHhGRkZGIHw+IG9mX2ludFxubGV0IGludDMyX3RvX2xvd19oaWdoIGkgPVxuICBsZXQgbCA9IGxvZ2FuZCBtYXNrMTYgaSBpblxuICBsZXQgaCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgaSAxNiBpblxuICAobCwgaClcblxubGV0IGRhdGFfb2Zmc2V0ID0gMzJcbmxldCBzdWJzdHJ1Y3R1cmVfc2l6ZSA9IDEyXG5sZXQgZGF0YV9zaXplID0gc3Vic3RydWN0dXJlX3NpemUgKiA0XG5sZXQgcGlkX29mZnNldCA9IDBcbmxldCBvdGlkX29mZnNldCA9IDRcbmxldCBjaGVja3N1bV9vZmZzZXQgPSAyOFxuXG5sZXQgZGVjcnlwdGlvbl9rZXkgeyBwaWQgOyBvdGlkIDsgXyB9ID0gbG9neG9yIHBpZCBvdGlkXG5cbmxldCBzdWJzdHJ1Y3R1cmVzX29yZGVyID0gW3xcbiAgXCJHQUVNXCIgOyBcIkdBTUVcIiA7IFwiR0VBTVwiIDsgXCJHRU1BXCIgOyBcIkdNQUVcIiA7IFwiR01FQVwiIDtcbiAgXCJBR0VNXCIgOyBcIkFHTUVcIiA7IFwiQUVHTVwiIDsgXCJBRU1HXCIgOyBcIkFNR0VcIiA7IFwiQU1FR1wiIDtcbiAgXCJFR0FNXCIgOyBcIkVHTUFcIiA7IFwiRUFHTVwiIDsgXCJFQU1HXCIgOyBcIkVNR0FcIiA7IFwiRU1BR1wiIDtcbiAgXCJNR0FFXCIgOyBcIk1HRUFcIiA7IFwiTUFHRVwiIDsgXCJNQUVHXCIgOyBcIk1FR0FcIiA7IFwiTUVBR1wiIDtcbnxdXG5cbmxldCBwa21uX2Zyb21fYnl0ZXMgYnVmID1cbiAgbGV0IHBpZCA9IEJ5dGVzLmdldF9pbnQzMl9sZSBidWYgcGlkX29mZnNldCBpblxuICBsZXQgb3RpZCA9IEJ5dGVzLmdldF9pbnQzMl9sZSBidWYgb3RpZF9vZmZzZXQgaW5cbiAgeyBwaWQgOyBvdGlkIH1cblxubGV0IHN1YnN0cnVjdHVyZV9wb3NpdGlvbiB7IHBpZCA7IF8gfSBzcyA9XG4gIGxldCBpID0gdW5zaWduZWRfcmVtIHBpZCAob2ZfaW50IDI0KSB8PiBVdGlscy51aW50MzJfdG9faW50IGluXG4gIGxldCBvcmRlciA9IHN1YnN0cnVjdHVyZXNfb3JkZXIuKGkpIGluXG4gIGxldCByZWMgYXV4IGkgPVxuICAgIGlmIG9yZGVyLltpXSA9IHNzIHRoZW4gaSBlbHNlIGF1eCAoaSsxKVxuICBpblxuICBhdXggMFxuXG5sZXQgc3Vic3RydWN0dXJlX29mZnNldCBwa21uIHNzID1cbiAgbGV0IHAgPSBzdWJzdHJ1Y3R1cmVfcG9zaXRpb24gcGttbiBzcyBpblxuICBkYXRhX29mZnNldCArIHN1YnN0cnVjdHVyZV9zaXplKnBcblxuKCogTG9jYWwgb3BlcmF0aW9ucyAqKVxuXG5sZXQgZGVjcnlwdF9hbGlnbmVkX2ludDMyIHBrbW4gaSA9XG4gIGxldCBrZXkgPSBkZWNyeXB0aW9uX2tleSBwa21uIGluXG4gIGxvZ3hvciBpIGtleVxuXG5sZXQgZW5jcnlwdF9hbGlnbmVkX2ludDMyID0gZGVjcnlwdF9hbGlnbmVkX2ludDMyXG5cbmxldCBjaGVja3N1bV9kaWZmX2Zvcl9hbGlnbmVkX2ludDMyIG8gbiA9XG4gIGxldCAobG8sIGhvKSA9IGludDMyX3RvX2xvd19oaWdoIG8gaW5cbiAgbGV0IChsbiwgaG4pID0gaW50MzJfdG9fbG93X2hpZ2ggbiBpblxuICBsZXQgZGlmZiA9IGFkZCAoc3ViIGxuIGxvKSAoc3ViIGhuIGhvKSBpblxuICBsb2dhbmQgZGlmZiBtYXNrMTZcblxuKCogR2xvYmFsIG9wZXJhdGlvbnMgKilcblxubGV0IGVuY19kZWMgcGttbiBidWYgc3RhcnQgbGVuID1cbiAgbGV0IHJlYyBlbmNfZGVjX2Zyb20gb2Zmc2V0ID0gXG4gICAgaWYgb2Zmc2V0ID49IHN0YXJ0ICsgbGVuIHRoZW4gKClcbiAgICBlbHNlIChcbiAgICAgIGxldCBpID0gQnl0ZXMuZ2V0X2ludDMyX2xlIGJ1ZiBvZmZzZXQgaW5cbiAgICAgIGxldCBpID0gZW5jcnlwdF9hbGlnbmVkX2ludDMyIHBrbW4gaSBpblxuICAgICAgQnl0ZXMuc2V0X2ludDMyX2xlIGJ1ZiBvZmZzZXQgaSA7XG4gICAgICBlbmNfZGVjX2Zyb20gKG9mZnNldCArIDQpXG4gICAgKVxuICBpblxuICBlbmNfZGVjX2Zyb20gc3RhcnRcblxubGV0IGV4dHJhY3RfZGF0YSBidWYgPVxuICBsZXQgcGttbiA9IHBrbW5fZnJvbV9ieXRlcyBidWYgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLnN1YiBidWYgZGF0YV9vZmZzZXQgZGF0YV9zaXplIGluXG4gIGVuY19kZWMgcGttbiByZXMgMCBkYXRhX3NpemUgO1xuICByZXNcblxubGV0IGNvbXB1dGVfY2hlY2tzdW0gYnVmIHN0YXJ0IGxlbiA9XG4gIGxldCByZWMgYXV4IGFjYyBpID1cbiAgICBpZiBpID49IHN0YXJ0K2xlblxuICAgIHRoZW4gYWNjXG4gICAgZWxzZVxuICAgICAgbGV0IG5iID0gQnl0ZXMuZ2V0X3VpbnQxNl9sZSBidWYgaSB8PiBJbnQzMi5vZl9pbnQgaW5cbiAgICAgIGF1eCAoSW50MzIuYWRkIGFjYyBuYikgKGkrMilcbiAgaW5cbiAgbGV0IHN1bSA9IGF1eCBJbnQzMi56ZXJvIHN0YXJ0IGluXG4gIGxldCBsb3cgPSBJbnQzMi5sb2dhbmQgc3VtIG1hc2sxNiBpblxuICBsb3cgfD4gVXRpbHMudWludDMyX3RvX2ludFxuXG5sZXQgdXBkYXRlX3dpdGhfZGF0YSBidWYgZGF0YSA9XG4gIGxldCBwa21uID0gcGttbl9mcm9tX2J5dGVzIGJ1ZiBpblxuICBsZXQgY2hlY2tzdW0gPSBjb21wdXRlX2NoZWNrc3VtIGRhdGEgMCBkYXRhX3NpemUgaW5cbiAgQnl0ZXMuYmxpdCBkYXRhIDAgYnVmIGRhdGFfb2Zmc2V0IGRhdGFfc2l6ZSA7XG4gIGVuY19kZWMgcGttbiBidWYgZGF0YV9vZmZzZXQgZGF0YV9zaXplIDtcbiAgQnl0ZXMuc2V0X3VpbnQxNl9sZSBidWYgY2hlY2tzdW1fb2Zmc2V0IGNoZWNrc3VtXG5cbigqIFNwZWNpZXMgKilcblxubGV0IHNwZWNpZXNfb2Zmc2V0IHBrbW4gPVxuICAoc3Vic3RydWN0dXJlX29mZnNldCBwa21uICdHJylcblxubGV0IHNwZWNpZXNfb2Zmc2V0X3JlbGF0aXZlX3RvX2RhdGEgcGttbiA9XG4gIChzdWJzdHJ1Y3R1cmVfb2Zmc2V0IHBrbW4gJ0cnKSAtIGRhdGFfb2Zmc2V0XG5cbigqIElWcyAqKVxuXG5sZXQgaXZlYV9vZmZzZXQgcGttbiA9XG4gIChzdWJzdHJ1Y3R1cmVfb2Zmc2V0IHBrbW4gJ00nKSArIDRcblxubGV0IG1hc2s1ID0gMGIxMTExMSB8PiBvZl9pbnRcblxubGV0IGl2ZWFfZGF0YV90b19pdnMgZGF0YSA9XG4gIGxldCBocCA9IGxvZ2FuZCBtYXNrNSBkYXRhIGluXG4gIGxldCBkYXRhID0gc2hpZnRfcmlnaHRfbG9naWNhbCBkYXRhIDUgaW5cbiAgbGV0IGF0ayA9IGxvZ2FuZCBtYXNrNSBkYXRhIGluXG4gIGxldCBkYXRhID0gc2hpZnRfcmlnaHRfbG9naWNhbCBkYXRhIDUgaW5cbiAgbGV0IGRlZiA9IGxvZ2FuZCBtYXNrNSBkYXRhIGluXG4gIGxldCBkYXRhID0gc2hpZnRfcmlnaHRfbG9naWNhbCBkYXRhIDUgaW5cbiAgbGV0IHNwZWVkID0gbG9nYW5kIG1hc2s1IGRhdGEgaW5cbiAgbGV0IGRhdGEgPSBzaGlmdF9yaWdodF9sb2dpY2FsIGRhdGEgNSBpblxuICBsZXQgc3BfYXRrID0gbG9nYW5kIG1hc2s1IGRhdGEgaW5cbiAgbGV0IGRhdGEgPSBzaGlmdF9yaWdodF9sb2dpY2FsIGRhdGEgNSBpblxuICBsZXQgc3BfZGVmID0gbG9nYW5kIG1hc2s1IGRhdGEgaW5cbiAgbGV0IGRhdGEgPSBzaGlmdF9yaWdodF9sb2dpY2FsIGRhdGEgNSBpblxuICAoaHAsYXRrLGRlZixzcGVlZCxzcF9hdGssc3BfZGVmLGRhdGEpXG5cbmxldCBpdnNfdG9faXZlYV9kYXRhIChocCxhdGssZGVmLHNwZWVkLHNwX2F0ayxzcF9kZWYsZGF0YSkgPVxuICBsZXQgZGF0YSA9IHNoaWZ0X2xlZnQgZGF0YSA1IGluXG4gIGxldCBkYXRhID0gbG9nb3IgZGF0YSBzcF9kZWYgaW5cbiAgbGV0IGRhdGEgPSBzaGlmdF9sZWZ0IGRhdGEgNSBpblxuICBsZXQgZGF0YSA9IGxvZ29yIGRhdGEgc3BfYXRrIGluXG4gIGxldCBkYXRhID0gc2hpZnRfbGVmdCBkYXRhIDUgaW5cbiAgbGV0IGRhdGEgPSBsb2dvciBkYXRhIHNwZWVkIGluXG4gIGxldCBkYXRhID0gc2hpZnRfbGVmdCBkYXRhIDUgaW5cbiAgbGV0IGRhdGEgPSBsb2dvciBkYXRhIGRlZiBpblxuICBsZXQgZGF0YSA9IHNoaWZ0X2xlZnQgZGF0YSA1IGluXG4gIGxldCBkYXRhID0gbG9nb3IgZGF0YSBhdGsgaW5cbiAgbGV0IGRhdGEgPSBzaGlmdF9sZWZ0IGRhdGEgNSBpblxuICBsZXQgZGF0YSA9IGxvZ29yIGRhdGEgaHAgaW5cbiAgZGF0YVxuIiwiXG50eXBlIGxhbmd1YWdlcyA9IEVORyB8IEZSQSB8IElUQSB8IFNQQSB8IEdFUiB8IEpBUCB8IEFCQ1xubGV0IGxhbmcgPSByZWYgRU5HXG5cbnR5cGUgdHdlYWtlcl9tb2RlcyA9IFN0cmljdCB8IEZsZXhpYmxlXG5sZXQgdHdlYWtlcl9tb2RlID0gcmVmIEZsZXhpYmxlXG5cbmxldCBoZXhfYm94X21vZGUgPSByZWYgZmFsc2VcblxubGV0IGNvbmZpZ3VyZSBsYW5ndWFnZSA9XG4gIHR3ZWFrZXJfbW9kZSA6PSBGbGV4aWJsZSA7XG4gIGhleF9ib3hfbW9kZSA6PSBmYWxzZSA7XG4gIG1hdGNoIGxhbmd1YWdlIHdpdGhcbiAgfCBcImVuZ1wiIC0+IGxhbmcgOj0gRU5HXG4gIHwgXCJzcGFcIiAtPiBsYW5nIDo9IFNQQVxuICB8IFwiZnJhXCIgLT4gbGFuZyA6PSBGUkFcbiAgfCBcIml0YVwiIC0+IGxhbmcgOj0gSVRBXG4gIHwgXCJnZXJcIiAtPiBsYW5nIDo9IEdFUlxuICB8IFwiamFwXCIgLT4gbGFuZyA6PSBKQVAgOyB0d2Vha2VyX21vZGUgOj0gU3RyaWN0XG4gIHwgXCJhYmNcIiAtPiBsYW5nIDo9IEFCQyA7IHR3ZWFrZXJfbW9kZSA6PSBTdHJpY3QgOyBoZXhfYm94X21vZGUgOj0gdHJ1ZVxuICB8IF8gLT4gbGFuZyA6PSBFTkdcbiIsIm9wZW4gVXRpbHNcclxub3BlbiBCaWdfaW50XHJcblxyXG5sZXQgbXVsdF9tb2QgeCB5IG0gPVxyXG4gIG1vZF9iaWdfaW50IChtdWx0X2JpZ19pbnQgeCB5KSBtXHJcblxyXG5sZXQgcHJlZCA9IHByZWRfYmlnX2ludFxyXG5sZXQgc3VjYyA9IHN1Y2NfYmlnX2ludFxyXG5sZXQgaW50X211bCA9IG11bHRfaW50X2JpZ19pbnRcclxubGV0IGxvZ2FuZCA9IGFuZF9iaWdfaW50XHJcbmxldCBzaGlmdF9sZWZ0ID0gc2hpZnRfbGVmdF9iaWdfaW50XHJcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0X2JpZ19pbnRcclxubGV0IHR3b19iaWdfaW50ID0gYmlnX2ludF9vZl9pbnQgMlxyXG5sZXQgdGhyZWVfYmlnX2ludCA9IGJpZ19pbnRfb2ZfaW50IDNcclxubGV0IGZvdXJfYmlnX2ludCA9IGJpZ19pbnRfb2ZfaW50IDRcclxuXHJcbmxldCBhID0gMHg0MWM2NGU2ZEwgfD4gYmlnX2ludF9vZl9pbnQ2NFxyXG5sZXQgYiA9IDB4NjA3M0wgfD4gYmlnX2ludF9vZl9pbnQ2NFxyXG5sZXQgYV9pbnYgPSAweEVFQjlFQjY1TCB8PiBiaWdfaW50X29mX2ludDY0XHJcbmxldCBiX2ludiA9IDB4MEEzNTYxQTFMIHw+IGJpZ19pbnRfb2ZfaW50NjRcclxubGV0IG0gPSAweDFfMDBfMDBfMDBfMDBMIHw+IGJpZ19pbnRfb2ZfaW50NjRcclxubGV0IGJfMSA9IDB4MzQxYjk0NGJiTCB8PiBiaWdfaW50X29mX2ludDY0ICgqIEludmVyc2Ugb2YgYiBtb2QgMioqMzQgKilcclxubGV0IGN5Y2xlX3BhcnRfcHJvZHVjdCA9XHJcbiAgbXVsdF9tb2QgKHByZWQgYSkgYl8xIChpbnRfbXVsIDQgbSlcclxuXHJcbmxldCBtYXNrMzIgPSBiaWdfaW50X29mX2ludDY0IDB4RkZGRkZGRkZMXHJcblxyXG5sZXQgZXZlbiBuID0gbG9nYW5kIG4gdW5pdF9iaWdfaW50IHw+IGVxX2JpZ19pbnQgemVyb19iaWdfaW50XHJcbmxldCBvZGQgbiA9IGV2ZW4gbiB8PiBub3RcclxuXHJcbmxldCByZWMgbXBvdyBiYXNlIGV4cCBuID1cclxuICBsZXQgYmFzZSA9IG1vZF9iaWdfaW50IGJhc2UgbiBpblxyXG4gIGlmIGVxX2JpZ19pbnQgZXhwIHplcm9fYmlnX2ludFxyXG4gIHRoZW4gdW5pdF9iaWdfaW50XHJcbiAgZWxzZSBpZiBlcV9iaWdfaW50IGV4cCB1bml0X2JpZ19pbnRcclxuICB0aGVuIGJhc2VcclxuICBlbHNlIGlmIGV2ZW4gZXhwXHJcbiAgdGhlbiBtcG93IChtdWx0X2JpZ19pbnQgYmFzZSBiYXNlKSAoZGl2X2JpZ19pbnQgZXhwIHR3b19iaWdfaW50KSBuXHJcbiAgZWxzZSBtdWx0X21vZCBiYXNlIChtcG93IGJhc2UgKHByZWQgZXhwKSBuKSBuXHJcblxyXG5sZXQgcmVjIHBvdyBiYXNlIGV4cCA9XHJcbiAgaWYgZXFfYmlnX2ludCBleHAgemVyb19iaWdfaW50XHJcbiAgdGhlbiB1bml0X2JpZ19pbnRcclxuICBlbHNlIGlmIGVxX2JpZ19pbnQgZXhwIHVuaXRfYmlnX2ludFxyXG4gIHRoZW4gYmFzZVxyXG4gIGVsc2UgaWYgZXZlbiBleHBcclxuICB0aGVuIHBvdyAobXVsdF9iaWdfaW50IGJhc2UgYmFzZSkgKGRpdl9iaWdfaW50IGV4cCB0d29fYmlnX2ludClcclxuICBlbHNlIG11bHRfYmlnX2ludCBiYXNlIChwb3cgYmFzZSAocHJlZCBleHApKVxyXG5cclxubGV0IGFkZF9pZl9uZWdhdGl2ZSB4IHkgPVxyXG4gIGlmIGdlX2JpZ19pbnQgeCB6ZXJvX2JpZ19pbnQgdGhlbiB4IGVsc2UgYWRkX2JpZ19pbnQgeCB5XHJcbmxldCBzdWJfaWZfZ2VxIHggeSA9XHJcbiAgaWYgZ2VfYmlnX2ludCB4IHkgdGhlbiBzdWJfYmlnX2ludCB4IHkgZWxzZSB4XHJcblxyXG5sZXQgc2VlZF9hdCBjeWNsZSA9XHJcbiAgbGV0IHJlcyA9IG11bHRfYmlnX2ludCAocHJlZCBhKSBtIGluXHJcbiAgbGV0IG9wMSA9IGFkZF9pZl9uZWdhdGl2ZSAobXBvdyBhIGN5Y2xlIHJlcyB8PiBwcmVkKSByZXMgaW5cclxuICBsZXQgYXV4ID0gZGl2X2JpZ19pbnQgb3AxIChwcmVkIGEpIGluXHJcbiAgbXVsdF9tb2QgYXV4IGIgbVxyXG5cclxuZXhjZXB0aW9uIERvZXNOb3RFeGlzdFxyXG5cclxubGV0IGRpc2NyZXRlX2xvZyBiYXNlIHBvd2VyIG4gY2hlY2tfZXhpc3RzID1cclxuICBsZXQgKGEsYyxtKSA9IChiYXNlLCBwb3dlciwgcG93IHR3b19iaWdfaW50IChiaWdfaW50X29mX2ludCBuKSkgaW5cclxuICBhc3NlcnQgKG4gPj0gMykgO1xyXG4gIGFzc2VydCAob2RkIGEgJiYgb2RkIGMpIDtcclxuICBpZiBjaGVja19leGlzdHNcclxuICB0aGVuIGJlZ2luXHJcbiAgICBsZXQgbW9kX3N3aXRjaCA9IGVxX2JpZ19pbnQgKG1vZF9iaWdfaW50IGEgZm91cl9iaWdfaW50KSB0aHJlZV9iaWdfaW50IGluXHJcbiAgICBsZXQgcmVjIGF1eCBrIG0xID1cclxuICAgICAgaWYgayA+PSAyIHRoZW4gYmVnaW5cclxuICAgICAgICBsZXQgeCA9IGlmIG1vZF9zd2l0Y2ggdGhlbiBtdWx0X21vZCBhIGEgbTEgZWxzZSBtb2RfYmlnX2ludCBhIG0xIGluXHJcbiAgICAgICAgaWYgZXFfYmlnX2ludCB4IHVuaXRfYmlnX2ludCB0aGVuIGJlZ2luXHJcbiAgICAgICAgICBsZXQgeCA9IG1vZF9iaWdfaW50IGMgbTEgaW5cclxuICAgICAgICAgIGlmICgoZXFfYmlnX2ludCB4IHVuaXRfYmlnX2ludCkgfHwgKG1vZF9zd2l0Y2ggJiYgZXFfYmlnX2ludCB4IGEpKSB8PiBub3RcclxuICAgICAgICAgIHRoZW4gcmFpc2UgRG9lc05vdEV4aXN0XHJcbiAgICAgICAgZW5kIGVsc2UgYXV4IChrLTEpIChzaGlmdF9yaWdodCBtMSAxKVxyXG4gICAgICBlbmRcclxuICAgIGluXHJcbiAgICBhdXggKG4tMSkgKHNoaWZ0X3JpZ2h0IG0gMSlcclxuICBlbmQgO1xyXG4gIGxldCBrID0gbi0yIGluXHJcbiAgbGV0IGJpdG1hc2sgPSBwb3cgdHdvX2JpZ19pbnQgKGstMSB8PiBiaWdfaW50X29mX2ludCkgfD4gcHJlZCBpblxyXG4gIGxldCBscyA9IEFycmF5Lm1ha2UgayBjIGluXHJcbiAgbGV0IHJlYyBhdXggaSBsID1cclxuICAgIGlmIGkgPCBrXHJcbiAgICB0aGVuIGJlZ2luXHJcbiAgICAgIGxldCBsID0gbXVsdF9tb2QgbCBsIG0gaW5cclxuICAgICAgICBscy4oaSkgPC0gbCA7IGF1eCAoaSsxKSBsXHJcbiAgICBlbmRcclxuICBpblxyXG4gIGF1eCAxIGMgO1xyXG4gIGxldCByZWMgYXV4IGkgYiBiaXQgPVxyXG4gICAgaWYgaSA+PSAwXHJcbiAgICB0aGVuIGJlZ2luXHJcbiAgICAgIGxldCBiID1cclxuICAgICAgICBpZiBlcV9iaWdfaW50IGxzLihpKSAobXBvdyBhIChzaGlmdF9sZWZ0IGIgaSB8PiBsb2dhbmQgYml0bWFzaykgbSkgfD4gbm90XHJcbiAgICAgICAgdGhlbiBhZGRfYmlnX2ludCBiIGJpdFxyXG4gICAgICAgIGVsc2UgYlxyXG4gICAgICBpblxyXG4gICAgICBhdXggKGktMSkgYiAoc2hpZnRfbGVmdCBiaXQgMSlcclxuICAgIGVuZCBlbHNlIGJcclxuICBpblxyXG4gIGF1eCAoay0xKSB6ZXJvX2JpZ19pbnQgdW5pdF9iaWdfaW50XHJcblxyXG5sZXQgY3ljbGVfdG8gc2VlZCA9XHJcbiAgbGV0IG1vZHVsbyA9IGludF9tdWwgNCBtIGluXHJcbiAgbGV0IHBvd2VyID0gc3ViX2lmX2dlcSAobXVsdF9tb2Qgc2VlZCBjeWNsZV9wYXJ0X3Byb2R1Y3QgbW9kdWxvIHw+IHN1Y2MpIG1vZHVsbyBpblxyXG4gIGRpc2NyZXRlX2xvZyBhIHBvd2VyICgzMisyKSBmYWxzZVxyXG5cclxubGV0IG5leHRfc2VlZCBzZWVkID1cclxuICBtdWx0X2JpZ19pbnQgc2VlZCBhIHw+IGFkZF9iaWdfaW50IGIgfD4gbG9nYW5kIG1hc2szMlxyXG5cclxubGV0IHByZXZfc2VlZCBzZWVkID1cclxuICBtdWx0X2JpZ19pbnQgc2VlZCBhX2ludiB8PiBhZGRfYmlnX2ludCBiX2ludiB8PiBsb2dhbmQgbWFzazMyXHJcblxyXG5sZXQgYmlnX2ludF9vZl91aW50MzIgaTMyID1cclxuICBpbnQ2NF9vZl91aW50MzIgaTMyXHJcbiAgfD4gYmlnX2ludF9vZl9pbnQ2NFxyXG5cclxubGV0IHVpbnQzMl9vZl9iaWdpbnQgYmkgPVxyXG4gIGxldCBtYXhpbnQzMiA9IEludDMyLm1heF9pbnQgfD4gYmlnX2ludF9vZl9pbnQzMiBpblxyXG4gIGxldCBtaW5pbnQzMiA9IEludDMyLm1pbl9pbnQgfD4gYmlnX2ludF9vZl9pbnQzMiBpblxyXG4gIGxldCB0b3RhbCA9IHN1Yl9iaWdfaW50IG1heGludDMyIG1pbmludDMyIHw+IHN1Y2NfYmlnX2ludCBpblxyXG4gIGxldCBiaSA9IGlmIGd0X2JpZ19pbnQgYmkgbWF4aW50MzJcclxuICAgIHRoZW4gc3ViX2JpZ19pbnQgYmkgdG90YWxcclxuICAgIGVsc2UgYmlcclxuICBpblxyXG4gIGludDMyX29mX2JpZ19pbnQgYmlcclxuXHJcbigqIEZpc2hpbmcgKGZyb20gU2hhbykgKilcclxuXHJcbmxldCBybmdfb2Ygc2VlZCA9IHNoaWZ0X3JpZ2h0IHNlZWQgMTYgfD4gaW50X29mX2JpZ19pbnRcclxuXHJcbmxldCBvbGRfcm9kID0gMFxyXG5sZXQgZ29vZF9yb2QgPSAxXHJcbmxldCBzdXBlcl9yb2QgPSAyXHJcbmxldCBhUHJlc3NlcyA9IFt8MTszOzZ8XVxyXG5sZXQgbW9yZUFQcmVzc2VzID0gW3wwOzEwOzMwfF1cclxubGV0IGZpc2hpbmdfYXR0ZW1wdCByb3V0ZTExOSBmZWViYXMgc3RhcnRpbmdfc2VlZCByb2QgaW5pdGlhbEFkdmFuY2VzID1cclxuICBsZXQgc2VlZCA9IHJlZiBzdGFydGluZ19zZWVkIGluXHJcbiAgZm9yIF89MSB0byBpbml0aWFsQWR2YW5jZXMgZG9cclxuICAgIHNlZWQgOj0gbmV4dF9zZWVkICFzZWVkXHJcbiAgZG9uZSA7XHJcbiAgbGV0IG1pblJvdW5kcyA9ICgocm5nX29mICFzZWVkKSBtb2QgKGFQcmVzc2VzLihyb2QpKSkgKyAxIGluXHJcbiAgc2VlZCA6PSBuZXh0X3NlZWQgIXNlZWQgOyAoKiBPbmUgY2FsbCB0byBkZXRlcm1pbmUgbnVtYmVyIG9mIGRvdHMgb24gZmlyc3QgY2FzdCAqKVxyXG4gIHNlZWQgOj0gbmV4dF9zZWVkICFzZWVkIDsgKCogY2FsbCB0aGF0IGRldGVybWluZXMgaWYgZmlzaCBpcyBvbiBsaW5lICopXHJcblxyXG4gIGxldCBiaXRlUm9sbCA9IChybmdfb2YgIXNlZWQpIG1vZCAxMDAgaW5cclxuICBsZXQgYml0ZVJlc3VsdCA9XHJcbiAgICBpZiBiaXRlUm9sbCBsYW5kIDEgPSAwIHRoZW4gMCAoKiBBIGZpc2ggd2lsbCBiZSBnZW5lcmF0ZWQgcmVnYXJkbGVzcyBvZiBsZWFkICopXHJcbiAgICBlbHNlIGlmIGJpdGVSb2xsID4gMTQgdGhlbiAxICgqIEEgU3VjdGlvbiBDdXBzIG9yIFN0aWNreSBIb2xkIGxlYWQgaXMgbmVjZXNzYXJ5IHRvIGdldCBhIGZpc2ggKilcclxuICAgIGVsc2UgMlxyXG4gIGluXHJcblxyXG4gIGZvciBfPTEgdG8gbWluUm91bmRzLTEgZG9cclxuICAgIHNlZWQgOj0gbmV4dF9zZWVkICFzZWVkICgqIE1vcmUgY2FsbHMgdG8gZGV0ZXJtaW5lIGRvdCBudW1iZXJzICopXHJcbiAgZG9uZSA7XHJcblxyXG4gIGxldCBhZHZhbmNlbWVudCA9IHJlZiAoaW5pdGlhbEFkdmFuY2VzICsgbWluUm91bmRzKSBpblxyXG4gIGlmIG1pblJvdW5kcyA9IDEgdGhlbiBiZWdpblxyXG4gICAgc2VlZCA6PSBuZXh0X3NlZWQgIXNlZWQgOyAoKiBEZWNpZGUgd2hldGhlciBvciBub3QgdG8gbWFrZSB0aGUgcGxheWVyIHJlZWwgYWdhaW4gKilcclxuICAgIGFkdmFuY2VtZW50IDo9ICFhZHZhbmNlbWVudCArIDEgO1xyXG4gICAgbGV0IGJpdGVSb2xsID0gKHJuZ19vZiAhc2VlZCkgbW9kIDEwMCBpblxyXG4gICAgaWYgYml0ZVJvbGwgPCBtb3JlQVByZXNzZXMuKHJvZClcclxuICAgIHRoZW4gKHNlZWQgOj0gbmV4dF9zZWVkICFzZWVkIDsgIGFkdmFuY2VtZW50IDo9ICFhZHZhbmNlbWVudCArIDEpXHJcbiAgZW5kIDtcclxuICBzZWVkIDo9IG5leHRfc2VlZCAhc2VlZCA7XHJcbiAgbGV0IGZlZWJhc1Jlc3VsdCA9IChybmdfb2YgIXNlZWQpIG1vZCAxMDAgPCA1MCBpblxyXG4gIGlmIHJvdXRlMTE5ICYmIG5vdCBmZWViYXMgdGhlbiBhZHZhbmNlbWVudCA6PSAhYWR2YW5jZW1lbnQgKyAxIDtcclxuICAoYml0ZVJlc3VsdCwgZmVlYmFzUmVzdWx0LCAhYWR2YW5jZW1lbnQpXHJcblxyXG5sZXQgYmVzdF9zZWVkX2Zvcl9yb2Qgcm91dGUxMTkgZmVlYmFzIHRhcmdldF9zZWVkIHJvZCA9XHJcbiAgbGV0IG1heEFkZGl0aW9uYWxPZmZzZXRzID0gW3wwOzE7NHxdIGluXHJcbiAgbGV0IHN0YXJ0ID0gNyBpblxyXG4gIGxldCBiZXN0UmVzdWx0cyA9IHJlZiBOb25lIGluXHJcblxyXG4gIGxldCBzdGFydGluZ19zZWVkID0gcmVmIChwcmV2X3NlZWQgdGFyZ2V0X3NlZWQpIGluXHJcbiAgZm9yIF89MSB0byBzdGFydCArIDEgZG9cclxuICAgIHN0YXJ0aW5nX3NlZWQgOj0gcHJldl9zZWVkICFzdGFydGluZ19zZWVkXHJcbiAgZG9uZSA7XHJcblxyXG4gIGxldCBvZmZzZXQxMTkgPVxyXG4gICAgaWYgcm91dGUxMTkgJiYgbm90IGZlZWJhc1xyXG4gICAgdGhlbiAoc3RhcnRpbmdfc2VlZCA6PSBwcmV2X3NlZWQgIXN0YXJ0aW5nX3NlZWQgOyAxKVxyXG4gICAgZWxzZSAwXHJcbiAgaW5cclxuXHJcbiAgZm9yIGFkZGl0aW9uYWxPZmZzZXQ9MCB0byBtYXhBZGRpdGlvbmFsT2Zmc2V0cy4ocm9kKSBkb1xyXG4gICAgbGV0IChiaXRlUmVzdWx0LCBmZWViYXNSZXN1bHQsIGFkdmFuY2VtZW50KSA9XHJcbiAgICAgIGZpc2hpbmdfYXR0ZW1wdCByb3V0ZTExOSBmZWViYXMgIXN0YXJ0aW5nX3NlZWQgcm9kIHN0YXJ0IGluXHJcbiAgICBzdGFydGluZ19zZWVkIDo9IHByZXZfc2VlZCAhc3RhcnRpbmdfc2VlZCA7XHJcbiAgICBpZiBiaXRlUmVzdWx0IDwgMiAmJiAobm90IGZlZWJhcyB8fCBmZWViYXNSZXN1bHQpXHJcbiAgICAgICYmIHN0YXJ0ICsgMiArIGFkZGl0aW9uYWxPZmZzZXQgKyBvZmZzZXQxMTkgPSBhZHZhbmNlbWVudFxyXG4gICAgdGhlbiBiZWdpblxyXG4gICAgICBiZXN0UmVzdWx0cyA6PVxyXG4gICAgICAgIG1hdGNoICFiZXN0UmVzdWx0cyB3aXRoXHJcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgKGJpdGVSZXN1bHQsIGFkdmFuY2VtZW50LCBuZXh0X3NlZWQgIXN0YXJ0aW5nX3NlZWQpXHJcbiAgICAgICAgfCBTb21lIChiciwgYWR2LCBzKSB3aGVuIGJyID0gMCAmJiBiaXRlUmVzdWx0ID0gMSAtPiBTb21lIChiciwgYWR2LCBzKVxyXG4gICAgICAgIHwgU29tZSAoYnIsIGFkdiwgcykgd2hlbiBiciA9IGJpdGVSZXN1bHQgJiYgYWR2IDwgYWR2YW5jZW1lbnQgLT4gU29tZSAoYnIsIGFkdiwgcylcclxuICAgICAgICB8IF8gLT4gU29tZSAoYml0ZVJlc3VsdCwgYWR2YW5jZW1lbnQsIG5leHRfc2VlZCAhc3RhcnRpbmdfc2VlZClcclxuICAgIGVuZFxyXG4gIGRvbmUgO1xyXG4gICFiZXN0UmVzdWx0c1xyXG5cclxuKCogSW50ZXJmYWNlICopXHJcblxyXG5sZXQgbmV4dF9zZWVkIHNlZWQgPVxyXG4gIG5leHRfc2VlZCAoYmlnX2ludF9vZl91aW50MzIgc2VlZCkgfD4gdWludDMyX29mX2JpZ2ludFxyXG5cclxubGV0IHByZXZfc2VlZCBzZWVkID1cclxuICBwcmV2X3NlZWQgKGJpZ19pbnRfb2ZfdWludDMyIHNlZWQpIHw+IHVpbnQzMl9vZl9iaWdpbnRcclxuXHJcbmxldCBjeWNsZV90byBzZWVkID1cclxuICBjeWNsZV90byAoYmlnX2ludF9vZl91aW50MzIgc2VlZCkgfD4gdWludDMyX29mX2JpZ2ludFxyXG5cclxubGV0IHNlZWRfYXQgY3ljbGUgPVxyXG4gIHNlZWRfYXQgKGJpZ19pbnRfb2ZfdWludDMyIGN5Y2xlKSB8PiB1aW50MzJfb2ZfYmlnaW50XHJcblxyXG5sZXQgYmVzdF9zZWVkX2Zvcl9yb2Qgcm91dGUxMTkgZmVlYmFzIHRhcmdldF9zZWVkIHJvZCA9XHJcbiAgbWF0Y2ggYmVzdF9zZWVkX2Zvcl9yb2Qgcm91dGUxMTkgZmVlYmFzIChiaWdfaW50X29mX3VpbnQzMiB0YXJnZXRfc2VlZCkgcm9kIHdpdGhcclxuICB8IE5vbmUgLT4gTm9uZVxyXG4gIHwgU29tZSAoYixpLHMpIC0+IFNvbWUgKGI9MSxpLHVpbnQzMl9vZl9iaWdpbnQgcylcclxuIiwib3BlbiBTZWVkXG5cbnR5cGUgcmVzdWx0ID0gXG4gIHwgQ29udCBvZiAoRm9ybWF0LmZvcm1hdHRlciAtPiBzdHJpbmcgLT4gcmVzdWx0KVxuICB8IE5vQ29udFxuXG5sZXQgcmVjIG1haW4gZm10ID1cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiUGxlYXNlIGVudGVyIHlvdXIgc2VlZCAodXNlIDB4IHByZWZpeCBpZiBoZXhhZGVjaW1hbCk6IEA/XCIgO1xuICBDb250IG1haW5fMVxuXG5hbmQgbWFpbl8xIGZtdCBzdHIgPVxuICBsZXQgc2VlZCA9IFV0aWxzLnVpbnQzMl9vZl9zdHIgc3RyIGluXG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkRvIHlvdSB3YW50IHRvIG9idGFpbiB0aGlzIHNlZWQgdXNpbmcgdGhlIGZyZWV6ZSBQUk5HIEFDRSBjb2RlID9ALlwiIDtcbiAgRm9ybWF0LmZwcmludGYgZm10IFwiMS4gWWVzLCBmb3IgbWV0aG9kIEgxICh3aWxkIHBva2Vtb24pIHVzaW5nIHN3ZWV0IHNjZW50LkAuXCIgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIyLiBZZXMsIGZvciBtYXNzIG91dGJyZWFrcyAobWV0aG9kIEgxLCB1c2luZyBzd2VldCBzY2VudCkuQC5cIiA7XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIjMuIFllcywgZm9yIG1ldGhvZCBIMSAod2lsZCBwb2tlbW9uKSB1c2luZyBhIHJvZC5ALlwiIDtcbiAgRm9ybWF0LmZwcmludGYgZm10IFwiNC4gWWVzLCBmb3IgbWV0aG9kIDEgKHN0YXRpb25uYXJ5IHBva2Vtb24pLkAuXCIgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCI1LiBObywgYnV0IHBsZWFzZSBzaG93IG1lIHRoZSBzZWVkcyBpbiB0aGUgdmljaW5pdHkuQC5cIiA7XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIjYuIE5vIChxdWl0KS5ALlwiIDtcbiAgQ29udCAobWFpbl8yIHNlZWQpXG5cbmFuZCBzaG93X3ZpY2luaXR5IGZtdCBwcmludF9jeWNsZSBzZWVkIHN0YXJ0IHN0b3AgPVxuICBsZXQgY3ljbGUgPSBjeWNsZV90byBzZWVkIGluXG4gIGlmIHByaW50X2N5Y2xlIHRoZW4gRm9ybWF0LmZwcmludGYgZm10IFwiQ3ljbGUgZnJvbSBzZWVkIDA6ICVsdUAuXCIgY3ljbGUgO1xuICBsZXQgc3RhcnRfc2VlZCA9IHJlZiAoc2VlZF9hdCAoSW50MzIuYWRkIGN5Y2xlIChJbnQzMi5vZl9pbnQgc3RhcnQpKSkgaW5cbiAgZm9yIGkgPSBzdGFydCB0byBzdG9wIGRvXG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiJWk6ICVsdSAoJSNseClALlwiIGkgKCFzdGFydF9zZWVkKSAoIXN0YXJ0X3NlZWQpIDtcbiAgICBzdGFydF9zZWVkIDo9IG5leHRfc2VlZCAoIXN0YXJ0X3NlZWQpXG4gIGRvbmVcblxuYW5kIG1haW5fMiBzZWVkIGZtdCBzdHIgPVxuICBtYXRjaCBzdHIgd2l0aFxuICB8IFwiMVwiIC0+XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiWW91IHNob3VsZCB1c2UgdGhlIHNlZWQgJSNseCAoMiBjeWNsZXMgYmVmb3JlIHlvdXIgdGFyZ2V0KS5ALlwiXG4gICAgICAocHJldl9zZWVkIChwcmV2X3NlZWQgc2VlZCkpIDtcbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJZb3Ugc2hvdWxkIHVzZSBzd2VldCBzY2VudCBkaXJlY3RseSBhZnRlciB0cmlnZ2VyaW5nIHRoZSBBQ0UsXCIgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiB3aXRob3V0IGNsb3NpbmcgdGhlIHBva2Vtb24gbWVudS5ALlwiIDtcbiAgICBOb0NvbnRcbiAgfCBcIjJcIiAtPlxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIllvdSBzaG91bGQgdXNlIHRoZSBzZWVkICUjbHggKDEgY3ljbGUgYmVmb3JlIHlvdXIgdGFyZ2V0KS5ALlwiXG4gICAgICAocHJldl9zZWVkIHNlZWQpIDtcbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJZb3Ugc2hvdWxkIHVzZSBzd2VldCBzY2VudCBkaXJlY3RseSBhZnRlciB0cmlnZ2VyaW5nIHRoZSBBQ0UsXCIgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiB3aXRob3V0IGNsb3NpbmcgdGhlIHBva2Vtb24gbWVudS5ALlwiIDtcbiAgICBOb0NvbnRcbiAgfCBcIjNcIiAtPlxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIlBsZWFzZSBzZWxlY3QgeW91ciBjb25maWd1cmF0aW9uOkAuXCIgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIjEuIEkgd2lsbCBub3QgYmUgZmlzaGluZyBvbiByb3V0ZSAxMTkuQC5cIiA7XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiMi4gSSB3aWxsIGJlIGZpc2hpbmcgb24gcm91dGUgMTE5LCBidXQgbm90IGZvciBhIGZlZWJhcy5ALlwiIDtcbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIzLiBJIHdpbGwgYmUgZmlzaGluZyBmb3IgZmVlYmFzIG9uIGEgZmVlYmFzIHRpbGUuQC5cIiA7XG4gICAgQ29udCAobWFpbl8zIHNlZWQpXG4gIHwgXCI0XCIgLT5cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJGb3IgbW9zdCBsZWdlbmRhcmllcywgeW91IHNob3VsZCB1c2UgdGhlIHNlZWQgYXQgY3ljbGUgLTMuQC5cIiA7XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiUGxlYXNlIHJlZmVyIHRvIHRoZSBpbnN0cnVjdGlvbnMgb24gdGhlIGZyZWV6ZSBQUk5HIEFDRSBjb2RlIGZvciBvdGhlciBzdGF0aW9ubmFyeSBwb2tlbW9ucy5ALlwiIDtcbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJZb3Ugc2hvdWxkIHN0YXJ0IHRoZSBiYXR0bGUgYXMgc29vbiBhcyB5b3UgY2FuXCIgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiAoanVzdCBhZnRlciBoYXZpbmcgZXhlY3V0ZWQgdGhlIEFDRSBhbmQgY2xvc2VkIHRoZSBtZW51KS5ALlwiIDtcbiAgICBzaG93X3ZpY2luaXR5IGZtdCBmYWxzZSBzZWVkICgtMTApIDAgO1xuICAgIE5vQ29udFxuICB8IFwiNVwiIC0+XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiUGxlYXNlIGVudGVyIHRoZSByYW5nZSAoZXhhbXBsZTogLTI1IDUpOkAuXCIgO1xuICAgIENvbnQgKG1haW5fdmljaW5pdHkgc2VlZClcbiAgfCBfIC0+IE5vQ29udFxuXG5hbmQgbWFpbl92aWNpbml0eSBzZWVkIGZtdCBzdHIgPVxuICBsZXQgKHN0YXJ0LCBzdG9wKSA9IFNjYW5mLnNzY2FuZiBzdHIgXCIgJWkgJWlcIiAoZnVuIGkgaiAtPiAoaSwgaikpIGluXG4gIHNob3dfdmljaW5pdHkgZm10IHRydWUgc2VlZCBzdGFydCBzdG9wIDtcbiAgTm9Db250XG5cbmFuZCBtYWluXzMgc2VlZCBmbXQgc3RyID1cbiAgbGV0IChyb3V0ZTExOSwgZmVlYmFzKSA9XG4gICAgbWF0Y2ggc3RyIHdpdGhcbiAgICB8IFwiMVwiIC0+IChmYWxzZSwgZmFsc2UpXG4gICAgfCBcIjJcIiAtPiAodHJ1ZSwgZmFsc2UpXG4gICAgfCBcIjNcIiAtPiAodHJ1ZSwgdHJ1ZSlcbiAgICB8IF8gLT4gZmFpbHdpdGggXCJVbmtub3duIGFuc3dlci5cIlxuICBpblxuICBmb3Igcm9kID0gb2xkX3JvZCB0byBzdXBlcl9yb2QgZG9cbiAgICBsZXQgcm9kbmFtZSA9XG4gICAgICBtYXRjaCByb2Qgd2l0aFxuICAgICAgfCByIHdoZW4gcj1vbGRfcm9kIC0+IFwiT2xkIHJvZFwiXG4gICAgICB8IHIgd2hlbiByPWdvb2Rfcm9kIC0+IFwiR29vZCByb2RcIlxuICAgICAgfCByIHdoZW4gcj1zdXBlcl9yb2QgLT4gXCJTdXBlciByb2RcIlxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgIGluXG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiJXM6QC5cIiByb2RuYW1lIDtcbiAgICBtYXRjaCBiZXN0X3NlZWRfZm9yX3JvZCByb3V0ZTExOSBmZWViYXMgc2VlZCByb2Qgd2l0aFxuICAgIHwgTm9uZSAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCJcXHRObyBtYXRjaGVzIGZvdW5kQC5cIlxuICAgIHwgU29tZSAoZmFsc2UsIGFkdiwgc2VlZCkgLT5cbiAgICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIlxcdFdpdGggbGVhZDogTm8gbGVhZCBuZWNlc3NhcnlALlwiIDtcbiAgICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIlxcdFVzZSBzZWVkICUjbHggdG8gZ2VuZXJhdGUgdGFyZ2V0IG9uIGFkdmFuY2VtZW50ICVpQC5cIiBzZWVkIGFkdlxuICAgIHwgU29tZSAodHJ1ZSwgYWR2LCBzZWVkKSAtPlxuICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiXFx0V2l0aCBsZWFkOiBNdXN0IGhhdmUgU3VjdGlvbiBDdXAgb3IgU3RpY2t5IEhvbGQgbGVhZEAuXCIgO1xuICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiXFx0VXNlIHNlZWQgJSNseCB0byBnZW5lcmF0ZSB0YXJnZXQgb24gYWR2YW5jZW1lbnQgJWlALlwiIHNlZWQgYWR2XG4gIGRvbmUgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJZb3Ugc2hvdWxkIHVzZSB0aGUgcm9kIGRpcmVjdGx5IGFmdGVyIHRyaWdnZXJpbmcgdGhlIEFDRVwiIDtcbiAgRm9ybWF0LmZwcmludGYgZm10IFwiIChsZWF2ZSB0aGUgcG9rZW1vbiBtZW51IGFuZCBlbnRlciB0aGUgYmFnKS5ALlwiIDtcbiAgRm9ybWF0LmZwcmludGYgZm10IFwiVGhhbmtzIHRvIFNoYW8gZm9yIHRoaXMgc2NyaXB0LkAuXCIgO1xuICBOb0NvbnQiLCJcbmV4Y2VwdGlvbiBJbnZhbGlkU2F2ZVxuXG5sZXQgZ2FtZV9zYXZlX0EgPSAweDAwMDBcbmxldCBnYW1lX3NhdmVfQiA9IDB4RTAwMFxuXG5sZXQgc2VjdGlvbl9zaXplID0gMHgxMDAwXG5sZXQgbmJfc2VjdGlvbnMgPSAxNFxubGV0IHNlY3Rpb25faWRfb2Zmc2V0ID0gMHhGRjRcbmxldCBjaGVja3N1bV9vZmZzZXQgPSAweEZGNlxubGV0IHNhdmVfaW5kZXhfb2Zmc2V0ID0gMHhGRkNcblxubGV0IHBjX2J1ZmZlcnNfZGF0YV9zaXplID0gMzk2OFxubGV0IGJveF9uYW1lc19zZWN0aW9uX2lkID0gMTMgKCogUEMgYnVmZmVyIEkgKilcbmxldCBib3hfbmFtZXNfc2VjdGlvbl9kYXRhX2xlbmd0aCA9IDIwMDBcbmxldCBib3hfbmFtZXNfb2Zmc2V0ID0gMHg4MzQ0IC0gOCpwY19idWZmZXJzX2RhdGFfc2l6ZVxubGV0IGJveF9uYW1lc19sZW5ndGggPSAxMjZcblxubGV0IHRlYW1faXRlbXNfc2VjdGlvbl9pZCA9IDFcbmxldCB0ZWFtX2l0ZW1zX3NlY3Rpb25fZGF0YV9sZW5ndGggPSAzOTY4XG5sZXQgdGVhbV9zaXplX29mZnNldCA9IDB4MjM0XG5sZXQgdGVhbV9kYXRhX29mZnNldCA9IDB4MjM4XG5sZXQgcGttbl9kYXRhX3NpemUgPSAxMDBcblxubGV0IGFkZHJfb2Zfc2VjdGlvbiBpbmMgaWQgPVxuICBsZXQgcmJ1ZiA9IEJ5dGVzLmNyZWF0ZSBzZWN0aW9uX3NpemUgaW5cbiAgbGV0IHJlYyBhdXggYmFzZSBpID1cbiAgICBpZiBpID49IG5iX3NlY3Rpb25zXG4gICAgdGhlbiByYWlzZSBJbnZhbGlkU2F2ZVxuICAgIGVsc2VcbiAgICAgIGxldCBhZGRyID0gYmFzZSArIGkqc2VjdGlvbl9zaXplIGluXG4gICAgICBzZWVrX2luIGluYyBhZGRyIDsgcmVhbGx5X2lucHV0IGluYyByYnVmIDAgc2VjdGlvbl9zaXplIDtcbiAgICAgIGxldCBpZCcgPSBCeXRlcy5nZXRfdWludDE2X2xlIHJidWYgc2VjdGlvbl9pZF9vZmZzZXQgaW5cbiAgICAgIGxldCBpbmRleCA9IEJ5dGVzLmdldF9pbnQzMl9sZSByYnVmIHNhdmVfaW5kZXhfb2Zmc2V0IGluXG4gICAgICBpZiBpZCcgPSBpZFxuICAgICAgdGhlbiAoYWRkciwgaW5kZXgpXG4gICAgICBlbHNlIGF1eCBiYXNlIChpKzEpXG4gIGluXG4gIGxldCAoYWRkcmEsIGluZGV4YSkgPSBhdXggZ2FtZV9zYXZlX0EgMCBpblxuICBsZXQgKGFkZHJiLCBpbmRleGIpID0gYXV4IGdhbWVfc2F2ZV9CIDAgaW5cbiAgaWYgSW50MzIudW5zaWduZWRfY29tcGFyZSBpbmRleGEgaW5kZXhiIDwgMFxuICB0aGVuIGFkZHJiIGVsc2UgYWRkcmFcblxubGV0IHJlYWRfc2VjdGlvbiBpbmMgc2VjdGlvbl9pZCA9XG4gIGxldCBhZGRyID0gYWRkcl9vZl9zZWN0aW9uIGluYyBzZWN0aW9uX2lkIGluXG4gIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgc2VjdGlvbl9zaXplIGluXG4gIHNlZWtfaW4gaW5jIGFkZHIgOyByZWFsbHlfaW5wdXQgaW5jIHJlcyAwIHNlY3Rpb25fc2l6ZSA7XG4gIChhZGRyLCByZXMpXG5cbmxldCB3cml0ZV9zZWN0aW9uIG9jIGFkZHIgYnVmID1cbiAgc2Vla19vdXQgb2MgYWRkciA7IG91dHB1dF9ieXRlcyBvYyBidWYgOyBmbHVzaCBvY1xuXG5sZXQgbWFzazE2ID0gSW50MzIub2ZfaW50IDB4RkZGRlxuXG5sZXQgY29tcHV0ZV9jaGVja3N1bSBidWYgc3RhcnQgbGVuID1cbiAgbGV0IHJlYyBhdXggYWNjIGkgPVxuICAgIGlmIGkgPj0gc3RhcnQrbGVuXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlXG4gICAgICBsZXQgbmIgPSBCeXRlcy5nZXRfaW50MzJfbGUgYnVmIGkgaW5cbiAgICAgIGF1eCAoSW50MzIuYWRkIGFjYyBuYikgKGkrNClcbiAgaW5cbiAgbGV0IHN1bSA9IGF1eCBJbnQzMi56ZXJvIHN0YXJ0IGluXG4gIGxldCBoaWdoID0gSW50MzIuc2hpZnRfcmlnaHRfbG9naWNhbCBzdW0gMTYgaW5cbiAgbGV0IGxvdyA9IEludDMyLmxvZ2FuZCBzdW0gbWFzazE2IGluXG4gIGxldCByZXMgPSBJbnQzMi5hZGQgaGlnaCBsb3cgaW5cbiAgSW50MzIubG9nYW5kIHJlcyBtYXNrMTYgfD4gVXRpbHMudWludDMyX3RvX2ludFxuXG4oKiAtLS0tLSBCT1ggTkFNRVMgLS0tLS0gKilcblxubGV0IGV4dHJhY3RfYm94X25hbWVzX2Zyb21fc2VjdGlvbiBidWYgPVxuICBCeXRlcy5zdWIgYnVmIGJveF9uYW1lc19vZmZzZXQgYm94X25hbWVzX2xlbmd0aFxuXG5sZXQgdXBkYXRlX2JveF9uYW1lcyBidWYgYm94X25hbWVzID1cbiAgbGV0IGxlbiA9IEJ5dGVzLmxlbmd0aCBib3hfbmFtZXMgaW5cbiAgQnl0ZXMuYmxpdCBib3hfbmFtZXMgMCBidWYgYm94X25hbWVzX29mZnNldCBsZW4gO1xuICBsZXQgY2hlY2tzdW0gPSBjb21wdXRlX2NoZWNrc3VtIGJ1ZiAwIGJveF9uYW1lc19zZWN0aW9uX2RhdGFfbGVuZ3RoIGluXG4gIEJ5dGVzLnNldF91aW50MTZfbGUgYnVmIGNoZWNrc3VtX29mZnNldCBjaGVja3N1bVxuXG4oKiAtLS0tLSBURUFNIC0tLS0tICopXG5cbmxldCBlbXB0eV9wa21uICgpID1cbiAgQnl0ZXMuY3JlYXRlIHBrbW5fZGF0YV9zaXplXG5cbmxldCBleHRyYWN0X3RlYW1fZnJvbV9zZWN0aW9uIGJ1ZiA9XG4gICgqbGV0IG5iID0gQnl0ZXMuZ2V0X2ludDMyX2xlIGJ1ZiB0ZWFtX3NpemVfb2Zmc2V0IHw+IFV0aWxzLnVpbnQzMl90b19pbnQgaW5cbiAgbGV0IG5iID0gaWYgbmIgPiA2IHRoZW4gNiBlbHNlIG5iIGluKilcbiAgbGV0IG5iID0gNiBpblxuICBsZXQgcmVjIGV4dHJhY3RfcGttbnMgYWNjIGkgPVxuICAgIGlmIGkgPCAwIHRoZW4gYWNjXG4gICAgZWxzZSAoXG4gICAgICBsZXQgYWRkciA9IHRlYW1fZGF0YV9vZmZzZXQgKyBwa21uX2RhdGFfc2l6ZSppIGluXG4gICAgICBsZXQgcGttbiA9IEJ5dGVzLnN1YiBidWYgYWRkciBwa21uX2RhdGFfc2l6ZSBpblxuICAgICAgZXh0cmFjdF9wa21ucyAocGttbjo6YWNjKSAoaS0xKVxuICAgIClcbiAgaW5cbiAgZXh0cmFjdF9wa21ucyBbXSAobmItMSlcblxubGV0IHVwZGF0ZV90ZWFtIGJ1ZiBwa21ucyA9XG4gIGxldCBsZW4gPSBMaXN0Lmxlbmd0aCBwa21ucyB8PiBJbnQzMi5vZl9pbnQgaW5cbiAgQnl0ZXMuc2V0X2ludDMyX2xlIGJ1ZiB0ZWFtX3NpemVfb2Zmc2V0IGxlbiA7XG4gIGxldCB1cGRhdGVfcGttbiBpIHBrbW4gPVxuICAgIGxldCBhZGRyID0gdGVhbV9kYXRhX29mZnNldCArIHBrbW5fZGF0YV9zaXplKmkgaW5cbiAgICBCeXRlcy5ibGl0IHBrbW4gMCBidWYgYWRkciBwa21uX2RhdGFfc2l6ZVxuICBpblxuICBMaXN0Lml0ZXJpIHVwZGF0ZV9wa21uIHBrbW5zIDtcbiAgbGV0IGNoZWNrc3VtID0gY29tcHV0ZV9jaGVja3N1bSBidWYgMCB0ZWFtX2l0ZW1zX3NlY3Rpb25fZGF0YV9sZW5ndGggaW5cbiAgQnl0ZXMuc2V0X3VpbnQxNl9sZSBidWYgY2hlY2tzdW1fb2Zmc2V0IGNoZWNrc3VtXG4iLCJcbnR5cGUgdW5vcCA9IE9JZCB8IE9OZWcgfCBPTm90IHwgT0JOb3RcbnR5cGUgYmlub3AgPSBPQWRkIHwgT1N1YiB8IE9NdWwgfCBPRGl2IHwgT01vZFxuICAgICAgICAgICB8IE9BbmQgfCBPWG9yIHwgT09yIHwgT0xTaGlmdCB8IE9SU2hpZnRcbiAgICAgICAgICAgfCBPRXEgfCBPTmVxIHwgT0JPciB8IE9CQW5kXG5cbnR5cGUgbWV0YV9leHByID1cbiAgfCBNQ29uc3Qgb2YgaW50MzJcbiAgfCBNQmluYXJ5IG9mIGJpbm9wICogbWV0YV9leHByICogbWV0YV9leHByXG4gIHwgTVVuYXJ5IG9mIHVub3AgKiBtZXRhX2V4cHJcbiAgfCBNVmFyIG9mIHN0cmluZ1xuICB8IE1Db25kIG9mIG1ldGFfZXhwciAqIG1ldGFfZXhwciAqIG1ldGFfZXhwclxuXG50eXBlIGRlZl92YWwgPSBITm9uZSB8IEhTdHJpbmcgb2Ygc3RyaW5nIHwgSEludCBvZiBpbnQzMiB8IEhCb29sIG9mIGJvb2xcbnR5cGUgZGVmaW5pdGlvbiA9IFBhcmFtIG9mIHN0cmluZyAqIGRlZl92YWwgfCBWYXJEZWYgb2Ygc3RyaW5nICogYm9vbCAqIG1ldGFfZXhwclxudHlwZSBoZWFkZXJzID0gZGVmaW5pdGlvbiBsaXN0XG5cbm1vZHVsZSBTdHJNYXAgPSBNYXAuTWFrZShTdHJpbmcpXG50eXBlIGVudiA9IGludDMyIFN0ck1hcC50XG5leGNlcHRpb24gVmFyTm90Rm91bmQgb2Ygc3RyaW5nXG5cbmxldCBnZXRfcGFyYW0gaGVhZGVycyBuYW1lID1cbiAgbGV0IHJlYyBhdXggbHN0ID1cbiAgICBtYXRjaCBsc3Qgd2l0aFxuICAgIHwgW10gLT4gSE5vbmVcbiAgICB8IChWYXJEZWYgXyk6OmxzdCAtPiBhdXggbHN0XG4gICAgfCAoUGFyYW0gKG4sdikpOjpfIHdoZW4gU3RyaW5nLmVxdWFsIG4gbmFtZSAtPiB2XG4gICAgfCAoUGFyYW0gXyk6OmxzdCAtPiBhdXggbHN0XG4gIGluXG4gIGF1eCBoZWFkZXJzXG5cbmxldCBldmFsX3VuYXJ5IG9wIGkgPVxuICBtYXRjaCBvcCB3aXRoXG4gIHwgT0lkIC0+IGlcbiAgfCBPTmVnIC0+IEludDMyLm5lZyBpXG4gIHwgT05vdCAtPiBJbnQzMi5sb2dub3QgaVxuICB8IE9CTm90IC0+IGlmIEludDMyLmVxdWFsIGkgSW50MzIuemVybyB0aGVuIEludDMyLm9uZSBlbHNlIEludDMyLnplcm9cblxubGV0IGV2YWxfYmluYXJ5IG9wIGkxIGkyID1cbiAgbWF0Y2ggb3Agd2l0aFxuICB8IE9BZGQgLT4gSW50MzIuYWRkIGkxIGkyXG4gIHwgT1N1YiAtPiBJbnQzMi5zdWIgaTEgaTJcbiAgfCBPTXVsIC0+IEludDMyLm11bCBpMSBpMlxuICB8IE9EaXYgLT4gSW50MzIudW5zaWduZWRfZGl2IGkxIGkyXG4gIHwgT01vZCAtPiBJbnQzMi51bnNpZ25lZF9yZW0gaTEgaTJcbiAgfCBPQW5kIC0+IEludDMyLmxvZ2FuZCBpMSBpMlxuICB8IE9Yb3IgLT4gSW50MzIubG9neG9yIGkxIGkyXG4gIHwgT09yIC0+IEludDMyLmxvZ29yIGkxIGkyXG4gIHwgT0xTaGlmdCAtPiBJbnQzMi5zaGlmdF9sZWZ0IGkxIChVdGlscy51aW50MzJfdG9faW50IGkyKVxuICB8IE9SU2hpZnQgLT4gSW50MzIuc2hpZnRfcmlnaHRfbG9naWNhbCBpMSAoVXRpbHMudWludDMyX3RvX2ludCBpMilcbiAgfCBPRXEgLT4gaWYgSW50MzIuZXF1YWwgaTEgaTIgdGhlbiBJbnQzMi5vbmUgZWxzZSBJbnQzMi56ZXJvXG4gIHwgT05lcSAtPiBpZiBJbnQzMi5lcXVhbCBpMSBpMiB0aGVuIEludDMyLnplcm8gZWxzZSBJbnQzMi5vbmVcbiAgfCBPQk9yIC0+XG4gICAgaWYgSW50MzIuZXF1YWwgaTEgSW50MzIuemVybyAmJiBJbnQzMi5lcXVhbCBpMiBJbnQzMi56ZXJvXG4gICAgdGhlbiBJbnQzMi56ZXJvIGVsc2UgSW50MzIub25lXG4gIHwgT0JBbmQgLT5cbiAgICBpZiBJbnQzMi5lcXVhbCBpMSBJbnQzMi56ZXJvIHx8IEludDMyLmVxdWFsIGkyIEludDMyLnplcm9cbiAgICB0aGVuIEludDMyLnplcm8gZWxzZSBJbnQzMi5vbmVcblxubGV0IGV2YWxfbWV0YV9leHByIGVudiBlID1cbiAgbGV0IHJlYyBhdXggZSA9XG4gICAgbWF0Y2ggZSB3aXRoXG4gICAgfCBNQ29uc3QgaSAtPiBpXG4gICAgfCBNVmFyIHN0ciAtPlxuICAgICAgaWYgU3RyTWFwLm1lbSBzdHIgZW52XG4gICAgICB0aGVuIFN0ck1hcC5maW5kIHN0ciBlbnZcbiAgICAgIGVsc2UgcmFpc2UgKFZhck5vdEZvdW5kIHN0cilcbiAgICB8IE1VbmFyeSAob3AsIGUpIC0+XG4gICAgICBsZXQgaSA9IGF1eCBlIGluXG4gICAgICBldmFsX3VuYXJ5IG9wIGlcbiAgICB8IE1CaW5hcnkgKG9wLCBlMSwgZTIpIC0+XG4gICAgICBsZXQgaTEgPSBhdXggZTEgYW5kIGkyID0gYXV4IGUyIGluXG4gICAgICBldmFsX2JpbmFyeSBvcCBpMSBpMlxuICAgIHwgTUNvbmQgKGUwLCBlMSwgZTIpIC0+XG4gICAgICBsZXQgaTAgPSBhdXggZTAgaW5cbiAgICAgIGlmIEludDMyLmVxdWFsIGkwIEludDMyLnplcm8gdGhlbiBhdXggZTIgZWxzZSBhdXggZTFcbiAgaW5cbiAgYXV4IGVcblxubGV0IGVtcHR5X2VudiA9IFN0ck1hcC5lbXB0eVxuXG5sZXQgZW52X2Zyb21faGVhZGVycyBmbXQgaGVhZGVycyA9XG4gIGxldCB0cmVhdF9kZWYgKHByaW50ZWQsIGFjYykgZGVmID1cbiAgICBtYXRjaCBkZWYgd2l0aFxuICAgIHwgUGFyYW0gXyAtPiAocHJpbnRlZCwgYWNjKVxuICAgIHwgVmFyRGVmIChzdHIsIHByaW50LCBleHByKSAtPlxuICAgICAgbGV0IGkgPSBldmFsX21ldGFfZXhwciBhY2MgZXhwciBpblxuICAgICAgaWYgcHJpbnQgdGhlbiBGb3JtYXQuZnByaW50ZiBmbXQgXCIlcyA9ICVsaSAoJSNseClALlwiIHN0ciBpIGkgO1xuICAgICAgKHByaW50ZWQgfHwgcHJpbnQsIFN0ck1hcC5hZGQgc3RyIGkgYWNjKVxuICBpblxuICBsZXQgKHByaW50ZWQsIHJlcykgPVxuICAgIExpc3QuZm9sZF9sZWZ0IHRyZWF0X2RlZiAoZmFsc2UsIFN0ck1hcC5lbXB0eSkgaGVhZGVycyBpblxuICBpZiBwcmludGVkIHRoZW4gRm9ybWF0LmZwcmludGYgZm10IFwiQC5cIiA7IHJlc1xuXG5sZXQgY29uY2F0X2VudiBlbnYxIGVudjIgPVxuICBTdHJNYXAuZm9sZCAoZnVuIGsgdiBhY2MgLT4gU3RyTWFwLmFkZCBrIHYgYWNjKSBlbnYyIGVudjFcbiIsIlxudHlwZSByZXN1bHQgPSBcbiAgfCBDb250IG9mIChGb3JtYXQuZm9ybWF0dGVyIC0+IHN0cmluZyAtPiByZXN1bHQpXG4gIHwgTm9Db250XG5cbmxldCByZWMgbWFpbiBmbXQgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJQbGVhc2UgZW50ZXIgbG93LVBJRDogQD9cIiA7XG4gIENvbnQgbWFpbl8xXG5cbmFuZCBtYWluXzEgZm10IHN0ciA9XG4gIGxldCBscGlkID0gU2NhbmYuc3NjYW5mIHN0ciBcIiAlbGlcIiAoZnVuIGkgLT4gaSkgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiUGxlYXNlIGVudGVyIGhpZ2gtUElEOiBAP1wiIDtcbiAgQ29udCAobWFpbl8yIGxwaWQpXG5cbmFuZCBtYWluXzIgbHBpZCBmbXQgc3RyID1cbiAgbGV0IGhwaWQgPSBTY2FuZi5zc2NhbmYgc3RyIFwiICVsaVwiIChmdW4gaSAtPiBpKSBpblxuICBsZXQgcGlkID0gU3RydWN0dXJlLmludDMyX2Zyb21fbG93X2hpZ2ggbHBpZCBocGlkIGluXG5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiUGxlYXNlIGVudGVyIG9yaWdpbmFsIHRyYWluZXIgdmlzaWJsZSBUSUQ6IEA/XCIgO1xuICBDb250IChtYWluXzMgcGlkKVxuXG5hbmQgbWFpbl8zIHBpZCBmbXQgc3RyID1cbiAgbGV0IHZpZCA9IFNjYW5mLnNzY2FuZiBzdHIgXCIgJWxpXCIgKGZ1biBpIC0+IGkpIGluXG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIlBsZWFzZSBlbnRlciBvcmlnaW5hbCB0cmFpbmVyIHNlY3JldCBUSUQ6IEA/XCIgO1xuICBDb250IChtYWluXzQgcGlkIHZpZClcblxuYW5kIG1haW5fNCBwaWQgdmlkIGZtdCBzdHIgPVxuICBsZXQgc2lkID0gU2NhbmYuc3NjYW5mIHN0ciBcIiAlbGlcIiAoZnVuIGkgLT4gaSkgaW5cbiAgbGV0IHRpZCA9IFN0cnVjdHVyZS5pbnQzMl9mcm9tX2xvd19oaWdoIHZpZCBzaWQgaW5cblxuICBsZXQgcGttbiA9IHsgU3RydWN0dXJlLnBpZD1waWQgOyBTdHJ1Y3R1cmUub3RpZD10aWQgfSBpblxuICBsZXQgbWlzY19wb3MgPSBTdHJ1Y3R1cmUuc3Vic3RydWN0dXJlX3Bvc2l0aW9uIHBrbW4gJ00nIGluXG4gIGxldCBpdmVhX29mZnNldCA9IFN0cnVjdHVyZS5pdmVhX29mZnNldCBwa21uIGluXG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIk1pc2Mgc3Vic3RydWN0dXJlIHBvc2l0aW9uOiAlZEAuXCIgKG1pc2NfcG9zKzEpIDtcbiAgRm9ybWF0LmZwcmludGYgZm10IFwiSVZFQSBvZmZzZXQ6ICUjeEAuXCIgaXZlYV9vZmZzZXQgO1xuXG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIlBsZWFzZSBlbnRlciBsb3ctSVZFQTogQD9cIiA7XG4gIENvbnQgKG1haW5fNSBwa21uKVxuXG5hbmQgbWFpbl81IHBrbW4gZm10IHN0ciA9XG4gIGxldCBsaXZlYSA9IFNjYW5mLnNzY2FuZiBzdHIgXCIgJWxpXCIgKGZ1biBpIC0+IGkpIGluXG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIlBsZWFzZSBlbnRlciBoaWdoLUlWRUE6IEA/XCIgO1xuICBDb250IChtYWluXzYgcGttbiBsaXZlYSlcblxuYW5kIG1haW5fNiBwa21uIGxpdmVhIGZtdCBzdHIgPVxuICBsZXQgaGl2ZWEgPSBTY2FuZi5zc2NhbmYgc3RyIFwiICVsaVwiIChmdW4gaSAtPiBpKSBpblxuICBsZXQgaXZlYSA9IFN0cnVjdHVyZS5pbnQzMl9mcm9tX2xvd19oaWdoIGxpdmVhIGhpdmVhIGluXG4gIGxldCB1aXZlYSA9IFN0cnVjdHVyZS5kZWNyeXB0X2FsaWduZWRfaW50MzIgcGttbiBpdmVhIGluXG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIlVuZW5jcnlwdGVkIElWRUEgZGF0YTogJSNseEAuXCIgdWl2ZWEgO1xuICBsZXQgKGhwLCBhdGssIGRlZiwgc3BlZWQsIHNwX2F0aywgc3BfZGVmLCBkYXRhKSA9IFN0cnVjdHVyZS5pdmVhX2RhdGFfdG9faXZzIHVpdmVhIGluXG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIlBva2Vtb24gSVZzIChocCBhdGsgZGVmIHNwZWVkIHNwX2F0ayBzcF9kZWYpOiAlbGQgJWxkICVsZCAlbGQgJWxkICVsZEAuXCJcbiAgICBocCBhdGsgZGVmIHNwZWVkIHNwX2F0ayBzcF9kZWYgO1xuXG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIk1heGluZyBJVnMuLi5ALlwiIDtcbiAgbGV0IGl2ID0gSW50MzIub2ZfaW50IDMxIGluXG4gIGxldCB1aXZlYScgPSBTdHJ1Y3R1cmUuaXZzX3RvX2l2ZWFfZGF0YSAoaXYsIGl2LCBpdiwgaXYsIGl2LCBpdiwgZGF0YSkgaW5cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiTmV3IHVuZW5jcnlwdGVkIElWRUEgZGF0YTogJSNseEAuXCIgdWl2ZWEnIDtcbiAgbGV0IGl2ZWEgPSBTdHJ1Y3R1cmUuZW5jcnlwdF9hbGlnbmVkX2ludDMyIHBrbW4gdWl2ZWEnIGluXG4gIGxldCAobGl2ZWEsIGhpdmVhKSA9IFN0cnVjdHVyZS5pbnQzMl90b19sb3dfaGlnaCBpdmVhIGluXG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIk5ldyBsb3ctSVZFQTogJSNseEAuXCIgbGl2ZWEgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJOZXcgaGlnaC1JVkVBOiAlI2x4QC5cIiBoaXZlYSA7XG4gIGxldCBjaGVja3N1bV9kaWZmID0gU3RydWN0dXJlLmNoZWNrc3VtX2RpZmZfZm9yX2FsaWduZWRfaW50MzIgdWl2ZWEgdWl2ZWEnIGluXG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkNoZWNrc3VtIGRpZmY6ICUjbHhALlwiIGNoZWNrc3VtX2RpZmYgO1xuICBOb0NvbnRcbiIsIlxudHlwZSBzaWduID0gaW50XG5cbnR5cGUgcmVnaXN0ZXIgPSBpbnRcblxudHlwZSBjb25kaXRpb25hbCA9IEVRIHwgTkUgfCBDUyB8IEhTIHwgQ0MgfCBMTyB8IE1JIHwgUEwgXG4gICAgICAgICAgICAgICAgIHwgVlMgfCBWQyB8IEhJIHwgTFMgfCBHRSB8IExUIHwgR1QgfCBMRSB8IEFMXG50eXBlIGxkcl9zdHJfdHlwZSA9IEIgfCBTQiB8IEggfCBTSCB8IFcgfCBUIHwgQlRcbnR5cGUgYWRkcmVzc2luZ190eXBlID0gT2Zmc2V0IHwgUHJlSW5kZXhlZCB8IFBvc3RJbmRleGVkXG5cbnR5cGUgc2NhbGVfdHlwZSA9IExTTCBvZiBpbnQgfCBMU1Igb2YgaW50IHwgQVNSIG9mIGludCB8IFJPUiBvZiBpbnQgfCBSUlhcbnR5cGUgb3BlcmFuZCA9IEltbWVkaWF0ZSBvZiBpbnQzMiB8IFJlZ2lzdGVyIG9mIHJlZ2lzdGVyIHwgU2NhbGVkUmVnaXN0ZXIgb2YgcmVnaXN0ZXIgKiBzY2FsZV90eXBlXG50eXBlIHJlZ2lzdGVyX29mZnNldCA9IE9JbW1lZGlhdGUgb2YgcmVnaXN0ZXIgKiBzaWduICogaW50MzIgfCBPUmVnaXN0ZXIgb2YgcmVnaXN0ZXIgKiBzaWduICogcmVnaXN0ZXIgfCBPU2NhbGVkUmVnaXN0ZXIgb2YgcmVnaXN0ZXIgKiBzaWduICogcmVnaXN0ZXIgKiBzY2FsZV90eXBlXG5cbnR5cGUgZGF0YV9wcm9jX2luc3RyID0gQURDIHwgU0JDIHwgQklDIHwgQU5EICgqIGZvciBKUDogKikgfCBBREQgfCBTVUIgfCBPUlIgfCBFT1JcbnR5cGUgbW92X2luc3RyID0gTU9WIHwgTVZOXG50eXBlIG1lbV9pbnN0ciA9IExEUiB8IFNUUlxuXG50eXBlIGFybSA9XG4gIHwgQ3VzdG9tIG9mIGludDMyXG4gIHwgTWVtIG9mIHsgaW5zdHI6IG1lbV9pbnN0ciA7IHR5cDogbGRyX3N0cl90eXBlIDsgY29uZDogY29uZGl0aW9uYWwgOyByZDogcmVnaXN0ZXIgOyBybzogcmVnaXN0ZXJfb2Zmc2V0ICogYWRkcmVzc2luZ190eXBlIH1cbiAgfCBNb3Ygb2YgeyBpbnN0cjogbW92X2luc3RyIDsgczpib29sIDsgY29uZDogY29uZGl0aW9uYWwgOyByZDogcmVnaXN0ZXIgOyByczogb3BlcmFuZCB9XG4gIHwgRGF0YVByb2Mgb2YgeyBpbnN0cjogZGF0YV9wcm9jX2luc3RyIDsgczpib29sIDsgY29uZDogY29uZGl0aW9uYWwgOyByZDogcmVnaXN0ZXIgOyBybjogcmVnaXN0ZXIgOyBvcDI6IG9wZXJhbmQgfVxuICB8IEJyYW5jaCBvZiB7IGw6Ym9vbCA7IGNvbmQ6IGNvbmRpdGlvbmFsIDsgdGFyZ2V0OiBpbnQzMiB9XG4gIHwgQnJhbmNoWCBvZiB7IGw6Ym9vbCA7IGNvbmQ6IGNvbmRpdGlvbmFsIDsgcm06IHJlZ2lzdGVyIH1cbiAgKCogQkxYX2ltbSBpcyBub3Qgc3VwcG9ydGVkIHlldCAqKVxuXG5vcGVuIEludDMyXG5cbmV4Y2VwdGlvbiBJbnZhbGlkQ29tbWFuZFxuXG5sZXQgYTEgPSAwXG5sZXQgYTIgPSAxXG5sZXQgYTMgPSAyXG5sZXQgYTQgPSAzXG5sZXQgdjEgPSA0XG5sZXQgdjIgPSA1XG5sZXQgdjMgPSA2XG5sZXQgdjQgPSA3XG5sZXQgdjUgPSA4XG5sZXQgdjYgPSA5XG5sZXQgdjcgPSAxMFxubGV0IHY4ID0gMTFcbmxldCBzYiA9IDlcbmxldCBzbCA9IDEwXG5sZXQgZnAgPSAxMVxubGV0IGlwID0gMTJcbmxldCBzcCA9IDEzXG5sZXQgbHIgPSAxNFxubGV0IHBjID0gMTVcblxubGV0IHNpZ25fcGx1cyA9IDFcbmxldCBzaWduX21pbnVzID0gMFxuXG5sZXQgaW50MSA9IDBiMVxubGV0IG1hc2sxID0gaW50MSB8PiBvZl9pbnRcbmxldCBpbnQyID0gMGIxMVxubGV0IG1hc2syID0gaW50MiB8PiBvZl9pbnRcbmxldCBpbnQ0ID0gMGIxMTExXG5sZXQgbWFzazQgPSBpbnQ0IHw+IG9mX2ludFxubGV0IGludDggPSAwYjExMTExMTExXG5sZXQgbWFzazggPSBpbnQ4IHw+IG9mX2ludFxubGV0IGludDkgPSAwYjExMTExMTExMVxubGV0IG1hc2s5ID0gaW50OSB8PiBvZl9pbnRcbmxldCBpbnQxMiA9IDBiMTExMTExMTExMTExXG5sZXQgbWFzazEyID0gaW50MTIgfD4gb2ZfaW50XG5sZXQgaW50MjQgPSAwYjExMTExMTExMTExMV8xMTExMTExMTExMTFcbmxldCBtYXNrMjQgPSBpbnQyNCB8PiBvZl9pbnRcblxubGV0IGNvbmRpdGlvbl9jb2RlIGMgPVxuICBiZWdpbiBtYXRjaCBjIHdpdGhcbiAgfCBFUSAtPiAwYjAwMDAgfCBORSAtPiAwYjAwMDEgfCBDUyB8IEhTIC0+IDBiMDAxMCB8IENDIHwgTE8gLT4gMGIwMDExXG4gIHwgTUkgLT4gMGIwMTAwIHwgUEwgLT4gMGIwMTAxIHwgVlMgLT4gMGIwMTEwIHwgVkMgLT4gMGIwMTExXG4gIHwgSEkgLT4gMGIxMDAwIHwgTFMgLT4gMGIxMDAxIHwgR0UgLT4gMGIxMDEwIHwgTFQgLT4gMGIxMDExIHwgR1QgLT4gMGIxMTAwIHwgTEUgLT4gMGIxMTAxIHwgQUwgLT4gMGIxMTEwXG4gIGVuZFxuICB8PiBvZl9pbnRcblxubGV0IGFkZF9jb25kaXRpb25fY29kZSBjIHYgPVxuICBzaGlmdF9sZWZ0IChjb25kaXRpb25fY29kZSBjKSAyOFxuICB8PiBsb2dvciB2XG5cbmxldCBhZGRfcm5fY29kZSBybiB2ID1cbiAgc2hpZnRfbGVmdCAob2ZfaW50IHJuKSAxNlxuICB8PiBsb2dvciB2XG5cbmxldCBhZGRfcmRfY29kZSByZCB2ID1cbiAgc2hpZnRfbGVmdCAob2ZfaW50IHJkKSAxMlxuICB8PiBsb2dvciB2XG5cbmxldCBhZGRfcm1fY29kZSBybSB2ID1cbiAgb2ZfaW50IHJtXG4gIHw+IGxvZ29yIHZcblxubGV0IHJlZ2lzdGVyX29mX3JlZ2lzdGVyX29mZnNldCBybyA9XG4gIG1hdGNoIHJvIHdpdGhcbiAgfCBPSW1tZWRpYXRlIChyLCBfLCBfKSB8IE9SZWdpc3RlciAociwgXywgXykgfCBPU2NhbGVkUmVnaXN0ZXIgKHIsIF8sIF8sIF8pIC0+IHJcblxubGV0IHJvdGF0ZV9yaWdodCB2ID1cbiAgbGV0IGxiID0gbG9nYW5kIHYgbWFzazEgaW5cbiAgbGV0IHYgPSBzaGlmdF9yaWdodF9sb2dpY2FsIHYgMSBpblxuICBsb2dvciB2IChzaGlmdF9sZWZ0IGxiIDMxKVxuXG5sZXQgcm90YXRlX2xlZnQgdiA9XG4gIGxldCBoYiA9IGxvZ2FuZCB2IChzaGlmdF9sZWZ0IG1hc2sxIDMxKSBpblxuICBsZXQgdiA9IHNoaWZ0X2xlZnQgdiAxIGluXG4gIGxvZ29yIHYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgaGIgMzEpXG5cbmxldCBkZWNvbXBvc2VfaW1tZWRpYXRlIGltbSA9XG4gIGxldCByZWMgYXV4IG4gaW1tID1cbiAgICBpZiBuID4gaW50NCB0aGVuIFtdXG4gICAgZWxzZVxuICAgICAgbGV0IG90aGVycyA9IGF1eCAobisxKSAocm90YXRlX2xlZnQgKHJvdGF0ZV9sZWZ0IGltbSkpIGluXG4gICAgICBsZXQgaW1tOCA9IGxvZ2FuZCBpbW0gbWFzazggaW5cbiAgICAgIGlmIGVxdWFsIGltbTggaW1tIHRoZW4gKG4sIGltbTgpOjpvdGhlcnMgZWxzZSBvdGhlcnNcbiAgaW5cbiAgbGV0IHJlcyA9IGF1eCAwIGltbSBpblxuICBpZiByZXMgPSBbXSB0aGVuIHJhaXNlIEludmFsaWRDb21tYW5kIGVsc2UgcmVzXG5cbmxldCBhZGRyX21vZGVfMSBycyA9XG4gIGxldCBwb3NzaWJpbGl0aWVzID1cbiAgICBtYXRjaCBycyB3aXRoXG4gICAgfCBJbW1lZGlhdGUgaSAtPlxuICAgICAgZGVjb21wb3NlX2ltbWVkaWF0ZSBpXG4gICAgICB8PiBMaXN0Lm1hcCAoZnVuIChyciwgaW1tOCkgLT5cbiAgICAgICAgKDEsIGxvZ29yIGltbTggKHNoaWZ0X2xlZnQgKG9mX2ludCBycikgOCkpXG4gICAgICApXG4gICAgfCBSZWdpc3RlciAocm0pIC0+XG4gICAgICBbKDAsIG9mX2ludCBybSldXG4gICAgfCBTY2FsZWRSZWdpc3RlciBfIC0+IGZhaWx3aXRoIFwiTm90IGltcGxlbWVudGVkXCJcbiAgaW5cbiAgcG9zc2liaWxpdGllcyB8PlxuICBMaXN0Lm1hcCAoZnVuIChpbW0sIHYpIC0+XG4gICAgbGV0IGkgPSBzaGlmdF9sZWZ0IChvZl9pbnQgaW1tKSAyNSBpblxuICAgIGxvZ29yIHYgaVxuICApXG5cbmxldCBwX2FuZF93IGFkZHJfdHlwID1cbiAgbWF0Y2ggYWRkcl90eXAgd2l0aFxuICB8IE9mZnNldCAtPiAoMSwwKVxuICB8IFByZUluZGV4ZWQgLT4gKDEsMSlcbiAgfCBQb3N0SW5kZXhlZCAtPiAoMCwwKVxuXG5sZXQgYWRkcl9tb2RlXzIgcm8gYWRkcl90eXAgPSAoKiBMb2FkIGFuZCBzdG9yZSBvZiB3b3JkIGFuZCB1Ynl0ZSAqKVxuICBsZXQgKHNpZ24sIHJlZywgdikgPVxuICAgIG1hdGNoIHJvIHdpdGhcbiAgICB8IE9JbW1lZGlhdGUgKF8sIHNpZ24sIHYpIC0+XG4gICAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHYgbWFzazEyID4gMCB0aGVuIHJhaXNlIEludmFsaWRDb21tYW5kIDtcbiAgICAgIChzaWduLCAwLCB2KVxuICAgIHwgT1JlZ2lzdGVyIChfLCBzaWduLCBybSkgLT5cbiAgICAgIChzaWduLCAxLCBvZl9pbnQgcm0pXG4gICAgfCBPU2NhbGVkUmVnaXN0ZXIgXyAtPiBmYWlsd2l0aCBcIk5vdCBpbXBsZW1lbnRlZFwiXG4gIGluXG4gIGxldCAocCwgdykgPSBwX2FuZF93IGFkZHJfdHlwIGluXG4gIGxldCBpID0gc2hpZnRfbGVmdCAob2ZfaW50IHJlZykgMjUgaW5cbiAgbGV0IHUgPSBzaGlmdF9sZWZ0IChvZl9pbnQgc2lnbikgMjMgaW5cbiAgbGV0IHAgPSBzaGlmdF9sZWZ0IChvZl9pbnQgcCkgMjQgaW5cbiAgbGV0IHcgPSBzaGlmdF9sZWZ0IChvZl9pbnQgdykgMjEgaW5cbiAgbG9nb3IgdiB1IHw+IGxvZ29yIHAgfD4gbG9nb3IgdyB8PiBsb2dvciBpXG5cbmxldCBhZGRyX21vZGVfMyBybyBhZGRyX3R5cCA9ICgqIE90aGVyIGxvYWQgYW5kIHN0b3JlICopXG4gIGxldCAoc2lnbiwgaW1tLCB2KSA9XG4gICAgbWF0Y2ggcm8gd2l0aFxuICAgIHwgT0ltbWVkaWF0ZSAoXywgc2lnbiwgdikgLT5cbiAgICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgdiBtYXNrOCA+IDAgdGhlbiByYWlzZSBJbnZhbGlkQ29tbWFuZCA7XG4gICAgICBsZXQgaW1tZWRMID0gbG9nYW5kIG1hc2s0IHYgaW5cbiAgICAgIGxldCBpbW1lZEggPSBsb2dhbmQgbWFzazQgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgdiA0KSBpblxuICAgICAgKHNpZ24sIDEsIGxvZ29yIGltbWVkTCAoc2hpZnRfbGVmdCBpbW1lZEggOCkpXG4gICAgfCBPUmVnaXN0ZXIgKF8sIHNpZ24sIHJtKSAtPlxuICAgICAgKHNpZ24sIDAsIG9mX2ludCBybSlcbiAgICB8IE9TY2FsZWRSZWdpc3RlciBfIC0+IHJhaXNlIEludmFsaWRDb21tYW5kXG4gIGluXG4gIGxldCAocCwgdykgPSBwX2FuZF93IGFkZHJfdHlwIGluXG4gIGxldCBpID0gc2hpZnRfbGVmdCAob2ZfaW50IGltbSkgMjIgaW5cbiAgbGV0IHUgPSBzaGlmdF9sZWZ0IChvZl9pbnQgc2lnbikgMjMgaW5cbiAgbGV0IHAgPSBzaGlmdF9sZWZ0IChvZl9pbnQgcCkgMjQgaW5cbiAgbGV0IHcgPSBzaGlmdF9sZWZ0IChvZl9pbnQgdykgMjEgaW5cbiAgbG9nb3IgdiB1IHw+IGxvZ29yIHAgfD4gbG9nb3IgdyB8PiBsb2dvciBpXG5cbmxldCBzaWduZWRfaW1tZWQyNCBpID1cbiAgaWYgZXF1YWwgKGxvZ2FuZCBpIG1hc2syKSB6ZXJvXG4gIHRoZW5cbiAgICBsZXQgaSA9IHNoaWZ0X3JpZ2h0IGkgMiBpblxuICAgIGxldCBtczkgPSBzaGlmdF9yaWdodF9sb2dpY2FsIGkgMjMgaW5cbiAgICBpZiBlcXVhbCBtczkgbWFzazkgfHwgZXF1YWwgbXM5IHplcm9cbiAgICB0aGVuIGxvZ2FuZCBpIG1hc2syNFxuICAgIGVsc2UgcmFpc2UgSW52YWxpZENvbW1hbmRcbiAgZWxzZSByYWlzZSBJbnZhbGlkQ29tbWFuZFxuXG5sZXQgbGRyX3N0cl90b19iaW5hcnkgaW5zdHIgdHlwIGNvbmQgcmQgKHJuLCBhZGRyX3R5cCkgPVxuICBsZXQgY2hlY2tfcG9zdF9hZGRyICgpID1cbiAgICBtYXRjaCBhZGRyX3R5cCB3aXRoXG4gICAgfCBQb3N0SW5kZXhlZCAtPiAoKVxuICAgIHwgXyAtPiByYWlzZSBJbnZhbGlkQ29tbWFuZFxuICBpblxuICBsZXQgb3Bjb2RlID0gbWF0Y2ggaW5zdHIsIHR5cCB3aXRoXG4gIHwgTERSLCBCICAtPiAwYjAxMDBfMDEwMV8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgfCBMRFIsIFNCIC0+IDBiMDAwMF8wMDAxXzAwMDBfMDAwMF8wMDAwXzExMDFfMDAwMFxuICB8IExEUiwgSCAgLT4gMGIwMDAwXzAwMDFfMDAwMF8wMDAwXzAwMDBfMTAxMV8wMDAwXG4gIHwgTERSLCBTSCAtPiAwYjAwMDBfMDAwMV8wMDAwXzAwMDBfMDAwMF8xMTExXzAwMDBcbiAgfCBMRFIsIFcgIC0+IDBiMDEwMF8wMDAxXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IExEUiwgVCAgLT4gY2hlY2tfcG9zdF9hZGRyICgpIDsgMGIwMTAwXzAwMTFfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIHwgTERSLCBCVCAtPiBjaGVja19wb3N0X2FkZHIgKCkgOyAwYjAxMDBfMDExMV8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgfCBTVFIsIEIgIC0+IDBiMDEwMF8wMTAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IFNUUiwgU0IgLT4gcmFpc2UgSW52YWxpZENvbW1hbmRcbiAgfCBTVFIsIEggIC0+IDBiMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzEwMTFfMDAwMFxuICB8IFNUUiwgU0ggLT4gcmFpc2UgSW52YWxpZENvbW1hbmRcbiAgfCBTVFIsIFcgIC0+IDBiMDEwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IFNUUiwgVCAgLT4gY2hlY2tfcG9zdF9hZGRyICgpIDsgMGIwMTAwXzAwMTBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIHwgU1RSLCBCVCAtPiBjaGVja19wb3N0X2FkZHIgKCkgOyAwYjAxMDBfMDExMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgaW5cbiAgbGV0IHYgPSBvZl9pbnQgb3Bjb2RlIHw+XG4gICAgYWRkX2NvbmRpdGlvbl9jb2RlIGNvbmQgfD5cbiAgICBhZGRfcm5fY29kZSAocmVnaXN0ZXJfb2ZfcmVnaXN0ZXJfb2Zmc2V0IHJuKSB8PlxuICAgIGFkZF9yZF9jb2RlIHJkIGluXG4gIGxldCBhZGRyX21vZGUgPVxuICAgIG1hdGNoIHR5cCB3aXRoXG4gICAgfCBCIHwgVyB8IFQgfCBCVCAtPiBhZGRyX21vZGVfMiBybiBhZGRyX3R5cFxuICAgIHwgSCB8IFNIIHwgU0IgLT4gYWRkcl9tb2RlXzMgcm4gYWRkcl90eXBcbiAgaW5cbiAgW2xvZ29yIHYgYWRkcl9tb2RlXVxuXG5sZXQgbW92X212bl90b19iaW5hcnkgaW5zdHIgcyBjb25kIHJkIHJzID1cbiAgbGV0IG9wY29kZSA9IG1hdGNoIGluc3RyIHdpdGhcbiAgfCBNT1YgLT4gMGIwMDAxXzEwMTBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIHwgTVZOIC0+IDBiMDAwMV8xMTEwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMCBpblxuICBsZXQgc2NvZGUgPSBpZiBzIHRoZW4gMSBlbHNlIDAgaW5cbiAgbGV0IHNjb2RlID0gc2hpZnRfbGVmdCAob2ZfaW50IHNjb2RlKSAyMCBpblxuICBsZXQgdiA9IG9mX2ludCBvcGNvZGUgfD5cbiAgICBhZGRfY29uZGl0aW9uX2NvZGUgY29uZCB8PlxuICAgIGFkZF9yZF9jb2RlIHJkIHw+XG4gICAgbG9nb3Igc2NvZGUgaW5cbiAgYWRkcl9tb2RlXzEgcnMgfD5cbiAgTGlzdC5tYXAgKGZ1biBhZGRyX21vZGUgLT4gbG9nb3IgdiBhZGRyX21vZGUpXG5cbmxldCBjYWxjdWxhdGlvbl90b19iaW5hcnkgaW5zdHIgcyBjb25kIHJkIHJuIG9wMiA9XG4gIGxldCBvcGNvZGUgPSBtYXRjaCBpbnN0ciB3aXRoXG4gIHwgQURDIC0+IDBiMDAwMF8xMDEwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IFNCQyAtPiAwYjAwMDBfMTEwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgfCBCSUMgLT4gMGIwMDAxXzExMDBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIHwgQU5EIC0+IDBiMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IEFERCAtPiAwYjAwMDBfMTAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgfCBTVUIgLT4gMGIwMDAwXzAxMDBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gIHwgT1JSIC0+IDBiMDAwMV8xMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMFxuICB8IEVPUiAtPiAwYjAwMDBfMDAxMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgaW5cbiAgbGV0IHNjb2RlID0gaWYgcyB0aGVuIDEgZWxzZSAwIGluXG4gIGxldCBzY29kZSA9IHNoaWZ0X2xlZnQgKG9mX2ludCBzY29kZSkgMjAgaW5cbiAgbGV0IHYgPSBvZl9pbnQgb3Bjb2RlIHw+XG4gICAgYWRkX2NvbmRpdGlvbl9jb2RlIGNvbmQgfD5cbiAgICBhZGRfcmRfY29kZSByZCB8PlxuICAgIGFkZF9ybl9jb2RlIHJuIHw+XG4gICAgbG9nb3Igc2NvZGUgaW5cbiAgYWRkcl9tb2RlXzEgb3AyIHw+XG4gIExpc3QubWFwIChmdW4gYWRkcl9tb2RlIC0+IGxvZ29yIHYgYWRkcl9tb2RlKVxuXG5sZXQgYnJhbmNoX3RvX2JpbmFyeSBsIGNvbmQgdGFyZ2V0ID1cbiAgbGV0IG9wY29kZSA9XG4gICAgaWYgbFxuICAgIHRoZW4gMGIxMDExXzAwMDBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXG4gICAgZWxzZSAwYjEwMTBfMDAwMF8wMDAwXzAwMDBfMDAwMF8wMDAwXzAwMDBcbiAgaW5cbiAgbGV0IHYgPSBvZl9pbnQgb3Bjb2RlIHw+XG4gICAgYWRkX2NvbmRpdGlvbl9jb2RlIGNvbmQgaW5cbiAgbGV0IGltbSA9IHNpZ25lZF9pbW1lZDI0IChzdWIgdGFyZ2V0IDhsKSBpblxuICBbbG9nb3IgdiBpbW1dXG5cbmxldCBicmFuY2h4X3RvX2JpbmFyeSBsIGNvbmQgcm0gPVxuICBsZXQgb3Bjb2RlID1cbiAgICBpZiBsXG4gICAgdGhlbiAwYjAwMDFfMDAxMF8xMTExXzExMTFfMTExMV8wMDExXzAwMDBcbiAgICBlbHNlIDBiMDAwMV8wMDEwXzExMTFfMTExMV8xMTExXzAwMDFfMDAwMFxuICBpblxuICBbb2ZfaW50IG9wY29kZSB8PlxuICBhZGRfY29uZGl0aW9uX2NvZGUgY29uZCB8PlxuICBhZGRfcm1fY29kZSBybV1cblxubGV0IGFybV90b19iaW5hcnkgYXJtID1cbiAgbWF0Y2ggYXJtIHdpdGhcbiAgfCBDdXN0b20gaSAtPiBbaV1cbiAgfCBNZW0ge2luc3RyO3R5cDtjb25kO3JkO3JvfSAtPiBsZHJfc3RyX3RvX2JpbmFyeSBpbnN0ciB0eXAgY29uZCByZCByb1xuICB8IE1vdiB7aW5zdHI7cztjb25kO3JkO3JzfSAgIC0+IG1vdl9tdm5fdG9fYmluYXJ5IGluc3RyIHMgY29uZCByZCByc1xuICB8IERhdGFQcm9jIHtpbnN0cjtzO2NvbmQ7cmQ7cm47b3AyfSAtPiBjYWxjdWxhdGlvbl90b19iaW5hcnkgaW5zdHIgcyBjb25kIHJkIHJuIG9wMlxuICB8IEJyYW5jaCB7bDtjb25kO3RhcmdldH0gLT4gYnJhbmNoX3RvX2JpbmFyeSBsIGNvbmQgdGFyZ2V0XG4gIHwgQnJhbmNoWCB7bDtjb25kO3JtfSAtPiBicmFuY2h4X3RvX2JpbmFyeSBsIGNvbmQgcm1cblxubGV0IHJldmVyc2VfZW5kaWFubmVzcyB2ID1cbiAgbGV0IHYxID0gc2hpZnRfbGVmdCAobG9nYW5kIG1hc2s4IHYpICgzKjgpIGluXG4gIGxldCB2ID0gc2hpZnRfcmlnaHRfbG9naWNhbCB2IDggaW5cbiAgbGV0IHYyID0gc2hpZnRfbGVmdCAobG9nYW5kIG1hc2s4IHYpICgyKjgpIGluXG4gIGxldCB2ID0gc2hpZnRfcmlnaHRfbG9naWNhbCB2IDggaW5cbiAgbGV0IHYzID0gc2hpZnRfbGVmdCAobG9nYW5kIG1hc2s4IHYpICgxKjgpIGluXG4gIGxldCB2ID0gc2hpZnRfcmlnaHRfbG9naWNhbCB2IDggaW5cbiAgbGV0IHY0ID0gbG9nYW5kIG1hc2s4IHYgaW5cbiAgbG9nb3IgdjEgdjIgfD4gbG9nb3IgdjMgfD4gbG9nb3IgdjRcbiIsIlxuZXhjZXB0aW9uIEJveEZpdHRpbmdFcnJvciBvZiBzdHJpbmdcblxudHlwZSBmaWxsZXJzID1cbiAgeyBub3BfY29kZTppbnQgbGlzdCA7IG5vcF9jb2RlX2FsdDppbnQgbGlzdDsgZmlsbGVyczppbnQgbGlzdCBhcnJheSB9XG5sZXQgZGVmYXVsdF9maWxsZXJzID0ge1xuICBub3BfY29kZSA9IFsweDAwIDsgMHgwMCA7IDB4MDAgOyAweDAwXSAoKiAwMDAwMDAwMCA6IGFuZGVxIHIwLCByMCwgcjAgKik7XG4gIG5vcF9jb2RlX2FsdCA9IFsweDAwIDsgMHgwMCA7IDB4MDAgOyAweEIwXSAoKiBCMDAwMDAwMCA6IGFuZGx0IHIwLCByMCwgcjAgKik7XG4gIGZpbGxlcnM9IFt8XG4gICAgWzB4RkYgOyAweDAwIDsgMHgwMCA7IDB4MDBdKCogMDAwMDAwRkYgKikgO1xuICAgIFsweDAwIDsgMHhGRiA7IDB4MDAgOyAweDAwXSgqIDAwMDBGRjAwICopIDtcbiAgICBbMHgwMCA7IDB4MDAgOyAweEZGIDsgMHgwMF0oKiAwMEZGMDAwMCAqKSA7XG4gICAgWzB4MDAgOyAweDAwIDsgMHgwMCA7IDB4RkZdKCogRkYwMDAwMDAgKikgO1xuICB8XVxuICB9XG5cbmxldCBuYW1lX3NpemUgPSA4XG5sZXQgbmJfYm94ZXMgPSAxNFxuXG5sZXQgZW9mID0gTmFtZS5lb2ZcblxubGV0IG5vX2VvZiBjb2RlcyA9XG4gIExpc3QuZm9yX2FsbCAoZnVuIGMgLT4gYyA8PiBlb2YpIGNvZGVzXG5cbmxldCByZWMgb25seV9jb25zZWN1dGl2ZV9lb2YgY29kZXMgPVxuICBtYXRjaCBjb2RlcyB3aXRoXG4gIHwgW10gLT4gdHJ1ZVxuICB8IGM6OmNvZGVzIHdoZW4gYyA8PiBlb2YgLT4gb25seV9jb25zZWN1dGl2ZV9lb2YgY29kZXNcbiAgfCBfOjpjJzo6Y29kZXMgd2hlbiBjJyA9IGVvZiAtPiBvbmx5X2NvbnNlY3V0aXZlX2VvZiAoYyc6OmNvZGVzKVxuICB8IF86OmNvZGVzIC0+IG5vX2VvZiBjb2Rlc1xuXG5sZXQgbGFzdF9lb2ZfaW5kZXggY29kZXMgPVxuICBsZXQgbiA9IExpc3QubGVuZ3RoIGNvZGVzIGluXG4gIGxldCBjb2RlcyA9IExpc3QucmV2IGNvZGVzIGluXG4gIGxldCByZWMgYXV4IGFjYyBjb2RlcyA9XG4gICAgbWF0Y2ggY29kZXMgd2l0aFxuICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBjOjpfIHdoZW4gYyA9IGVvZiAtPiBhY2NcbiAgICB8IF86OmNvZGVzIC0+IGF1eCAoYWNjKzEpIGNvZGVzXG4gIGluXG4gIG4gLSAxIC0gKGF1eCAwIGNvZGVzKVxuXG5sZXQgZmlyc3Rfbm9uX2VvZl9pbmRleCBjb2RlcyA9XG4gIGxldCByZWMgYXV4IGFjYyBjb2RlcyA9XG4gICAgbWF0Y2ggY29kZXMgd2l0aFxuICAgIHwgYzo6Y29kZXMgd2hlbiBjID0gZW9mIC0+IGF1eCAoYWNjKzEpIGNvZGVzXG4gICAgfCBfIC0+IGFjY1xuICBpblxuICBhdXggMCBjb2Rlc1xuXG5sZXQgcGFkIGZpbGxlcnMgcG9zID1cbiAgbGV0IHBvcyA9IHBvcyBtb2QgKG5hbWVfc2l6ZSsxKSBpblxuICBsZXQgbiA9IExpc3QubGVuZ3RoIGZpbGxlcnMubm9wX2NvZGUgaW5cbiAgaWYgcG9zICsgbiA8PSBuYW1lX3NpemVcbiAgdGhlbiBmaWxsZXJzLm5vcF9jb2RlXG4gIGVsc2UgZmlsbGVycy5maWxsZXJzLihuYW1lX3NpemUtcG9zKVxuXG5sZXQgcmVjIHBhZF9uYiBmaWxsZXJzIHBvcyBuYiA9XG4gIGlmIG5iIDwgMFxuICB0aGVuIHJhaXNlIChCb3hGaXR0aW5nRXJyb3IgXCJDYW5ub3QgcGFkIHRoZSByZXF1aXJlZCBhbW91bnQuIElzIHN0YXJ0aW5nIHBvc2l0aW9uIHZhbGlkP1wiKVxuICBlbHNlIGlmIG5iID0gMCB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgY29kZSA9IHBhZCBmaWxsZXJzIHBvcyBpblxuICAgIGxldCBtID0gTGlzdC5sZW5ndGggY29kZSBpblxuICAgIGNvZGVAKHBhZF9uYiBmaWxsZXJzIChwb3MgKyBtKSAobmIgLSBtKSlcblxubGV0IHJlYyBmaXRfY29kZV9hdF9wb3MgPyhuZXh0PVNvbWUgW10pIGZpbGxlcnMgcG9zIGNvZGVzID1cbiAgbGV0IHBvcyA9IHBvcyBtb2QgKG5hbWVfc2l6ZSsxKSBpblxuICBsZXQgbiA9IExpc3QubGVuZ3RoIGNvZGVzIGluXG4gIGxldCBpc19va19oZXJlID1cbiAgICBpZiBub19lb2YgY29kZXNcbiAgICB0aGVuIHBvcyArIG4gPD0gbmFtZV9zaXplXG4gICAgZWxzZSBpZiBvbmx5X2NvbnNlY3V0aXZlX2VvZiBjb2Rlc1xuICAgIHRoZW5cbiAgICAgIGxldCBpID0gbGFzdF9lb2ZfaW5kZXggY29kZXMgaW5cbiAgICAgIGxldCBqID0gbWF0Y2ggbmV4dCB3aXRoIFNvbWUgbmV4dCAtPiBmaXJzdF9ub25fZW9mX2luZGV4IG5leHQgfCBOb25lIC0+IDAgaW5cbiAgICAgIChwb3MraSA9IG5hbWVfc2l6ZSkgfHxcbiAgICAgIChpID0gbi0xICYmIHBvcytpKzEgPSBuYW1lX3NpemUpIHx8ICgqIEZvbGxvd2VkIGJ5IGZpbGxlciBjb2RlICopXG4gICAgICAoaSA9IG4tMSAmJiBwb3MraStqID0gbmFtZV9zaXplKSB8fCAoKiBGb2xsb3dlZCBieSBuZXh0IGNvZGUgKilcbiAgICAgIChuZXh0ID0gTm9uZSAmJiBpID0gbi0xICYmIHBvcytpIDw9IG5hbWVfc2l6ZSkgKCogTm90aGluZyBhZnRlciAqKVxuICAgIGVsc2UgcmFpc2UgKEJveEZpdHRpbmdFcnJvclxuICAgIFwiU29tZSBjb2RlcyBjYW5ub3QgYmUgcG9zaXRpb25uZWQgZHVlIHRvIG5vbi1jb25zZWN1dGl2ZSAweEZGIGJ5dGVzLlwiKVxuICBpblxuICBpZiBpc19va19oZXJlIHRoZW4gY29kZXNcbiAgZWxzZSBiZWdpblxuICAgIGxldCBtID0gTGlzdC5sZW5ndGggZmlsbGVycy5ub3BfY29kZSBpblxuICAgIGxldCBub3BfY29kZSA9XG4gICAgICBpZiBwb3MgKyBtIDw9IG5hbWVfc2l6ZSB0aGVuIGZpbGxlcnMubm9wX2NvZGVcbiAgICAgIGVsc2UgZmlsbGVycy5maWxsZXJzLihuYW1lX3NpemUtcG9zKVxuICAgIGluXG4gICAgbGV0IG0gPSBMaXN0Lmxlbmd0aCBub3BfY29kZSBpblxuICAgIG5vcF9jb2RlQChmaXRfY29kZV9hdF9wb3Mgfm5leHQgZmlsbGVycyAocG9zICsgbSkgY29kZXMpXG4gIGVuZFxuXG5sZXQgYWRkX2NvZGVzX2FmdGVyID8oZmluYWw9ZmFsc2UpIGZpbGxlcnMgcmVzIGNvZGVzID1cbiAgbGV0IHJlYyBhdXggYWNjIGNvZGVzID1cbiAgICBtYXRjaCBjb2RlcyB3aXRoXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IFtjb2Rlc10gLT5cbiAgICAgIGxldCBuZXh0ID0gaWYgZmluYWwgdGhlbiBOb25lIGVsc2UgU29tZSBbXSBpblxuICAgICAgYWNjQChmaXRfY29kZV9hdF9wb3Mgfm5leHQgZmlsbGVycyAoTGlzdC5sZW5ndGggYWNjKSBjb2RlcylcbiAgICB8IGMxOjpjMjo6Y29kZXMgLT5cbiAgICAgIGxldCBuYyA9IGZpdF9jb2RlX2F0X3BvcyB+bmV4dDooU29tZSBjMikgZmlsbGVycyAoTGlzdC5sZW5ndGggYWNjKSBjMSBpblxuICAgICAgYXV4IChhY2NAbmMpIChjMjo6Y29kZXMpXG4gIGluXG4gIGF1eCByZXMgY29kZXNcblxubGV0IG1vZHVsbyB4IHkgPVxuICBsZXQgcmVzdWx0ID0geCBtb2QgeSBpblxuICBpZiByZXN1bHQgPj0gMCB0aGVuIHJlc3VsdFxuICBlbHNlIHJlc3VsdCArIHlcblxubGV0IHNwbGl0X3Jhd19pbnRvX2JveGVzID8oZmlsbF9sYXN0PWZhbHNlKSByYXcgPVxuICBsZXQgcmVjIHNwbGl0IGZpbmlzaGVkIGN1cnJlbnQgY29kZXMgaSA9XG4gICAgbWF0Y2ggY29kZXMgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIGlmIGkgPD4gMFxuICAgICAgdGhlbiBiZWdpblxuICAgICAgICBsZXQgY3VycmVudCA9XG4gICAgICAgICAgbGV0IG4gPSBMaXN0Lmxlbmd0aCBjdXJyZW50IGluXG4gICAgICAgICAgaWYgZmlsbF9sYXN0ICYmIG4gPSBpICgqIElmIGN1cnJlbnQgYm94IGRvZXMgbm90IGVuZCBieSAweEZGICopXG4gICAgICAgICAgdGhlbiAoTGlzdC5pbml0IChuYW1lX3NpemUtbikgKGZ1biBfIC0+IE5hbWUuc3BhY2UpKUBjdXJyZW50XG4gICAgICAgICAgZWxzZSBjdXJyZW50XG4gICAgICAgIGluXG4gICAgICAgIGN1cnJlbnQ6OmZpbmlzaGVkXG4gICAgICBlbmQgZWxzZSBmaW5pc2hlZFxuICAgIHwgYzo6Y29kZXMgd2hlbiBpID0gbmFtZV9zaXplIC0+XG4gICAgICBpZiBjIDw+IGVvZlxuICAgICAgdGhlbiByYWlzZSAoQm94Rml0dGluZ0Vycm9yXG4gICAgICBcIlJlc3VsdCBpcyBpbmNvbnNpc3RlbnQuIFBsZWFzZSBjaGVjayB0aGUgZmlsbGVycy5cIikgO1xuICAgICAgc3BsaXQgKGN1cnJlbnQ6OmZpbmlzaGVkKSBbXSBjb2RlcyAwXG4gICAgfCBjOjpjb2RlcyB3aGVuIGMgPSBlb2YgLT5cbiAgICAgIHNwbGl0IGZpbmlzaGVkIGN1cnJlbnQgY29kZXMgKGkrMSlcbiAgICB8IGM6OmNvZGVzIC0+XG4gICAgICBpZiBMaXN0Lmxlbmd0aCBjdXJyZW50IDw+IGlcbiAgICAgIHRoZW4gcmFpc2UgKEJveEZpdHRpbmdFcnJvclxuICAgICAgXCJSZXN1bHQgaXMgaW5jb25zaXN0ZW50LiBQbGVhc2UgY2hlY2sgdGhlIGZpbGxlcnMuXCIpIDtcbiAgICAgIHNwbGl0IGZpbmlzaGVkIChjOjpjdXJyZW50KSBjb2RlcyAoaSsxKVxuICBpblxuICBzcGxpdCBbXSBbXSByYXcgMCB8PlxuICBMaXN0Lm1hcCBMaXN0LnJldiB8PlxuICBMaXN0LnJldlxuXG5sZXQgZml0X2NvZGVzX2ludG9fYm94ZXMgPyhmaWxsX2xhc3Q9dHJ1ZSkgPyhmaWxsZXJzPWRlZmF1bHRfZmlsbGVycykgPyhzdGFydD0wKSA/KGV4aXQ9Tm9uZSkgY29kZXMgPVxuICAoKiBNYWluIGNvZGUgKilcbiAgbGV0IHBhZGRpbmcgPSBwYWRfbmIgZmlsbGVycyAwIHN0YXJ0IGluXG4gIGxldCByZXMgPVxuICAgIGFkZF9jb2Rlc19hZnRlciB+ZmluYWw6KGV4aXQgPSBOb25lKSBmaWxsZXJzIHBhZGRpbmcgY29kZXMgaW5cbiAgKCogQWRkIGV4aXQgY29kZSAqKVxuICBsZXQgcmVzID1cbiAgICBtYXRjaCBleGl0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmVzXG4gICAgfCBTb21lIGV4aXQgLT5cbiAgICAgIGxldCBpID0gTGlzdC5sZW5ndGggcmVzIGluXG4gICAgICBsZXQgKGosZWNvZGUpID0gRXhpdC5nZXRfcHJlZmVycmVkIGV4aXQgaSBpblxuICAgICAgbGV0IHBhZGRpbmcgPSBwYWRfbmIgZmlsbGVycyBpIChqLWkpIGluXG4gICAgICBsZXQgcmVzID0gcmVzQHBhZGRpbmcgaW5cbiAgICAgIGFkZF9jb2Rlc19hZnRlciB+ZmluYWw6dHJ1ZSBmaWxsZXJzIHJlcyBlY29kZVxuICBpblxuICAoKiBTcGxpdCBieSBib3ggKilcbiAgbGV0IHJlcyA9IHNwbGl0X3Jhd19pbnRvX2JveGVzIH5maWxsX2xhc3QgcmVzIGluXG4gICgqIElmIGEgYm94IGlzIGZ1bGwgb2Ygc3BhY2VzLi4uICopXG4gIHJlcyB8PiBMaXN0Lm1hcGkgKGZ1biBpIGxzdCAtPlxuICAgIGlmIE5hbWUuaXNfZnVsbF9vZl9zcGFjZXMgbHN0XG4gICAgdGhlblxuICAgICAgbGV0IG0gPSBMaXN0Lmxlbmd0aCBmaWxsZXJzLm5vcF9jb2RlX2FsdCBpblxuICAgICAgbGV0IHBvcyA9IG1vZHVsbyAoLWkqKG5hbWVfc2l6ZSsxKSkgbSBpblxuICAgICAgbGV0IHByZWZpeCA9IExpc3QuaW5pdCBwb3MgKGZ1biBfIC0+IE5hbWUuc3BhY2UpIGluXG4gICAgICBsZXQgc3VmZml4X2xlbiA9IChMaXN0Lmxlbmd0aCBsc3QpLXBvcy1tIGluXG4gICAgICBpZiBzdWZmaXhfbGVuIDwgMCB0aGVuIGxzdFxuICAgICAgZWxzZVxuICAgICAgICBsZXQgc3VmZml4ID0gTGlzdC5pbml0IHN1ZmZpeF9sZW4gKGZ1biBfIC0+IE5hbWUuc3BhY2UpIGluXG4gICAgICAgIExpc3QuY29uY2F0IFtwcmVmaXggOyBmaWxsZXJzLm5vcF9jb2RlX2FsdCA7IHN1ZmZpeF1cbiAgICBlbHNlIGxzdFxuICApXG5cbmxldCBmaXRfY29kZXNfaW50b19oZXhfYm94ZXMgPyhleGl0PU5vbmUpIGNvZGVzID1cbiAgKCogQWRkIGV4aXQgY29kZSAqKVxuICBsZXQgY29kZXMgPVxuICAgIG1hdGNoIGV4aXQgd2l0aFxuICAgIHwgTm9uZSAtPiBjb2Rlc1xuICAgIHwgU29tZSBleGl0IC0+XG4gICAgICBsZXQgKF8sZWNvZGUpID0gRXhpdC5nZXRfcHJlZmVycmVkIGV4aXQgMCBpblxuICAgICAgY29kZXMgQCBlY29kZVxuICBpblxuICAoKiBGaXQgaW50byBib3hlcyAqKVxuICBjb2RlcyB8PiBMaXN0Lm1hcCAoZnVuIGNvZGUgLT5cbiAgICBjb2RlIHw+IExpc3QubWFwIChmdW4gaSAtPlxuICAgICAgbGV0IGhleDEgPSBGb3JtYXQuc3ByaW50ZiBcIiVYXCIgKGkgbW9kIDE2KSBpblxuICAgICAgbGV0IGhleDIgPSBGb3JtYXQuc3ByaW50ZiBcIiVYXCIgKGkgLyAxNikgaW5cbiAgICAgIFsgQ2hhcnNldC5lbmNvZGVfd3JpdGFibGVfY2hhciBoZXgyIDsgQ2hhcnNldC5lbmNvZGVfd3JpdGFibGVfY2hhciBoZXgxIF1cbiAgICApIHw+IExpc3QuZmxhdHRlblxuICApXG5cbmxldCBwcF9ib3hlc19uYW1lcyBmbXQgbHN0ID1cbiAgbGV0IHBwX2JveCBpIGNvZGVzID1cbiAgICBsZXQgY2hhcnMgPSBOYW1lLmNvZGVzX3RvX2NoYXJzIGNvZGVzIGluXG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiQm94ICUyaTogJWFcXHRbJWFdQC5cIiAoaSsxKVxuICAgICAgTmFtZS5wcF9jaGFycyBjaGFycyBOYW1lLnBwX2NoYXJzX3JhdyBjaGFyc1xuICBpblxuICBMaXN0Lml0ZXJpIHBwX2JveCBsc3RcblxubGV0IHBwX2JveF9yYXcgZm10IGxzdCA9XG4gIGxldCBwYWQgPVxuICAgIExpc3QuaW5pdCAobmFtZV9zaXplKzEtKExpc3QubGVuZ3RoIGxzdCkpIChmdW4gXyAtPiBlb2YpIGluXG4gIGxzdEBwYWQgfD4gTGlzdC5pdGVyIChGb3JtYXQuZnByaW50ZiBmbXQgXCIlMDJYIEA/XCIpXG4iLCJvcGVuIEludDMyXG5vcGVuIENoYXJzZXRcbm9wZW4gVXRpbHNcblxubGV0IGVvZiA9IDB4RkZcbmxldCBzcGFjZSA9IDB4MDBcblxubGV0IGludDggPSAwYjExMTExMTExXG5sZXQgbWFzazggPSBpbnQ4IHw+IG9mX2ludFxuXG5sZXQgY29kZXNfZm9yX2NvbW1hbmQgdiA9XG4gIGxldCB2MSA9IGxvZ2FuZCBtYXNrOCB2IGluXG4gIGxldCB2ID0gc2hpZnRfcmlnaHRfbG9naWNhbCB2IDggaW5cbiAgbGV0IHYyID0gbG9nYW5kIG1hc2s4IHYgaW5cbiAgbGV0IHYgPSBzaGlmdF9yaWdodF9sb2dpY2FsIHYgOCBpblxuICBsZXQgdjMgPSBsb2dhbmQgbWFzazggdiBpblxuICBsZXQgdiA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgdiA4IGluXG4gIGxldCB2NCA9IGxvZ2FuZCBtYXNrOCB2IGluXG4gIFsgdWludDMyX3RvX2ludCB2MSA7IHVpbnQzMl90b19pbnQgdjIgOyB1aW50MzJfdG9faW50IHYzIDsgdWludDMyX3RvX2ludCB2NCBdXG5cbmxldCBjb21tYW5kX2Zvcl9jb2RlcyBjb2RlcyA9XG4gIG1hdGNoIGNvZGVzIHdpdGhcbiAgfCBbYzE7YzI7YzM7YzRdIC0+XG4gICAgbGV0IHYxID0gYzEgfD4gb2ZfaW50IGluXG4gICAgbGV0IHYyID0gYzIgfD4gb2ZfaW50IGluXG4gICAgbGV0IHYzID0gYzMgfD4gb2ZfaW50IGluXG4gICAgbGV0IHY0ID0gYzQgfD4gb2ZfaW50IGluXG4gICAgbGV0IHYgPSBzaGlmdF9sZWZ0IHY0IDggaW5cbiAgICBsZXQgdiA9IGxvZ29yIHYgdjMgaW5cbiAgICBsZXQgdiA9IHNoaWZ0X2xlZnQgdiA4IGluXG4gICAgbGV0IHYgPSBsb2dvciB2IHYyIGluXG4gICAgbGV0IHYgPSBzaGlmdF9sZWZ0IHYgOCBpblxuICAgIGxvZ29yIHYgdjFcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgY29kZXNfdG9fY2hhcnMgYyA9XG4gIExpc3QubWFwIHdyaXRhYmxlX2NoYXJfYXQgY1xuXG5sZXQgY2hhcnNfZm9yX2NvbW1hbmQgdiA9XG4gIGNvZGVzX2Zvcl9jb21tYW5kIHYgfD4gY29kZXNfdG9fY2hhcnNcblxubGV0IHBwX2NoYXJzIGZtdCBsc3QgPVxuICBsc3QgfD4gTGlzdC5pdGVyaSAoZnVuIGkgc3RyIC0+XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiJXMlc1wiIChpZiBpID0gMCB0aGVuIFwiXCIgZWxzZSBcIiBcIikgc3RyXG4gIClcblxubGV0IHBwX2NoYXJzX3JhdyBmbXQgbHN0ID1cbiAgbHN0IHw+IExpc3QuaXRlciAoZnVuIHN0ciAtPlxuICAgIGxldCBzdHIgPSBpZiBzdHIgPSBzcGFjaW5nX2NoYXIgdGhlbiBcIiBcIiBlbHNlIHN0ciBpblxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVzXCIgc3RyXG4gIClcblxubGV0IGlzX2NvZGVfd3JpdGFibGUgY29kZXMgPVxuICBMaXN0LmZvcl9hbGwgaXNfY29kZV9hdmFpbGFibGUgY29kZXNcblxubGV0IHJlYyBmaXJzdF9jb2RlIGYgY29kZXMgPVxuICBtYXRjaCBjb2RlcyB3aXRoXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgY29kZTo6Y29kZXMgLT5cbiAgICBpZiBmIGNvZGUgdGhlbiBjb2RlXG4gICAgZWxzZSBmaXJzdF9jb2RlIGYgY29kZXNcblxubGV0IGZpcnN0X3dyaXRhYmxlX2NvZGUgY29kZXMgPVxuICBmaXJzdF9jb2RlIGlzX2NvZGVfd3JpdGFibGUgY29kZXNcblxubGV0IGlzX2NvZGVfd3JpdGFibGVfb3Jfb25lX2VvZiBjb2RlID1cbiAgKExpc3QuZmlsdGVyIChmdW4gYyAtPiBjIDw+IGVvZikgY29kZSB8PiBpc19jb2RlX3dyaXRhYmxlKSAmJlxuICAoTGlzdC5mb2xkX2xlZnQgKGZ1biBuYiBjIC0+IGlmIGMgPSBlb2YgdGhlbiBuYisxIGVsc2UgbmIpIDAgY29kZSkgPD0gMVxuXG5sZXQgcHJlZmVycmVkX2NvZGUgY29kZXMgPVxuICB0cnkgZmlyc3Rfd3JpdGFibGVfY29kZSBjb2Rlc1xuICB3aXRoIE5vdF9mb3VuZCAtPiBiZWdpblxuICAgIHRyeSBmaXJzdF9jb2RlIGlzX2NvZGVfd3JpdGFibGVfb3Jfb25lX2VvZiBjb2Rlc1xuICAgIHdpdGggTm90X2ZvdW5kIC0+IExpc3QuaGQgY29kZXNcbiAgZW5kXG5cbmxldCBpc19mdWxsX29mX3NwYWNlcyBjb2RlcyA9XG4gIExpc3QuZm9yX2FsbCAoZnVuIGMgLT4gYyA9IHNwYWNlKSBjb2Rlc1xuIiwib3BlbiBJbnQzMlxub3BlbiBVdGlsc1xub3BlbiBBcm1cblxuZXhjZXB0aW9uIENhbm5vdE9wdGltaXplXG5cbnR5cGUgdHdlYWtpbmdfc2V0dGluZ3MgPVxuICB8IE5vVHdlYWtpbmdcbiAgfCBUd2Vha0ZpeGVkTGVuZ3RoIG9mIGludFxuICB8IFR3ZWFrTWluTGVuZ3RoXG5cbm1vZHVsZSBVSW50MzIgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50MzJcbiAgKCpsZXQgZXF1YWwgPSBlcXVhbCopXG4gIGxldCBjb21wYXJlID0gdW5zaWduZWRfY29tcGFyZVxuZW5kXG5cbm1vZHVsZSBVSW50MzJTZXQgPSBTZXQuTWFrZShVSW50MzIpXG5cbmxldCBwYWRkaW5nX2NvZGUgPSBDdXN0b20gemVyb1xuXG5sZXQgY2Fycnlfb3V0IGkgPSBjb21wYXJlIGkgemVybyA8IDBcblxubGV0IGNvbXB1dGVfYWxsX2NvbnN0YW50cyBfID1cbiAgbGV0IHJlYyBhbGxfaW1tZWQ4IG1heCBhY2MgaSA9XG4gICAgaWYgZXF1YWwgaSBtYXggdGhlbiBpOjphY2NcbiAgICBlbHNlIGFsbF9pbW1lZDggbWF4IChpOjphY2MpIChzdWNjIGkpXG4gIGluXG4gIGxldCBpbW1lZDggPSBhbGxfaW1tZWQ4IChvZl9pbnQgMjU1KSBbXSB6ZXJvIGluXG4gIGxldCBpbW1lZDggPSBpbW1lZDggfD4gTGlzdC5maWx0ZXIgKGZ1biBpIC0+XG4gICAgTmFtZS5pc19jb2RlX3dyaXRhYmxlIFtVdGlscy51aW50MzJfdG9faW50IGldXG4gICkgaW5cbiAgbGV0IHJlYyBhbGxfcm90YXRpb25zIGluaXRpYWwgYWNjIGkgPVxuICAgIGxldCBpID0gQXJtLnJvdGF0ZV9yaWdodCBpIHw+IEFybS5yb3RhdGVfcmlnaHQgaW5cbiAgICBpZiBlcXVhbCBpIGluaXRpYWwgdGhlbiBhY2NcbiAgICBlbHNlIGFsbF9yb3RhdGlvbnMgaW5pdGlhbCAoaTo6YWNjKSBpXG4gIGluXG4gIGltbWVkOCB8PiBMaXN0Lm1hcCAoZnVuIGkgLT5cbiAgICBhbGxfcm90YXRpb25zIGkgW2ldIGlcbiAgKSB8PiBMaXN0LmZsYXR0ZW4gfD4gVUludDMyU2V0Lm9mX2xpc3RcblxubGV0IGNvbnN0YW50c19zZXQgPSBjb21wdXRlX2FsbF9jb25zdGFudHMgKClcbmxldCBjb25zdGFudHNfc2V0X25vX2NhcnJ5ID1cbiAgY29uc3RhbnRzX3NldCB8PiBVSW50MzJTZXQuZmlsdGVyIChmdW4gaSAtPiBjYXJyeV9vdXQgaSB8PiBub3QpXG5cbmxldCBjb25zdGFudHMgPSBjb25zdGFudHNfc2V0IHw+IFVJbnQzMlNldC5lbGVtZW50c1xubGV0IHJldl9jb25zdGFudHMgPSBMaXN0LnJldiBjb25zdGFudHNcblxubGV0IGNvbnN0YW50c19tb3ZfbXZuID1cbiAgbGV0IG5zZXQgPSBVSW50MzJTZXQubWFwIGxvZ25vdCBjb25zdGFudHNfc2V0IGluXG4gIFVJbnQzMlNldC51bmlvbiBjb25zdGFudHNfc2V0X25vX2NhcnJ5IG5zZXRcbiAgfD4gVUludDMyU2V0LnJlbW92ZSBJbnQzMi56ZXJvICgqIFdlIHRyeSB0byBhdm9pZCBzZXR0aW5nIHRoZSB6ZXJvIGZsYWcgKilcbiAgfD4gVUludDMyU2V0LmVsZW1lbnRzXG5cbmxldCBjb25zdGFudHNfbW92X212bl9zdHJpY3QgPVxuICBsZXQgbnNldCA9IFVJbnQzMlNldC5tYXAgbG9nbm90IGNvbnN0YW50c19zZXQgaW5cbiAgVUludDMyU2V0LnVuaW9uIGNvbnN0YW50c19zZXQgbnNldFxuICB8PiBVSW50MzJTZXQuZWxlbWVudHNcblxubGV0IHJldl9jb25zdGFudHNfbW92X212biA9IExpc3QucmV2IGNvbnN0YW50c19tb3ZfbXZuXG5sZXQgcmV2X2NvbnN0YW50c19tb3ZfbXZuX3N0cmljdCA9IExpc3QucmV2IGNvbnN0YW50c19tb3ZfbXZuX3N0cmljdFxuXG5sZXQgdHJpZXNfYXRfZGVwdGhfMCA9IFt8IDB4MTAwMDAgOyAweDEwMDAwIDsgMHgxMDAwMCA7IDB4MjAwIDsgMHg0MCA7IDB4OCA7IDB4MSB8XVxuXG5sZXQgcmVjIHJlbW92ZV93aGlsZSBmIGxzdCA9XG4gIG1hdGNoIGxzdCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBpJzo6bHN0IHdoZW4gZiBpJyAtPiByZW1vdmVfd2hpbGUgZiBsc3RcbiAgfCBsc3QgLT4gbHN0XG5cbnR5cGUgY29uc3RhbnRzX2NhdCA9IEFyaXRoIHwgTW92TXZuIHwgTW92TXZuU3RyaWN0XG5sZXQgc3ludGhlc2lzIH5jb25zdGFudHNfY2F0IH5hZGRpdGl2ZSB+aW5jciBtYXhfY2FyZCBpIGlzX3ZhbGlkX2ZzdCBpc192YWxpZCA9XG4gIGxldCB0YWQwID0gdHJpZXNfYXRfZGVwdGhfMCBpblxuICBsZXQgdGFkMF9sZW4gPSBBcnJheS5sZW5ndGggdGFkMCBpblxuICBsZXQgdGFkMCA9IGlmIHRhZDBfbGVuIDwgbWF4X2NhcmQgdGhlbiB0YWQwLih0YWQwX2xlbi0xKSBlbHNlIHRhZDAuKG1heF9jYXJkLTEpIGluXG5cbiAgbGV0IHJlbW92ZSA9IChmdW4gaSAtPiByZW1vdmVfd2hpbGUgKGZ1biBqIC0+IHVuc2lnbmVkX2NvbXBhcmUgaSBqIDwgMCkpIGluXG4gIGxldCByZWMgbmV4dCBhY2MgcmMgaSA9XG4gICAgbGV0IHJlYyBhdXggdHJ5X25iIHJjID1cbiAgICAgIGlmIGVxdWFsIGkgemVybyB0aGVuIFNvbWUgYWNjXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBkZXB0aCA9IExpc3QubGVuZ3RoIGFjYyBpblxuICAgICAgICBpZiBkZXB0aCA+PSBtYXhfY2FyZCB0aGVuIE5vbmVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCByZW1fZGVwdGggPSBtYXhfY2FyZCAtIGRlcHRoIHw+IEludDY0Lm9mX2ludCBpblxuICAgICAgICAgIGxldCBpNjQgPSBpbnQ2NF9vZl91aW50MzIgaSBpblxuICAgICAgICAgIGxldCBpaSA9IGlmIGluY3IgdGhlbiBwcmVkIGkgZWxzZSBpIGluXG4gICAgICAgICAgbWF0Y2ggcmVtb3ZlIGlpIHJjIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IE5vbmVcbiAgICAgICAgICB8IGZzdDo6XyB3aGVuIEludDY0LnVuc2lnbmVkX2NvbXBhcmUgKCogT3B0aW1pc2F0aW9uICopXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChJbnQ2NC5tdWwgKChpZiBpbmNyIHRoZW4gc3VjYyBmc3QgZWxzZSBmc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHw+IGludDY0X29mX3VpbnQzMikgcmVtX2RlcHRoKSBpNjQgPCAwIC0+IE5vbmVcbiAgICAgICAgICB8IGZzdDo6cmMgLT5cbiAgICAgICAgICAgIGxldCByZW1haW5kZXIgPSBzdWIgaWkgZnN0IGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBuZXh0IChmc3Q6OmFjYykgKGZzdDo6cmMpIHJlbWFpbmRlciB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gYXV4ICh0cnlfbmIrMSkgcmNcbiAgICAgICAgICAgIHwgU29tZSByZXMgLT4gU29tZSByZXNcbiAgICAgICAgICAgIGVuZFxuICAgIGluXG4gICAgYXV4IDAgcmNcbiAgaW5cblxuICBsZXQgZmlsdGVyZWRfcmV2X2NvbnN0YW50cyA9IExpc3QuZmlsdGVyIGlzX3ZhbGlkIHJldl9jb25zdGFudHMgaW5cbiAgbGV0IHJlbW92ZV9pbml0ID1cbiAgICBpZiBhZGRpdGl2ZSB0aGVuIHJlbW92ZVxuICAgIGVsc2UgKGZ1biBpIC0+IHJlbW92ZV93aGlsZSAoZnVuIGogLT4gdW5zaWduZWRfY29tcGFyZSBpIGogPiAwKSlcbiAgaW5cbiAgbGV0IG9wX2luaXQgPSBpZiBhZGRpdGl2ZSB0aGVuIHN1YiBlbHNlIChmdW4geCB5IC0+IHN1YiB5IHgpIGluXG4gIGxldCByZWMgaW5pdCB0cnlfbmIgcmMgPVxuICAgIGlmIHRyeV9uYiA+PSB0YWQwIHRoZW4gTm9uZVxuICAgIGVsc2UgbWF0Y2ggcmVtb3ZlX2luaXQgaSByYyB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBmc3Q6OnJjIC0+XG4gICAgICBsZXQgcmVtYWluZGVyID0gb3BfaW5pdCBpIGZzdCBpblxuICAgICAgYmVnaW4gbWF0Y2ggbmV4dCBbZnN0XSBmaWx0ZXJlZF9yZXZfY29uc3RhbnRzIHJlbWFpbmRlciB3aXRoXG4gICAgICB8IE5vbmUgLT4gaW5pdCAodHJ5X25iKzEpIHJjXG4gICAgICB8IFNvbWUgcmVzIC0+IFNvbWUgcmVzXG4gICAgICBlbmRcbiAgaW5cblxuICBsZXQgaW5pdF9yYyA9XG4gICAgbWF0Y2ggYWRkaXRpdmUsIGNvbnN0YW50c19jYXQgd2l0aFxuICAgIHwgdHJ1ZSwgQXJpdGggLT4gcmV2X2NvbnN0YW50c1xuICAgIHwgdHJ1ZSwgTW92TXZuIC0+IHJldl9jb25zdGFudHNfbW92X212blxuICAgIHwgdHJ1ZSwgTW92TXZuU3RyaWN0IC0+IHJldl9jb25zdGFudHNfbW92X212bl9zdHJpY3RcbiAgICB8IGZhbHNlLCBBcml0aCAtPiBjb25zdGFudHNcbiAgICB8IGZhbHNlLCBNb3ZNdm4gLT4gY29uc3RhbnRzX21vdl9tdm5cbiAgICB8IGZhbHNlLCBNb3ZNdm5TdHJpY3QgLT4gY29uc3RhbnRzX21vdl9tdm5fc3RyaWN0XG4gIGluXG4gIGxldCBpbml0X3JjID0gTGlzdC5maWx0ZXIgaXNfdmFsaWRfZnN0IGluaXRfcmMgaW5cbiAgaW5pdCAwIGluaXRfcmMgfD5cbiAgKGZ1bmN0aW9uIE5vbmUgLT4gTm9uZSB8IFNvbWUgbHN0IC0+IFNvbWUgKExpc3QucmV2IGxzdCkpXG5cbmxldCBzeW50aGVzaXNfb3B0aW1hbCB+Y29uc3RhbnRzX2NhdCB+aW5jcl9hZGQgfmluY3Jfc3ViIG1heF9jYXJkIGkgaXNfdmFsaWRfZnN0IGlzX3ZhbGlkID1cbiAgbGV0IHJlYyBhdXggY2FyZCA9XG4gICAgKCpGb3JtYXQucHJpbnRmIFwiVHJ5aW5nIHdpdGggY2FyZD0laUAuXCIgY2FyZCA7KilcbiAgICBpZiBjYXJkID4gbWF4X2NhcmQgdGhlbiBOb25lXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggc3ludGhlc2lzIH5jb25zdGFudHNfY2F0IH5hZGRpdGl2ZTp0cnVlIH5pbmNyOmluY3JfYWRkXG4gICAgICAgICAgICAgICAgICBjYXJkIGkgaXNfdmFsaWRfZnN0IChpc192YWxpZCB0cnVlKSB3aXRoXG4gICAgICB8IFNvbWUgbHN0IC0+IFNvbWUgKGxzdCwgdHJ1ZSlcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBiZWdpbiBtYXRjaCBzeW50aGVzaXMgfmNvbnN0YW50c19jYXQgfmFkZGl0aXZlOmZhbHNlIH5pbmNyOmluY3Jfc3ViXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJkIGkgaXNfdmFsaWRfZnN0IChpc192YWxpZCBmYWxzZSkgd2l0aFxuICAgICAgICB8IFNvbWUgbHN0IC0+IFNvbWUgKGxzdCwgZmFsc2UpXG4gICAgICAgIHwgTm9uZSAtPiBhdXggKGNhcmQrMSlcbiAgICAgICAgZW5kXG4gIGluXG4gIGF1eCAxXG5cbmxldCBzeW50aGVzaXNfdGVzdCBtYXhfY2FyZCBpID1cbiAgc3ludGhlc2lzX29wdGltYWwgfmNvbnN0YW50c19jYXQ6TW92TXZuIH5pbmNyX2FkZDpmYWxzZSB+aW5jcl9zdWI6dHJ1ZVxuICAgIG1heF9jYXJkIGkgKGZ1biBfIC0+IHRydWUpIChmdW4gXyBfIC0+IHRydWUpXG5cbmxldCBpc19jb21tYW5kX3ZhbGlkIGFybSA9XG4gIHRyeSAoXG4gICAgYXJtX3RvX2JpbmFyeSBhcm0gfD5cbiAgICBMaXN0LmV4aXN0cyAoZnVuIGkgLT4gTmFtZS5jb2Rlc19mb3JfY29tbWFuZCBpIHw+IE5hbWUuaXNfY29kZV93cml0YWJsZSlcbiAgKSB3aXRoIEludmFsaWRDb21tYW5kIC0+IGZhbHNlXG5cbmxldCB0d2Vha19tb3ZfbXZuIHN0cmljdCBpbnN0ciBzIGNvbmQgcmQgcnMgbWF4X2NhcmQgPVxuICBsZXQgY21kID0gTW92IHtpbnN0cjtzO2NvbmQ7cmQ7cnN9IGluXG4gIG1hdGNoIHJzIHdpdGhcbiAgfCBSZWdpc3RlciBfIC0+IFtjbWRdXG4gIHwgU2NhbGVkUmVnaXN0ZXIgXyAtPiBmYWlsd2l0aCBcIk5vdCBpbXBsZW1lbnRlZFwiXG4gIHwgSW1tZWRpYXRlIGkgLT5cbiAgICBsZXQgbWtfY21kX2ZpcnN0IGZzdCA9XG4gICAgICBsZXQgbmZzdCA9IGxvZ25vdCBmc3QgaW5cbiAgICAgIGxldCBjb25zdGFudF9zZXRfbW92ID0gaWYgc3RyaWN0IHRoZW4gY29uc3RhbnRzX3NldCBlbHNlIGNvbnN0YW50c19zZXRfbm9fY2FycnkgaW5cbiAgICAgIGxldCBpc19tb3YgPVxuICAgICAgICAoaW5zdHIgPSBNT1YgJiYgVUludDMyU2V0Lm1lbSBmc3QgY29uc3RhbnRfc2V0X21vdilcbiAgICAgICAgfHwgKFVJbnQzMlNldC5tZW0gbmZzdCBjb25zdGFudHNfc2V0IHw+IG5vdClcbiAgICAgIGluXG4gICAgICBtYXRjaCBpc19tb3YsIHN0cmljdCB3aXRoXG4gICAgICB8IHRydWUsIGZhbHNlIC0+IE1vdiB7aW5zdHI9TU9WO3M9dHJ1ZTtjb25kO3JkO3JzPUltbWVkaWF0ZSBmc3R9XG4gICAgICB8IHRydWUsIHRydWUgLT4gTW92IHtpbnN0cj1NT1Y7cztjb25kO3JkO3JzPUltbWVkaWF0ZSBmc3R9XG4gICAgICB8IGZhbHNlLCBmYWxzZSAtPiBNb3Yge2luc3RyPU1WTjtzPWZhbHNlO2NvbmQ7cmQ7cnM9SW1tZWRpYXRlIG5mc3R9XG4gICAgICB8IGZhbHNlLCB0cnVlIC0+IE1vdiB7aW5zdHI9TVZOO3M7Y29uZDtyZDtycz1JbW1lZGlhdGUgbmZzdH1cbiAgICBpblxuICAgIGxldCBta19jbWQgYWRkaXRpdmUgaSA9XG4gICAgICBtYXRjaCBhZGRpdGl2ZSwgc3RyaWN0IHdpdGhcbiAgICAgIHwgdHJ1ZSwgZmFsc2UgLT4gRGF0YVByb2Mge2luc3RyPUFEQztzPShyZD0xNSB8fCByZD0wKTtjb25kO3JkO3JuPXJkO29wMj1JbW1lZGlhdGUgaX1cbiAgICAgIHwgdHJ1ZSwgdHJ1ZSAtPiBEYXRhUHJvYyB7aW5zdHI9QUREO3M7Y29uZDtyZDtybj1yZDtvcDI9SW1tZWRpYXRlIGl9XG4gICAgICB8IGZhbHNlLCBmYWxzZSAtPiBEYXRhUHJvYyB7aW5zdHI9U0JDO3M9ZmFsc2U7Y29uZDtyZDtybj1yZDtvcDI9SW1tZWRpYXRlIGl9XG4gICAgICB8IGZhbHNlLCB0cnVlIC0+IERhdGFQcm9jIHtpbnN0cj1TVUI7cztjb25kO3JkO3JuPXJkO29wMj1JbW1lZGlhdGUgaX1cbiAgICBpblxuICAgIGxldCBpID0gaWYgaW5zdHIgPSBNT1YgdGhlbiBpIGVsc2UgbG9nbm90IGkgaW5cbiAgICBiZWdpbiBtYXRjaCBzeW50aGVzaXNfb3B0aW1hbCB+Y29uc3RhbnRzX2NhdDooaWYgc3RyaWN0IHRoZW4gTW92TXZuU3RyaWN0IGVsc2UgTW92TXZuKVxuICAgICAgICAgICAgICAgICAgfmluY3JfYWRkOmZhbHNlIH5pbmNyX3N1Yjoobm90IHN0cmljdCkgbWF4X2NhcmQgaVxuICAgICAgICAgICAgICAgICAgKGZ1biBpIC0+IG1rX2NtZF9maXJzdCBpIHw+IGlzX2NvbW1hbmRfdmFsaWQpXG4gICAgICAgICAgICAgICAgICAoZnVuIGFkZCBpIC0+IG1rX2NtZCBhZGQgaSB8PiBpc19jb21tYW5kX3ZhbGlkKSB3aXRoXG4gICAgfCBOb25lIC0+IFtjbWRdXG4gICAgfCBTb21lIChmc3Q6OmxzdCwgYWRkaXRpdmUpIC0+XG4gICAgICAobWtfY21kX2ZpcnN0IGZzdCk6OihMaXN0Lm1hcCAobWtfY21kIGFkZGl0aXZlKSBsc3QpXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgIGVuZFxuXG5sZXQgdHdlYWtfYXJpdGggc3RyaWN0IGluc3RyIHMgY29uZCByZCBybiBvcDIgbWF4X2NhcmQgPVxuICBhc3NlcnQgKGluc3RyID0gQURDIHx8IGluc3RyID0gU0JDIHx8IGluc3RyID0gQUREIHx8IGluc3RyID0gU1VCKSA7XG4gIGxldCBjbWQgPSBEYXRhUHJvYyB7aW5zdHI7cztjb25kO3JkO3JuO29wMn0gaW5cbiAgbWF0Y2ggb3AyIHdpdGhcbiAgfCBSZWdpc3RlciBfIC0+IFtjbWRdXG4gIHwgU2NhbGVkUmVnaXN0ZXIgXyAtPiBmYWlsd2l0aCBcIk5vdCBpbXBsZW1lbnRlZFwiXG4gIHwgSW1tZWRpYXRlIGkgLT5cbiAgICBsZXQgaSA9IGlmIG5vdCBzdHJpY3QgJiYgaW5zdHIgPSBTVUIgdGhlbiBwcmVkIGkgZWxzZSBpIGluICgqIEJlY2F1c2UgdGhlIFNVQiB3aWxsIGJlIHJlcGxhY2VkIGJ5IFNCQyAqKVxuICAgIGxldCBpc19hZGRpdGlvbiA9ICBpbnN0ciA9IEFEQyB8fCBpbnN0ciA9IEFERCBpblxuICAgIGxldCBta19jbWRfZmlyc3QgZnN0ID1cbiAgICAgIG1hdGNoIGlzX2FkZGl0aW9uLCBzdHJpY3Qgd2l0aFxuICAgICAgfCBfLCB0cnVlIC0+IERhdGFQcm9jIHtpbnN0cjtzO2NvbmQ7cmQ7cm47b3AyPUltbWVkaWF0ZSBmc3R9XG4gICAgICB8IHRydWUsIGZhbHNlIC0+IERhdGFQcm9jIHtpbnN0cj1BREM7cz0ocm49MTUgfHwgcm49MCk7Y29uZDtyZDtybjtvcDI9SW1tZWRpYXRlIGZzdH1cbiAgICAgIHwgZmFsc2UsIGZhbHNlIC0+IERhdGFQcm9jIHtpbnN0cj1TQkM7cz1mYWxzZTtjb25kO3JkO3JuO29wMj1JbW1lZGlhdGUgZnN0fVxuICAgIGluXG4gICAgbGV0IG1rX2NtZCBhZGRpdGl2ZSBpID1cbiAgICAgIGxldCBtdXN0X2FkZCA9IChhZGRpdGl2ZSAmJiBpc19hZGRpdGlvbikgfHwgKG5vdCBhZGRpdGl2ZSAmJiBub3QgaXNfYWRkaXRpb24pIGluXG4gICAgICBtYXRjaCBtdXN0X2FkZCwgc3RyaWN0IHdpdGhcbiAgICAgIHwgdHJ1ZSwgZmFsc2UgLT4gRGF0YVByb2Mge2luc3RyPUFEQztzPShyZD0xNSB8fCByZD0wKTtjb25kO3JkO3JuPXJkO29wMj1JbW1lZGlhdGUgaX1cbiAgICAgIHwgdHJ1ZSwgdHJ1ZSAtPiBEYXRhUHJvYyB7aW5zdHI9QUREO3M7Y29uZDtyZDtybj1yZDtvcDI9SW1tZWRpYXRlIGl9XG4gICAgICB8IGZhbHNlLCBmYWxzZSAtPiBEYXRhUHJvYyB7aW5zdHI9U0JDO3M9ZmFsc2U7Y29uZDtyZDtybj1yZDtvcDI9SW1tZWRpYXRlIGl9XG4gICAgICB8IGZhbHNlLCB0cnVlIC0+IERhdGFQcm9jIHtpbnN0cj1TVUI7cztjb25kO3JkO3JuPXJkO29wMj1JbW1lZGlhdGUgaX1cbiAgICBpblxuICAgIGJlZ2luIG1hdGNoIHN5bnRoZXNpc19vcHRpbWFsIH5jb25zdGFudHNfY2F0OkFyaXRoIH5pbmNyX2FkZDoobm90IGlzX2FkZGl0aW9uICYmIG5vdCBzdHJpY3QpXG4gICAgICAgICAgICAgICAgICB+aW5jcl9zdWI6KGlzX2FkZGl0aW9uICYmIG5vdCBzdHJpY3QpIG1heF9jYXJkIGlcbiAgICAgICAgICAgICAgICAgIChmdW4gaSAtPiBta19jbWRfZmlyc3QgaSB8PiBpc19jb21tYW5kX3ZhbGlkKVxuICAgICAgICAgICAgICAgICAgKGZ1biBhZGQgaSAtPiBta19jbWQgYWRkIGkgfD4gaXNfY29tbWFuZF92YWxpZCkgd2l0aFxuICAgIHwgTm9uZSAtPiBbY21kXVxuICAgIHwgU29tZSAoZnN0Ojpsc3QsIGFkZGl0aXZlKSAtPlxuICAgICAgKG1rX2NtZF9maXJzdCBmc3QpOjooTGlzdC5tYXAgKG1rX2NtZCBhZGRpdGl2ZSkgbHN0KVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxubGV0IHR3ZWFrX2NvbW1hbmQgKGFybSwgb3B0aW1pemUpID1cbiAgbGV0IHN0cmljdCA9XG4gICAgbWF0Y2ggIVNldHRpbmdzLnR3ZWFrZXJfbW9kZSB3aXRoXG4gICAgfCBTZXR0aW5ncy5GbGV4aWJsZSAtPiBmYWxzZSB8IFNldHRpbmdzLlN0cmljdCAtPiB0cnVlXG4gIGluXG4gIGxldCBvcHRpbWl6ZV93aXRoX2NhcmQgYXJtIG4gcGFkID1cbiAgICBsZXQgcmVzID1cbiAgICAgIG1hdGNoIGFybSB3aXRoXG4gICAgICB8IE1vdiB7aW5zdHI7cztjb25kO3JkO3JzfSAtPiB0d2Vha19tb3ZfbXZuIHN0cmljdCBpbnN0ciBzIGNvbmQgcmQgcnMgblxuICAgICAgfCBEYXRhUHJvYyB7aW5zdHI7cztjb25kO3JkO3JuO29wMn1cbiAgICAgIHdoZW4gaW5zdHIgPSBBREMgfHwgaW5zdHIgPSBTQkMgfHwgaW5zdHIgPSBBREQgfHwgaW5zdHIgPSBTVUIgLT5cbiAgICAgICAgdHdlYWtfYXJpdGggc3RyaWN0IGluc3RyIHMgY29uZCByZCBybiBvcDIgblxuICAgICAgfCBfIC0+IFthcm1dXG4gICAgaW5cbiAgICBpZiBwYWRcbiAgICB0aGVuXG4gICAgICBsZXQgcGFkZGluZyA9IExpc3QuaW5pdCAobiAtIChMaXN0Lmxlbmd0aCByZXMpKSAoZnVuIF8gLT4gcGFkZGluZ19jb2RlKSBpblxuICAgICAgcmVzQHBhZGRpbmdcbiAgICBlbHNlIHJlc1xuICBpblxuICBtYXRjaCBvcHRpbWl6ZSB3aXRoXG4gIHwgTm9Ud2Vha2luZyAtPiBbYXJtXVxuICB8IFR3ZWFrTWluTGVuZ3RoIC0+IG9wdGltaXplX3dpdGhfY2FyZCBhcm0gNSBmYWxzZVxuICB8IFR3ZWFrRml4ZWRMZW5ndGggY2FyZCAtPiBvcHRpbWl6ZV93aXRoX2NhcmQgYXJtIGNhcmQgdHJ1ZVxuXG5sZXQgdHdlYWtfYXJtIGxzdCA9XG4gIGxzdCB8PiBMaXN0Lm1hcCB0d2Vha19jb21tYW5kIHw+IExpc3QuZmxhdHRlblxuXG5sZXQgZG9fbm90X3R3ZWFrX2FybSBsc3QgPVxuICBsc3QgfD4gTGlzdC5tYXAgKGZ1biAoYXJtLCBvcHRpbWl6ZSkgLT5cbiAgICBpZiBvcHRpbWl6ZSA8PiBOb1R3ZWFraW5nIHRoZW4gcmFpc2UgQ2Fubm90T3B0aW1pemUgZWxzZSBhcm1cbiAgKVxuIiwiXG5tb2R1bGUgTWVuaGlyQmFzaWNzID0gc3RydWN0XG4gIFxuICBleGNlcHRpb24gRXJyb3JcbiAgXG4gIHR5cGUgdG9rZW4gPSBcbiAgICB8IFhPUlxuICAgIHwgVElNRVNcbiAgICB8IFNUUklORyBvZiAoXG4jIDcgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxMyBcIklPL3BhcnNlci5tbFwiXG4gIClcbiAgICB8IFJTSElGVFxuICAgIHwgUlBBUkVOXG4gICAgfCBSSUdIVF9CUkFDS1xuICAgIHwgUklHSFRfQlJBQ0VcbiAgICB8IFBMVVNcbiAgICB8IE9SXG4gICAgfCBOVU1CRVIgb2YgKFxuIyA4IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKGludDMyKVxuIyAyNCBcIklPL3BhcnNlci5tbFwiXG4gIClcbiAgICB8IE5VTExcbiAgICB8IE5PVFxuICAgIHwgTkVRXG4gICAgfCBNT0RcbiAgICB8IE1JTlVTXG4gICAgfCBMU0hJRlRcbiAgICB8IExQQVJFTlxuICAgIHwgTEVGVF9CUkFDS1xuICAgIHwgTEVGVF9CUkFDRVxuICAgIHwgSU5URVJST0dfTUFSS1xuICAgIHwgSUQgb2YgKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDM5IFwiSU8vcGFyc2VyLm1sXCJcbiAgKVxuICAgIHwgSEVBREVSXG4gICAgfCBIQVNIXG4gICAgfCBFWENMQU1fTUFSS1xuICAgIHwgRVFVQUxcbiAgICB8IEVRXG4gICAgfCBFT0xcbiAgICB8IEVPRlxuICAgIHwgRElWXG4gICAgfCBDT01NQVxuICAgIHwgQ09MT05cbiAgICB8IEJPUlxuICAgIHwgQk9PTCBvZiAoXG4jIDkgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoYm9vbClcbiMgNTUgXCJJTy9wYXJzZXIubWxcIlxuICApXG4gICAgfCBCQU5EXG4gICAgfCBBTkRcbiAgXG5lbmRcblxuaW5jbHVkZSBNZW5oaXJCYXNpY3NcblxubGV0IF9lUlIgPVxuICBNZW5oaXJCYXNpY3MuRXJyb3JcblxudHlwZSBfbWVuaGlyX2VudiA9IHtcbiAgX21lbmhpcl9sZXhlcjogTGV4aW5nLmxleGJ1ZiAtPiB0b2tlbjtcbiAgX21lbmhpcl9sZXhidWY6IExleGluZy5sZXhidWY7XG4gIF9tZW5oaXJfdG9rZW46IHRva2VuO1xuICBtdXRhYmxlIF9tZW5oaXJfZXJyb3I6IGJvb2xcbn1cblxuYW5kIF9tZW5oaXJfc3RhdGUgPSBcbiAgfCBNZW5oaXJTdGF0ZTExNFxuICB8IE1lbmhpclN0YXRlMTAyXG4gIHwgTWVuaGlyU3RhdGUxMDBcbiAgfCBNZW5oaXJTdGF0ZTk2XG4gIHwgTWVuaGlyU3RhdGU5MlxuICB8IE1lbmhpclN0YXRlODdcbiAgfCBNZW5oaXJTdGF0ZTc5XG4gIHwgTWVuaGlyU3RhdGU3NFxuICB8IE1lbmhpclN0YXRlNjlcbiAgfCBNZW5oaXJTdGF0ZTY3XG4gIHwgTWVuaGlyU3RhdGU2NlxuICB8IE1lbmhpclN0YXRlNjJcbiAgfCBNZW5oaXJTdGF0ZTU5XG4gIHwgTWVuaGlyU3RhdGU1OFxuICB8IE1lbmhpclN0YXRlNTNcbiAgfCBNZW5oaXJTdGF0ZTQ2XG4gIHwgTWVuaGlyU3RhdGU0NFxuICB8IE1lbmhpclN0YXRlNDJcbiAgfCBNZW5oaXJTdGF0ZTQwXG4gIHwgTWVuaGlyU3RhdGUzOFxuICB8IE1lbmhpclN0YXRlMzVcbiAgfCBNZW5oaXJTdGF0ZTMzXG4gIHwgTWVuaGlyU3RhdGUzMVxuICB8IE1lbmhpclN0YXRlMjlcbiAgfCBNZW5oaXJTdGF0ZTI3XG4gIHwgTWVuaGlyU3RhdGUyNVxuICB8IE1lbmhpclN0YXRlMjNcbiAgfCBNZW5oaXJTdGF0ZTIxXG4gIHwgTWVuaGlyU3RhdGUxOVxuICB8IE1lbmhpclN0YXRlMTdcbiAgfCBNZW5oaXJTdGF0ZTE1XG4gIHwgTWVuaGlyU3RhdGUxMlxuICB8IE1lbmhpclN0YXRlMTBcbiAgfCBNZW5oaXJTdGF0ZTlcbiAgfCBNZW5oaXJTdGF0ZThcbiAgfCBNZW5oaXJTdGF0ZTZcbiAgfCBNZW5oaXJTdGF0ZTVcbiAgfCBNZW5oaXJTdGF0ZTNcbiAgfCBNZW5oaXJTdGF0ZTFcbiAgfCBNZW5oaXJTdGF0ZTBcblxuIyAxIFwiSU8vcGFyc2VyLm1seVwiXG4gICBvcGVuIFBhcnNlcl9hc3QgXG4jIDExOCBcIklPL3BhcnNlci5tbFwiXG5cbiMgMiBcIklPL3BhcnNlci5tbHlcIlxuICAgb3BlbiBQcmVwcm9jZXNzIFxuIyAxMjIgXCJJTy9wYXJzZXIubWxcIlxuXG5sZXQgcmVjIF9tZW5oaXJfcnVuMTUgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxNVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTUgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTVcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTVcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE1XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxNSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxNVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTVcblxuYW5kIF9tZW5oaXJfcnVuMTcgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxN1xuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTcgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTdcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTdcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE3XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxNyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxN1xuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTdcblxuYW5kIF9tZW5oaXJfcnVuMTkgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxOVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTkgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTlcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTlcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTE5XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxOSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxOVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTlcblxuYW5kIF9tZW5oaXJfcnVuMjEgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyMVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjEgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjFcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjFcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTIxXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyMSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyMVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjFcblxuYW5kIF9tZW5oaXJfcnVuMzggOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzOFxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzggX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzhcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzhcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTM4XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzOCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzOFxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzhcblxuYW5kIF9tZW5oaXJfcnVuMjkgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyOVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjkgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjlcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjlcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI5XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyOSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyOVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjlcblxuYW5kIF9tZW5oaXJfcnVuMjMgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyM1xuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjMgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjNcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjNcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTIzXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyMyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyM1xuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjNcblxuYW5kIF9tZW5oaXJfcnVuMjcgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyN1xuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjcgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjdcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjdcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI3XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyNyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyN1xuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjdcblxuYW5kIF9tZW5oaXJfcnVuMzEgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzMVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzEgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzFcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzFcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMxXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzMSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzMVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzFcblxuYW5kIF9tZW5oaXJfcnVuNDAgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MFxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDAgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDBcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDBcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQwXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MFxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDBcblxuYW5kIF9tZW5oaXJfcnVuMzMgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzM1xuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzMgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzNcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzNcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMzXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzMyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzM1xuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzNcblxuYW5kIF9tZW5oaXJfcnVuMjUgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyNVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjUgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjVcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjVcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTI1XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyNSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUyNVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMjVcblxuYW5kIF9tZW5oaXJfcnVuNDQgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NFxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDQgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDRcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDRcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQ0XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NFxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDRcblxuYW5kIF9tZW5oaXJfcnVuNDYgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NlxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDYgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDZcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDZcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQ2XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NiBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0NlxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDZcblxuYW5kIF9tZW5oaXJfcnVuMzUgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgKiBfbWVuaGlyX3N0YXRlICogKFByZXByb2Nlc3MubWV0YV9leHByKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzNVxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzUgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzVcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzVcbiAgICB8IE5PVCAtPlxuICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTM1XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzNSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzNVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMzVcblxuYW5kIF9tZW5oaXJfZ290b19vZmZzZXQgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoUGFyc2VyX2FzdC5vZmZzZXQpIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfdikgaW5cbiAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgIHwgTWVuaGlyU3RhdGU1OCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcyksIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyA0OTQgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXyksIF8sIChvIDogKFBhcnNlcl9hc3Qub2Zmc2V0KSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzKSA9IFxuIyAxMjEgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggT2Zmc2V0IChpZCwgbywgQXJtLlBvc3RJbmRleGVkKSApXG4jIDQ5OSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fYXJnIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTc0IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgUklHSFRfQlJBQ0sgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICB8IEVYQ0xBTV9NQVJLIC0+XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgKCgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDUxOSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgKSksIF9zdGFydHBvc19pZF8pLCBfLCAobyA6IChQYXJzZXJfYXN0Lm9mZnNldCkpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzKSA9IFxuIyAxMTggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBPZmZzZXQgKGlkLCBvLCBBcm0uUHJlSW5kZXhlZCkgKVxuIyA1MjQgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19hcmcgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgICAgIHwgQ09NTUEgfCBFT0YgfCBFT0wgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCAoKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCAoaWQgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgNTMyIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXyksIF8sIChvIDogKFBhcnNlcl9hc3Qub2Zmc2V0KSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LmFyZ3MpID0gXG4jIDExNSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBPZmZzZXQgKGlkLCBvLCBBcm0uT2Zmc2V0KSApXG4jIDUzNyBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgX21lbmhpcl9nb3RvX2FyZyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IF8gLT5cbiAgICAgICAgX21lbmhpcl9mYWlsICgpXG5cbmFuZCBfbWVuaGlyX2dvdG9fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfYXJnXyA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+IChQYXJzZXJfYXN0LmFyZ3MgbGlzdCkgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgLT5cbiAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgIHwgTWVuaGlyU3RhdGU1MyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICh4IDogKFBhcnNlcl9hc3QuYXJncyBsaXN0KSkgPSBfdiBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzIGxpc3QpID0gXG4jIDE0NCBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIHggKVxuIyA1NjUgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfYXJnX18gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlODcgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoeHMgOiAoUGFyc2VyX2FzdC5hcmdzIGxpc3QpKSA9IF92IGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCAoeCA6IChQYXJzZXJfYXN0LmFyZ3MpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LmFyZ3MgbGlzdCkgPSBcbiMgMjQzIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeCA6OiB4cyApXG4jIDU3NiBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfYXJnXyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgXyAtPlxuICAgICAgICBfbWVuaGlyX2ZhaWwgKClcblxuYW5kIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfdikgaW5cbiAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgIHwgTWVuaGlyU3RhdGUxMiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXywgKGUgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgODAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTVVuYXJ5IChPQk5vdCwgZSkgKVxuIyA1OTMgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGUxMCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQkFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40NiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQk9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ0IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJQQVJFTiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfLCAoZSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNjIgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBlIClcbiMgNjMzIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFhPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlMTUgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBBTkQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBSU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBJTlRFUlJPR19NQVJLIHwgT1IgfCBSSUdIVF9CUkFDRSB8IFJQQVJFTiB8IFhPUiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCAoZTEgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSksIF8sIChlMiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNjkgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPWG9yLCBlMSwgZTIpIClcbiMgNjc5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTE3IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDY1IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPTXVsLCBlMSwgZTIpIClcbiMgNjk1IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlMTkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBBTkQgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBFUSB8IElOVEVSUk9HX01BUksgfCBMU0hJRlQgfCBORVEgfCBPUiB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIHwgUlNISUZUIHwgWE9SIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3NiBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1CaW5hcnkgKE9SU2hpZnQsIGUxLCBlMikgKVxuIyA3MTkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlMjEgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEFORCB8IEJBTkQgfCBCT1IgfCBDT0xPTiB8IEVPTCB8IEVRIHwgSU5URVJST0dfTUFSSyB8IExTSElGVCB8IE1JTlVTIHwgTkVRIHwgT1IgfCBQTFVTIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gfCBSU0hJRlQgfCBYT1IgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDYzIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1CaW5hcnkgKE9BZGQsIGUxLCBlMikgKVxuIyA3NDUgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlMjMgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNjcgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPTW9kLCBlMSwgZTIpIClcbiMgNzYxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlMjUgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgNjYgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPRGl2LCBlMSwgZTIpIClcbiMgNzcxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlMjcgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEFORCB8IEJBTkQgfCBCT1IgfCBDT0xPTiB8IEVPTCB8IEVRIHwgSU5URVJST0dfTUFSSyB8IExTSElGVCB8IE1JTlVTIHwgTkVRIHwgT1IgfCBQTFVTIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gfCBSU0hJRlQgfCBYT1IgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDY0IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBNQmluYXJ5IChPU3ViLCBlMSwgZTIpIClcbiMgNzkxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTI5IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgRElWIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEFORCB8IEJBTkQgfCBCT1IgfCBDT0xPTiB8IEVPTCB8IEVRIHwgSU5URVJST0dfTUFSSyB8IE5FUSB8IE9SIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gfCBYT1IgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDc0IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT05lcSwgZTEsIGUyKSApXG4jIDgyNSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGUzMSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEFORCB8IEJBTkQgfCBCT1IgfCBDT0xPTiB8IEVPTCB8IEVRIHwgSU5URVJST0dfTUFSSyB8IExTSElGVCB8IE5FUSB8IE9SIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gfCBSU0hJRlQgfCBYT1IgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDc1IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT0xTaGlmdCwgZTEsIGUyKSApXG4jIDg1NSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGUzMyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTFNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTU9EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBSU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBBTkQgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBFUSB8IElOVEVSUk9HX01BUksgfCBORVEgfCBPUiB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIHwgWE9SIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3MyBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT0VxLCBlMSwgZTIpIClcbiMgODg5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTM1IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgRElWIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBFUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTFNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTU9EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBORVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEFORCB8IEJBTkQgfCBCT1IgfCBDT0xPTiB8IEVPTCB8IElOVEVSUk9HX01BUksgfCBPUiB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIHwgWE9SIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA2OCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1CaW5hcnkgKE9BbmQsIGUxLCBlMikgKVxuIyA5MjcgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlMzggLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBBTkQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjIxIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBSU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFRJTUVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBYT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEJBTkQgfCBCT1IgfCBDT0xPTiB8IEVPTCB8IElOVEVSUk9HX01BUksgfCBPUiB8IFJJR0hUX0JSQUNFIHwgUlBBUkVOIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChlMSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSwgXywgKGUyIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3MCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT09yLCBlMSwgZTIpIClcbiMgOTY5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTQwIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IENPTE9OIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICAgICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuMTIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQyXG4gICAgICAgICAgICB8IElEIF92IC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDIgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICB8IExQQVJFTiAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQyXG4gICAgICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW45IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU0MlxuICAgICAgICAgICAgfCBOT1QgLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQyXG4gICAgICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNDIgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQyXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTQyKVxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IElOVEVSUk9HX01BUksgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUlNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBUSU1FUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgWE9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGU0MiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQkFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40NiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQk9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ0IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFhPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQ09MT04gfCBFT0wgfCBSSUdIVF9CUkFDRSB8IFJQQVJFTiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUwIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTEgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSksIF8sIChlMiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikgPSBcbiMgODIgXCJJTy9wYXJzZXIubWx5XCJcbiAgKCBNQ29uZCAoZTAsIGUxLCBlMikgKVxuIyAxMDgzIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTQ0IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFhPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBJTlRFUlJPR19NQVJLIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDcxIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTUJpbmFyeSAoT0JPciwgZTEsIGUyKSApXG4jIDExMjkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fbWV0YV9leHByIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlNDYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBBTkQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUlNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBUSU1FUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgWE9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCQU5EIHwgQk9SIHwgQ09MT04gfCBFT0wgfCBJTlRFUlJPR19NQVJLIHwgUklHSFRfQlJBQ0UgfCBSUEFSRU4gLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGUxIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpLCBfLCAoZTIgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDcyIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1CaW5hcnkgKE9CQW5kLCBlMSwgZTIpIClcbiMgMTE3MyBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19tZXRhX2V4cHIgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgTWVuaGlyU3RhdGU5IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfLCAoZSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3OCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTVVuYXJ5IChPTmVnLCBlKSApXG4jIDExODkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU4IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfLCAoZSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3OSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICggTVVuYXJ5IChPTm90LCBlKSApXG4jIDExOTkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU2IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfLCAoZSA6IChQcmVwcm9jZXNzLm1ldGFfZXhwcikpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MubWV0YV9leHByKSA9IFxuIyA3NyBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE1VbmFyeSAoT0lkLCBlKSApXG4jIDEyMDkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU1IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IElOVEVSUk9HX01BUksgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUklHSFRfQlJBQ0UgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfc3RhcnRwb3NfXzFfKSwgXywgKGUgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX18xXyBpblxuICAgICAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpID0gXG4jIDEzNCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTWV0YUV4cHIgZSApXG4jIDEyNTAgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fbnVtYmVyIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IF9zdGFydHBvc1xuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFhPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IE1lbmhpclN0YXRlMTAwIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjM1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCQU5EIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBCT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IERJViAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRVEgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IElOVEVSUk9HX01BUksgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNDAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IExTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1PRCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgTkVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgUlNISUZUIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBUSU1FUyAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgWE9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjE1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBFT0wgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxMzA1IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSwgXywgKGUgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5kZWZpbml0aW9uKSA9IFxuIyA5MCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggVmFyRGVmIChpZCwgdHJ1ZSwgZSkgKVxuIyAxMzEwIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgX21lbmhpcl9nb3RvX2RlZmluaXRpb24gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfdlxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBNZW5oaXJTdGF0ZTEwMiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4zNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQkFORCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40NiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgQk9SIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQ0IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBESVYgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IEVRIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjMzIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBMU0hJRlQgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjI3IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaylcbiAgICAgICAgfCBNT0QgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjMgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IE5FUSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4yOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgT1IgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFJTSElGVCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgVElNRVMgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuMTcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKVxuICAgICAgICB8IFhPUiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW4xNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spXG4gICAgICAgIHwgRU9MIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCAoaWQgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTM1OSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXyksIF8sIChlIDogKFByZXByb2Nlc3MubWV0YV9leHByKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MuZGVmaW5pdGlvbikgPSBcbiMgODkgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggVmFyRGVmIChpZCwgZmFsc2UsIGUpIClcbiMgMTM2NCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19kZWZpbml0aW9uIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX3ZcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgXyAtPlxuICAgICAgICBfbWVuaGlyX2ZhaWwgKClcblxuYW5kIF9tZW5oaXJfZ290b19jb21tYW5kIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFBhcnNlcl9hc3QuY29tbWFuZCkgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF92KSBpblxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IEVPRiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSwgXywgKGNtZCA6IChQYXJzZXJfYXN0LmNvbW1hbmQpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LmFzdCkgPSBcbiMgMTAxIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBbY21kXSApXG4jIDEzOTAgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2FzdCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgRU9MIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgRU9MIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTkyXG4gICAgICAgIHwgRU9GIHwgSUQgXyB8IExFRlRfQlJBQ0UgfCBOVU1CRVIgXyAtPlxuICAgICAgICAgICAgX21lbmhpcl9yZWR1Y2UyNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOTJcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5MilcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG5cbmFuZCBfbWVuaGlyX2dvdG9fbnVtYmVyIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpIC0+IExleGluZy5wb3NpdGlvbiAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiBfc3RhcnRwb3MgLT5cbiAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgIHwgTWVuaGlyU3RhdGU1OSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChpIDogKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpKSA9IF92IGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfaV8gPSBfc3RhcnRwb3MgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5vZmZzZXQpID0gXG4jIDEyNiBcIklPL3BhcnNlci5tbHlcIlxuICAoIE9JbW1lZGlhdGUgKEFybS5zaWduX3BsdXMsIGkpIClcbiMgMTQyNSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fb2Zmc2V0IF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTYyIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKGkgOiAoUGFyc2VyX2FzdC51bnByb2Nlc3NlZF9pbnQzMikpID0gX3YgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvc19pXyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0Lm9mZnNldCkgPSBcbiMgMTI3IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE9JbW1lZGlhdGUgKEFybS5zaWduX21pbnVzLCBpKSApXG4jIDE0MzcgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX29mZnNldCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU2NyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChpIDogKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpKSA9IF92IGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfaV8gPSBfc3RhcnRwb3MgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0Lm9mZnNldCkgPSBcbiMgMTI2IFwiSU8vcGFyc2VyLm1seVwiXG4gICggT0ltbWVkaWF0ZSAoQXJtLnNpZ25fcGx1cywgaSkgKVxuIyAxNDQ5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19vZmZzZXQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlNjkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoaSA6IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcyksIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5vZmZzZXQpID0gXG4jIDEyNyBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBPSW1tZWRpYXRlIChBcm0uc2lnbl9taW51cywgaSkgKVxuIyAxNDYxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19vZmZzZXQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlNjYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoaSA6IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3Qub2Zmc2V0KSA9IFxuIyAxMjYgXCJJTy9wYXJzZXIubWx5XCJcbiAgKCBPSW1tZWRpYXRlIChBcm0uc2lnbl9wbHVzLCBpKSApXG4jIDE0NzMgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX29mZnNldCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU3NCB8IE1lbmhpclN0YXRlNTggLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoaSA6IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0Lm9mZnNldCkgPSBcbiMgMTI2IFwiSU8vcGFyc2VyLm1seVwiXG4gICggT0ltbWVkaWF0ZSAoQXJtLnNpZ25fcGx1cywgaSkgKVxuIyAxNDg0IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19vZmZzZXQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlNzkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoaSA6IChQYXJzZXJfYXN0LnVucHJvY2Vzc2VkX2ludDMyKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXJncykgPSBcbiMgMTE0IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggSW1tZWRpYXRlIGkgKVxuIyAxNDk2IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19hcmcgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IE1lbmhpclN0YXRlODcgfCBNZW5oaXJTdGF0ZTUzIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKGkgOiAoUGFyc2VyX2FzdC51bnByb2Nlc3NlZF9pbnQzMikpID0gX3YgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvc19pXyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzKSA9IFxuIyAxMTQgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBJbW1lZGlhdGUgaSApXG4jIDE1MDcgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2FyZyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGUzIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKG5iIDogKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpKSA9IF92IGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfbmJfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0LmNvbW1hbmQpID0gbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19uYl8gaW5cbiAgICAgICAgXG4jIDEwOSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICggQklOIChfc3RhcnRwb3MsIG5iKSApXG4jIDE1MTkgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2NvbW1hbmQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IF8gLT5cbiAgICAgICAgX21lbmhpcl9mYWlsICgpXG5cbmFuZCBfbWVuaGlyX3J1bjU5IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBJRCBfdiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3MgPSBNZW5oaXJTdGF0ZTU5IGluXG4gICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3AgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxNTQwIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgKSkgPSBfdiBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zX2lkXyA9IF9zdGFydHBvcyBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQYXJzZXJfYXN0Lm9mZnNldCkgPSBcbiMgMTI4IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICggT1JlZ2lzdGVyIChBcm0uc2lnbl9wbHVzLCBpZCkgKVxuIyAxNTQ3IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19vZmZzZXQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IExFRlRfQlJBQ0UgLT5cbiAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1OSBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTU5IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNTlcblxuYW5kIF9tZW5oaXJfcnVuNjIgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgaW5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IElEIF92IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfcyA9IE1lbmhpclN0YXRlNjIgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcCBpblxuICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDE1NzQgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICApKSA9IF92IGluXG4gICAgICAgIGxldCBfc3RhcnRwb3NfaWRfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3Qub2Zmc2V0KSA9IFxuIyAxMjkgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgKCBPUmVnaXN0ZXIgKEFybS5zaWduX21pbnVzLCBpZCkgKVxuIyAxNTgxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19vZmZzZXQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IExFRlRfQlJBQ0UgLT5cbiAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2MiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTYyIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNjJcblxuYW5kIF9tZW5oaXJfcnVuNjUgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTU5NiBcIklPL3BhcnNlci5tbFwiXG4pIC0+IExleGluZy5wb3NpdGlvbiAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiBfc3RhcnRwb3MgLT5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgbGV0IChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxNjA0IFwiSU8vcGFyc2VyLm1sXCJcbiAgICApKSA9IF92IGluXG4gICAgbGV0IF9zdGFydHBvc19pZF8gPSBfc3RhcnRwb3MgaW5cbiAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5vZmZzZXQpID0gXG4jIDEyOCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIE9SZWdpc3RlciAoQXJtLnNpZ25fcGx1cywgaWQpIClcbiMgMTYxMCBcIklPL3BhcnNlci5tbFwiXG4gICAgIGluXG4gICAgX21lbmhpcl9nb3RvX29mZnNldCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuXG5hbmQgX21lbmhpcl9ydW42NiA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgTEVGVF9CUkFDRSAtPlxuICAgICAgICBfbWVuaGlyX3J1bjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTY2IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTUlOVVMgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zID0gTWVuaGlyU3RhdGU2NiBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpIGluXG4gICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IExFRlRfQlJBQ0UgLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcnVuNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNjkgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTY5IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTY5KVxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNjYgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfcyA9IE1lbmhpclN0YXRlNjYgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBMRUZUX0JSQUNFIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjUgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTY3IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2NyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2NylcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTY2XG5cbmFuZCBfbWVuaGlyX2dvdG9fYXJnIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFBhcnNlcl9hc3QuYXJncykgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF92KSBpblxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IENPTU1BIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgSEFTSCAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW43OSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlODdcbiAgICAgICAgfCBJRCBfdiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW43OCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlODcgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgIHwgTEVGVF9CUkFDRSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4NyBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgfCBMRUZUX0JSQUNLIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjU0IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4N1xuICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4NyBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4NylcbiAgICB8IEVPRiB8IEVPTCB8IElOVEVSUk9HX01BUksgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKHggOiAoUGFyc2VyX2FzdC5hcmdzKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzIGxpc3QpID0gXG4jIDI0MSBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFsgeCBdIClcbiMgMTY5MSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICBpblxuICAgICAgICBfbWVuaGlyX2dvdG9fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfYXJnXyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcblxuYW5kIF9tZW5oaXJfZmFpbCA6IHVuaXQgLT4gJ2EgPVxuICBmdW4gKCkgLT5cbiAgICBQcmludGYuZnByaW50ZiBzdGRlcnIgXCJJbnRlcm5hbCBmYWlsdXJlIC0tIHBsZWFzZSBjb250YWN0IHRoZSBwYXJzZXIgZ2VuZXJhdG9yJ3MgZGV2ZWxvcGVycy5cXG4lIVwiO1xuICAgIGFzc2VydCBmYWxzZVxuXG5hbmQgX21lbmhpcl9ydW42IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2XG4gICAgfCBJRCBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjExIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTZcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNlxuICAgIHwgTk9UIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNlxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNiBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2XG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU2XG5cbmFuZCBfbWVuaGlyX3J1bjcgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoXG4jIDggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoaW50MzIpXG4jIDE3MzQgXCJJTy9wYXJzZXIubWxcIlxuKSAtPiBMZXhpbmcucG9zaXRpb24gLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgX3N0YXJ0cG9zIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgIGxldCAoaSA6IChcbiMgOCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChpbnQzMilcbiMgMTc0MiBcIklPL3BhcnNlci5tbFwiXG4gICAgKSkgPSBfdiBpblxuICAgIGxldCBfc3RhcnRwb3NfaV8gPSBfc3RhcnRwb3MgaW5cbiAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDYwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAoIE1Db25zdCBpIClcbiMgMTc0OCBcIklPL3BhcnNlci5tbFwiXG4gICAgIGluXG4gICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuXG5hbmQgX21lbmhpcl9ydW44IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEyIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4XG4gICAgfCBJRCBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjExIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZThcbiAgICB8IE1JTlVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOFxuICAgIHwgTk9UIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOFxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IFBMVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW42IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4XG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU4XG5cbmFuZCBfbWVuaGlyX3J1bjkgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgaW5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IEVYQ0xBTV9NQVJLIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTlcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTkgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOVxuICAgIHwgTUlOVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW45IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgUExVUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTlcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTlcblxuYW5kIF9tZW5oaXJfcnVuMTAgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyAtPlxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgaW5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IEVYQ0xBTV9NQVJLIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwXG4gICAgfCBJRCBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjExIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IExQQVJFTiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjEwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMFxuICAgIHwgTUlOVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW45IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMFxuICAgIHwgTk9UIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTBcbiAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICBfbWVuaGlyX3J1bjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgUExVUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwXG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMFxuXG5hbmQgX21lbmhpcl9ydW4xMSA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxODMwIFwiSU8vcGFyc2VyLm1sXCJcbikgLT4gTGV4aW5nLnBvc2l0aW9uIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IF9zdGFydHBvcyAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICBsZXQgKHYgOiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMTgzOCBcIklPL3BhcnNlci5tbFwiXG4gICAgKSkgPSBfdiBpblxuICAgIGxldCBfc3RhcnRwb3Nfdl8gPSBfc3RhcnRwb3MgaW5cbiAgICBsZXQgX3YgOiAoUHJlcHJvY2Vzcy5tZXRhX2V4cHIpID0gXG4jIDYxIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICggTVZhciB2IClcbiMgMTg0NCBcIklPL3BhcnNlci5tbFwiXG4gICAgIGluXG4gICAgX21lbmhpcl9nb3RvX21ldGFfZXhwciBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuXG5hbmQgX21lbmhpcl9ydW4xMiA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTJcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEyIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgTFBBUkVOIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEyXG4gICAgfCBNSU5VUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEyXG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMlxuICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTIgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBQTFVTIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTJcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEyXG5cbmFuZCBfbWVuaGlyX2dvdG9fZGVmaW5pdGlvbiA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiAoUHJlcHJvY2Vzcy5kZWZpbml0aW9uKSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF92IC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX3YpIGluXG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRU9MIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgRU9MIC0+XG4gICAgICAgICAgICBfbWVuaGlyX3J1bjEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTExNFxuICAgICAgICB8IEhFQURFUiB8IElEIF8gLT5cbiAgICAgICAgICAgIF9tZW5oaXJfcmVkdWNlMjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTExNFxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTExNClcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcblxuYW5kIF9tZW5oaXJfZ290b19oZWFkZXJzIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFByZXByb2Nlc3MuaGVhZGVycykgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgLT5cbiAgICBtYXRjaCBfbWVuaGlyX3Mgd2l0aFxuICAgIHwgTWVuaGlyU3RhdGUxMTQgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoZHMgOiAoUHJlcHJvY2Vzcy5oZWFkZXJzKSkgPSBfdiBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pLCAoZCA6IChQcmVwcm9jZXNzLmRlZmluaXRpb24pKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLmhlYWRlcnMpID0gXG4jIDk1IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggZDo6ZHMgKVxuIyAxOTExIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgIGluXG4gICAgICAgIF9tZW5oaXJfZ290b19oZWFkZXJzIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgfCBNZW5oaXJTdGF0ZTk2IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF8xIDogKFByZXByb2Nlc3MuaGVhZGVycykpID0gX3YgaW5cbiAgICAgICAgT2JqLm1hZ2ljIF8xXG4gICAgfCBfIC0+XG4gICAgICAgIF9tZW5oaXJfZmFpbCAoKVxuXG5hbmQgX21lbmhpcl9nb3RvX2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfYXJnX18gOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoUGFyc2VyX2FzdC5hcmdzIGxpc3QpIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfdikgaW5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCAoaSA6IChcbiMgOCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChpbnQzMilcbiMgMTk0MiBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICApKSA9IF92IGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zX2lfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxOTQ4IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSwgXywgKHhzIDogKFBhcnNlcl9hc3QuYXJncyBsaXN0KSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuY29tbWFuZCkgPSBsZXQgYXJncyA9IFxuIyAyMzIgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4cyApXG4jIDE5NTMgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2lkXyBpblxuICAgICAgICAgICAgXG4jIDEwOCBcIklPL3BhcnNlci5tbHlcIlxuICAoIEFTTSAoX3N0YXJ0cG9zLCBpZCwgYXJncywgT3B0aW1pemVyLlR3ZWFrRml4ZWRMZW5ndGggKFV0aWxzLnVpbnQzMl90b19pbnQgaSkpIClcbiMgMTk1OSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19jb21tYW5kIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgRU9GIHwgRU9MIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAxOTY3IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSwgXywgKHhzIDogKFBhcnNlcl9hc3QuYXJncyBsaXN0KSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuY29tbWFuZCkgPSBsZXQgYXJncyA9IFxuIyAyMzIgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4cyApXG4jIDE5NzIgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2lkXyBpblxuICAgICAgICAgICAgXG4jIDEwNiBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggQVNNIChfc3RhcnRwb3MsIGlkLCBhcmdzLCBPcHRpbWl6ZXIuVHdlYWtNaW5MZW5ndGgpIClcbiMgMTk3OCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZ290b19jb21tYW5kIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICB8IEVPRiB8IEVPTCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDE5OTIgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICApKSwgX3N0YXJ0cG9zX2lkXyksIF8sICh4cyA6IChQYXJzZXJfYXN0LmFyZ3MgbGlzdCkpKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuY29tbWFuZCkgPSBsZXQgYXJncyA9IFxuIyAyMzIgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCB4cyApXG4jIDE5OTcgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9zdGFydHBvc19pZF8gaW5cbiAgICAgICAgXG4jIDEwNSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBBU00gKF9zdGFydHBvcywgaWQsIGFyZ3MsIE9wdGltaXplci5Ob1R3ZWFraW5nKSApXG4jIDIwMDMgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2NvbW1hbmQgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG5cbmFuZCBfbWVuaGlyX3J1bjQgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoXG4jIDggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoaW50MzIpXG4jIDIwMTYgXCJJTy9wYXJzZXIubWxcIlxuKSAtPiBMZXhpbmcucG9zaXRpb24gLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgX3N0YXJ0cG9zIC0+XG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgIGxldCAoaSA6IChcbiMgOCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChpbnQzMilcbiMgMjAyNCBcIklPL3BhcnNlci5tbFwiXG4gICAgKSkgPSBfdiBpblxuICAgIGxldCBfc3RhcnRwb3NfaV8gPSBfc3RhcnRwb3MgaW5cbiAgICBsZXQgX3N0YXJ0cG9zID0gX3N0YXJ0cG9zX2lfIGluXG4gICAgbGV0IF92IDogKFBhcnNlcl9hc3QudW5wcm9jZXNzZWRfaW50MzIpID0gXG4jIDEzMyBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgKCBDb25zdEludDMyIGkgKVxuIyAyMDMxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgaW5cbiAgICBfbWVuaGlyX2dvdG9fbnVtYmVyIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92IF9zdGFydHBvc1xuXG5hbmQgX21lbmhpcl9ydW41NCA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgSUQgX3YgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3N0YXJ0cG9zID0gX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wIGluXG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF92LCBfc3RhcnRwb3MpIGluXG4gICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IENPTU1BIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICAgICAgfCBIQVNIIC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW42NiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNzRcbiAgICAgICAgICAgIHwgSUQgX3YgLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjY1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU3NCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgIHwgTEVGVF9CUkFDRSAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNzQgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW42MiBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNzRcbiAgICAgICAgICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU3NCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNTkgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTc0XG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTc0KVxuICAgICAgICB8IFJJR0hUX0JSQUNLIC0+XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICAgICAgfCBDT01NQSAtPlxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICAgICAgfCBIQVNIIC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTU4XG4gICAgICAgICAgICAgICAgfCBJRCBfdiAtPlxuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjY1IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1OCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgICAgICB8IExFRlRfQlJBQ0UgLT5cbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1OCBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgICAgICB8IE1JTlVTIC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNjIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTU4XG4gICAgICAgICAgICAgICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1OCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgICAgICB8IFBMVVMgLT5cbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW41OSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNThcbiAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTU4KVxuICAgICAgICAgICAgfCBFWENMQU1fTUFSSyAtPlxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDIxMDIgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzKSA9IFxuIyAxMjAgXCJJTy9wYXJzZXIubWx5XCJcbiAgKCBPZmZzZXQgKGlkLCBPSW1tZWRpYXRlIChBcm0uc2lnbl9wbHVzLCBDb25zdEludDMyIEludDMyLnplcm8pLCBBcm0uUHJlSW5kZXhlZCkgKVxuIyAyMTA3IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX2dvdG9fYXJnIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgICAgICB8IEVPRiB8IEVPTCB8IElOVEVSUk9HX01BUksgLT5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDIxMTUgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzKSA9IFxuIyAxMTcgXCJJTy9wYXJzZXIubWx5XCJcbiAgKCBPZmZzZXQgKGlkLCBPSW1tZWRpYXRlIChBcm0uc2lnbl9wbHVzLCBDb25zdEludDMyIEludDMyLnplcm8pLCBBcm0uT2Zmc2V0KSApXG4jIDIxMjAgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19hcmcgX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zKVxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcblxuYW5kIF9tZW5oaXJfcnVuNSA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+IExleGluZy5wb3NpdGlvbiAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfc3RhcnRwb3MgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF9zdGFydHBvcykgaW5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICBtYXRjaCBfdG9rIHdpdGhcbiAgICB8IEVYQ0xBTV9NQVJLIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTVcbiAgICB8IElEIF92IC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMTEgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTUgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBMUEFSRU4gLT5cbiAgICAgICAgX21lbmhpcl9ydW4xMCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNVxuICAgIHwgTUlOVVMgLT5cbiAgICAgICAgX21lbmhpcl9ydW45IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1XG4gICAgfCBOT1QgLT5cbiAgICAgICAgX21lbmhpcl9ydW44IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1XG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW43IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1IF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgIHwgUExVUyAtPlxuICAgICAgICBfbWVuaGlyX3J1bjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTVcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTVcblxuYW5kIF9tZW5oaXJfcnVuNzggOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAoXG4jIDEwIFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKHN0cmluZylcbiMgMjE3MCBcIklPL3BhcnNlci5tbFwiXG4pIC0+IExleGluZy5wb3NpdGlvbiAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiBfc3RhcnRwb3MgLT5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgbGV0IChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyMTc4IFwiSU8vcGFyc2VyLm1sXCJcbiAgICApKSA9IF92IGluXG4gICAgbGV0IF9zdGFydHBvc19pZF8gPSBfc3RhcnRwb3MgaW5cbiAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzKSA9IFxuIyAxMTMgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICggUmVnaXN0ZXIgaWQgKVxuIyAyMTg0IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgaW5cbiAgICBfbWVuaGlyX2dvdG9fYXJnIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG5cbmFuZCBfbWVuaGlyX3J1bjc5IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBMRUZUX0JSQUNFIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuNSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNzkgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgfCBOVU1CRVIgX3YgLT5cbiAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU3OSBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICB8IF8gLT5cbiAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTc5XG5cbmFuZCBfbWVuaGlyX2dvdG9fYXN0IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKFBhcnNlcl9hc3QuYXN0KSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdiAtPlxuICAgIG1hdGNoIF9tZW5oaXJfcyB3aXRoXG4gICAgfCBNZW5oaXJTdGF0ZTkyIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKGNtZHMgOiAoUGFyc2VyX2FzdC5hc3QpKSA9IF92IGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXyksIF8sIChjbWQgOiAoUGFyc2VyX2FzdC5jb21tYW5kKSkpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hc3QpID0gXG4jIDEwMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGNtZDo6Y21kcyApXG4jIDIyMTQgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2FzdCBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGUwIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF8xIDogKFBhcnNlcl9hc3QuYXN0KSkgPSBfdiBpblxuICAgICAgICBPYmoubWFnaWMgXzFcbiAgICB8IF8gLT5cbiAgICAgICAgX21lbmhpcl9mYWlsICgpXG5cbmFuZCBfbWVuaGlyX2dvdG9fbGlzdF9FT0xfIDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gKHVuaXQgbGlzdCkgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3YgLT5cbiAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF92KSBpblxuICAgIG1hdGNoIF9tZW5oaXJfcyB3aXRoXG4gICAgfCBNZW5oaXJTdGF0ZTEgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcyksIF8sICh4cyA6ICh1bml0IGxpc3QpKSkgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCB4ID0gKCkgaW5cbiAgICAgICAgbGV0IF92IDogKHVuaXQgbGlzdCkgPSBcbiMgMjEzIFwiPHN0YW5kYXJkLm1seT5cIlxuICAgICggeCA6OiB4cyApXG4jIDIyMzcgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgaW5cbiAgICAgICAgX21lbmhpcl9nb3RvX2xpc3RfRU9MXyBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyBfdlxuICAgIHwgTWVuaGlyU3RhdGU5MiB8IE1lbmhpclN0YXRlMCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBsZXQgX3RvayA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfdG9rZW4gaW5cbiAgICAgICAgKG1hdGNoIF90b2sgd2l0aFxuICAgICAgICB8IEVPRiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfcyA9IE1lbmhpclN0YXRlMyBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF92IDogKFBhcnNlcl9hc3QuYXN0KSA9IFxuIyA5OSBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgICAgICAgICAgICAgICAgKCBbXSApXG4jIDIyNTMgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICBfbWVuaGlyX2dvdG9fYXN0IF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgIHwgSUQgX3YgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3MgPSBNZW5oaXJTdGF0ZTMgaW5cbiAgICAgICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3AgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgX3YsIF9zdGFydHBvcykgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICB8IEhBU0ggLT5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjc5IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1M1xuICAgICAgICAgICAgfCBJRCBfdiAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNzggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTUzIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICAgICAgfCBMRUZUX0JSQUNFIC0+XG4gICAgICAgICAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU1MyBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgIHwgTEVGVF9CUkFDSyAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNTQgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTUzXG4gICAgICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNTMgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICB8IEVPRiB8IEVPTCB8IElOVEVSUk9HX01BUksgLT5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfcyA9IE1lbmhpclN0YXRlNTMgaW5cbiAgICAgICAgICAgICAgICBsZXQgX3YgOiAoUGFyc2VyX2FzdC5hcmdzIGxpc3QpID0gXG4jIDE0MiBcIjxzdGFuZGFyZC5tbHk+XCJcbiAgICAoIFtdIClcbiMgMjI4MCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgX21lbmhpcl9nb3RvX2xvcHRpb25fc2VwYXJhdGVkX25vbmVtcHR5X2xpc3RfQ09NTUFfYXJnX18gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcbiAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlNTMpXG4gICAgICAgIHwgTEVGVF9CUkFDRSAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW41IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzIF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgX21lbmhpcl9ydW40IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUzIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTMpXG4gICAgfCBNZW5oaXJTdGF0ZTExNCB8IE1lbmhpclN0YXRlOTYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgfCBIRUFERVIgLT5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICB8IEVPRiAtPlxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLmhlYWRlcnMpID0gXG4jIDk0IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBbXSApXG4jIDIzMTIgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19oZWFkZXJzIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgICAgICB8IEVPTCAtPlxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLmhlYWRlcnMpID0gXG4jIDk0IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBbXSApXG4jIDIzMjIgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19oZWFkZXJzIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIF92XG4gICAgICAgICAgICB8IElEIF92IC0+XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfc3RhcnRwb3MgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3AgaW5cbiAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IChfbWVuaGlyX3N0YWNrLCBfdiwgX3N0YXJ0cG9zKSBpblxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgICAgICAgICB8IEVRVUFMIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICAgICAgICAgIHwgQk9PTCBfdiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgKGIgOiAoXG4jIDkgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoYm9vbClcbiMgMjM0NCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICApKSA9IF92IGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyMzQ5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLmRlZmluaXRpb24pID0gXG4jIDg3IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBQYXJhbSAoaWQsIEhCb29sIGIpIClcbiMgMjM1NCBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19kZWZpbml0aW9uIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX3ZcbiAgICAgICAgICAgICAgICAgICAgfCBOVUxMIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9lbnYgPSBfbWVuaGlyX2Rpc2NhcmQgX21lbmhpcl9lbnYgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDIzNjQgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKSksIF9zdGFydHBvc19pZF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MuZGVmaW5pdGlvbikgPSBcbiMgODggXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggUGFyYW0gKGlkLCBITm9uZSkgKVxuIyAyMzY5IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9nb3RvX2RlZmluaXRpb24gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfdlxuICAgICAgICAgICAgICAgICAgICB8IE5VTUJFUiBfdiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgKG5iIDogKFxuIyA4IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgKGludDMyKVxuIyAyMzgwIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpID0gX3YgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfc3RhcnRwb3NfbmJfID0gX3N0YXJ0cG9zIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIChpZCA6IChcbiMgMTAgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyMzg2IFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpLCBfc3RhcnRwb3NfaWRfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfdiA6IChQcmVwcm9jZXNzLmRlZmluaXRpb24pID0gXG4jIDg2IFwiSU8vcGFyc2VyLm1seVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBQYXJhbSAoaWQsIEhJbnQgbmIpIClcbiMgMjM5MSBcIklPL3BhcnNlci5tbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZ290b19kZWZpbml0aW9uIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX3ZcbiAgICAgICAgICAgICAgICAgICAgfCBTVFJJTkcgX3YgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IChzdHIgOiAoXG4jIDcgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAoc3RyaW5nKVxuIyAyNDAxIFwiSU8vcGFyc2VyLm1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpID0gX3YgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgKGlkIDogKFxuIyAxMCBcIklPL3BhcnNlci5tbHlcIlxuICAgICAgIChzdHJpbmcpXG4jIDI0MDYgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKSksIF9zdGFydHBvc19pZF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IF92IDogKFByZXByb2Nlc3MuZGVmaW5pdGlvbikgPSBcbiMgODUgXCJJTy9wYXJzZXIubWx5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBQYXJhbSAoaWQsIEhTdHJpbmcgc3RyKSApXG4jIDI0MTEgXCJJTy9wYXJzZXIubWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX2dvdG9fZGVmaW5pdGlvbiBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF92XG4gICAgICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgICAgICByYWlzZSBfZVJSKVxuICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgICAgICAgICAgICAgIHJhaXNlIF9lUlIpXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfcylcbiAgICAgICAgfCBJRCBfdiAtPlxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IF9zdGFydHBvcyA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcCBpblxuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX3YsIF9zdGFydHBvcykgaW5cbiAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICB8IEVRVUFMIC0+XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgICAgICAgICB8IEVYQ0xBTV9NQVJLIC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuMTIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMlxuICAgICAgICAgICAgICAgIHwgSUQgX3YgLT5cbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW4xMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTAyIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICAgICAgICAgIHwgTFBBUkVOIC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuMTAgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMlxuICAgICAgICAgICAgICAgIHwgTUlOVVMgLT5cbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW45IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDJcbiAgICAgICAgICAgICAgICB8IE5PVCAtPlxuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjggX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMlxuICAgICAgICAgICAgICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuNyBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTAyIF92IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfc3RhcnRfcFxuICAgICAgICAgICAgICAgIHwgUExVUyAtPlxuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMlxuICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTAyKVxuICAgICAgICAgICAgfCBJTlRFUlJPR19NQVJLIC0+XG4gICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgICAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgICAgIChtYXRjaCBfdG9rIHdpdGhcbiAgICAgICAgICAgICAgICB8IEVRVUFMIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgICAgICAgICAgICAgICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgICAgICAgICAgICAgICAgICAobWF0Y2ggX3RvayB3aXRoXG4gICAgICAgICAgICAgICAgICAgIHwgRVhDTEFNX01BUksgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuMTIgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMFxuICAgICAgICAgICAgICAgICAgICB8IElEIF92IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjExIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDAgX3YgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICAgICAgICAgICAgICAgIHwgTFBBUkVOIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjEwIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDBcbiAgICAgICAgICAgICAgICAgICAgfCBNSU5VUyAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9ydW45IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxMDBcbiAgICAgICAgICAgICAgICAgICAgfCBOT1QgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfcnVuOCBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMTAwXG4gICAgICAgICAgICAgICAgICAgIHwgTlVNQkVSIF92IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjcgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMCBfdiBfbWVuaGlyX2Vudi5fbWVuaGlyX2xleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BcbiAgICAgICAgICAgICAgICAgICAgfCBQTFVTIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBfbWVuaGlyX3J1bjYgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMFxuICAgICAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBNZW5oaXJTdGF0ZTEwMClcbiAgICAgICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IgPC0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgICAgICAgICByYWlzZSBfZVJSKVxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgYXNzZXJ0IChub3QgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvcik7XG4gICAgICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgICAgICAgICByYWlzZSBfZVJSKVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3MpXG4gICAgfCBfIC0+XG4gICAgICAgIF9tZW5oaXJfZmFpbCAoKVxuXG5hbmQgX21lbmhpcl9lcnJvcmNhc2UgOiBfbWVuaGlyX2VudiAtPiAndHR2X3RhaWwgLT4gX21lbmhpcl9zdGF0ZSAtPiAndHR2X3JldHVybiA9XG4gIGZ1biBfbWVuaGlyX2VudiBfbWVuaGlyX3N0YWNrIF9tZW5oaXJfcyAtPlxuICAgIG1hdGNoIF9tZW5oaXJfcyB3aXRoXG4gICAgfCBNZW5oaXJTdGF0ZTExNCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXyksIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUxMDIgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICByYWlzZSBfZVJSXG4gICAgfCBNZW5oaXJTdGF0ZTEwMCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIHJhaXNlIF9lUlJcbiAgICB8IE1lbmhpclN0YXRlOTYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICByYWlzZSBfZVJSXG4gICAgfCBNZW5oaXJTdGF0ZTkyIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU4NyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlNzkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTc0IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0ICgoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSwgXywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTY5IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU2NyAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlNjYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTYyIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU1OSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlNTggLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MpLCBfLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlNTMgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTQ2IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGU0NCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlNDIgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTQwIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUzOCAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMzUgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTMzIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUzMSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMjkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTI3IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUyNSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMjMgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTIxIC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUxOSAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zLCBfKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMTcgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTE1IC0+XG4gICAgICAgIGxldCBfbWVuaGlyX3N0YWNrID0gT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgbGV0IChfbWVuaGlyX3N0YWNrLCBfbWVuaGlyX3MsIF8pID0gX21lbmhpcl9zdGFjayBpblxuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIF9tZW5oaXJfc1xuICAgIHwgTWVuaGlyU3RhdGUxMiAtPlxuICAgICAgICBsZXQgX21lbmhpcl9zdGFjayA9IE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIGxldCAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSA9IF9tZW5oaXJfc3RhY2sgaW5cbiAgICAgICAgX21lbmhpcl9lcnJvcmNhc2UgX21lbmhpcl9lbnYgKE9iai5tYWdpYyBfbWVuaGlyX3N0YWNrKSBfbWVuaGlyX3NcbiAgICB8IE1lbmhpclN0YXRlMTAgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTkgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTggLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTYgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTUgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTMgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcywgXykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTEgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICBsZXQgKF9tZW5oaXJfc3RhY2ssIF9tZW5oaXJfcykgPSBfbWVuaGlyX3N0YWNrIGluXG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgX21lbmhpcl9zXG4gICAgfCBNZW5oaXJTdGF0ZTAgLT5cbiAgICAgICAgbGV0IF9tZW5oaXJfc3RhY2sgPSBPYmoubWFnaWMgX21lbmhpcl9zdGFjayBpblxuICAgICAgICByYWlzZSBfZVJSXG5cbmFuZCBfbWVuaGlyX3JlZHVjZTI2IDogX21lbmhpcl9lbnYgLT4gJ3R0dl90YWlsIC0+IF9tZW5oaXJfc3RhdGUgLT4gJ3R0dl9yZXR1cm4gPVxuICBmdW4gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgLT5cbiAgICBsZXQgX3YgOiAodW5pdCBsaXN0KSA9IFxuIyAyMTEgXCI8c3RhbmRhcmQubWx5PlwiXG4gICAgKCBbXSApXG4jIDI2NzIgXCJJTy9wYXJzZXIubWxcIlxuICAgICBpblxuICAgIF9tZW5oaXJfZ290b19saXN0X0VPTF8gX21lbmhpcl9lbnYgX21lbmhpcl9zdGFjayBfbWVuaGlyX3MgX3ZcblxuYW5kIF9tZW5oaXJfcnVuMSA6IF9tZW5oaXJfZW52IC0+ICd0dHZfdGFpbCAtPiBfbWVuaGlyX3N0YXRlIC0+ICd0dHZfcmV0dXJuID1cbiAgZnVuIF9tZW5oaXJfZW52IF9tZW5oaXJfc3RhY2sgX21lbmhpcl9zIC0+XG4gICAgbGV0IF9tZW5oaXJfc3RhY2sgPSAoX21lbmhpcl9zdGFjaywgX21lbmhpcl9zKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRU9MIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMVxuICAgIHwgRU9GIHwgSEVBREVSIHwgSUQgXyB8IExFRlRfQlJBQ0UgfCBOVU1CRVIgXyAtPlxuICAgICAgICBfbWVuaGlyX3JlZHVjZTI2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxXG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUxXG5cbmFuZCBfbWVuaGlyX2Rpc2NhcmQgOiBfbWVuaGlyX2VudiAtPiBfbWVuaGlyX2VudiA9XG4gIGZ1biBfbWVuaGlyX2VudiAtPlxuICAgIGxldCBsZXhlciA9IF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4ZXIgaW5cbiAgICBsZXQgbGV4YnVmID0gX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYgaW5cbiAgICBsZXQgX3RvayA9IGxleGVyIGxleGJ1ZiBpblxuICAgIHtcbiAgICAgIF9tZW5oaXJfbGV4ZXIgPSBsZXhlcjtcbiAgICAgIF9tZW5oaXJfbGV4YnVmID0gbGV4YnVmO1xuICAgICAgX21lbmhpcl90b2tlbiA9IF90b2s7XG4gICAgICBfbWVuaGlyX2Vycm9yID0gZmFsc2U7XG4gICAgfVxuXG5hbmQgYXN0IDogKExleGluZy5sZXhidWYgLT4gdG9rZW4pIC0+IExleGluZy5sZXhidWYgLT4gKFBhcnNlcl9hc3QuYXN0KSA9XG4gIGZ1biBsZXhlciBsZXhidWYgLT5cbiAgICBsZXQgX21lbmhpcl9lbnYgPSB7XG4gICAgICBfbWVuaGlyX2xleGVyID0gbGV4ZXI7XG4gICAgICBfbWVuaGlyX2xleGJ1ZiA9IGxleGJ1ZjtcbiAgICAgIF9tZW5oaXJfdG9rZW4gPSBPYmoubWFnaWMgKCk7XG4gICAgICBfbWVuaGlyX2Vycm9yID0gZmFsc2U7XG4gICAgfSBpblxuICAgIE9iai5tYWdpYyAobGV0IF9tZW5oaXJfc3RhY2sgPSAoKCksIF9tZW5oaXJfZW52Ll9tZW5oaXJfbGV4YnVmLkxleGluZy5sZXhfY3Vycl9wKSBpblxuICAgIGxldCBfbWVuaGlyX2VudiA9IF9tZW5oaXJfZGlzY2FyZCBfbWVuaGlyX2VudiBpblxuICAgIGxldCBfdG9rID0gX21lbmhpcl9lbnYuX21lbmhpcl90b2tlbiBpblxuICAgIG1hdGNoIF90b2sgd2l0aFxuICAgIHwgRU9MIC0+XG4gICAgICAgIF9tZW5oaXJfcnVuMSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlMFxuICAgIHwgRU9GIHwgSUQgXyB8IExFRlRfQlJBQ0UgfCBOVU1CRVIgXyAtPlxuICAgICAgICBfbWVuaGlyX3JlZHVjZTI2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUwXG4gICAgfCBfIC0+XG4gICAgICAgIGFzc2VydCAobm90IF9tZW5oaXJfZW52Ll9tZW5oaXJfZXJyb3IpO1xuICAgICAgICBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yIDwtIHRydWU7XG4gICAgICAgIF9tZW5oaXJfZXJyb3JjYXNlIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGUwKVxuXG5hbmQgaGVhZGVycyA6IChMZXhpbmcubGV4YnVmIC0+IHRva2VuKSAtPiBMZXhpbmcubGV4YnVmIC0+IChQcmVwcm9jZXNzLmhlYWRlcnMpID1cbiAgZnVuIGxleGVyIGxleGJ1ZiAtPlxuICAgIGxldCBfbWVuaGlyX2VudiA9IHtcbiAgICAgIF9tZW5oaXJfbGV4ZXIgPSBsZXhlcjtcbiAgICAgIF9tZW5oaXJfbGV4YnVmID0gbGV4YnVmO1xuICAgICAgX21lbmhpcl90b2tlbiA9IE9iai5tYWdpYyAoKTtcbiAgICAgIF9tZW5oaXJfZXJyb3IgPSBmYWxzZTtcbiAgICB9IGluXG4gICAgT2JqLm1hZ2ljIChsZXQgX21lbmhpcl9zdGFjayA9ICgoKSwgX21lbmhpcl9lbnYuX21lbmhpcl9sZXhidWYuTGV4aW5nLmxleF9jdXJyX3ApIGluXG4gICAgbGV0IF9tZW5oaXJfZW52ID0gX21lbmhpcl9kaXNjYXJkIF9tZW5oaXJfZW52IGluXG4gICAgbGV0IF90b2sgPSBfbWVuaGlyX2Vudi5fbWVuaGlyX3Rva2VuIGluXG4gICAgbWF0Y2ggX3RvayB3aXRoXG4gICAgfCBFT0wgLT5cbiAgICAgICAgX21lbmhpcl9ydW4xIF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5NlxuICAgIHwgSEVBREVSIHwgSUQgXyAtPlxuICAgICAgICBfbWVuaGlyX3JlZHVjZTI2IF9tZW5oaXJfZW52IChPYmoubWFnaWMgX21lbmhpcl9zdGFjaykgTWVuaGlyU3RhdGU5NlxuICAgIHwgXyAtPlxuICAgICAgICBhc3NlcnQgKG5vdCBfbWVuaGlyX2Vudi5fbWVuaGlyX2Vycm9yKTtcbiAgICAgICAgX21lbmhpcl9lbnYuX21lbmhpcl9lcnJvciA8LSB0cnVlO1xuICAgICAgICBfbWVuaGlyX2Vycm9yY2FzZSBfbWVuaGlyX2VudiAoT2JqLm1hZ2ljIF9tZW5oaXJfc3RhY2spIE1lbmhpclN0YXRlOTYpXG5cbiMgMjY5IFwiPHN0YW5kYXJkLm1seT5cIlxuICBcblxuIyAyNzQ4IFwiSU8vcGFyc2VyLm1sXCJcbiIsIiV7IG9wZW4gUGFyc2VyX2FzdCAlfVxuJXsgb3BlbiBQcmVwcm9jZXNzICV9XG5cbiV0b2tlbiBIRUFERVJcbiV0b2tlbiBOVUxMXG4ldG9rZW4gRVFVQUxcbiV0b2tlbiA8c3RyaW5nPiBTVFJJTkdcbiV0b2tlbiA8aW50MzI+IE5VTUJFUlxuJXRva2VuIDxib29sPiBCT09MXG4ldG9rZW4gPHN0cmluZz4gSURcbiV0b2tlbiBIQVNIXG4ldG9rZW4gTEVGVF9CUkFDS1xuJXRva2VuIFJJR0hUX0JSQUNLXG4ldG9rZW4gTEVGVF9CUkFDRVxuJXRva2VuIFJJR0hUX0JSQUNFXG4ldG9rZW4gTFBBUkVOXG4ldG9rZW4gUlBBUkVOXG4ldG9rZW4gTFNISUZUXG4ldG9rZW4gUlNISUZUXG4ldG9rZW4gQ09NTUFcbiV0b2tlbiBFWENMQU1fTUFSS1xuJXRva2VuIElOVEVSUk9HX01BUktcbiV0b2tlbiBDT0xPTlxuJXRva2VuIFRJTUVTXG4ldG9rZW4gRElWXG4ldG9rZW4gTU9EXG4ldG9rZW4gUExVU1xuJXRva2VuIE1JTlVTXG4ldG9rZW4gQU5EXG4ldG9rZW4gT1JcbiV0b2tlbiBYT1JcbiV0b2tlbiBOT1RcbiV0b2tlbiBFUVxuJXRva2VuIE5FUVxuJXRva2VuIEJPUlxuJXRva2VuIEJBTkRcbiV0b2tlbiBFT0xcbiV0b2tlbiBFT0ZcblxuJW5vbmFzc29jIEFSR1xuJW5vbmFzc29jIENPTU1BXG5cbiVyaWdodCBJTlRFUlJPR19NQVJLIENPTE9OXG4lbGVmdCBCT1JcbiVsZWZ0IEJBTkRcbiVsZWZ0IE9SXG4lbGVmdCBYT1JcbiVsZWZ0IEFORFxuJWxlZnQgRVEgTkVRXG4lbGVmdCBMU0hJRlQgUlNISUZUXG4lbGVmdCBQTFVTIE1JTlVTXG4lbGVmdCBUSU1FUyBESVYgTU9EXG4lbm9uYXNzb2MgRVhDTEFNX01BUksgTk9UIFVQTFVTIFVNSU5VU1xuXG4lc3RhcnQgPFBhcnNlcl9hc3QuYXN0PiBhc3RcbiVzdGFydCA8UHJlcHJvY2Vzcy5oZWFkZXJzPiBoZWFkZXJzXG4lJVxuXG5tZXRhX2V4cHI6XG4gIHwgaSA9IE5VTUJFUiB7IE1Db25zdCBpIH1cbiAgfCB2ID0gSUQgeyBNVmFyIHYgfVxuICB8IExQQVJFTiBlID0gbWV0YV9leHByIFJQQVJFTiB7IGUgfVxuICB8IGUxID0gbWV0YV9leHByIFBMVVMgZTIgPSBtZXRhX2V4cHIgeyBNQmluYXJ5IChPQWRkLCBlMSwgZTIpIH1cbiAgfCBlMSA9IG1ldGFfZXhwciBNSU5VUyBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9TdWIsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIFRJTUVTIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT011bCwgZTEsIGUyKSB9XG4gIHwgZTEgPSBtZXRhX2V4cHIgRElWIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT0RpdiwgZTEsIGUyKSB9XG4gIHwgZTEgPSBtZXRhX2V4cHIgTU9EIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT01vZCwgZTEsIGUyKSB9XG4gIHwgZTEgPSBtZXRhX2V4cHIgQU5EIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT0FuZCwgZTEsIGUyKSB9XG4gIHwgZTEgPSBtZXRhX2V4cHIgWE9SIGUyID0gbWV0YV9leHByIHsgTUJpbmFyeSAoT1hvciwgZTEsIGUyKSB9XG4gIHwgZTEgPSBtZXRhX2V4cHIgT1IgZTIgPSBtZXRhX2V4cHIgeyBNQmluYXJ5IChPT3IsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIEJPUiBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9CT3IsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIEJBTkQgZTIgPSBtZXRhX2V4cHIgeyBNQmluYXJ5IChPQkFuZCwgZTEsIGUyKSB9XG4gIHwgZTEgPSBtZXRhX2V4cHIgRVEgZTIgPSBtZXRhX2V4cHIgeyBNQmluYXJ5IChPRXEsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIE5FUSBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9OZXEsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIExTSElGVCBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9MU2hpZnQsIGUxLCBlMikgfVxuICB8IGUxID0gbWV0YV9leHByIFJTSElGVCBlMiA9IG1ldGFfZXhwciB7IE1CaW5hcnkgKE9SU2hpZnQsIGUxLCBlMikgfVxuICB8IFBMVVMgZSA9IG1ldGFfZXhwciAlcHJlYyBVUExVUyB7IE1VbmFyeSAoT0lkLCBlKSB9XG4gIHwgTUlOVVMgZSA9IG1ldGFfZXhwciAlcHJlYyBVTUlOVVMgeyBNVW5hcnkgKE9OZWcsIGUpIH1cbiAgfCBOT1QgZSA9IG1ldGFfZXhwciB7IE1VbmFyeSAoT05vdCwgZSkgfVxuICB8IEVYQ0xBTV9NQVJLIGUgPSBtZXRhX2V4cHIgeyBNVW5hcnkgKE9CTm90LCBlKSB9XG4gIHwgZTAgPSBtZXRhX2V4cHIgSU5URVJST0dfTUFSSyBlMSA9IG1ldGFfZXhwciBDT0xPTiBlMiA9IG1ldGFfZXhwclxuICB7IE1Db25kIChlMCwgZTEsIGUyKSB9XG5cbmRlZmluaXRpb246XG4gIHwgSEVBREVSIDsgaWQgPSBJRCA7IEVRVUFMIDsgc3RyID0gU1RSSU5HIHsgUGFyYW0gKGlkLCBIU3RyaW5nIHN0cikgfVxuICB8IEhFQURFUiA7IGlkID0gSUQgOyBFUVVBTCA7IG5iID0gTlVNQkVSIHsgUGFyYW0gKGlkLCBISW50IG5iKSB9XG4gIHwgSEVBREVSIDsgaWQgPSBJRCA7IEVRVUFMIDsgYiA9IEJPT0wgeyBQYXJhbSAoaWQsIEhCb29sIGIpIH1cbiAgfCBIRUFERVIgOyBpZCA9IElEIDsgRVFVQUwgOyBOVUxMIHsgUGFyYW0gKGlkLCBITm9uZSkgfVxuICB8IGlkID0gSUQgOyBFUVVBTCA7IGUgPSBtZXRhX2V4cHIgeyBWYXJEZWYgKGlkLCBmYWxzZSwgZSkgfVxuICB8IGlkID0gSUQgOyBJTlRFUlJPR19NQVJLIDsgRVFVQUwgOyBlID0gbWV0YV9leHByIHsgVmFyRGVmIChpZCwgdHJ1ZSwgZSkgfVxuICA7XG5cbmhlYWRlcnM6XG4gIHwgbGlzdCAoRU9MKSA7IEhFQURFUiA7IEVPTCB8IGxpc3QgKEVPTCkgOyBIRUFERVIgOyBFT0YgeyBbXSB9XG4gIHwgbGlzdCAoRU9MKSA7IGQgPSBkZWZpbml0aW9uIDsgRU9MIDsgZHMgPSBoZWFkZXJzIHsgZDo6ZHMgfVxuICA7XG5cbmFzdDpcbiAgfCBsaXN0IChFT0wpIDsgRU9GIHsgW10gfVxuICB8IGxpc3QgKEVPTCkgOyBjbWQgPSBjb21tYW5kIDsgRU9MIDsgY21kcyA9IGFzdCB7IGNtZDo6Y21kcyB9XG4gIHwgbGlzdCAoRU9MKSA7IGNtZCA9IGNvbW1hbmQgOyBFT0YgeyBbY21kXSB9XG4gIDtcblxuY29tbWFuZDpcbiAgfCBpZCA9IElEIDsgYXJncyA9IHNlcGFyYXRlZF9saXN0KENPTU1BLCBhcmcpIHsgQVNNICgkc3RhcnRwb3MsIGlkLCBhcmdzLCBPcHRpbWl6ZXIuTm9Ud2Vha2luZykgfVxuICB8IGlkID0gSUQgOyBhcmdzID0gc2VwYXJhdGVkX2xpc3QoQ09NTUEsIGFyZykgOyBJTlRFUlJPR19NQVJLIHsgQVNNICgkc3RhcnRwb3MsIGlkLCBhcmdzLCBPcHRpbWl6ZXIuVHdlYWtNaW5MZW5ndGgpIH1cbiAgfCBpZCA9IElEIDsgYXJncyA9IHNlcGFyYXRlZF9saXN0KENPTU1BLCBhcmcpIDsgSU5URVJST0dfTUFSSyA7IGkgPSBOVU1CRVJcbiAgeyBBU00gKCRzdGFydHBvcywgaWQsIGFyZ3MsIE9wdGltaXplci5Ud2Vha0ZpeGVkTGVuZ3RoIChVdGlscy51aW50MzJfdG9faW50IGkpKSB9XG4gIHwgbmIgPSBudW1iZXIgeyBCSU4gKCRzdGFydHBvcywgbmIpIH1cbiAgO1xuXG5hcmc6XG4gIHwgaWQgPSBJRCB7IFJlZ2lzdGVyIGlkIH1cbiAgfCBIQVNIIDsgaSA9IG51bWJlciB8IGkgPSBudW1iZXIgeyBJbW1lZGlhdGUgaSB9XG4gIHwgTEVGVF9CUkFDSyA7IGlkID0gSUQgOyBDT01NQSA7IG8gPSBvZmZzZXQgOyBSSUdIVF9CUkFDSyB7IE9mZnNldCAoaWQsIG8sIEFybS5PZmZzZXQpIH1cbiAgfCBMRUZUX0JSQUNLIDsgaWQgPSBJRCA7IFJJR0hUX0JSQUNLICVwcmVjIEFSR1xuICB7IE9mZnNldCAoaWQsIE9JbW1lZGlhdGUgKEFybS5zaWduX3BsdXMsIENvbnN0SW50MzIgSW50MzIuemVybyksIEFybS5PZmZzZXQpIH1cbiAgfCBMRUZUX0JSQUNLIDsgaWQgPSBJRCA7IENPTU1BIDsgbyA9IG9mZnNldCA7IFJJR0hUX0JSQUNLIDsgRVhDTEFNX01BUksgeyBPZmZzZXQgKGlkLCBvLCBBcm0uUHJlSW5kZXhlZCkgfVxuICB8IExFRlRfQlJBQ0sgOyBpZCA9IElEIDsgUklHSFRfQlJBQ0sgOyBFWENMQU1fTUFSS1xuICB7IE9mZnNldCAoaWQsIE9JbW1lZGlhdGUgKEFybS5zaWduX3BsdXMsIENvbnN0SW50MzIgSW50MzIuemVybyksIEFybS5QcmVJbmRleGVkKSB9XG4gIHwgTEVGVF9CUkFDSyA7IGlkID0gSUQgOyBSSUdIVF9CUkFDSyA7IENPTU1BIDsgbyA9IG9mZnNldCB7IE9mZnNldCAoaWQsIG8sIEFybS5Qb3N0SW5kZXhlZCkgfVxuICA7XG5cbm9mZnNldDpcbiAgfCBIQVNIIDsgaSA9IG51bWJlciB8IEhBU0ggOyBQTFVTIDsgaSA9IG51bWJlciB8IGkgPSBudW1iZXIgfCBQTFVTIDsgaSA9IG51bWJlclxuICB7IE9JbW1lZGlhdGUgKEFybS5zaWduX3BsdXMsIGkpIH1cbiAgfCBIQVNIIDsgTUlOVVMgOyBpID0gbnVtYmVyIHwgTUlOVVMgOyBpID0gbnVtYmVyIHsgT0ltbWVkaWF0ZSAoQXJtLnNpZ25fbWludXMsIGkpIH1cbiAgfCBpZCA9IElEIHwgUExVUyA7IGlkID0gSUQgeyBPUmVnaXN0ZXIgKEFybS5zaWduX3BsdXMsIGlkKSB9XG4gIHwgTUlOVVMgOyBpZCA9IElEIHsgT1JlZ2lzdGVyIChBcm0uc2lnbl9taW51cywgaWQpIH1cbiAgO1xuXG5udW1iZXI6XG4gIHwgaSA9IE5VTUJFUiB7IENvbnN0SW50MzIgaSB9XG4gIHwgTEVGVF9CUkFDRSA7IGU9bWV0YV9leHByIDsgUklHSFRfQlJBQ0UgeyBNZXRhRXhwciBlIH1cbiAgOyIsIntcbm9wZW4gTGV4aW5nXG5vcGVuIFBhcnNlclxuXG5leGNlcHRpb24gU3ludGF4RXJyb3Igb2Ygc3RyaW5nXG5cbmxldCBuZXh0X2xpbmUgbGV4YnVmID1cbiAgbGV0IHBvcyA9IGxleGJ1Zi5sZXhfY3Vycl9wIGluXG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtXG4gICAgeyBwb3Mgd2l0aCBwb3NfYm9sID0gbGV4YnVmLmxleF9jdXJyX3BvcztcbiAgICAgICAgICAgICAgIHBvc19sbnVtID0gcG9zLnBvc19sbnVtICsgMVxuICAgIH1cblxubGV0IGVvZl9yZWFjaGVkIGxleGJ1ZiA9XG4gIGxleGJ1Zi5sZXhfZW9mX3JlYWNoZWQgPC0gdHJ1ZVxufVxuXG5sZXQgZGRpZ2l0ID0gWycwJy0nOSddXG5sZXQgaGRpZ2l0ID0gWycwJy0nOScgJ2EnLSdmJyAnQSctJ0YnXVxubGV0IGJkaWdpdCA9IFsnMCctJzEnXVxubGV0IG9kaWdpdCA9IFsnMCctJzcnXVxuXG5sZXQgZHByZWZpeCA9IFwiMHVcIiB8IFwiMFVcIlxubGV0IGhwcmVmaXggPSBcIjB4XCIgfCBcIjBYXCJcbmxldCBicHJlZml4ID0gXCIwYlwiIHwgXCIwQlwiXG5sZXQgb3ByZWZpeCA9IFwiMG9cIiB8IFwiME9cIlxuXG5sZXQgZG51bWJlciA9IGRwcmVmaXg/IGRkaWdpdCtcbmxldCBobnVtYmVyID0gaHByZWZpeCBoZGlnaXQrXG5sZXQgYm51bWJlciA9IGJwcmVmaXggYmRpZ2l0K1xubGV0IG9udW1iZXIgPSBvcHJlZml4IG9kaWdpdCtcblxubGV0IG51bWJlciA9IGRudW1iZXIgfCBobnVtYmVyIHwgYm51bWJlciB8IG9udW1iZXJcblxubGV0IGNvbW1lbnQgPSBcIkBcIiB8IFwiJSVcIiB8IFwiO1wiIHwgXCIvL1wiXG5cbmxldCB3aGl0ZSA9IFsnICcgJ1xcdCddK1xubGV0IG5ld2xpbmUgPSAnXFxyJyB8ICdcXG4nIHwgXCJcXHJcXG5cIlxubGV0IGlkID0gWydhJy0neicgJ0EnLSdaJyAnXyddIFsnYSctJ3onICdBJy0nWicgJzAnLSc5JyAnXyddKlxuXG5sZXQgZmlsZV9zZXBhcmF0b3IgPSBcIj09PT09XCIgJz0nKlxuXG5ydWxlIHJlYWQgPSBwYXJzZVxuICB8IGZpbGVfc2VwYXJhdG9yIHsgRU9GIH1cbiAgfCBcIkBAXCIgICAgICB7IEhFQURFUiB9XG4gIHwgXCJudWxsXCIgICAgeyBOVUxMIH1cbiAgfCBcInRydWVcIiAgICB7IEJPT0wgdHJ1ZSB9XG4gIHwgXCJmYWxzZVwiICAgeyBCT09MIGZhbHNlIH1cbiAgfCBcIjw8XCIgICAgICB7IExTSElGVCB9XG4gIHwgXCI+PlwiICAgICAgeyBSU0hJRlQgfVxuICB8IFwiPT1cIiAgICAgIHsgRVEgfVxuICB8IFwiIT1cIiAgICAgIHsgTkVRIH1cbiAgfCBcInx8XCIgICAgICB7IEJPUiB9XG4gIHwgXCImJlwiICAgICAgeyBCQU5EIH1cbiAgfCBjb21tZW50ICAgeyByZWFkX2NvbW1lbnQgbGV4YnVmIH1cbiAgfCB3aGl0ZSAgICAgeyByZWFkIGxleGJ1ZiB9XG4gIHwgJ1xcXFwnIG5ld2xpbmUgeyBuZXh0X2xpbmUgbGV4YnVmIDsgcmVhZCBsZXhidWYgfVxuICB8IG5ld2xpbmUgICB7IG5leHRfbGluZSBsZXhidWYgOyBFT0wgfVxuICB8IG51bWJlciAgICB7IE5VTUJFUiAoVXRpbHMudWludDMyX29mX3N0ciAoTGV4aW5nLmxleGVtZSBsZXhidWYpKSB9XG4gIHwgaWQgICAgICAgIHsgSUQgKExleGluZy5sZXhlbWUgbGV4YnVmKSB9XG4gIHwgJ1wiJyAgICAgICB7IHJlYWRfc3RyaW5nIChCdWZmZXIuY3JlYXRlIDE3KSBsZXhidWYgfVxuICB8ICc9JyAgICAgICB7IEVRVUFMIH1cbiAgfCAnIycgICAgICAgeyBIQVNIIH1cbiAgfCAnWycgICAgICAgeyBMRUZUX0JSQUNLIH1cbiAgfCAnXScgICAgICAgeyBSSUdIVF9CUkFDSyB9XG4gIHwgJ3snICAgICAgIHsgTEVGVF9CUkFDRSB9XG4gIHwgJ30nICAgICAgIHsgUklHSFRfQlJBQ0UgfVxuICB8ICcsJyAgICAgICB7IENPTU1BIH1cbiAgfCAnIScgICAgICAgeyBFWENMQU1fTUFSSyB9XG4gIHwgJz8nICAgICAgIHsgSU5URVJST0dfTUFSSyB9XG4gIHwgJzonICAgICAgIHsgQ09MT04gfVxuICB8ICcoJyAgICAgICB7IExQQVJFTiB9XG4gIHwgJyknICAgICAgIHsgUlBBUkVOIH1cbiAgfCAnKycgICAgICAgeyBQTFVTIH1cbiAgfCAnLScgICAgICAgeyBNSU5VUyB9XG4gIHwgJyonICAgICAgIHsgVElNRVMgfVxuICB8ICcvJyAgICAgICB7IERJViB9XG4gIHwgJyUnICAgICAgIHsgTU9EIH1cbiAgfCAnJicgICAgICAgeyBBTkQgfVxuICB8ICd8JyAgICAgICB7IE9SIH1cbiAgfCAnXicgICAgICAgeyBYT1IgfVxuICB8ICd+JyAgICAgICB7IE5PVCB9XG4gIHwgZW9mICAgICAgIHsgZW9mX3JlYWNoZWQgbGV4YnVmIDsgRU9GIH1cbiAgfCBfIHsgcmFpc2UgKFN5bnRheEVycm9yIChcIlVuZXhwZWN0ZWQgY2hhcjogXCIgXiBMZXhpbmcubGV4ZW1lIGxleGJ1ZikpIH1cblxuYW5kIHJlYWRfc3RyaW5nIGJ1ZiA9IHBhcnNlXG4gIHwgJ1wiJyAgICAgICB7IFNUUklORyAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgfVxuICB8ICdcXFxcJyAnLycgIHsgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnLyc7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgfVxuICB8ICdcXFxcJyAnXFxcXCcgeyBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXFxcJzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiB9XG4gIHwgJ1xcXFwnICdiJyAgeyBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXGInOyByZWFkX3N0cmluZyBidWYgbGV4YnVmIH1cbiAgfCAnXFxcXCcgJ2YnICB7IEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xcMDEyJzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiB9XG4gIHwgJ1xcXFwnICduJyAgeyBCdWZmZXIuYWRkX2NoYXIgYnVmICdcXG4nOyByZWFkX3N0cmluZyBidWYgbGV4YnVmIH1cbiAgfCAnXFxcXCcgJ3InICB7IEJ1ZmZlci5hZGRfY2hhciBidWYgJ1xccic7IHJlYWRfc3RyaW5nIGJ1ZiBsZXhidWYgfVxuICB8ICdcXFxcJyAndCcgIHsgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFx0JzsgcmVhZF9zdHJpbmcgYnVmIGxleGJ1ZiB9XG4gIHwgW14gJ1wiJyAnXFxcXCcgJ1xccicgJ1xcbiddK1xuICAgIHsgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChMZXhpbmcubGV4ZW1lIGxleGJ1Zik7XG4gICAgICByZWFkX3N0cmluZyBidWYgbGV4YnVmXG4gICAgfVxuICB8IG5ld2xpbmUgeyByYWlzZSAoU3ludGF4RXJyb3IgKFwiU3RyaW5nIGNhbm5vdCBiZSBtdWx0aWxpbmVcIikpIH1cbiAgfCBlb2YgeyByYWlzZSAoU3ludGF4RXJyb3IgKFwiU3RyaW5nIGlzIG5vdCB0ZXJtaW5hdGVkXCIpKSB9XG4gIHwgXyB7IHJhaXNlIChTeW50YXhFcnJvciAoXCJJbGxlZ2FsIHN0cmluZyBjaGFyYWN0ZXI6IFwiIF4gTGV4aW5nLmxleGVtZSBsZXhidWYpKSB9XG5cbmFuZCByZWFkX2NvbW1lbnQgPSBwYXJzZVxuICB8IG5ld2xpbmUgeyBuZXh0X2xpbmUgbGV4YnVmIDsgRU9MIH1cbiAgfCBlb2YgeyBlb2ZfcmVhY2hlZCBsZXhidWYgOyBFT0YgfVxuICB8IF8geyByZWFkX2NvbW1lbnQgbGV4YnVmIH0iLCJvcGVuIExleGVyXG5vcGVuIExleGluZ1xuXG5leGNlcHRpb24gSW52YWxpZENvbnRlbnQgb2Ygc3RyaW5nXG5cbnR5cGUgcGFyc2VkX2NvbnRlbnQgPVxuICBQcmVwcm9jZXNzLmhlYWRlcnMgKiBQYXJzZXJfYXN0LmFzdFxuXG5sZXQgcHJpbnRfcG9zaXRpb24gZm10IHBvcyA9XG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVzOiVkOiVkXCIgcG9zLnBvc19mbmFtZVxuICAgIHBvcy5wb3NfbG51bSAocG9zLnBvc19jbnVtIC0gcG9zLnBvc19ib2wgKyAxKVxuXG5sZXQgcHJpbnRfbGV4YnVmX3BvcyBmbXQgbGV4YnVmID1cbiAgcHJpbnRfcG9zaXRpb24gZm10IGxleGJ1Zi5sZXhfY3Vycl9wXG5cbmxldCBwYXJzZV93aXRoX2Vycm9yIGYgbGV4YnVmID1cbiAgdHJ5IGYgbGV4YnVmIHdpdGhcbiAgfCBTeW50YXhFcnJvciBtc2cgLT5cbiAgICByYWlzZSAoSW52YWxpZENvbnRlbnRcbiAgICAgIChGb3JtYXQuYXNwcmludGYgXCIlYTogJXNcXG5cIiBwcmludF9sZXhidWZfcG9zIGxleGJ1ZiBtc2cpKVxuICB8IFBhcnNlci5FcnJvciAtPlxuICAgIHJhaXNlIChJbnZhbGlkQ29udGVudFxuICAgICAgKEZvcm1hdC5hc3ByaW50ZiBcIiVhOiBwYXJzZXIgZXJyb3JcXG5cIiBwcmludF9sZXhidWZfcG9zIGxleGJ1ZikpXG5cbmxldCBmcm9tX2xleGJ1ZiB+aGVhZGVycyBsZXhidWYgPVxuICBsZXQgaGVhZGVycyA9XG4gICAgaWYgaGVhZGVyc1xuICAgIHRoZW4gcGFyc2Vfd2l0aF9lcnJvciAoUGFyc2VyLmhlYWRlcnMgTGV4ZXIucmVhZCkgbGV4YnVmXG4gICAgZWxzZSBbXVxuICBpblxuICBsZXQgYXN0ID0gcGFyc2Vfd2l0aF9lcnJvciAoUGFyc2VyLmFzdCBMZXhlci5yZWFkKSBsZXhidWYgaW5cbiAgKGhlYWRlcnMsIGFzdClcblxubGV0IGZyb21fZmlsZW5hbWUgfmhlYWRlcnMgZmlsZW5hbWUgPVxuICBsZXQgY2hhbm5lbCA9IG9wZW5faW4gZmlsZW5hbWUgaW5cbiAgbGV0IGxleGJ1ZiA9IExleGluZy5mcm9tX2NoYW5uZWwgY2hhbm5lbCBpblxuICBsZXhidWYubGV4X2N1cnJfcCA8LSB7IGxleGJ1Zi5sZXhfY3Vycl9wIHdpdGggcG9zX2ZuYW1lID0gZmlsZW5hbWUgfTtcbiAgbGV0IHJlcyA9IGZyb21fbGV4YnVmIH5oZWFkZXJzIGxleGJ1ZiBpblxuICBjbG9zZV9pbiBjaGFubmVsIDsgcmVzXG5cbmxldCBmcm9tX3N0ciB+aGVhZGVycyBzdHIgPVxuICBMZXhpbmcuZnJvbV9zdHJpbmcgc3RyIHw+IGZyb21fbGV4YnVmIH5oZWFkZXJzXG5cbmxldCBwYXJzZWRfYXN0X3RvX2FybSB+b3B0aW1pemUgZW52IGxzdCA9XG4gIHRyeVxuICAgIFBhcnNlcl9hc3QudG9fYXJtIGVudiBsc3QgfD5cbiAgICBpZiBvcHRpbWl6ZSB0aGVuIE9wdGltaXplci50d2Vha19hcm0gZWxzZSBPcHRpbWl6ZXIuZG9fbm90X3R3ZWFrX2FybVxuICB3aXRoIFBhcnNlcl9hc3QuQ29tbWFuZEVycm9yIHBvcyAtPlxuICAgIHJhaXNlIChJbnZhbGlkQ29udGVudFxuICAgICAgKEZvcm1hdC5hc3ByaW50ZiBcIiVhOiBjb21tYW5kIGVycm9yXFxuXCIgcHJpbnRfcG9zaXRpb24gcG9zKVxuICAgIClcblxubGV0IHBhcnNlZF9jb250ZW50X3RvX2FybSBmbXQgfm9wdGltaXplIGVudiAoaGVhZGVycywgbHN0KSA9XG4gIGxldCBlbnYgPVxuICAgIFByZXByb2Nlc3MuZW52X2Zyb21faGVhZGVycyBmbXQgaGVhZGVycyB8PlxuICAgIFByZXByb2Nlc3MuY29uY2F0X2VudiBlbnYgaW5cbiAgcGFyc2VkX2FzdF90b19hcm0gfm9wdGltaXplIGVudiBsc3RcbiIsIlxubW9kdWxlIFN0ck1hcCA9IE1hcC5NYWtlKFN0cmluZylcblxudHlwZSB0ID0gUGFyc2UucGFyc2VkX2NvbnRlbnQgKiAoUGFyc2UucGFyc2VkX2NvbnRlbnQgU3RyTWFwLnQpXG5cbmxldCByZWMgYWRkX2ZpbGVzIGxleGJ1ZiBhY2MgPVxuICBpZiBsZXhidWYuTGV4aW5nLmxleF9lb2ZfcmVhY2hlZCB0aGVuIGFjY1xuICBlbHNlIChcbiAgICBsZXQgKGhlYWRlcnMsIGFybSkgPSBQYXJzZS5mcm9tX2xleGJ1ZiB+aGVhZGVyczp0cnVlIGxleGJ1ZiBpblxuICAgIGxldCBmbiA9XG4gICAgICBtYXRjaCBQcmVwcm9jZXNzLmdldF9wYXJhbSBoZWFkZXJzIFwiZmlsZW5hbWVcIiB3aXRoXG4gICAgICB8IEhOb25lIC0+IGZhaWx3aXRoIFwiUGxlYXNlIHNwZWNpZnkgdGhlICdmaWxlbmFtZScgaGVhZGVyIGV2ZXJ5d2hlcmUuXCJcbiAgICAgIHwgSFN0cmluZyBmbiAtPiBmblxuICAgICAgfCBfIC0+IGZhaWx3aXRoIFwiSW52YWxpZCBoZWFkZXJzLlwiXG4gICAgaW5cbiAgICBTdHJNYXAuYWRkIGZuIChoZWFkZXJzLCBhcm0pIGFjYyB8PiBhZGRfZmlsZXMgbGV4YnVmXG4gIClcblxubGV0IHBhcnNlIGxleGJ1ZiA9XG4gIGxleGJ1Zi5MZXhpbmcubGV4X2VvZl9yZWFjaGVkIDwtIGZhbHNlIDtcbiAgbGV0IG1haW5fZmlsZSA9IFBhcnNlLmZyb21fbGV4YnVmIH5oZWFkZXJzOnRydWUgbGV4YnVmIGluXG4gIGxldCBmaWxlcyA9IGFkZF9maWxlcyBsZXhidWYgU3RyTWFwLmVtcHR5IGluXG4gIChtYWluX2ZpbGUsIGZpbGVzKVxuXG5sZXQgZnJvbV9maWxlbmFtZSBmaWxlbmFtZSA9XG4gIGxldCBjaGFubmVsID0gb3Blbl9pbiBmaWxlbmFtZSBpblxuICBsZXQgbGV4YnVmID0gTGV4aW5nLmZyb21fY2hhbm5lbCBjaGFubmVsIGluXG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHsgbGV4YnVmLmxleF9jdXJyX3Agd2l0aCBwb3NfZm5hbWUgPSBmaWxlbmFtZSB9O1xuICBsZXQgcmVzID0gcGFyc2UgbGV4YnVmIGluXG4gIGNsb3NlX2luIGNoYW5uZWwgOyByZXNcblxubGV0IGZyb21fc3RyIHN0ciA9XG4gIExleGluZy5mcm9tX3N0cmluZyBzdHIgfD4gcGFyc2VcblxubGV0IG1haW5fZmlsZSAobWYsIF8pID0gbWZcblxubGV0IGdldF9maWxlIG5hbWUgKF8sIGZpbGVzKSA9XG4gIFN0ck1hcC5maW5kIG5hbWUgZmlsZXNcbiIsIlxudHlwZSB0ID0gKChpbnQgKiAoKGludCBsaXN0KSBsaXN0KSkgbGlzdCkgKiAoKChpbnQgbGlzdCkgbGlzdCkgb3B0aW9uKVxuXG5sZXQgbG9hZF9mcm9tX2RpciBlbnYgZGlybmFtZSA9XG4gIHRyeSAoXG4gICAgVXRpbHMuZW51bWVyYXRlX2ZpbGVzIGRpcm5hbWUgXCIudHh0XCJcbiAgICB8PiBMaXN0Lm1hcCAoZnVuIHggLT5cbiAgICAgIGxldCBwYXRoID0gRmlsZW5hbWUuY29uY2F0IGRpcm5hbWUgeCBpblxuICAgICAgbGV0IHN0ciA9IEZpbGVuYW1lLmJhc2VuYW1lIHggfD4gRmlsZW5hbWUucmVtb3ZlX2V4dGVuc2lvbiBpblxuICAgICAgbGV0IGkgPSBpbnRfb2Zfc3RyaW5nIHN0ciBpblxuICAgICAgbGV0IGFybSA9IFBhcnNlLmZyb21fZmlsZW5hbWUgfmhlYWRlcnM6ZmFsc2UgcGF0aCB8PlxuICAgICAgICBQYXJzZS5wYXJzZWRfY29udGVudF90b19hcm0gVXRpbHMuZHVtbXlfZm10IH5vcHRpbWl6ZTpmYWxzZSBlbnYgaW5cbiAgICAgIGxldCBjb2RlcyA9IGFybSB8PlxuICAgICAgICBMaXN0Lm1hcCAoZnVuIGFybSAtPlxuICAgICAgICAgIEFybS5hcm1fdG9fYmluYXJ5IGFybSB8PlxuICAgICAgICAgIExpc3QubWFwIE5hbWUuY29kZXNfZm9yX2NvbW1hbmQgfD5cbiAgICAgICAgICBOYW1lLnByZWZlcnJlZF9jb2RlXG4gICAgICAgIClcbiAgICAgIGluXG4gICAgICAoaSwgY29kZXMpXG4gICAgKVxuICAgIHw+IExpc3Quc29ydCAoZnVuIChpLF8pIChqLF8pIC0+IGNvbXBhcmUgaSBqKVxuICAgIHw+IChmdW4geCAtPiAoeCwgTm9uZSkpXG4gIClcbiAgd2l0aCBPcHRpbWl6ZXIuQ2Fubm90T3B0aW1pemUgLT5cbiAgICBmYWlsd2l0aCBcIkV4aXQgY29kZXMgY2Fubm90IGJlIHR3ZWFrZWQgKHBsZWFzZSByZW1vdmUgaW50ZXJyb2dhdGlvbiBtYXJrcykuXCJcblxubGV0IGxvYWRfZnJvbV9wYXJzZWRfZmlsZSBmbXQgZW52IChoLCBhcm0pID1cbiAgbGV0IGNvZGVzID0gKGgsIGFybSkgfD5cbiAgICBQYXJzZS5wYXJzZWRfY29udGVudF90b19hcm0gZm10IH5vcHRpbWl6ZTp0cnVlIGVudiB8PlxuICAgIExpc3QubWFwIChmdW4gYXJtIC0+XG4gICAgICBBcm0uYXJtX3RvX2JpbmFyeSBhcm0gfD5cbiAgICAgIExpc3QubWFwIE5hbWUuY29kZXNfZm9yX2NvbW1hbmQgfD5cbiAgICAgIE5hbWUucHJlZmVycmVkX2NvZGVcbiAgICApXG4gIGluXG4gIG1hdGNoIFByZXByb2Nlc3MuZ2V0X3BhcmFtIGggXCJzdGFydFwiIHdpdGhcbiAgfCBISW50IGkgLT4gKFsoVXRpbHMudWludDMyX3RvX2ludCBpLCBjb2RlcyldLCBOb25lKVxuICB8IEhOb25lIC0+IChbXSwgU29tZSBjb2RlcylcbiAgfCBfIC0+IGZhaWx3aXRoIFwiRXhpdCBjb2RlIGhhcyBpbnZhbGlkIGhlYWRlcnMuXCJcblxubGV0IGxvYWRfZnJvbV9maWxlIGZtdCBlbnYgZmlsZW5hbWUgPVxuICBsZXQgKGhlYWRlcnMsYXN0KSA9IFBhcnNlLmZyb21fZmlsZW5hbWUgfmhlYWRlcnM6dHJ1ZSBmaWxlbmFtZSBpblxuICAoaGVhZGVycywgbG9hZF9mcm9tX3BhcnNlZF9maWxlIGZtdCBlbnYgKGhlYWRlcnMsIGFzdCkpXG5cbmV4Y2VwdGlvbiBOb0V4aXRDb2RlXG5cbmxldCBnZXRfcHJlZmVycmVkIChsc3QsIGRlZmF1bHQpIGkgPVxuICB0cnkgKFxuICAgIGxldCByZWMgYXV4IGxzdCA9XG4gICAgICBtYXRjaCBsc3Qgd2l0aFxuICAgICAgfCBbXSAtPiByYWlzZSBOb0V4aXRDb2RlXG4gICAgICB8IChqLCBjKTo6XyB3aGVuIGkgPD0gaiAtPiAoaiwgYylcbiAgICAgIHwgXzo6bHN0IC0+IGF1eCBsc3RcbiAgICBpblxuICAgIGF1eCBsc3RcbiAgKSB3aXRoIE5vRXhpdENvZGUgLT4gKFxuICAgIG1hdGNoIGRlZmF1bHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBOb0V4aXRDb2RlXG4gICAgfCBTb21lIGMgLT4gKGksIGMpXG4gIClcblxuIiwiXG5tb2R1bGUgVVN0cmluZyA9IFV1dGYuU3RyaW5nXG5tb2R1bGUgVUJ1ZmZlciA9IFV1dGYuQnVmZmVyXG5cbmxldCBzdHJpbmdfb2ZfdWNoYXIgdWNoYXIgPVxuICBsZXQgYnVmZmVyID0gQnVmZmVyLmNyZWF0ZSA0IGluXG4gIFVCdWZmZXIuYWRkX3V0Zl84IGJ1ZmZlciB1Y2hhciA7XG4gIEJ1ZmZlci5jb250ZW50cyBidWZmZXJcblxubGV0IGRlY29tcG9zZV9pbnRvX3VjaGFycyBzdHIgPVxuICBVU3RyaW5nLmZvbGRfdXRmXzggKGZ1biBhY2MgXyB1YyAtPiBtYXRjaCB1YyB3aXRoXG4gIHwgYE1hbGZvcm1lZCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IGBVY2hhciB1YyAtPiB1Yzo6YWNjKSBbXSBzdHJcbiAgfD4gTGlzdC5yZXZcblxudHlwZSByZXN1bHQgPSBcbiAgfCBDb250IG9mIChGb3JtYXQuZm9ybWF0dGVyIC0+IHN0cmluZyAtPiByZXN1bHQpXG4gIHwgTm9Db250XG5cbmxldCByZWMgbWFpbiBmbXQgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJBdmFpbGFibGUgY2hhcmFjdGVyczogQC5cIiA7XG4gIENoYXJzZXQuYWxsX3dyaXRhYmxlX2NoYXJzIHw+XG4gIExpc3QuaXRlciAoRm9ybWF0LmZwcmludGYgZm10IFwiJXNcIikgO1xuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJALlBsZWFzZSBlbnRlciB0ZXh0IHRvIGVuY29kZTogQD9cIiA7XG4gIENvbnQgbWFpbl8xXG5cbmFuZCBtYWluXzEgZm10IHN0ciA9XG4gIGxldCByZWMgYXV4MiBsc3QgPVxuICAgIG1hdGNoIGxzdCB3aXRoXG4gICAgfCBbXSAtPiAoKVxuICAgIHwgYTo6Yjo6bHN0IC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlMDJYJTAyWCBcIiBiIGEgO1xuICAgICAgYXV4MiBsc3RcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGluXG4gIGxldCByZWMgYXV4NCBsc3QgPVxuICAgIG1hdGNoIGxzdCB3aXRoXG4gICAgfCBbXSAtPiAoKVxuICAgIHwgYTo6Yjo6Yzo6ZDo6bHN0IC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlMDJYJTAyWCUwMlglMDJYIFwiIGQgYyBiIGEgO1xuICAgICAgYXV4NCBsc3RcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gIGluXG4gIGJlZ2luIHRyeVxuICAgIGxldCBlbmNvZGluZyA9XG4gICAgICBkZWNvbXBvc2VfaW50b191Y2hhcnMgc3RyIHw+XG4gICAgICBMaXN0Lm1hcCBzdHJpbmdfb2ZfdWNoYXIgfD5cbiAgICAgIExpc3QubWFwIENoYXJzZXQuZW5jb2RlX3dyaXRhYmxlX2NoYXIgaW5cbiAgICBsZXQgZW5jb2RpbmcgPSBlbmNvZGluZ0BbTmFtZS5lb2ZdIGluXG5cbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJFbmNvZGVkIGRhdGEgKDEtYnl0ZSk6IEAuXCIgO1xuICAgIExpc3QuaXRlciAoRm9ybWF0LmZwcmludGYgZm10IFwiJTAyWCBcIikgZW5jb2RpbmcgO1xuXG4gICAgbGV0IG4gPSBMaXN0Lmxlbmd0aCBlbmNvZGluZyBpblxuICAgIGxldCBlbmNvZGluZyA9IGlmIG4gbW9kIDIgPD4gMCB0aGVuIGVuY29kaW5nQFswXSBlbHNlIGVuY29kaW5nIGluXG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiQC5FbmNvZGVkIGRhdGEgKDItYnl0ZXMpOiBALlwiIDtcbiAgICBhdXgyIGVuY29kaW5nIDtcblxuICAgIGxldCBuID0gTGlzdC5sZW5ndGggZW5jb2RpbmcgaW5cbiAgICBsZXQgZW5jb2RpbmcgPSBpZiBuIG1vZCA0IDw+IDAgdGhlbiBlbmNvZGluZ0BbMDswXSBlbHNlIGVuY29kaW5nIGluXG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiQC5FbmNvZGVkIGRhdGEgKDQtYnl0ZXMpOiBALlwiIDtcbiAgICBhdXg0IGVuY29kaW5nIDtcbiAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJALlwiXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiQW4gZXJyb3Igb2NjdXJlZC4gUGxlYXNlIGNoZWNrIHlvdSBvbmx5IHVzZSBhdmFpbGFibGUgY2hhcmFjdGVycy5cIlxuICBlbmQgO1xuICBOb0NvbnRcbiIsIm9wZW4gQXJtXG5cbmxldCBwcF9oZXggZm10IGkgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIlMDhsWFwiIGlcblxubGV0IGNvbmRfdG9fc3RyIGMgPVxuICBtYXRjaCBjIHdpdGhcbiAgfCBFUSAtPiBcIkVRXCIgfCBORSAtPiBcIk5FXCIgfCBDUyAtPiBcIkNTXCIgfCBIUyAtPiBcIkhTXCJcbiAgfCBDQyAtPiBcIkNDXCIgfCBMTyAtPiBcIkxPXCIgfCBNSSAtPiBcIk1JXCIgfCBQTCAtPiBcIlBMXCIgXG4gIHwgVlMgLT4gXCJWU1wiIHwgVkMgLT4gXCJWQ1wiIHwgSEkgLT4gXCJISVwiIHwgTFMgLT4gXCJMU1wiXG4gIHwgR0UgLT4gXCJHRVwiIHwgTFQgLT4gXCJMVFwiIHwgR1QgLT4gXCJHVFwiIHwgTEUgLT4gXCJMRVwiXG4gIHwgQUwgLT4gXCJcIlxuXG5sZXQgbGRyX3N0cl90eXBlX3RvX3N0ciB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgQiAtPiBcIkJcIiB8IFNCIC0+IFwiU0JcIiB8IEggLT4gXCJIXCIgfCBTSCAtPiBcIlNIXCIgfCBXIC0+IFwiXCJcbiAgfCBUIC0+IFwiVFwiIHwgQlQgLT4gXCJCVFwiXG5cbmxldCBzaWduX3RvX3N0ciBzaWduID1cbiAgaWYgc2lnbiA9IHNpZ25fbWludXMgdGhlbiBcIi1cIiBlbHNlIFwiXCJcblxubGV0IHNfdG9fc3RyIHMgPVxuICBpZiBzIHRoZW4gXCJTXCIgZWxzZSBcIlwiXG5cbmxldCBsX3RvX3N0ciBsID1cbiAgaWYgbCB0aGVuIFwiTFwiIGVsc2UgXCJcIlxuXG5sZXQgcHJpbnRfcmVnaXN0ZXIgZm10IHIgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCJyJWRcIiByXG5cbmxldCBwcmludF9pbW1lZGlhdGUgZm10IGkgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIjJSNseFwiIGlcblxubGV0IHByaW50X29wZXJhbmQgZm10IG9wID1cbiAgbWF0Y2ggb3Agd2l0aFxuICB8IEltbWVkaWF0ZSBpIC0+IHByaW50X2ltbWVkaWF0ZSBmbXQgaVxuICB8IFJlZ2lzdGVyIHIgLT4gRm9ybWF0LmZwcmludGYgZm10IFwiJWFcIiBwcmludF9yZWdpc3RlciByXG4gIHwgU2NhbGVkUmVnaXN0ZXIgXyAtPiBmYWlsd2l0aCBcIk5vdCBpbXBsZW1lbnRlZFwiXG5cbmxldCBwcmludF9pbW1lZGlhdGVfb2Zmc2V0IGZtdCAocywgaSkgPVxuICBGb3JtYXQuZnByaW50ZiBmbXQgXCIjJXMlI2x4XCIgKHNpZ25fdG9fc3RyIHMpIGlcblxubGV0IHByaW50X3JlZ2lzdGVyX29mZnNldCBmbXQgKHJvLCBhZGRyX3R5cCkgPVxuICBsZXQgc3RyID0gaWYgYWRkcl90eXAgPSBQcmVJbmRleGVkIHRoZW4gXCIhXCIgZWxzZSBcIlwiIGluXG4gIG1hdGNoIHJvLCBhZGRyX3R5cCB3aXRoXG4gIHwgT0ltbWVkaWF0ZSAocixzLGkpLCBQb3N0SW5kZXhlZCAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCJbJWFdLCAlYVwiXG4gICAgcHJpbnRfcmVnaXN0ZXIgciBwcmludF9pbW1lZGlhdGVfb2Zmc2V0IChzLCBpKVxuICB8IE9SZWdpc3RlciAocixzLHJvKSwgUG9zdEluZGV4ZWQgLT4gRm9ybWF0LmZwcmludGYgZm10IFwiWyVhXSwgJXMlYVwiXG4gICAgcHJpbnRfcmVnaXN0ZXIgciAoc2lnbl90b19zdHIgcykgcHJpbnRfcmVnaXN0ZXIgcm9cbiAgfCBPSW1tZWRpYXRlIChyLHMsaSksIF8gLT4gRm9ybWF0LmZwcmludGYgZm10IFwiWyVhLCAlYV0lc1wiXG4gICAgcHJpbnRfcmVnaXN0ZXIgciBwcmludF9pbW1lZGlhdGVfb2Zmc2V0IChzLCBpKSBzdHJcbiAgfCBPUmVnaXN0ZXIgKHIscyxybyksIF8gLT4gRm9ybWF0LmZwcmludGYgZm10IFwiWyVhLCAlcyVhXSVzXCJcbiAgICBwcmludF9yZWdpc3RlciByIChzaWduX3RvX3N0ciBzKSBwcmludF9yZWdpc3RlciBybyBzdHJcbiAgfCBPU2NhbGVkUmVnaXN0ZXIgXywgXyAtPiBmYWlsd2l0aCBcIk5vdCBpbXBsZW1lbnRlZFwiXG5cbmxldCBtZW1faW5zdHJfdG9fc3RyIGluc3RyID1cbiAgbWF0Y2ggaW5zdHIgd2l0aFxuICB8IFNUUiAtPiBcIlNUUlwiIHwgTERSIC0+IFwiTERSXCJcblxubGV0IG1vdl9pbnN0cl90b19zdHIgaW5zdHIgPVxuICBtYXRjaCBpbnN0ciB3aXRoXG4gIHwgTU9WIC0+IFwiTU9WXCIgfCBNVk4gLT4gXCJNVk5cIlxuXG5sZXQgZGF0YV9wcm9jX2luc3RyX3RvX3N0ciBpbnN0ciA9XG4gIG1hdGNoIGluc3RyIHdpdGhcbiAgfCBBREMgLT4gXCJBRENcIiB8IFNCQyAtPiBcIlNCQ1wiIHwgQU5EIC0+IFwiQU5EXCIgfCBCSUMgLT4gXCJCSUNcIlxuICB8IEFERCAtPiBcIkFERFwiIHwgU1VCIC0+IFwiU1VCXCIgfCBPUlIgLT4gXCJPUlJcIiB8IEVPUiAtPiBcIkVPUlwiXG5cbmxldCBwcF9hcm0gZm10IGFybSA9XG4gIG1hdGNoIGFybSB3aXRoXG4gIHwgQ3VzdG9tIGkgLT4gcHBfaGV4IGZtdCBpXG4gIHwgTWVtIHtpbnN0cjt0eXA7Y29uZDtyZDtyb30gLT4gRm9ybWF0LmZwcmludGYgZm10IFwiJXMlcyVzICVhLCAlYVwiXG4gICAgKG1lbV9pbnN0cl90b19zdHIgaW5zdHIpIChjb25kX3RvX3N0ciBjb25kKSAobGRyX3N0cl90eXBlX3RvX3N0ciB0eXApXG4gICAgcHJpbnRfcmVnaXN0ZXIgcmQgcHJpbnRfcmVnaXN0ZXJfb2Zmc2V0IHJvXG4gIHwgTW92IHtpbnN0cjtzO2NvbmQ7cmQ7cnN9ICAgLT4gRm9ybWF0LmZwcmludGYgZm10IFwiJXMlcyVzICVhLCAlYVwiXG4gICAgKG1vdl9pbnN0cl90b19zdHIgaW5zdHIpIChjb25kX3RvX3N0ciBjb25kKSAoc190b19zdHIgcylcbiAgICBwcmludF9yZWdpc3RlciByZCBwcmludF9vcGVyYW5kIHJzXG4gIHwgRGF0YVByb2Mge2luc3RyO3M7Y29uZDtyZDtybjtvcDJ9IC0+IEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVzJXMlcyAlYSwgJWEsICVhXCJcbiAgICAoZGF0YV9wcm9jX2luc3RyX3RvX3N0ciBpbnN0cikgKGNvbmRfdG9fc3RyIGNvbmQpIChzX3RvX3N0ciBzKVxuICAgIHByaW50X3JlZ2lzdGVyIHJkIHByaW50X3JlZ2lzdGVyIHJuIHByaW50X29wZXJhbmQgb3AyXG4gIHwgQnJhbmNoIHtsO2NvbmQ7dGFyZ2V0fSAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCJCJXMlcyAlYVwiXG4gICAgKGxfdG9fc3RyIGwpIChjb25kX3RvX3N0ciBjb25kKSBwcmludF9pbW1lZGlhdGUgdGFyZ2V0XG4gIHwgQnJhbmNoWCB7bDtjb25kO3JtfSAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCJCJXNYJXMgJWFcIlxuICAobF90b19zdHIgbCkgKGNvbmRfdG9fc3RyIGNvbmQpIHByaW50X3JlZ2lzdGVyIHJtXG4iLCJvcGVuIEFybVxuXG5sZXQgdHJlYXRfY29tbWFuZCBmbXQgYXJtID1cbiAgbGV0IGhleHMgPSBhcm1fdG9fYmluYXJ5IGFybSBpblxuICBsZXQgY29kZXMgPSBMaXN0Lm1hcCBOYW1lLmNvZGVzX2Zvcl9jb21tYW5kIGhleHMgaW5cbiAgbGV0IGNvZGUgPSBOYW1lLnByZWZlcnJlZF9jb2RlIGNvZGVzIGluXG4gIGxldCBoZXggPSBOYW1lLmNvbW1hbmRfZm9yX2NvZGVzIGNvZGUgaW5cbiAgbGV0IGNoYXJzID0gTmFtZS5jb2Rlc190b19jaGFycyBjb2RlIGluXG4gIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVhIFxcdCVhXFx0JWFALlwiXG4gICAgTmFtZS5wcF9jaGFycyBjaGFyc1xuICAgIEFybV9wcmludGVyLnBwX2hleCBoZXhcbiAgICBBcm1fcHJpbnRlci5wcF9hcm0gYXJtIDtcbiAgY29kZVxuXG5sZXQgbWFpbiBmbXQgZW52IChoZWFkZXJzLGhlYWRlcnMyKSBwYXJzZWQgZXhpdCA9XG4gIGxldCBvbmx5cmF3ID1cbiAgICBtYXRjaCBQcmVwcm9jZXNzLmdldF9wYXJhbSBoZWFkZXJzIFwib25seXJhd1wiIHdpdGhcbiAgICB8IEhOb25lIC0+IGZhbHNlXG4gICAgfCBIQm9vbCBiIC0+IGJcbiAgICB8IF8gLT4gZmFpbHdpdGggXCJJbnZhbGlkIGhlYWRlcnMuXCJcbiAgaW5cbiAgaWYgb25seXJhdyAmJiBleGl0IDw+IE5vbmVcbiAgdGhlbiBmYWlsd2l0aCBcIk9ubHktcmF3IG1vZGUgZG9lcyBub3Qgc3VwcG9ydCBleGl0IGNvZGVzLlwiIDtcbiAgbGV0IHN0YXJ0ID1cbiAgICBtYXRjaCBQcmVwcm9jZXNzLmdldF9wYXJhbSBoZWFkZXJzIFwic3RhcnRcIiB3aXRoXG4gICAgfCBITm9uZSAtPiAwXG4gICAgfCBISW50IGkgLT4gVXRpbHMudWludDMyX3RvX2ludCBpXG4gICAgfCBfIC0+IGZhaWx3aXRoIFwiSW52YWxpZCBoZWFkZXJzLlwiXG4gIGluXG4gIGxldCBmaWxsZXJzID1cbiAgICBBcnJheS5pbml0IDQgKGZ1biBuIC0+XG4gICAgICBsZXQgaGVhZGVyX25hbWUgPSBGb3JtYXQuc3ByaW50ZiBcImZpbGxlciVuXCIgKG4rMSkgaW5cbiAgICAgIG1hdGNoIFByZXByb2Nlc3MuZ2V0X3BhcmFtIGhlYWRlcnMgaGVhZGVyX25hbWUgd2l0aFxuICAgICAgfCBITm9uZSAtPiBCb3hlcy5kZWZhdWx0X2ZpbGxlcnMuZmlsbGVycy4obilcbiAgICAgIHwgSEludCBpIC0+XG4gICAgICAgIGxldCBjb2RlcyA9IE5hbWUuY29kZXNfZm9yX2NvbW1hbmQgaSBpblxuICAgICAgICBpZiBMaXN0Lm50aCBjb2RlcyBuIDw+IE5hbWUuZW9mIHRoZW4gZmFpbHdpdGggXCJJbnZhbGlkIGZpbGxlci5cIiA7XG4gICAgICAgIGNvZGVzXG4gICAgICB8IF8gLT4gZmFpbHdpdGggXCJJbnZhbGlkIGhlYWRlcnMuXCJcbiAgICApXG4gIGluXG4gIGxldCBub3BfY29kZSA9XG4gICAgbWF0Y2ggUHJlcHJvY2Vzcy5nZXRfcGFyYW0gaGVhZGVycyBcImZpbGxlcjBcIiB3aXRoXG4gICAgfCBITm9uZSAtPiBCb3hlcy5kZWZhdWx0X2ZpbGxlcnMubm9wX2NvZGVcbiAgICB8IEhJbnQgaSAtPiBOYW1lLmNvZGVzX2Zvcl9jb21tYW5kIGlcbiAgICB8IF8gLT4gZmFpbHdpdGggXCJJbnZhbGlkIGhlYWRlcnMuXCJcbiAgaW5cbiAgbGV0IG5vcF9jb2RlX2FsdCA9XG4gICAgbWF0Y2ggUHJlcHJvY2Vzcy5nZXRfcGFyYW0gaGVhZGVycyBcImZpbGxlcjBfYWx0XCIgd2l0aFxuICAgIHwgSE5vbmUgLT4gQm94ZXMuZGVmYXVsdF9maWxsZXJzLm5vcF9jb2RlX2FsdFxuICAgIHwgSEludCBpIC0+IE5hbWUuY29kZXNfZm9yX2NvbW1hbmQgaVxuICAgIHwgXyAtPiBmYWlsd2l0aCBcIkludmFsaWQgaGVhZGVycy5cIlxuICBpblxuICBsZXQgZmlsbF9sYXN0ID1cbiAgICBtYXRjaCBQcmVwcm9jZXNzLmdldF9wYXJhbSBoZWFkZXJzIFwiZmlsbFwiLFxuICAgICAgICAgIFByZXByb2Nlc3MuZ2V0X3BhcmFtIGhlYWRlcnMyIFwiZmlsbFwiIHdpdGhcbiAgICB8IEhOb25lLCBITm9uZSAtPiB0cnVlXG4gICAgfCBITm9uZSwgSEJvb2wgYiB8IEhCb29sIGIsIEhOb25lIC0+IGJcbiAgICB8IEhCb29sIGIxLCBIQm9vbCBiMiB3aGVuIGIxPWIyIC0+IGIxXG4gICAgfCBIQm9vbCBfLCBIQm9vbCBfIC0+XG4gICAgICBmYWlsd2l0aCBcIlRoZSAnZmlsbCcgaGVhZGVyIGhhcyBhIGRpZmZlcmVudCB2YWx1ZSBpbiB0aGUgbWFpbiBjb2RlIGFuZCBpbiB0aGUgZXhpdCBjb2RlLlwiXG4gICAgfCBfIC0+IGZhaWx3aXRoIFwiSW52YWxpZCBoZWFkZXJzLlwiXG4gIGluXG4gIGxldCByZXMgPVxuICAgIFBhcnNlLnBhcnNlZF9hc3RfdG9fYXJtIH5vcHRpbWl6ZTp0cnVlIGVudiBwYXJzZWQgfD5cbiAgICBMaXN0Lm1hcCAodHJlYXRfY29tbWFuZCBmbXQpIGluXG4gIGlmIG9ubHlyYXdcbiAgdGhlbiBiZWdpblxuICAgIGxldCBzdGFydCA9IExpc3QuaW5pdCBzdGFydCAoZnVuIF8gLT4gMCkgaW5cbiAgICBsZXQgcmVzID0gTGlzdC5jb25jYXQgKHN0YXJ0OjpyZXMpIGluXG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiQC5SYXcgZGF0YSAoaW4gaGV4YWRlY2ltYWwpOkAuXCIgO1xuICAgIExpc3QuaXRlciAoRm9ybWF0LmZwcmludGYgZm10IFwiJTAyWCBAP1wiKSByZXMgO1xuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkAuXCIgOyBOb25lXG4gIGVuZCBlbHNlXG4gICAgdHJ5XG4gICAgICBsZXQgZmlsbGVycyA9IHsgQm94ZXMuZmlsbGVyczsgQm94ZXMubm9wX2NvZGU7IEJveGVzLm5vcF9jb2RlX2FsdCB9IGluXG4gICAgICBsZXQgYm94ZXNfY29kZXMgPVxuICAgICAgICBpZiAhU2V0dGluZ3MuaGV4X2JveF9tb2RlXG4gICAgICAgIHRoZW4gQm94ZXMuZml0X2NvZGVzX2ludG9faGV4X2JveGVzIH5leGl0IHJlc1xuICAgICAgICBlbHNlIEJveGVzLmZpdF9jb2Rlc19pbnRvX2JveGVzIH5maWxsX2xhc3QgfmZpbGxlcnMgfnN0YXJ0IH5leGl0IHJlc1xuICAgICAgaW5cbiAgICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkAuJWFALlwiIEJveGVzLnBwX2JveGVzX25hbWVzIGJveGVzX2NvZGVzIDtcbiAgICAgIGxldCBzaXplID0gTGlzdC5sZW5ndGggYm94ZXNfY29kZXMgaW5cbiAgICAgIGJlZ2luXG4gICAgICAgIGlmIHNpemUgPiBCb3hlcy5uYl9ib3hlc1xuICAgICAgICB0aGVuXG4gICAgICAgICAgRm9ybWF0LmZwcmludGYgZm10IFwiV2FybmluZzogTm90IGVub3VnaCBzcGFjZS4uLiBOZWVkICVuLyVuIGJveGVzLkAuXCJcbiAgICAgICAgICBzaXplIEJveGVzLm5iX2JveGVzXG4gICAgICBlbmQgO1xuICAgICAgYmVnaW5cbiAgICAgICAgaWYgTGlzdC5leGlzdHMgKGZ1biBjIC0+IE5hbWUuaXNfY29kZV93cml0YWJsZSBjIHw+IG5vdCkgYm94ZXNfY29kZXNcbiAgICAgICAgdGhlbiBGb3JtYXQuZnByaW50ZiBmbXQgXCJXYXJuaW5nOiBDb250YWlucyB1bndyaXRhYmxlIGNoYXJhY3RlcnMuLi5ALlwiXG4gICAgICAgIGVsc2UgaWYgTGlzdC5leGlzdHMgTmFtZS5pc19mdWxsX29mX3NwYWNlcyBib3hlc19jb2Rlc1xuICAgICAgICB0aGVuIEZvcm1hdC5mcHJpbnRmIGZtdCBcIldhcm5pbmc6IEEgYm94IG5hbWUgY2Fubm90IGJlIHdyaXR0ZW4gKG9ubHkgY29udGFpbnMgc3BhY2VzKS4uLkAuXCJcbiAgICAgIGVuZCA7XG4gICAgICBGb3JtYXQuZnByaW50ZiBmbXQgXCJSYXcgZGF0YSAoaW4gaGV4YWRlY2ltYWwpOkAuXCIgO1xuICAgICAgYm94ZXNfY29kZXMgfD4gTGlzdC5pdGVyIChGb3JtYXQuZnByaW50ZiBmbXQgXCIlYVwiIEJveGVzLnBwX2JveF9yYXcpIDtcbiAgICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIkAuXCIgO1xuICAgICAgU29tZSAoTGlzdC5tYXAgKGZ1biBjIC0+IE5hbWUuY29kZXNfdG9fY2hhcnMgYyB8PiBVdGlscy5jb25jYXRfc3RyaW5ncykgYm94ZXNfY29kZXMpXG4gICAgd2l0aCBFeGl0Lk5vRXhpdENvZGUgLT5cbiAgICAgIGZhaWx3aXRoIFwiVGhlIGV4aXQgY29kZSBvdmVybGFwcyB0aGlzIGNvZGUgKHRvbyBsb25nPykuQC5cIlxuIixudWxsLCJvcGVuIEFjZV9jb21tb25cbm9wZW4gSnNfb2Zfb2NhbWxcblxubW9kdWxlIEh0bWwgPSBEb21faHRtbFxuXG5sZXQgdHJlYXRfaW5wdXQgbGFuZyBzdHIgPVxuICBTZXR0aW5ncy5jb25maWd1cmUgbGFuZyA7XG4gIGxldCBidWZmZXIgPSBCdWZmZXIuY3JlYXRlIDEwMDAgaW5cbiAgbGV0IGZtdCA9IEZvcm1hdC5mb3JtYXR0ZXJfb2ZfYnVmZmVyIGJ1ZmZlciBpblxuICBiZWdpbiB0cnkgKFxuICAgIGxldCBmcyA9IEZzLmZyb21fc3RyIHN0ciBpblxuICAgIGxldCAoaGVhZGVycywgcHJvZ3JhbSkgPSBGcy5tYWluX2ZpbGUgZnMgaW5cbiAgICBsZXQgZW52ID0gUHJlcHJvY2Vzcy5lbnZfZnJvbV9oZWFkZXJzIGZtdCBoZWFkZXJzIGluXG4gICAgbGV0IChleGl0LCBoZWFkZXJzMikgPVxuICAgICAgbWF0Y2ggUHJlcHJvY2Vzcy5nZXRfcGFyYW0gaGVhZGVycyBcImV4aXRcIiB3aXRoXG4gICAgICB8IEhOb25lIC0+IChOb25lLCBbXSlcbiAgICAgIHwgSFN0cmluZyBmbiAtPlxuICAgICAgICBsZXQgKGhlYWRlcnMsIGFzdCkgPSBGcy5nZXRfZmlsZSBmbiBmcyBpblxuICAgICAgICBsZXQgZXhpdCA9IEV4aXQubG9hZF9mcm9tX3BhcnNlZF9maWxlIGZtdCBlbnYgKGhlYWRlcnMsIGFzdCkgaW5cbiAgICAgICAgKFNvbWUgZXhpdCwgaGVhZGVycylcbiAgICAgIHwgXyAtPiBmYWlsd2l0aCBcIkludmFsaWQgaGVhZGVycy5cIlxuICAgIGluXG4gICAgbWFpbiBmbXQgZW52IChoZWFkZXJzLCBoZWFkZXJzMikgcHJvZ3JhbSBleGl0IHw+IGlnbm9yZVxuICApIHdpdGggZSAtPiBCdWZmZXIuYWRkX3N0cmluZyBidWZmZXIgKFByaW50ZXhjLnRvX3N0cmluZyBlKSBlbmQgO1xuICBGb3JtYXQucHBfcHJpbnRfZmx1c2ggZm10ICgpIDtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZmZlclxuXG5sZXQgaXNfYmxhbmtfc3RyIHMgPSAgXG4gIGxldCByZWMgZW1wdHkgaSA9XG4gICAgaWYgaSA8IDAgdGhlbiB0cnVlXG4gICAgZWxzZVxuICAgICAgbGV0IGMgPSBTdHJpbmcuZ2V0IHMgaSBpblxuICAgICAgaWYgYyA9ICcgJyB8fCBjID0gJ1xcdCcgfHwgYyA9ICdcXG4nIHx8IGMgPSAnXFxyJyB0aGVuIGVtcHR5IChpLTEpXG4gICAgICBlbHNlIGZhbHNlXG4gIGluXG4gIGVtcHR5ICgoU3RyaW5nLmxlbmd0aCBzKS0xKVxuXG5sZXQgY29tcHV0ZSBfID1cbiAgbGV0IG1haW5faW5wdXQgPVxuICAgIE9wdGlvbi5nZXRcbiAgICAgIChIdG1sLmdldEVsZW1lbnRCeUlkX2NvZXJjZSBcIm1haW5cIiBIdG1sLkNvZXJjZVRvLnRleHRhcmVhKVxuICBpblxuICBsZXQgc2Vjb25kYXJ5X2lucHV0ID1cbiAgICBPcHRpb24uZ2V0XG4gICAgICAoSHRtbC5nZXRFbGVtZW50QnlJZF9jb2VyY2UgXCJzZWNvbmRhcnlcIiBIdG1sLkNvZXJjZVRvLnRleHRhcmVhKVxuICBpblxuICBsZXQgb3V0cHV0ID1cbiAgICBPcHRpb24uZ2V0XG4gICAgICAoSHRtbC5nZXRFbGVtZW50QnlJZF9jb2VyY2UgXCJvdXRwdXRcIiBIdG1sLkNvZXJjZVRvLnRleHRhcmVhKVxuICBpblxuICBsZXQgbGFuZyA9XG4gICAgT3B0aW9uLmdldFxuICAgICAgKEh0bWwuZ2V0RWxlbWVudEJ5SWRfY29lcmNlIFwibGFuZ1wiIEh0bWwuQ29lcmNlVG8uc2VsZWN0KVxuICBpblxuICBsZXQgbWFpbl9pbnB1dCA9IEpzLnRvX3N0cmluZyBtYWluX2lucHV0IyMudmFsdWUgaW5cbiAgbGV0IHNlY29uZGFyeV9pbnB1dCA9IEpzLnRvX3N0cmluZyBzZWNvbmRhcnlfaW5wdXQjIy52YWx1ZSBpblxuICBsZXQgaW5wdXQgPSBtYWluX2lucHV0XihcbiAgICBpZiBpc19ibGFua19zdHIgc2Vjb25kYXJ5X2lucHV0XG4gICAgdGhlbiBcIlwiIGVsc2UgXCJcXG49PT09PVxcblwiXnNlY29uZGFyeV9pbnB1dFxuICApIGluXG4gIGxldCBsYW5nID0gSnMudG9fc3RyaW5nIGxhbmcjIy52YWx1ZSBpblxuICBsZXQgcmVzID0gdHJlYXRfaW5wdXQgbGFuZyBpbnB1dCBpblxuICBvdXRwdXQjIy52YWx1ZSA6PSBKcy5zdHJpbmcgcmVzO1xuICBKcy5fdHJ1ZVxuXG5sZXQgaW5pdCBfID1cbiAgbGV0IGNvbXB1dGVfYnV0dG9uID1cbiAgICBPcHRpb24uZ2V0XG4gICAgICAoSHRtbC5nZXRFbGVtZW50QnlJZF9jb2VyY2UgXCJjb21wdXRlXCIgSHRtbC5Db2VyY2VUby5idXR0b24pXG4gIGluXG4gIEh0bWwuYWRkRXZlbnRMaXN0ZW5lciBjb21wdXRlX2J1dHRvblxuICAgIChIdG1sLkV2ZW50Lm1ha2UgXCJjbGlja1wiKSAoSHRtbC5oYW5kbGVyIGNvbXB1dGUpIChKcy5ib29sIGZhbHNlKVxuICB8PiBpZ25vcmUgO1xuICBKcy5fZmFsc2VcblxubGV0IF8gPSBIdG1sLmFkZEV2ZW50TGlzdGVuZXIgSHRtbC53aW5kb3dcbiAgKEh0bWwuRXZlbnQubWFrZSBcImxvYWRcIikgKEh0bWwuaGFuZGxlciBpbml0KSAoSnMuYm9vbCBmYWxzZSlcbiAgfD4gaWdub3JlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEVuc3VyZSB0aGF0IFthdF9leGl0XSBmdW5jdGlvbnMgYXJlIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IHByb2dyYW0gKilcblxubGV0IF8gPSBkb19hdF9leGl0KClcbiJdfQ==